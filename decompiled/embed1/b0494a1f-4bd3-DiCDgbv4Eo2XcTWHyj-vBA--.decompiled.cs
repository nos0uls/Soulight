using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Resources;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MathNet.Numerics.Differentiation;
using MathNet.Numerics.Distributions;
using MathNet.Numerics.IntegralTransforms;
using MathNet.Numerics.Integration;
using MathNet.Numerics.Integration.GaussRule;
using MathNet.Numerics.Interpolation;
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Complex;
using MathNet.Numerics.LinearAlgebra.Complex.Factorization;
using MathNet.Numerics.LinearAlgebra.Complex32;
using MathNet.Numerics.LinearAlgebra.Complex32.Factorization;
using MathNet.Numerics.LinearAlgebra.Double;
using MathNet.Numerics.LinearAlgebra.Double.Factorization;
using MathNet.Numerics.LinearAlgebra.Factorization;
using MathNet.Numerics.LinearAlgebra.Single;
using MathNet.Numerics.LinearAlgebra.Single.Factorization;
using MathNet.Numerics.LinearAlgebra.Solvers;
using MathNet.Numerics.LinearAlgebra.Storage;
using MathNet.Numerics.LinearRegression;
using MathNet.Numerics.Optimization;
using MathNet.Numerics.Optimization.LineSearch;
using MathNet.Numerics.Optimization.ObjectiveFunctions;
using MathNet.Numerics.Optimization.TrustRegion.Subproblems;
using MathNet.Numerics.Providers.Common.Cuda;
using MathNet.Numerics.Providers.Common.Mkl;
using MathNet.Numerics.Providers.Common.OpenBlas;
using MathNet.Numerics.Providers.FourierTransform;
using MathNet.Numerics.Providers.FourierTransform.Managed;
using MathNet.Numerics.Providers.FourierTransform.Mkl;
using MathNet.Numerics.Providers.LinearAlgebra;
using MathNet.Numerics.Providers.LinearAlgebra.Cuda;
using MathNet.Numerics.Providers.LinearAlgebra.Managed;
using MathNet.Numerics.Providers.LinearAlgebra.ManagedReference;
using MathNet.Numerics.Providers.LinearAlgebra.Mkl;
using MathNet.Numerics.Providers.LinearAlgebra.OpenBlas;
using MathNet.Numerics.Providers.SparseSolver;
using MathNet.Numerics.Providers.SparseSolver.Managed;
using MathNet.Numerics.Providers.SparseSolver.Mkl;
using MathNet.Numerics.Random;
using MathNet.Numerics.RootFinding;
using MathNet.Numerics.Statistics;
using MathNet.Numerics.Threading;
using Microsoft.CodeAnalysis;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: CLSCompliant(true)]
[assembly: ComVisible(false)]
[assembly: Guid("7b66646f-f0ee-425d-9065-910d1937a2df")]
[assembly: InternalsVisibleTo("MathNet.Numerics.Tests")]
[assembly: InternalsVisibleTo("MathNet.Numerics.Tests.MKL")]
[assembly: InternalsVisibleTo("MathNet.Numerics.Tests.CUDA")]
[assembly: InternalsVisibleTo("MathNet.Numerics.Tests.OpenBLAS")]
[assembly: InternalsVisibleTo("Benchmark")]
[assembly: TargetFramework(".NETFramework,Version=v4.0", FrameworkDisplayName = ".NET Framework 4")]
[assembly: AssemblyCompany("Math.NET Project")]
[assembly: AssemblyConfiguration("Release")]
[assembly: AssemblyCopyright("Copyright Math.NET Project")]
[assembly: AssemblyDescription("Math.NET Numerics is the numerical foundation of the Math.NET project, aiming to provide methods and algorithms for numerical computations in science, engineering and every day use. Supports .Net Framework 4.0 or higher and .Net Standard 1.3 or higher, on Windows, Linux and Mac.")]
[assembly: AssemblyFileVersion("4.15.0.0")]
[assembly: AssemblyInformationalVersion("4.15.0")]
[assembly: AssemblyProduct("Math.NET Numerics")]
[assembly: AssemblyTitle("MathNet.Numerics")]
[assembly: NeutralResourcesLanguage("en")]
[assembly: AssemblyVersion("4.15.0.0")]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
}
namespace System
{
	internal class FormattableString
	{
		private readonly string format;

		private readonly object[] args;

		public FormattableString(string format, object[] args)
		{
			this.format = format;
			this.args = args;
		}

		public static string Invariant(FormattableString messageFormat)
		{
			return messageFormat.ToString(CultureInfo.InvariantCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			return string.Format(formatProvider, format, args);
		}

		public override string ToString()
		{
			return string.Format(format, args);
		}
	}
}
namespace System.Runtime.CompilerServices
{
	internal class FormattableStringFactory
	{
		public static FormattableString Create(string format, params object[] args)
		{
			return new FormattableString(format, args);
		}
	}
}
namespace MathNet.Numerics
{
	public static class AppSwitches
	{
		private const string AppSwitchDisableNativeProviderProbing = "Switch.MathNet.Numerics.Providers.DisableNativeProviderProbing";

		private const string AppSwitchDisableNativeProviders = "Switch.MathNet.Numerics.Providers.DisableNativeProviders";

		private const string AppSwitchDisableMklNativeProvider = "Switch.MathNet.Numerics.Providers.DisableMklNativeProvider";

		private const string AppSwitchDisableAcmlNativeProvider = "Switch.MathNet.Numerics.Providers.DisableAcmlNativeProvider";

		private const string AppSwitchDisableCudaNativeProvider = "Switch.MathNet.Numerics.Providers.DisableCudaNativeProvider";

		private const string AppSwitchDisableOpenBlasNativeProvider = "Switch.MathNet.Numerics.Providers.DisableOpenBlasNativeProvider";

		private static readonly Dictionary<string, bool> Switches = new Dictionary<string, bool>();

		public static bool DisableNativeProviderProbing
		{
			get
			{
				return IsEnabled("Switch.MathNet.Numerics.Providers.DisableNativeProviderProbing");
			}
			set
			{
				SetSwitch("Switch.MathNet.Numerics.Providers.DisableNativeProviderProbing", value);
			}
		}

		public static bool DisableNativeProviders
		{
			get
			{
				return IsEnabled("Switch.MathNet.Numerics.Providers.DisableNativeProviders");
			}
			set
			{
				SetSwitch("Switch.MathNet.Numerics.Providers.DisableNativeProviders", value);
			}
		}

		public static bool DisableMklNativeProvider
		{
			get
			{
				return IsEnabled("Switch.MathNet.Numerics.Providers.DisableMklNativeProvider");
			}
			set
			{
				SetSwitch("Switch.MathNet.Numerics.Providers.DisableMklNativeProvider", value);
			}
		}

		public static bool DisableAcmlNativeProvider
		{
			get
			{
				return IsEnabled("Switch.MathNet.Numerics.Providers.DisableAcmlNativeProvider");
			}
			set
			{
				SetSwitch("Switch.MathNet.Numerics.Providers.DisableAcmlNativeProvider", value);
			}
		}

		public static bool DisableCudaNativeProvider
		{
			get
			{
				return IsEnabled("Switch.MathNet.Numerics.Providers.DisableCudaNativeProvider");
			}
			set
			{
				SetSwitch("Switch.MathNet.Numerics.Providers.DisableCudaNativeProvider", value);
			}
		}

		public static bool DisableOpenBlasNativeProvider
		{
			get
			{
				return IsEnabled("Switch.MathNet.Numerics.Providers.DisableOpenBlasNativeProvider");
			}
			set
			{
				SetSwitch("Switch.MathNet.Numerics.Providers.DisableOpenBlasNativeProvider", value);
			}
		}

		private static void SetSwitch(string switchName, bool isEnabled)
		{
			Switches[switchName] = isEnabled;
		}

		private static bool IsEnabled(string switchName)
		{
			bool value;
			return Switches.TryGetValue(switchName, out value) && value;
		}
	}
	internal static class ArrayExtensions
	{
		public static void Copy(this double[] source, double[] dest)
		{
			Buffer.BlockCopy(source, 0, dest, 0, source.Length * 8);
		}

		public static void Copy(this float[] source, float[] dest)
		{
			Buffer.BlockCopy(source, 0, dest, 0, source.Length * 4);
		}

		public static void Copy(this Complex[] source, Complex[] dest)
		{
			Array.Copy(source, 0, dest, 0, source.Length);
		}

		public static void Copy(this Complex32[] source, Complex32[] dest)
		{
			Array.Copy(source, 0, dest, 0, source.Length);
		}
	}
	public static class Combinatorics
	{
		public static double Variations(int n, int k)
		{
			if (k < 0 || n < 0 || k > n)
			{
				return 0.0;
			}
			return Math.Floor(0.5 + Math.Exp(SpecialFunctions.FactorialLn(n) - SpecialFunctions.FactorialLn(n - k)));
		}

		public static double VariationsWithRepetition(int n, int k)
		{
			if (k < 0 || n < 0)
			{
				return 0.0;
			}
			return Math.Pow(n, k);
		}

		public static double Combinations(int n, int k)
		{
			return SpecialFunctions.Binomial(n, k);
		}

		public static double CombinationsWithRepetition(int n, int k)
		{
			if (k < 0 || n < 0 || (n == 0 && k > 0))
			{
				return 0.0;
			}
			if (n == 0 && k == 0)
			{
				return 1.0;
			}
			return Math.Floor(0.5 + Math.Exp(SpecialFunctions.FactorialLn(n + k - 1) - SpecialFunctions.FactorialLn(k) - SpecialFunctions.FactorialLn(n - 1)));
		}

		public static double Permutations(int n)
		{
			return SpecialFunctions.Factorial(n);
		}

		public static int[] GeneratePermutation(int n, System.Random randomSource = null)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "Value must not be negative (zero is ok).");
			}
			int[] array = new int[n];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = i;
			}
			SelectPermutationInplace(array, randomSource);
			return array;
		}

		public static void SelectPermutationInplace<T>(T[] data, System.Random randomSource = null)
		{
			System.Random random = randomSource ?? SystemRandomSource.Default;
			for (int num = data.Length - 1; num > 0; num--)
			{
				int num2 = random.Next(num + 1);
				T val = data[num];
				data[num] = data[num2];
				data[num2] = val;
			}
		}

		public static IEnumerable<T> SelectPermutation<T>(this IEnumerable<T> data, System.Random randomSource = null)
		{
			System.Random random = randomSource ?? SystemRandomSource.Default;
			T[] array = data.ToArray();
			for (int i = array.Length - 1; i >= 0; i--)
			{
				int j = random.Next(i + 1);
				yield return array[j];
				array[j] = array[i];
			}
		}

		public static bool[] GenerateCombination(int n, System.Random randomSource = null)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "Value must not be negative (zero is ok).");
			}
			System.Random rnd = randomSource ?? SystemRandomSource.Default;
			bool[] array = new bool[n];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = rnd.NextBoolean();
			}
			return array;
		}

		public static bool[] GenerateCombination(int n, int k, System.Random randomSource = null)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "Value must not be negative (zero is ok).");
			}
			if (k < 0)
			{
				throw new ArgumentOutOfRangeException("k", "Value must not be negative (zero is ok).");
			}
			if (k > n)
			{
				throw new ArgumentOutOfRangeException("k", "k must be smaller than or equal to n.");
			}
			System.Random random = randomSource ?? SystemRandomSource.Default;
			bool[] array = new bool[n];
			if (k * 3 < n)
			{
				int num = 0;
				while (num < k)
				{
					int num2 = random.Next(n);
					if (!array[num2])
					{
						array[num2] = true;
						num++;
					}
				}
				return array;
			}
			int[] array2 = GeneratePermutation(n, random);
			for (int i = 0; i < k; i++)
			{
				array[array2[i]] = true;
			}
			return array;
		}

		public static IEnumerable<T> SelectCombination<T>(this IEnumerable<T> data, int elementsToChoose, System.Random randomSource = null)
		{
			T[] array = (data as T[]) ?? data.ToArray();
			if (elementsToChoose < 0)
			{
				throw new ArgumentOutOfRangeException("elementsToChoose", "Value must not be negative (zero is ok).");
			}
			if (elementsToChoose > array.Length)
			{
				throw new ArgumentOutOfRangeException("elementsToChoose", "elementsToChoose must be smaller than or equal to data.Count.");
			}
			bool[] mask = GenerateCombination(array.Length, elementsToChoose, randomSource);
			for (int i = 0; i < mask.Length; i++)
			{
				if (mask[i])
				{
					yield return array[i];
				}
			}
		}

		public static int[] GenerateCombinationWithRepetition(int n, int k, System.Random randomSource = null)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "Value must not be negative (zero is ok).");
			}
			if (k < 0)
			{
				throw new ArgumentOutOfRangeException("k", "Value must not be negative (zero is ok).");
			}
			System.Random random = randomSource ?? SystemRandomSource.Default;
			int[] array = new int[n];
			for (int i = 0; i < k; i++)
			{
				array[random.Next(n)]++;
			}
			return array;
		}

		public static IEnumerable<T> SelectCombinationWithRepetition<T>(this IEnumerable<T> data, int elementsToChoose, System.Random randomSource = null)
		{
			if (elementsToChoose < 0)
			{
				throw new ArgumentOutOfRangeException("elementsToChoose", "Value must not be negative (zero is ok).");
			}
			T[] array = (data as T[]) ?? data.ToArray();
			int[] mask = GenerateCombinationWithRepetition(array.Length, elementsToChoose, randomSource);
			for (int i = 0; i < mask.Length; i++)
			{
				for (int j = 0; j < mask[i]; j++)
				{
					yield return array[i];
				}
			}
		}

		public static int[] GenerateVariation(int n, int k, System.Random randomSource = null)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "Value must not be negative (zero is ok).");
			}
			if (k < 0)
			{
				throw new ArgumentOutOfRangeException("k", "Value must not be negative (zero is ok).");
			}
			if (k > n)
			{
				throw new ArgumentOutOfRangeException("k", "k must be smaller than or equal to n.");
			}
			System.Random random = randomSource ?? SystemRandomSource.Default;
			int[] array = new int[n];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = i;
			}
			int[] array2 = new int[k];
			int num = 0;
			int num2 = array.Length - 1;
			while (num < array2.Length)
			{
				int num3 = random.Next(num2 + 1);
				array2[num] = array[num3];
				array[num3] = array[num2];
				num++;
				num2--;
			}
			return array2;
		}

		public static IEnumerable<T> SelectVariation<T>(this IEnumerable<T> data, int elementsToChoose, System.Random randomSource = null)
		{
			System.Random random = randomSource ?? SystemRandomSource.Default;
			T[] array = data.ToArray();
			if (elementsToChoose < 0)
			{
				throw new ArgumentOutOfRangeException("elementsToChoose", "Value must not be negative (zero is ok).");
			}
			if (elementsToChoose > array.Length)
			{
				throw new ArgumentOutOfRangeException("elementsToChoose", "elementsToChoose must be smaller than or equal to data.Count.");
			}
			for (int i = array.Length - 1; i >= array.Length - elementsToChoose; i--)
			{
				int swapIndex = random.Next(i + 1);
				yield return array[swapIndex];
				array[swapIndex] = array[i];
			}
		}

		public static int[] GenerateVariationWithRepetition(int n, int k, System.Random randomSource = null)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "Value must not be negative (zero is ok).");
			}
			if (k < 0)
			{
				throw new ArgumentOutOfRangeException("k", "Value must not be negative (zero is ok).");
			}
			System.Random rnd = randomSource ?? SystemRandomSource.Default;
			int[] array = new int[k];
			rnd.NextInt32s(array, 0, n);
			return array;
		}

		public static IEnumerable<T> SelectVariationWithRepetition<T>(this IEnumerable<T> data, int elementsToChoose, System.Random randomSource = null)
		{
			if (elementsToChoose < 0)
			{
				throw new ArgumentOutOfRangeException("elementsToChoose", "Value must not be negative (zero is ok).");
			}
			T[] array = (data as T[]) ?? data.ToArray();
			int[] indices = GenerateVariationWithRepetition(array.Length, elementsToChoose, randomSource);
			for (int i = 0; i < indices.Length; i++)
			{
				yield return array[indices[i]];
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics")]
	public readonly struct Complex32 : IFormattable, IEquatable<Complex32>
	{
		[DataMember(Order = 1)]
		private readonly float _real;

		[DataMember(Order = 2)]
		private readonly float _imag;

		public static readonly Complex32 Zero = new Complex32(0f, 0f);

		public static readonly Complex32 One = new Complex32(1f, 0f);

		public static readonly Complex32 ImaginaryOne = new Complex32(0f, 1f);

		public static readonly Complex32 PositiveInfinity = new Complex32(float.PositiveInfinity, float.PositiveInfinity);

		public static readonly Complex32 NaN = new Complex32(float.NaN, float.NaN);

		public float Real
		{
			[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
			get
			{
				return _real;
			}
		}

		public float Imaginary
		{
			[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
			get
			{
				return _imag;
			}
		}

		public float Phase
		{
			[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
			get
			{
				if (_imag != 0f || !(_real < 0f))
				{
					return (float)Math.Atan2(_imag, _real);
				}
				return (float)Math.PI;
			}
		}

		public float Magnitude
		{
			[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
			get
			{
				if (float.IsNaN(_real) || float.IsNaN(_imag))
				{
					return float.NaN;
				}
				if (float.IsInfinity(_real) || float.IsInfinity(_imag))
				{
					return float.PositiveInfinity;
				}
				float num = Math.Abs(_real);
				float num2 = Math.Abs(_imag);
				if (num > num2)
				{
					double num3 = num2 / num;
					return num * (float)Math.Sqrt(1.0 + num3 * num3);
				}
				if (num == 0f)
				{
					return num2;
				}
				double num4 = num / num2;
				return num2 * (float)Math.Sqrt(1.0 + num4 * num4);
			}
		}

		public float MagnitudeSquared => _real * _real + _imag * _imag;

		public Complex32 Sign
		{
			get
			{
				if (float.IsPositiveInfinity(_real) && float.IsPositiveInfinity(_imag))
				{
					return new Complex32(0.70710677f, 0.70710677f);
				}
				if (float.IsPositiveInfinity(_real) && float.IsNegativeInfinity(_imag))
				{
					return new Complex32(0.70710677f, -0.70710677f);
				}
				if (float.IsNegativeInfinity(_real) && float.IsPositiveInfinity(_imag))
				{
					return new Complex32(-0.70710677f, -0.70710677f);
				}
				if (float.IsNegativeInfinity(_real) && float.IsNegativeInfinity(_imag))
				{
					return new Complex32(-0.70710677f, 0.70710677f);
				}
				float num = SpecialFunctions.Hypotenuse(_real, _imag);
				if (num == 0f)
				{
					return Zero;
				}
				return new Complex32(_real / num, _imag / num);
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public Complex32(float real, float imaginary)
		{
			_real = real;
			_imag = imaginary;
		}

		public static Complex32 FromPolarCoordinates(float magnitude, float phase)
		{
			return new Complex32(magnitude * (float)Math.Cos(phase), magnitude * (float)Math.Sin(phase));
		}

		public bool IsZero()
		{
			if (_real == 0f)
			{
				return _imag == 0f;
			}
			return false;
		}

		public bool IsOne()
		{
			if (_real == 1f)
			{
				return _imag == 0f;
			}
			return false;
		}

		public bool IsImaginaryOne()
		{
			if (_real == 0f)
			{
				return _imag == 1f;
			}
			return false;
		}

		public bool IsNaN()
		{
			if (!float.IsNaN(_real))
			{
				return float.IsNaN(_imag);
			}
			return true;
		}

		public bool IsInfinity()
		{
			if (!float.IsInfinity(_real))
			{
				return float.IsInfinity(_imag);
			}
			return true;
		}

		public bool IsReal()
		{
			return _imag == 0f;
		}

		public bool IsRealNonNegative()
		{
			if (_imag == 0f)
			{
				return _real >= 0f;
			}
			return false;
		}

		public Complex32 Exponential()
		{
			float num = (float)Math.Exp(_real);
			if (IsReal())
			{
				return new Complex32(num, 0f);
			}
			return new Complex32(num * (float)Math.Cos(_imag), num * (float)Math.Sin(_imag));
		}

		public Complex32 NaturalLogarithm()
		{
			if (IsRealNonNegative())
			{
				return new Complex32((float)Math.Log(_real), 0f);
			}
			return new Complex32(0.5f * (float)Math.Log(MagnitudeSquared), Phase);
		}

		public Complex32 CommonLogarithm()
		{
			return NaturalLogarithm() / 2.3025851f;
		}

		public Complex32 Logarithm(float baseValue)
		{
			return NaturalLogarithm() / (float)Math.Log(baseValue);
		}

		public Complex32 Power(Complex32 exponent)
		{
			if (IsZero())
			{
				if (exponent.IsZero())
				{
					return One;
				}
				if (exponent.Real > 0f)
				{
					return Zero;
				}
				if (exponent.Real < 0f)
				{
					if (exponent.Imaginary != 0f)
					{
						return new Complex32(float.PositiveInfinity, float.PositiveInfinity);
					}
					return new Complex32(float.PositiveInfinity, 0f);
				}
				return NaN;
			}
			return (exponent * NaturalLogarithm()).Exponential();
		}

		public Complex32 Root(Complex32 rootExponent)
		{
			return Power(1f / rootExponent);
		}

		public Complex32 Square()
		{
			if (IsReal())
			{
				return new Complex32(_real * _real, 0f);
			}
			return new Complex32(_real * _real - _imag * _imag, 2f * _real * _imag);
		}

		public Complex32 SquareRoot()
		{
			if (IsRealNonNegative())
			{
				return new Complex32((float)Math.Sqrt(_real), 0f);
			}
			float num = Math.Abs(Real);
			float num2 = Math.Abs(Imaginary);
			double num4;
			if (num >= num2)
			{
				float num3 = Imaginary / Real;
				num4 = Math.Sqrt(num) * Math.Sqrt(0.5 * (1.0 + Math.Sqrt(1f + num3 * num3)));
			}
			else
			{
				float num5 = Real / Imaginary;
				num4 = Math.Sqrt(num2) * Math.Sqrt(0.5 * ((double)Math.Abs(num5) + Math.Sqrt(1f + num5 * num5)));
			}
			return (Real >= 0f) ? new Complex32((float)num4, (float)((double)Imaginary / (2.0 * num4))) : ((!(Imaginary >= 0f)) ? new Complex32((float)((double)num2 / (2.0 * num4)), (float)(0.0 - num4)) : new Complex32((float)((double)num2 / (2.0 * num4)), (float)num4));
		}

		public Tuple<Complex32, Complex32> SquareRoots()
		{
			Complex32 complex = SquareRoot();
			return new Tuple<Complex32, Complex32>(complex, -complex);
		}

		public Tuple<Complex32, Complex32, Complex32> CubicRoots()
		{
			float magnitude = (float)Math.Pow(Magnitude, 1.0 / 3.0);
			float num = Phase / 3f;
			return new Tuple<Complex32, Complex32, Complex32>(FromPolarCoordinates(magnitude, num), FromPolarCoordinates(magnitude, num + (float)Math.PI * 2f / 3f), FromPolarCoordinates(magnitude, num - (float)Math.PI * 2f / 3f));
		}

		public static bool operator ==(Complex32 complex1, Complex32 complex2)
		{
			return complex1.Equals(complex2);
		}

		public static bool operator !=(Complex32 complex1, Complex32 complex2)
		{
			return !complex1.Equals(complex2);
		}

		public static Complex32 operator +(Complex32 summand)
		{
			return summand;
		}

		public static Complex32 operator -(Complex32 subtrahend)
		{
			return new Complex32(0f - subtrahend._real, 0f - subtrahend._imag);
		}

		public static Complex32 operator +(Complex32 summand1, Complex32 summand2)
		{
			return new Complex32(summand1._real + summand2._real, summand1._imag + summand2._imag);
		}

		public static Complex32 operator -(Complex32 minuend, Complex32 subtrahend)
		{
			return new Complex32(minuend._real - subtrahend._real, minuend._imag - subtrahend._imag);
		}

		public static Complex32 operator +(Complex32 summand1, float summand2)
		{
			return new Complex32(summand1._real + summand2, summand1._imag);
		}

		public static Complex32 operator -(Complex32 minuend, float subtrahend)
		{
			return new Complex32(minuend._real - subtrahend, minuend._imag);
		}

		public static Complex32 operator +(float summand1, Complex32 summand2)
		{
			return new Complex32(summand2._real + summand1, summand2._imag);
		}

		public static Complex32 operator -(float minuend, Complex32 subtrahend)
		{
			return new Complex32(minuend - subtrahend._real, 0f - subtrahend._imag);
		}

		public static Complex32 operator *(Complex32 multiplicand, Complex32 multiplier)
		{
			return new Complex32(multiplicand._real * multiplier._real - multiplicand._imag * multiplier._imag, multiplicand._real * multiplier._imag + multiplicand._imag * multiplier._real);
		}

		public static Complex32 operator *(float multiplicand, Complex32 multiplier)
		{
			return new Complex32(multiplier._real * multiplicand, multiplier._imag * multiplicand);
		}

		public static Complex32 operator *(Complex32 multiplicand, float multiplier)
		{
			return new Complex32(multiplicand._real * multiplier, multiplicand._imag * multiplier);
		}

		public static Complex32 operator /(Complex32 dividend, Complex32 divisor)
		{
			if (dividend.IsZero() && divisor.IsZero())
			{
				return NaN;
			}
			if (divisor.IsZero())
			{
				return PositiveInfinity;
			}
			float real = dividend.Real;
			float imaginary = dividend.Imaginary;
			float real2 = divisor.Real;
			float imaginary2 = divisor.Imaginary;
			if (Math.Abs(imaginary2) <= Math.Abs(real2))
			{
				return InternalDiv(real, imaginary, real2, imaginary2, swapped: false);
			}
			return InternalDiv(imaginary, real, imaginary2, real2, swapped: true);
		}

		private static Complex32 InternalDiv(float a, float b, float c, float d, bool swapped)
		{
			float num = d / c;
			float num2 = 1f / (c + d * num);
			float real;
			float num3;
			if (num != 0f)
			{
				real = (a + b * num) * num2;
				num3 = (b - a * num) * num2;
			}
			else
			{
				real = (a + d * (b / c)) * num2;
				num3 = (b - d * (a / c)) * num2;
			}
			if (swapped)
			{
				num3 = 0f - num3;
			}
			return new Complex32(real, num3);
		}

		public static Complex32 operator /(float dividend, Complex32 divisor)
		{
			if (dividend == 0f && divisor.IsZero())
			{
				return NaN;
			}
			if (divisor.IsZero())
			{
				return PositiveInfinity;
			}
			float real = divisor.Real;
			float imaginary = divisor.Imaginary;
			if (Math.Abs(imaginary) <= Math.Abs(real))
			{
				return InternalDiv(dividend, 0f, real, imaginary, swapped: false);
			}
			return InternalDiv(0f, dividend, imaginary, real, swapped: true);
		}

		public static Complex32 operator /(Complex32 dividend, float divisor)
		{
			if (dividend.IsZero() && divisor == 0f)
			{
				return NaN;
			}
			if (divisor == 0f)
			{
				return PositiveInfinity;
			}
			return new Complex32(dividend._real / divisor, dividend._imag / divisor);
		}

		public Complex32 Conjugate()
		{
			return new Complex32(_real, 0f - _imag);
		}

		public Complex32 Reciprocal()
		{
			if (IsZero())
			{
				return Zero;
			}
			return 1f / this;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", new object[2] { _real, _imag });
		}

		public string ToString(string format)
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", new object[2]
			{
				_real.ToString(format, CultureInfo.CurrentCulture),
				_imag.ToString(format, CultureInfo.CurrentCulture)
			});
		}

		public string ToString(IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", new object[2] { _real, _imag });
		}

		public string ToString(string format, IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", new object[2]
			{
				_real.ToString(format, provider),
				_imag.ToString(format, provider)
			});
		}

		public bool Equals(Complex32 other)
		{
			if (IsNaN() || other.IsNaN())
			{
				return false;
			}
			if (IsInfinity() && other.IsInfinity())
			{
				return true;
			}
			if (_real.AlmostEqual(other._real))
			{
				return _imag.AlmostEqual(other._imag);
			}
			return false;
		}

		public override int GetHashCode()
		{
			int num = 27;
			num = 13 * num + _real.GetHashCode();
			return 13 * num + _imag.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj is Complex32)
			{
				return Equals((Complex32)obj);
			}
			return false;
		}

		public static Complex32 Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			NumberFormatInfo numberFormatInfo = formatProvider.GetNumberFormatInfo();
			TextInfo textInfo = formatProvider.GetTextInfo();
			string[] keywords = new string[8] { textInfo.ListSeparator, numberFormatInfo.NaNSymbol, numberFormatInfo.NegativeInfinitySymbol, numberFormatInfo.PositiveInfinitySymbol, "+", "-", "i", "j" };
			LinkedList<string> linkedList = new LinkedList<string>();
			GlobalizationHelper.Tokenize(linkedList.AddFirst(value), keywords, 0);
			LinkedListNode<string> token = linkedList.First;
			bool imaginary;
			float num = ParsePart(ref token, out imaginary, formatProvider);
			if (token == null)
			{
				if (!imaginary)
				{
					return new Complex32(num, 0f);
				}
				return new Complex32(0f, num);
			}
			if (token.Value == textInfo.ListSeparator)
			{
				token = token.Next;
				if (imaginary)
				{
					throw new FormatException();
				}
				bool imaginary2;
				float imaginary3 = ParsePart(ref token, out imaginary2, formatProvider);
				return new Complex32(num, imaginary3);
			}
			bool imaginary4;
			float num2 = ParsePart(ref token, out imaginary4, formatProvider);
			if (!(imaginary ^ imaginary4))
			{
				throw new FormatException();
			}
			if (!imaginary)
			{
				return new Complex32(num, num2);
			}
			return new Complex32(num2, num);
		}

		private static float ParsePart(ref LinkedListNode<string> token, out bool imaginary, IFormatProvider format)
		{
			imaginary = false;
			if (token == null)
			{
				throw new FormatException();
			}
			if (token.Value == "+")
			{
				token = token.Next;
				if (token == null)
				{
					throw new FormatException();
				}
			}
			bool flag = false;
			if (token.Value == "-")
			{
				flag = true;
				token = token.Next;
				if (token == null)
				{
					throw new FormatException();
				}
			}
			if (string.Compare(token.Value, "i", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(token.Value, "j", StringComparison.OrdinalIgnoreCase) == 0)
			{
				imaginary = true;
				token = token.Next;
				if (token == null)
				{
					return (!flag) ? 1 : (-1);
				}
			}
			float num = GlobalizationHelper.ParseSingle(ref token, format.GetCultureInfo());
			if (token != null && (string.Compare(token.Value, "i", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(token.Value, "j", StringComparison.OrdinalIgnoreCase) == 0))
			{
				if (imaginary)
				{
					throw new FormatException();
				}
				imaginary = true;
				token = token.Next;
			}
			if (!flag)
			{
				return num;
			}
			return 0f - num;
		}

		public static bool TryParse(string value, out Complex32 result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out Complex32 result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = Zero;
				return false;
			}
			catch (FormatException)
			{
				result = Zero;
				return false;
			}
		}

		public static explicit operator Complex32(decimal value)
		{
			return new Complex32((float)value, 0f);
		}

		public static explicit operator Complex32(Complex value)
		{
			return new Complex32((float)value.Real, (float)value.Imaginary);
		}

		public static implicit operator Complex32(byte value)
		{
			return new Complex32((int)value, 0f);
		}

		public static implicit operator Complex32(short value)
		{
			return new Complex32(value, 0f);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex32(sbyte value)
		{
			return new Complex32(value, 0f);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex32(ushort value)
		{
			return new Complex32((int)value, 0f);
		}

		public static implicit operator Complex32(int value)
		{
			return new Complex32(value, 0f);
		}

		public static implicit operator Complex32(BigInteger value)
		{
			return new Complex32((long)value, 0f);
		}

		public static implicit operator Complex32(long value)
		{
			return new Complex32(value, 0f);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex32(uint value)
		{
			return new Complex32(value, 0f);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex32(ulong value)
		{
			return new Complex32(value, 0f);
		}

		public static implicit operator Complex32(float value)
		{
			return new Complex32(value, 0f);
		}

		public static explicit operator Complex32(double value)
		{
			return new Complex32((float)value, 0f);
		}

		public Complex ToComplex()
		{
			return new Complex(_real, _imag);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Negate(Complex32 value)
		{
			return -value;
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Conjugate(Complex32 value)
		{
			return value.Conjugate();
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Add(Complex32 left, Complex32 right)
		{
			return left + right;
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Subtract(Complex32 left, Complex32 right)
		{
			return left - right;
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Multiply(Complex32 left, Complex32 right)
		{
			return left * right;
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Divide(Complex32 dividend, Complex32 divisor)
		{
			return dividend / divisor;
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Reciprocal(Complex32 value)
		{
			return value.Reciprocal();
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Sqrt(Complex32 value)
		{
			return value.SquareRoot();
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double Abs(Complex32 value)
		{
			return value.Magnitude;
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Exp(Complex32 value)
		{
			return value.Exponential();
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Pow(Complex32 value, Complex32 power)
		{
			return value.Power(power);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Pow(Complex32 value, float power)
		{
			return value.Power(power);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Log(Complex32 value)
		{
			return value.NaturalLogarithm();
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Log(Complex32 value, float baseValue)
		{
			return value.Logarithm(baseValue);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex32 Log10(Complex32 value)
		{
			return value.CommonLogarithm();
		}

		public static Complex32 Sin(Complex32 value)
		{
			return (Complex32)value.ToComplex().Sin();
		}

		public static Complex32 Cos(Complex32 value)
		{
			return (Complex32)value.ToComplex().Cos();
		}

		public static Complex32 Tan(Complex32 value)
		{
			return (Complex32)value.ToComplex().Tan();
		}

		public static Complex32 Asin(Complex32 value)
		{
			return (Complex32)value.ToComplex().Asin();
		}

		public static Complex32 Acos(Complex32 value)
		{
			return (Complex32)value.ToComplex().Acos();
		}

		public static Complex32 Atan(Complex32 value)
		{
			return (Complex32)value.ToComplex().Atan();
		}

		public static Complex32 Sinh(Complex32 value)
		{
			return (Complex32)value.ToComplex().Sinh();
		}

		public static Complex32 Cosh(Complex32 value)
		{
			return (Complex32)value.ToComplex().Cosh();
		}

		public static Complex32 Tanh(Complex32 value)
		{
			return (Complex32)value.ToComplex().Tanh();
		}
	}
	public static class ComplexExtensions
	{
		public static double MagnitudeSquared(this Complex32 complex)
		{
			return complex.Real * complex.Real + complex.Imaginary * complex.Imaginary;
		}

		public static double MagnitudeSquared(this Complex complex)
		{
			return complex.Real * complex.Real + complex.Imaginary * complex.Imaginary;
		}

		public static Complex Sign(this Complex complex)
		{
			if (double.IsPositiveInfinity(complex.Real) && double.IsPositiveInfinity(complex.Imaginary))
			{
				return new Complex(0.7071067811865476, 0.7071067811865476);
			}
			if (double.IsPositiveInfinity(complex.Real) && double.IsNegativeInfinity(complex.Imaginary))
			{
				return new Complex(0.7071067811865476, -0.7071067811865476);
			}
			if (double.IsNegativeInfinity(complex.Real) && double.IsPositiveInfinity(complex.Imaginary))
			{
				return new Complex(-0.7071067811865476, -0.7071067811865476);
			}
			if (double.IsNegativeInfinity(complex.Real) && double.IsNegativeInfinity(complex.Imaginary))
			{
				return new Complex(-0.7071067811865476, 0.7071067811865476);
			}
			double num = SpecialFunctions.Hypotenuse(complex.Real, complex.Imaginary);
			if (num == 0.0)
			{
				return Complex.Zero;
			}
			return new Complex(complex.Real / num, complex.Imaginary / num);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex Conjugate(this Complex complex)
		{
			return Complex.Conjugate(complex);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex Reciprocal(this Complex complex)
		{
			return Complex.Reciprocal(complex);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex Exp(this Complex complex)
		{
			return Complex.Exp(complex);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex Ln(this Complex complex)
		{
			return Complex.Log(complex);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex Log10(this Complex complex)
		{
			return Complex.Log10(complex);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static Complex Log(this Complex complex, double baseValue)
		{
			return Complex.Log(complex, baseValue);
		}

		public static Complex Power(this Complex complex, Complex exponent)
		{
			if (complex.IsZero())
			{
				if (exponent.IsZero())
				{
					return Complex.One;
				}
				if (exponent.Real > 0.0)
				{
					return Complex.Zero;
				}
				if (exponent.Real < 0.0)
				{
					if (exponent.Imaginary != 0.0)
					{
						return new Complex(double.PositiveInfinity, double.PositiveInfinity);
					}
					return new Complex(double.PositiveInfinity, 0.0);
				}
				return new Complex(double.NaN, double.NaN);
			}
			return Complex.Pow(complex, exponent);
		}

		public static Complex Root(this Complex complex, Complex rootExponent)
		{
			return Complex.Pow(complex, 1 / rootExponent);
		}

		public static Complex Square(this Complex complex)
		{
			if (complex.IsReal())
			{
				return new Complex(complex.Real * complex.Real, 0.0);
			}
			return new Complex(complex.Real * complex.Real - complex.Imaginary * complex.Imaginary, 2.0 * complex.Real * complex.Imaginary);
		}

		public static Complex SquareRoot(this Complex complex)
		{
			if (complex.IsRealNonNegative())
			{
				return new Complex(Math.Sqrt(complex.Real), 0.0);
			}
			double num = Math.Abs(complex.Real);
			double num2 = Math.Abs(complex.Imaginary);
			double num4;
			if (num >= num2)
			{
				double num3 = complex.Imaginary / complex.Real;
				num4 = Math.Sqrt(num) * Math.Sqrt(0.5 * (1.0 + Math.Sqrt(1.0 + num3 * num3)));
			}
			else
			{
				double num5 = complex.Real / complex.Imaginary;
				num4 = Math.Sqrt(num2) * Math.Sqrt(0.5 * (Math.Abs(num5) + Math.Sqrt(1.0 + num5 * num5)));
			}
			return (complex.Real >= 0.0) ? new Complex(num4, complex.Imaginary / (2.0 * num4)) : ((!(complex.Imaginary >= 0.0)) ? new Complex(num2 / (2.0 * num4), 0.0 - num4) : new Complex(num2 / (2.0 * num4), num4));
		}

		public static Tuple<Complex, Complex> SquareRoots(this Complex complex)
		{
			Complex complex2 = complex.SquareRoot();
			return new Tuple<Complex, Complex>(complex2, -complex2);
		}

		public static Tuple<Complex, Complex, Complex> CubicRoots(this Complex complex)
		{
			double magnitude = Math.Pow(complex.Magnitude, 1.0 / 3.0);
			double num = complex.Phase / 3.0;
			return new Tuple<Complex, Complex, Complex>(Complex.FromPolarCoordinates(magnitude, num), Complex.FromPolarCoordinates(magnitude, num + Math.PI * 2.0 / 3.0), Complex.FromPolarCoordinates(magnitude, num - Math.PI * 2.0 / 3.0));
		}

		public static bool IsZero(this Complex complex)
		{
			if (complex.Real == 0.0)
			{
				return complex.Imaginary == 0.0;
			}
			return false;
		}

		public static bool IsOne(this Complex complex)
		{
			if (complex.Real == 1.0)
			{
				return complex.Imaginary == 0.0;
			}
			return false;
		}

		public static bool IsImaginaryOne(this Complex complex)
		{
			if (complex.Real == 0.0)
			{
				return complex.Imaginary == 1.0;
			}
			return false;
		}

		public static bool IsNaN(this Complex complex)
		{
			if (!double.IsNaN(complex.Real))
			{
				return double.IsNaN(complex.Imaginary);
			}
			return true;
		}

		public static bool IsInfinity(this Complex complex)
		{
			if (!double.IsInfinity(complex.Real))
			{
				return double.IsInfinity(complex.Imaginary);
			}
			return true;
		}

		public static bool IsReal(this Complex complex)
		{
			return complex.Imaginary == 0.0;
		}

		public static bool IsRealNonNegative(this Complex complex)
		{
			if (complex.Imaginary == 0.0)
			{
				return complex.Real >= 0.0;
			}
			return false;
		}

		public static double Norm(this Complex complex)
		{
			return complex.MagnitudeSquared();
		}

		public static double Norm(this Complex32 complex)
		{
			return complex.MagnitudeSquared;
		}

		public static double NormOfDifference(this Complex complex, Complex otherValue)
		{
			return (complex - otherValue).MagnitudeSquared();
		}

		public static double NormOfDifference(this Complex32 complex, Complex32 otherValue)
		{
			return (complex - otherValue).MagnitudeSquared;
		}

		public static Complex ToComplex(this string value)
		{
			return value.ToComplex(null);
		}

		public static Complex ToComplex(this string value, IFormatProvider formatProvider)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			NumberFormatInfo numberFormatInfo = formatProvider.GetNumberFormatInfo();
			TextInfo textInfo = formatProvider.GetTextInfo();
			string[] keywords = new string[8] { textInfo.ListSeparator, numberFormatInfo.NaNSymbol, numberFormatInfo.NegativeInfinitySymbol, numberFormatInfo.PositiveInfinitySymbol, "+", "-", "i", "j" };
			LinkedList<string> linkedList = new LinkedList<string>();
			GlobalizationHelper.Tokenize(linkedList.AddFirst(value), keywords, 0);
			LinkedListNode<string> token = linkedList.First;
			bool imaginary;
			double num = ParsePart(ref token, out imaginary, formatProvider);
			if (token == null)
			{
				if (!imaginary)
				{
					return new Complex(num, 0.0);
				}
				return new Complex(0.0, num);
			}
			if (token.Value == textInfo.ListSeparator)
			{
				token = token.Next;
				if (imaginary)
				{
					throw new FormatException();
				}
				bool imaginary2;
				double imaginary3 = ParsePart(ref token, out imaginary2, formatProvider);
				return new Complex(num, imaginary3);
			}
			bool imaginary4;
			double num2 = ParsePart(ref token, out imaginary4, formatProvider);
			if (!(imaginary ^ imaginary4))
			{
				throw new FormatException();
			}
			if (!imaginary)
			{
				return new Complex(num, num2);
			}
			return new Complex(num2, num);
		}

		private static double ParsePart(ref LinkedListNode<string> token, out bool imaginary, IFormatProvider format)
		{
			imaginary = false;
			if (token == null)
			{
				throw new FormatException();
			}
			if (token.Value == "+")
			{
				token = token.Next;
				if (token == null)
				{
					throw new FormatException();
				}
			}
			bool flag = false;
			if (token.Value == "-")
			{
				flag = true;
				token = token.Next;
				if (token == null)
				{
					throw new FormatException();
				}
			}
			if (string.Compare(token.Value, "i", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(token.Value, "j", StringComparison.OrdinalIgnoreCase) == 0)
			{
				imaginary = true;
				token = token.Next;
				if (token == null)
				{
					return (!flag) ? 1 : (-1);
				}
			}
			double num = GlobalizationHelper.ParseDouble(ref token, format.GetCultureInfo());
			if (token != null && (string.Compare(token.Value, "i", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(token.Value, "j", StringComparison.OrdinalIgnoreCase) == 0))
			{
				if (imaginary)
				{
					throw new FormatException();
				}
				imaginary = true;
				token = token.Next;
			}
			if (!flag)
			{
				return num;
			}
			return 0.0 - num;
		}

		public static bool TryToComplex(this string value, out Complex result)
		{
			return value.TryToComplex(null, out result);
		}

		public static bool TryToComplex(this string value, IFormatProvider formatProvider, out Complex result)
		{
			try
			{
				result = value.ToComplex(formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = Complex.Zero;
				return false;
			}
			catch (FormatException)
			{
				result = Complex.Zero;
				return false;
			}
		}

		public static Complex32 ToComplex32(this string value)
		{
			return Complex32.Parse(value);
		}

		public static Complex32 ToComplex32(this string value, IFormatProvider formatProvider)
		{
			return Complex32.Parse(value, formatProvider);
		}

		public static bool TryToComplex32(this string value, out Complex32 result)
		{
			return Complex32.TryParse(value, out result);
		}

		public static bool TryToComplex32(this string value, IFormatProvider formatProvider, out Complex32 result)
		{
			return Complex32.TryParse(value, formatProvider, out result);
		}
	}
	public static class Constants
	{
		public const double E = Math.E;

		public const double Log2E = 1.4426950408889634;

		public const double Log10E = 0.4342944819032518;

		public const double Ln2 = 0.6931471805599453;

		public const double Ln10 = 2.302585092994046;

		public const double LnPi = 1.1447298858494002;

		public const double Ln2PiOver2 = 0.9189385332046728;

		public const double InvE = 1.0 / Math.E;

		public const double SqrtE = 1.6487212707001282;

		public const double Sqrt2 = 1.4142135623730951;

		public const double Sqrt3 = 1.7320508075688772;

		public const double Sqrt1Over2 = 0.7071067811865476;

		public const double HalfSqrt3 = 0.8660254037844386;

		public const double Pi = Math.PI;

		public const double Pi2 = Math.PI * 2.0;

		public const double PiOver2 = Math.PI / 2.0;

		public const double Pi3Over2 = 4.71238898038469;

		public const double PiOver4 = Math.PI / 4.0;

		public const double SqrtPi = 1.772453850905516;

		public const double Sqrt2Pi = 2.5066282746310007;

		public const double SqrtPiOver2 = 1.2533141373155003;

		public const double Sqrt2PiE = 4.132731354122493;

		public const double LogSqrt2Pi = 0.9189385332046728;

		public const double LogSqrt2PiE = 1.4189385332046727;

		public const double LogTwoSqrtEOverPi = 0.6207822376352452;

		public const double InvPi = 1.0 / Math.PI;

		public const double TwoInvPi = 2.0 / Math.PI;

		public const double InvSqrtPi = 0.5641895835477563;

		public const double InvSqrt2Pi = 0.3989422804014327;

		public const double TwoInvSqrtPi = 1.1283791670955126;

		public const double TwoSqrtEOverPi = 1.8603827342052657;

		public const double Degree = Math.PI / 180.0;

		public const double Grad = Math.PI / 200.0;

		public const double PowerDecibel = 0.11512925464970228;

		public const double NeutralDecibel = 0.23025850929940456;

		public const double Catalan = 0.915965594177219;

		public const double EulerMascheroni = 0.5772156649015329;

		public const double GoldenRatio = 1.618033988749895;

		public const double Glaisher = 1.2824271291006226;

		public const double Khinchin = 2.6854520010653062;

		public const int SizeOfDouble = 8;

		public const int SizeOfInt = 4;

		public const int SizeOfFloat = 4;

		public const int SizeOfComplex = 16;

		public const int SizeOfComplex32 = 8;

		public const double SpeedOfLight = 299792458.0;

		public const double MagneticPermeability = 1.2566370614359173E-06;

		public const double ElectricPermittivity = 8.854187817193708E-12;

		public const double CharacteristicImpedanceVacuum = 376.73031346177066;

		public const double GravitationalConstant = 6.67429E-11;

		public const double PlancksConstant = 6.62606896E-34;

		public const double DiracsConstant = 1.054571629E-34;

		public const double PlancksMass = 2.17644E-08;

		public const double PlancksTemperature = 1.416786E+32;

		public const double PlancksLength = 1.616253E-35;

		public const double PlancksTime = 5.39124E-44;

		public const double ElementaryCharge = 1.602176487E-19;

		public const double MagneticFluxQuantum = 2.067833668E-15;

		public const double ConductanceQuantum = 7.7480917005E-05;

		public const double JosephsonConstant = 483597891000000.0;

		public const double VonKlitzingConstant = 25812.807557;

		public const double BohrMagneton = 9.27400915E-24;

		public const double NuclearMagneton = 5.05078324E-27;

		public const double FineStructureConstant = 0.0072973525376;

		public const double RydbergConstant = 10973731.568528;

		public const double BohrRadius = 5.2917720859E-11;

		public const double HartreeEnergy = 4.35974394E-18;

		public const double QuantumOfCirculation = 0.00036369475199;

		public const double FermiCouplingConstant = 1.16637E-05;

		public const double WeakMixingAngle = 0.22256;

		public const double ElectronMass = 9.10938215E-31;

		public const double ElectronMassEnergyEquivalent = 8.18710438E-14;

		public const double ElectronMolarMass = 5.4857990943E-07;

		public const double ComptonWavelength = 2.4263102175E-12;

		public const double ClassicalElectronRadius = 2.8179402894E-15;

		public const double ThomsonCrossSection = 6.652458558E-29;

		public const double ElectronMagneticMoment = -9.28476377E-24;

		public const double ElectronGFactor = -2.0023193043622;

		public const double MuonMass = 1.8835313E-28;

		public const double MuonMassEnegryEquivalent = 1.692833511E-11;

		public const double MuonMolarMass = 0.0001134289256;

		public const double MuonComptonWavelength = 1.173444104E-14;

		public const double MuonMagneticMoment = -4.49044786E-26;

		public const double MuonGFactor = -2.0023318414;

		public const double TauMass = 3.16777E-27;

		public const double TauMassEnergyEquivalent = 2.84705E-10;

		public const double TauMolarMass = 0.00190768;

		public const double TauComptonWavelength = 6.9772E-16;

		public const double ProtonMass = 1.672621637E-27;

		public const double ProtonMassEnergyEquivalent = 1.503277359E-10;

		public const double ProtonMolarMass = 0.00100727646677;

		public const double ProtonComptonWavelength = 1.3214098446E-15;

		public const double ProtonMagneticMoment = 1.410606662E-26;

		public const double ProtonGFactor = 5.585694713;

		public const double ShieldedProtonMagneticMoment = 1.410570419E-26;

		public const double ProtonGyromagneticRatio = 267522209.9;

		public const double ShieldedProtonGyromagneticRatio = 267515336.2;

		public const double NeutronMass = 1.674927212E-27;

		public const double NeutronMassEnegryEquivalent = 1.505349506E-10;

		public const double NeutronMolarMass = 0.00100866491597;

		public const double NeutronComptonWavelength = 0.13195908951;

		public const double NeutronMagneticMoment = -9.6623641E-27;

		public const double NeutronGFactor = -3.82608545;

		public const double NeutronGyromagneticRatio = 183247185.0;

		public const double DeuteronMass = 3.3435832E-27;

		public const double DeuteronMassEnegryEquivalent = 3.00506272E-10;

		public const double DeuteronMolarMass = 0.002013553212725;

		public const double DeuteronMagneticMoment = 4.33073465E-27;

		public const double HelionMass = 5.00641192E-27;

		public const double HelionMassEnegryEquivalent = 4.49953864E-10;

		public const double HelionMolarMass = 0.0030149322473;

		public const double Avogadro = 6.0221412927E+23;

		public const double Yotta = 1E+24;

		public const double Zetta = 1E+21;

		public const double Exa = 1E+18;

		public const double Peta = 1000000000000000.0;

		public const double Tera = 1000000000000.0;

		public const double Giga = 1000000000.0;

		public const double Mega = 1000000.0;

		public const double Kilo = 1000.0;

		public const double Hecto = 100.0;

		public const double Deca = 10.0;

		public const double Deci = 0.1;

		public const double Centi = 0.01;

		public const double Milli = 0.001;

		public const double Micro = 1E-06;

		public const double Nano = 1E-09;

		public const double Pico = 1E-12;

		public const double Femto = 1E-15;

		public const double Atto = 1E-18;

		public const double Zepto = 1E-21;

		public const double Yocto = 1E-24;
	}
	public static class Control
	{
		private static int _maxDegreeOfParallelism;

		private static int _parallelizeOrder;

		private static int _parallelizeElements;

		private static string _nativeProviderHintPath;

		public static bool CheckDistributionParameters { get; set; }

		public static bool ThreadSafeRandomNumberGenerators { get; set; }

		public static string NativeProviderPath
		{
			get
			{
				return _nativeProviderHintPath;
			}
			set
			{
				_nativeProviderHintPath = value;
				LinearAlgebraControl.HintPath = value;
				FourierTransformControl.HintPath = value;
				SparseSolverControl.HintPath = value;
			}
		}

		public static int MaxDegreeOfParallelism
		{
			get
			{
				return _maxDegreeOfParallelism;
			}
			set
			{
				_maxDegreeOfParallelism = Math.Max(1, Math.Min(1024, value));
				LinearAlgebraControl.Provider.InitializeVerify();
				FourierTransformControl.Provider.InitializeVerify();
				SparseSolverControl.Provider.InitializeVerify();
			}
		}

		public static TaskScheduler TaskScheduler { get; set; }

		internal static int ParallelizeOrder
		{
			get
			{
				return _parallelizeOrder;
			}
			set
			{
				_parallelizeOrder = Math.Max(3, value);
			}
		}

		internal static int ParallelizeElements
		{
			get
			{
				return _parallelizeElements;
			}
			set
			{
				_parallelizeElements = Math.Max(3, value);
			}
		}

		static Control()
		{
			ConfigureAuto();
		}

		public static void ConfigureAuto()
		{
			CheckDistributionParameters = true;
			ThreadSafeRandomNumberGenerators = true;
			_maxDegreeOfParallelism = Environment.ProcessorCount;
			_parallelizeOrder = 64;
			_parallelizeElements = 300;
			TaskScheduler = TaskScheduler.Default;
		}

		public static void UseManaged()
		{
			LinearAlgebraControl.UseManaged();
			FourierTransformControl.UseManaged();
			SparseSolverControl.UseManaged();
		}

		public static void UseManagedReference()
		{
			LinearAlgebraControl.UseManagedReference();
			FourierTransformControl.UseManaged();
			SparseSolverControl.UseManaged();
		}

		public static void UseDefaultProviders()
		{
			if (AppSwitches.DisableNativeProviders)
			{
				UseManaged();
				return;
			}
			LinearAlgebraControl.UseDefault();
			FourierTransformControl.UseDefault();
			SparseSolverControl.UseDefault();
		}

		public static void UseBestProviders()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				UseManaged();
				return;
			}
			LinearAlgebraControl.UseBest();
			FourierTransformControl.UseBest();
			SparseSolverControl.UseBest();
		}

		public static void UseNativeMKL()
		{
			LinearAlgebraControl.UseNativeMKL();
			FourierTransformControl.UseNativeMKL();
			SparseSolverControl.UseNativeMKL();
		}

		[CLSCompliant(false)]
		public static void UseNativeMKL(MklConsistency consistency = MklConsistency.Auto, MklPrecision precision = MklPrecision.Double, MklAccuracy accuracy = MklAccuracy.High)
		{
			LinearAlgebraControl.UseNativeMKL(consistency, precision, accuracy);
			FourierTransformControl.UseNativeMKL();
			SparseSolverControl.UseNativeMKL();
		}

		public static bool TryUseNativeMKL()
		{
			bool num = LinearAlgebraControl.TryUseNativeMKL();
			bool flag = FourierTransformControl.TryUseNativeMKL();
			bool flag2 = SparseSolverControl.TryUseNativeMKL();
			return num || flag || flag2;
		}

		public static void UseNativeCUDA()
		{
			LinearAlgebraControl.UseNativeCUDA();
		}

		public static bool TryUseNativeCUDA()
		{
			return LinearAlgebraControl.TryUseNativeCUDA();
		}

		public static void UseNativeOpenBLAS()
		{
			LinearAlgebraControl.UseNativeOpenBLAS();
		}

		public static bool TryUseNativeOpenBLAS()
		{
			return LinearAlgebraControl.TryUseNativeOpenBLAS();
		}

		public static bool TryUseNative()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				return false;
			}
			bool num = LinearAlgebraControl.TryUseNative();
			bool flag = FourierTransformControl.TryUseNative();
			bool flag2 = SparseSolverControl.TryUseNative();
			return num || flag || flag2;
		}

		public static void FreeResources()
		{
			LinearAlgebraControl.FreeResources();
			FourierTransformControl.FreeResources();
			SparseSolverControl.FreeResources();
		}

		public static void UseSingleThread()
		{
			_maxDegreeOfParallelism = 1;
			ThreadSafeRandomNumberGenerators = false;
			LinearAlgebraControl.Provider.InitializeVerify();
			FourierTransformControl.Provider.InitializeVerify();
			SparseSolverControl.Provider.InitializeVerify();
		}

		public static void UseMultiThreading()
		{
			_maxDegreeOfParallelism = Environment.ProcessorCount;
			ThreadSafeRandomNumberGenerators = true;
			LinearAlgebraControl.Provider.InitializeVerify();
			FourierTransformControl.Provider.InitializeVerify();
			SparseSolverControl.Provider.InitializeVerify();
		}

		public static string Describe()
		{
			AssemblyInformationalVersionAttribute assemblyInformationalVersionAttribute = typeof(Control).Assembly.GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute), inherit: false).OfType<AssemblyInformationalVersionAttribute>().FirstOrDefault();
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Math.NET Numerics Configuration:");
			stringBuilder.AppendLine("Version " + assemblyInformationalVersionAttribute?.InformationalVersion);
			stringBuilder.AppendLine("Built for .Net Framework 4.0");
			stringBuilder.AppendLine($"Linear Algebra Provider: {LinearAlgebraControl.Provider}");
			stringBuilder.AppendLine($"Fourier Transform Provider: {FourierTransformControl.Provider}");
			stringBuilder.AppendLine($"Sparse Solver Provider: {SparseSolverControl.Provider}");
			stringBuilder.AppendLine($"Max Degree of Parallelism: {MaxDegreeOfParallelism}");
			stringBuilder.AppendLine($"Parallelize Elements: {ParallelizeElements}");
			stringBuilder.AppendLine($"Parallelize Order: {ParallelizeOrder}");
			stringBuilder.AppendLine($"Check Distribution Parameters: {CheckDistributionParameters}");
			stringBuilder.AppendLine($"Thread-Safe RNGs: {ThreadSafeRandomNumberGenerators}");
			stringBuilder.AppendLine($"Operating System: {Environment.OSVersion}");
			stringBuilder.AppendLine($"Framework: {Environment.Version}");
			return stringBuilder.ToString();
		}
	}
	public static class Differentiate
	{
		public static NumericalDerivative Points(int points, int center)
		{
			return new NumericalDerivative(points, center);
		}

		public static NumericalDerivative Order(int order)
		{
			int num = order + (order.IsEven() ? 1 : 2);
			return new NumericalDerivative(num, num / 2);
		}

		public static double Derivative(Func<double, double> f, double x, int order)
		{
			return Order(order).EvaluateDerivative(f, x, order);
		}

		public static Func<double, double> DerivativeFunc(Func<double, double> f, int order)
		{
			return Order(order).CreateDerivativeFunctionHandle(f, order);
		}

		public static double FirstDerivative(Func<double, double> f, double x)
		{
			return Order(1).EvaluateDerivative(f, x, 1);
		}

		public static Func<double, double> FirstDerivativeFunc(Func<double, double> f)
		{
			return Order(1).CreateDerivativeFunctionHandle(f, 1);
		}

		public static double SecondDerivative(Func<double, double> f, double x)
		{
			return Order(2).EvaluateDerivative(f, x, 2);
		}

		public static Func<double, double> SecondDerivativeFunc(Func<double, double> f)
		{
			return Order(2).CreateDerivativeFunctionHandle(f, 2);
		}

		public static double PartialDerivative(Func<double[], double> f, double[] x, int parameterIndex, int order)
		{
			return Order(order).EvaluatePartialDerivative(f, x, parameterIndex, order);
		}

		public static Func<double[], double> PartialDerivativeFunc(Func<double[], double> f, int parameterIndex, int order)
		{
			return Order(order).CreatePartialDerivativeFunctionHandle(f, parameterIndex, order);
		}

		public static double FirstPartialDerivative(Func<double[], double> f, double[] x, int parameterIndex)
		{
			return PartialDerivative(f, x, parameterIndex, 1);
		}

		public static Func<double[], double> FirstPartialDerivativeFunc(Func<double[], double> f, int parameterIndex)
		{
			return PartialDerivativeFunc(f, parameterIndex, 1);
		}

		public static double PartialDerivative2(Func<double, double, double> f, double x, double y, int parameterIndex, int order)
		{
			return Order(order).EvaluatePartialDerivative((double[] array) => f(array[0], array[1]), new double[2] { x, y }, parameterIndex, order);
		}

		public static Func<double, double, double> PartialDerivative2Func(Func<double, double, double> f, int parameterIndex, int order)
		{
			Func<double[], double> handle = Order(order).CreatePartialDerivativeFunctionHandle((double[] array) => f(array[0], array[1]), parameterIndex, order);
			return (double x, double y) => handle(new double[2] { x, y });
		}

		public static double FirstPartialDerivative2(Func<double, double, double> f, double x, double y, int parameterIndex)
		{
			return PartialDerivative2(f, x, y, parameterIndex, 1);
		}

		public static Func<double, double, double> FirstPartialDerivative2Func(Func<double, double, double> f, int parameterIndex)
		{
			return PartialDerivative2Func(f, parameterIndex, 1);
		}
	}
	public static class DifferIntegrate
	{
		public static double DoubleExponential(Func<double, double> f, double x, double order, double x0 = 0.0, double targetAbsoluteError = 1E-10)
		{
			if (Math.Abs(order) < double.Epsilon)
			{
				return f(x);
			}
			if (order > 0.0 && Math.Abs(order - (double)(int)order) < double.Epsilon)
			{
				return Differentiate.Derivative(f, x, (int)order);
			}
			int num = (int)Math.Ceiling(order) + 1;
			if (num < 1)
			{
				num = 1;
			}
			double r = (double)num - order - 1.0;
			double num2 = Differentiate.Derivative((double v) => Integrate.DoubleExponential((double t) => Math.Pow(v - t, r) * f(t), x0, v, targetAbsoluteError), x, num);
			double num3 = SpecialFunctions.Gamma((double)num - order);
			return num2 / num3;
		}

		public static double GaussLegendre(Func<double, double> f, double x, double order, double x0 = 0.0, int gaussLegendrePoints = 128)
		{
			if (Math.Abs(order) < double.Epsilon)
			{
				return f(x);
			}
			if (order > 0.0 && Math.Abs(order - (double)(int)order) < double.Epsilon)
			{
				return Differentiate.Derivative(f, x, (int)order);
			}
			int num = (int)Math.Ceiling(order) + 1;
			if (num < 1)
			{
				num = 1;
			}
			double r = (double)num - order - 1.0;
			double num2 = Differentiate.Derivative((double v) => Integrate.GaussLegendre((double t) => Math.Pow(v - t, r) * f(t), x0, v, gaussLegendrePoints), x, num);
			double num3 = SpecialFunctions.Gamma((double)num - order);
			return num2 / num3;
		}

		public static double GaussKronrod(Func<double, double> f, double x, double order, double x0 = 0.0, double targetRelativeError = 1E-10, int gaussKronrodPoints = 15)
		{
			if (Math.Abs(order) < double.Epsilon)
			{
				return f(x);
			}
			if (order > 0.0 && Math.Abs(order - (double)(int)order) < double.Epsilon)
			{
				return Differentiate.Derivative(f, x, (int)order);
			}
			int num = (int)Math.Ceiling(order) + 1;
			if (num < 1)
			{
				num = 1;
			}
			double r = (double)num - order - 1.0;
			double num2 = Differentiate.Derivative((double v) => Integrate.GaussKronrod((double t) => Math.Pow(v - t, r) * f(t), x0, v, targetRelativeError, 15, gaussKronrodPoints), x, num);
			double num3 = SpecialFunctions.Gamma((double)num - order);
			return num2 / num3;
		}
	}
	public static class Distance
	{
		public static double SAD<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			return (a - b).L1Norm();
		}

		public static double SAD(double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double num = 0.0;
			for (int i = 0; i < a.Length; i++)
			{
				num += Math.Abs(a[i] - b[i]);
			}
			return num;
		}

		public static float SAD(float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float num = 0f;
			for (int i = 0; i < a.Length; i++)
			{
				num += Math.Abs(a[i] - b[i]);
			}
			return num;
		}

		public static double MAE<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			return (a - b).L1Norm() / (double)a.Count;
		}

		public static double MAE(double[] a, double[] b)
		{
			return SAD(a, b) / (double)a.Length;
		}

		public static float MAE(float[] a, float[] b)
		{
			return SAD(a, b) / (float)a.Length;
		}

		public static double SSD<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			double num = (a - b).L2Norm();
			return num * num;
		}

		public static double SSD(double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double[] array = new double[a.Length];
			LinearAlgebraControl.Provider.SubtractArrays(a, b, array);
			return LinearAlgebraControl.Provider.DotProduct(array, array);
		}

		public static float SSD(float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float[] array = new float[a.Length];
			LinearAlgebraControl.Provider.SubtractArrays(a, b, array);
			return LinearAlgebraControl.Provider.DotProduct(array, array);
		}

		public static double MSE<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			double num = (a - b).L2Norm();
			return num * num / (double)a.Count;
		}

		public static double MSE(double[] a, double[] b)
		{
			return SSD(a, b) / (double)a.Length;
		}

		public static float MSE(float[] a, float[] b)
		{
			return SSD(a, b) / (float)a.Length;
		}

		public static double Euclidean<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			return (a - b).L2Norm();
		}

		public static double Euclidean(double[] a, double[] b)
		{
			return Math.Sqrt(SSD(a, b));
		}

		public static float Euclidean(float[] a, float[] b)
		{
			return (float)Math.Sqrt(SSD(a, b));
		}

		public static double Manhattan<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			return (a - b).L1Norm();
		}

		public static double Manhattan(double[] a, double[] b)
		{
			return SAD(a, b);
		}

		public static float Manhattan(float[] a, float[] b)
		{
			return SAD(a, b);
		}

		public static double Chebyshev<T>(Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			return (a - b).InfinityNorm();
		}

		public static double Chebyshev(double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double num = Math.Abs(a[0] - b[0]);
			for (int i = 1; i < a.Length; i++)
			{
				double num2 = Math.Abs(a[i] - b[i]);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		public static float Chebyshev(float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float num = Math.Abs(a[0] - b[0]);
			for (int i = 1; i < a.Length; i++)
			{
				float num2 = Math.Abs(a[i] - b[i]);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		public static double Minkowski<T>(double p, Vector<T> a, Vector<T> b) where T : struct, IEquatable<T>, IFormattable
		{
			return (a - b).Norm(p);
		}

		public static double Minkowski(double p, double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return Manhattan(a, b);
			}
			if (p == 2.0)
			{
				return Euclidean(a, b);
			}
			if (double.IsPositiveInfinity(p))
			{
				return Chebyshev(a, b);
			}
			double num = 0.0;
			for (int i = 0; i < a.Length; i++)
			{
				num += Math.Pow(Math.Abs(a[i] - b[i]), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		public static float Minkowski(double p, float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return Manhattan(a, b);
			}
			if (p == 2.0)
			{
				return Euclidean(a, b);
			}
			if (double.IsPositiveInfinity(p))
			{
				return Chebyshev(a, b);
			}
			double num = 0.0;
			for (int i = 0; i < a.Length; i++)
			{
				num += Math.Pow(Math.Abs(a[i] - b[i]), p);
			}
			return (float)Math.Pow(num, 1.0 / p);
		}

		public static double Canberra(double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double num = 0.0;
			for (int i = 0; i < a.Length; i++)
			{
				num += Math.Abs(a[i] - b[i]) / (Math.Abs(a[i]) + Math.Abs(b[i]));
			}
			return num;
		}

		public static float Canberra(float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float num = 0f;
			for (int i = 0; i < a.Length; i++)
			{
				num += Math.Abs(a[i] - b[i]) / (Math.Abs(a[i]) + Math.Abs(b[i]));
			}
			return num;
		}

		public static double Cosine(double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double num = LinearAlgebraControl.Provider.DotProduct(a, b);
			double num2 = LinearAlgebraControl.Provider.DotProduct(a, a);
			double num3 = LinearAlgebraControl.Provider.DotProduct(b, b);
			return 1.0 - num / Math.Sqrt(num2 * num3);
		}

		public static float Cosine(float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float num = LinearAlgebraControl.Provider.DotProduct(a, b);
			float num2 = LinearAlgebraControl.Provider.DotProduct(a, a);
			float num3 = LinearAlgebraControl.Provider.DotProduct(b, b);
			return (float)(1.0 - (double)num / Math.Sqrt(num2 * num3));
		}

		public static double Hamming(double[] a, double[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			int num = 0;
			for (int i = 0; i < a.Length; i++)
			{
				if (a[i] != b[i])
				{
					num++;
				}
			}
			return num;
		}

		public static float Hamming(float[] a, float[] b)
		{
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			int num = 0;
			for (int i = 0; i < a.Length; i++)
			{
				if (a[i] != b[i])
				{
					num++;
				}
			}
			return num;
		}

		public static double Pearson(IEnumerable<double> a, IEnumerable<double> b)
		{
			return 1.0 - Correlation.Pearson(a, b);
		}

		public static double Jaccard(double[] a, double[] b)
		{
			int num = 0;
			int num2 = 0;
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (a.Length == 0 && b.Length == 0)
			{
				return 0.0;
			}
			int i = 0;
			for (int num3 = a.Length; i < num3; i++)
			{
				if (a[i] != 0.0 && b[i] != 0.0)
				{
					if (a[i] == b[i])
					{
						num++;
					}
					num2++;
				}
			}
			return 1.0 - (double)num / (double)num2;
		}

		public static double Jaccard(float[] a, float[] b)
		{
			int num = 0;
			int num2 = 0;
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != b.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (a.Length == 0 && b.Length == 0)
			{
				return 0.0;
			}
			int i = 0;
			for (int num3 = a.Length; i < num3; i++)
			{
				if (a[i] != 0f && b[i] != 0f)
				{
					if (a[i] == b[i])
					{
						num++;
					}
					num2++;
				}
			}
			return 1.0 - (double)((float)num / (float)num2);
		}
	}
	public static class Euclid
	{
		private static readonly int[] MultiplyDeBruijnBitPosition = new int[32]
		{
			0, 9, 1, 10, 13, 21, 2, 29, 11, 14,
			16, 18, 22, 25, 3, 30, 8, 12, 20, 28,
			15, 17, 24, 7, 19, 27, 23, 6, 26, 5,
			4, 31
		};

		public static double Modulus(double dividend, double divisor)
		{
			return (dividend % divisor + divisor) % divisor;
		}

		public static float Modulus(float dividend, float divisor)
		{
			return (dividend % divisor + divisor) % divisor;
		}

		public static int Modulus(int dividend, int divisor)
		{
			return (dividend % divisor + divisor) % divisor;
		}

		public static long Modulus(long dividend, long divisor)
		{
			return (dividend % divisor + divisor) % divisor;
		}

		public static BigInteger Modulus(BigInteger dividend, BigInteger divisor)
		{
			return (dividend % divisor + divisor) % divisor;
		}

		public static double Remainder(double dividend, double divisor)
		{
			return dividend % divisor;
		}

		public static float Remainder(float dividend, float divisor)
		{
			return dividend % divisor;
		}

		public static int Remainder(int dividend, int divisor)
		{
			return dividend % divisor;
		}

		public static long Remainder(long dividend, long divisor)
		{
			return dividend % divisor;
		}

		public static BigInteger Remainder(BigInteger dividend, BigInteger divisor)
		{
			return dividend % divisor;
		}

		public static bool IsEven(this int number)
		{
			return (number & 1) == 0;
		}

		public static bool IsEven(this long number)
		{
			return (number & 1) == 0;
		}

		public static bool IsOdd(this int number)
		{
			return (number & 1) == 1;
		}

		public static bool IsOdd(this long number)
		{
			return (number & 1) == 1;
		}

		public static bool IsPowerOfTwo(this int number)
		{
			if (number > 0)
			{
				return (number & (number - 1)) == 0;
			}
			return false;
		}

		public static bool IsPowerOfTwo(this long number)
		{
			if (number > 0)
			{
				return (number & (number - 1)) == 0;
			}
			return false;
		}

		public static bool IsPerfectSquare(this int number)
		{
			if (number < 0)
			{
				return false;
			}
			int num = number & 0xF;
			if (num > 9)
			{
				return false;
			}
			if (num == 0 || num == 1 || num == 4 || num == 9)
			{
				int num2 = (int)Math.Floor(Math.Sqrt(number) + 0.5);
				return num2 * num2 == number;
			}
			return false;
		}

		public static bool IsPerfectSquare(this long number)
		{
			if (number < 0)
			{
				return false;
			}
			int num = (int)(number & 0xF);
			if (num > 9)
			{
				return false;
			}
			if (num == 0 || num == 1 || num == 4 || num == 9)
			{
				long num2 = (long)Math.Floor(Math.Sqrt(number) + 0.5);
				return num2 * num2 == number;
			}
			return false;
		}

		public static int PowerOfTwo(this int exponent)
		{
			if (exponent < 0 || exponent >= 31)
			{
				throw new ArgumentOutOfRangeException("exponent");
			}
			return 1 << exponent;
		}

		public static long PowerOfTwo(this long exponent)
		{
			if (exponent < 0 || exponent >= 63)
			{
				throw new ArgumentOutOfRangeException("exponent");
			}
			return 1L << (int)exponent;
		}

		public static int Log2(this int number)
		{
			number |= number >> 1;
			number |= number >> 2;
			number |= number >> 4;
			number |= number >> 8;
			number |= number >> 16;
			return MultiplyDeBruijnBitPosition[(uint)((long)number * 130329821L) >> 27];
		}

		public static int CeilingToPowerOfTwo(this int number)
		{
			if (number == int.MinValue)
			{
				return 0;
			}
			if (number > 1073741824)
			{
				throw new ArgumentOutOfRangeException("number");
			}
			number--;
			number |= number >> 1;
			number |= number >> 2;
			number |= number >> 4;
			number |= number >> 8;
			number |= number >> 16;
			return number + 1;
		}

		public static long CeilingToPowerOfTwo(this long number)
		{
			if (number == long.MinValue)
			{
				return 0L;
			}
			if (number > 4611686018427387904L)
			{
				throw new ArgumentOutOfRangeException("number");
			}
			number--;
			number |= number >> 1;
			number |= number >> 2;
			number |= number >> 4;
			number |= number >> 8;
			number |= number >> 16;
			number |= number >> 32;
			return number + 1;
		}

		public static long GreatestCommonDivisor(long a, long b)
		{
			while (b != 0L)
			{
				long num = a % b;
				a = b;
				b = num;
			}
			return Math.Abs(a);
		}

		public static long GreatestCommonDivisor(IList<long> integers)
		{
			if (integers == null)
			{
				throw new ArgumentNullException("integers");
			}
			if (integers.Count == 0)
			{
				return 0L;
			}
			long num = Math.Abs(integers[0]);
			for (int i = 1; i < integers.Count; i++)
			{
				if (num <= 1)
				{
					break;
				}
				num = GreatestCommonDivisor(num, integers[i]);
			}
			return num;
		}

		public static long GreatestCommonDivisor(params long[] integers)
		{
			return GreatestCommonDivisor((IList<long>)integers);
		}

		public static long ExtendedGreatestCommonDivisor(long a, long b, out long x, out long y)
		{
			long num = 1L;
			long num2 = 0L;
			long num3 = 0L;
			long num4 = 1L;
			while (b != 0L)
			{
				long result;
				long num5 = Math.DivRem(a, b, out result);
				a = b;
				b = result;
				long num6 = num3;
				num3 = num - num5 * num3;
				num = num6;
				long num7 = num4;
				num4 = num2 - num5 * num4;
				num2 = num7;
			}
			if (a >= 0)
			{
				x = num;
				y = num2;
				return a;
			}
			x = -num;
			y = -num2;
			return -a;
		}

		public static long LeastCommonMultiple(long a, long b)
		{
			if (a == 0L || b == 0L)
			{
				return 0L;
			}
			return Math.Abs(a / GreatestCommonDivisor(a, b) * b);
		}

		public static long LeastCommonMultiple(IList<long> integers)
		{
			if (integers == null)
			{
				throw new ArgumentNullException("integers");
			}
			if (integers.Count == 0)
			{
				return 1L;
			}
			long num = Math.Abs(integers[0]);
			for (int i = 1; i < integers.Count; i++)
			{
				num = LeastCommonMultiple(num, integers[i]);
			}
			return num;
		}

		public static long LeastCommonMultiple(params long[] integers)
		{
			return LeastCommonMultiple((IList<long>)integers);
		}

		public static BigInteger GreatestCommonDivisor(BigInteger a, BigInteger b)
		{
			return BigInteger.GreatestCommonDivisor(a, b);
		}

		public static BigInteger GreatestCommonDivisor(IList<BigInteger> integers)
		{
			if (integers == null)
			{
				throw new ArgumentNullException("integers");
			}
			if (integers.Count == 0)
			{
				return 0;
			}
			BigInteger bigInteger = BigInteger.Abs(integers[0]);
			for (int i = 1; i < integers.Count; i++)
			{
				if (!(bigInteger > BigInteger.One))
				{
					break;
				}
				bigInteger = GreatestCommonDivisor(bigInteger, integers[i]);
			}
			return bigInteger;
		}

		public static BigInteger GreatestCommonDivisor(params BigInteger[] integers)
		{
			return GreatestCommonDivisor((IList<BigInteger>)integers);
		}

		public static BigInteger ExtendedGreatestCommonDivisor(BigInteger a, BigInteger b, out BigInteger x, out BigInteger y)
		{
			BigInteger bigInteger = BigInteger.One;
			BigInteger bigInteger2 = BigInteger.Zero;
			BigInteger bigInteger3 = BigInteger.Zero;
			BigInteger bigInteger4 = BigInteger.One;
			while (!b.IsZero)
			{
				BigInteger remainder;
				BigInteger bigInteger5 = BigInteger.DivRem(a, b, out remainder);
				a = b;
				b = remainder;
				BigInteger bigInteger6 = bigInteger3;
				bigInteger3 = bigInteger - bigInteger5 * bigInteger3;
				bigInteger = bigInteger6;
				BigInteger bigInteger7 = bigInteger4;
				bigInteger4 = bigInteger2 - bigInteger5 * bigInteger4;
				bigInteger2 = bigInteger7;
			}
			if (a >= BigInteger.Zero)
			{
				x = bigInteger;
				y = bigInteger2;
				return a;
			}
			x = -bigInteger;
			y = -bigInteger2;
			return -a;
		}

		public static BigInteger LeastCommonMultiple(BigInteger a, BigInteger b)
		{
			if (a.IsZero || b.IsZero)
			{
				return BigInteger.Zero;
			}
			return BigInteger.Abs(a / BigInteger.GreatestCommonDivisor(a, b) * b);
		}

		public static BigInteger LeastCommonMultiple(IList<BigInteger> integers)
		{
			if (integers == null)
			{
				throw new ArgumentNullException("integers");
			}
			if (integers.Count == 0)
			{
				return 1;
			}
			BigInteger bigInteger = BigInteger.Abs(integers[0]);
			for (int i = 1; i < integers.Count; i++)
			{
				bigInteger = LeastCommonMultiple(bigInteger, integers[i]);
			}
			return bigInteger;
		}

		public static BigInteger LeastCommonMultiple(params BigInteger[] integers)
		{
			return LeastCommonMultiple((IList<BigInteger>)integers);
		}
	}
	public static class ExcelFunctions
	{
		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double NormSDist(double z)
		{
			return Normal.CDF(0.0, 1.0, z);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double NormSInv(double probability)
		{
			return Normal.InvCDF(0.0, 1.0, probability);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double NormDist(double x, double mean, double standardDev, bool cumulative)
		{
			if (!cumulative)
			{
				return Normal.PDF(mean, standardDev, x);
			}
			return Normal.CDF(mean, standardDev, x);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double NormInv(double probability, double mean, double standardDev)
		{
			return Normal.InvCDF(mean, standardDev, probability);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double TDist(double x, int degreesFreedom, int tails)
		{
			return tails switch
			{
				1 => 1.0 - StudentT.CDF(0.0, 1.0, degreesFreedom, x), 
				2 => 1.0 - StudentT.CDF(0.0, 1.0, degreesFreedom, x) + StudentT.CDF(0.0, 1.0, degreesFreedom, 0.0 - x), 
				_ => throw new ArgumentOutOfRangeException("tails"), 
			};
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double TInv(double probability, int degreesFreedom)
		{
			return 0.0 - StudentT.InvCDF(0.0, 1.0, degreesFreedom, probability / 2.0);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double FDist(double x, int degreesFreedom1, int degreesFreedom2)
		{
			return 1.0 - FisherSnedecor.CDF(degreesFreedom1, degreesFreedom2, x);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double FInv(double probability, int degreesFreedom1, int degreesFreedom2)
		{
			return FisherSnedecor.InvCDF(degreesFreedom1, degreesFreedom2, 1.0 - probability);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double BetaDist(double x, double alpha, double beta)
		{
			return Beta.CDF(alpha, beta, x);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double BetaInv(double probability, double alpha, double beta)
		{
			return Beta.InvCDF(alpha, beta, probability);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double GammaDist(double x, double alpha, double beta, bool cumulative)
		{
			if (!cumulative)
			{
				return Gamma.PDF(alpha, 1.0 / beta, x);
			}
			return Gamma.CDF(alpha, 1.0 / beta, x);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double GammaInv(double probability, double alpha, double beta)
		{
			return Gamma.InvCDF(alpha, 1.0 / beta, probability);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double Quartile(double[] array, int quant)
		{
			return quant switch
			{
				0 => ArrayStatistics.Minimum(array), 
				1 => array.QuantileCustom(0.25, QuantileDefinition.R7), 
				2 => array.QuantileCustom(0.5, QuantileDefinition.R7), 
				3 => array.QuantileCustom(0.75, QuantileDefinition.R7), 
				4 => ArrayStatistics.Maximum(array), 
				_ => throw new ArgumentOutOfRangeException("quant"), 
			};
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double Percentile(double[] array, double k)
		{
			return array.QuantileCustom(k, QuantileDefinition.R7);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double PercentRank(double[] array, double x)
		{
			return array.QuantileRank(x, RankDefinition.Min);
		}
	}
	[Serializable]
	public class NonConvergenceException : Exception
	{
		public NonConvergenceException()
			: base("An algorithm failed to converge.")
		{
		}

		public NonConvergenceException(string message)
			: base(message)
		{
		}

		public NonConvergenceException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected NonConvergenceException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	public class NumericalBreakdownException : NonConvergenceException
	{
		public NumericalBreakdownException()
			: base("Algorithm experience a numerical break down.")
		{
		}

		public NumericalBreakdownException(string message)
			: base(message)
		{
		}

		public NumericalBreakdownException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected NumericalBreakdownException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	public abstract class NativeInterfaceException : Exception
	{
		protected NativeInterfaceException()
		{
		}

		protected NativeInterfaceException(string message)
			: base(message)
		{
		}

		protected NativeInterfaceException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected NativeInterfaceException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	public class InvalidParameterException : NativeInterfaceException
	{
		public InvalidParameterException()
			: base("An invalid parameter was passed to a native method.")
		{
		}

		public InvalidParameterException(int parameter)
			: base($"An invalid parameter was passed to a native method, parameter number : {parameter}")
		{
		}

		public InvalidParameterException(int parameter, Exception innerException)
			: base($"An invalid parameter was passed to a native method, parameter number : {parameter}", innerException)
		{
		}

		protected InvalidParameterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	public class MemoryAllocationException : NativeInterfaceException
	{
		public MemoryAllocationException()
			: base("Unable to allocate native memory.")
		{
		}

		public MemoryAllocationException(Exception innerException)
			: base("Unable to allocate native memory.", innerException)
		{
		}

		protected MemoryAllocationException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	public class SingularUMatrixException : NativeInterfaceException
	{
		public SingularUMatrixException()
			: base("U is singular, and the inversion could not be completed.")
		{
		}

		public SingularUMatrixException(int element)
			: base($"U is singular, and the inversion could not be completed. The {element}-th diagonal element of the factor U is zero.")
		{
		}

		public SingularUMatrixException(int element, Exception innerException)
			: base($"U is singular, and the inversion could not be completed. The {element}-th diagonal element of the factor U is zero.", innerException)
		{
		}

		protected SingularUMatrixException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	public static class FindMinimum
	{
		public static double OfScalarFunctionConstrained(Func<double, double> function, double lowerBound, double upperBound, double tolerance = 1E-05, int maxIterations = 1000)
		{
			return GoldenSectionMinimizer.Minimum(ObjectiveFunction.ScalarValue(function), lowerBound, upperBound, tolerance, maxIterations).MinimizingPoint;
		}

		public static double OfScalarFunction(Func<double, double> function, double initialGuess, double tolerance = 1E-08, int maxIterations = 1000)
		{
			return NelderMeadSimplex.Minimum(ObjectiveFunction.Value((Vector<double> v) => function(v[0])), CreateVector.Dense(new double[1] { initialGuess }), tolerance, maxIterations).MinimizingPoint[0];
		}

		public static Tuple<double, double> OfFunction(Func<double, double, double> function, double initialGuess0, double initialGuess1, double tolerance = 1E-08, int maxIterations = 1000)
		{
			MinimizationResult minimizationResult = NelderMeadSimplex.Minimum(ObjectiveFunction.Value((Vector<double> v) => function(v[0], v[1])), CreateVector.Dense(new double[2] { initialGuess0, initialGuess1 }), tolerance, maxIterations);
			return Tuple.Create(minimizationResult.MinimizingPoint[0], minimizationResult.MinimizingPoint[1]);
		}

		public static Tuple<double, double, double> OfFunction(Func<double, double, double, double> function, double initialGuess0, double initialGuess1, double initialGuess2, double tolerance = 1E-08, int maxIterations = 1000)
		{
			MinimizationResult minimizationResult = NelderMeadSimplex.Minimum(ObjectiveFunction.Value((Vector<double> v) => function(v[0], v[1], v[2])), CreateVector.Dense(new double[3] { initialGuess0, initialGuess1, initialGuess2 }), tolerance, maxIterations);
			return Tuple.Create(minimizationResult.MinimizingPoint[0], minimizationResult.MinimizingPoint[1], minimizationResult.MinimizingPoint[2]);
		}

		public static Vector<double> OfFunction(Func<Vector<double>, double> function, Vector<double> initialGuess, double tolerance = 1E-08, int maxIterations = 1000)
		{
			return NelderMeadSimplex.Minimum(ObjectiveFunction.Value(function), initialGuess, tolerance, maxIterations).MinimizingPoint;
		}

		public static Vector<double> OfFunctionConstrained(Func<Vector<double>, double> function, Vector<double> lowerBound, Vector<double> upperBound, Vector<double> initialGuess, double gradientTolerance = 1E-05, double parameterTolerance = 1E-05, double functionProgressTolerance = 1E-05, int maxIterations = 1000)
		{
			ForwardDifferenceGradientObjectiveFunction objective = new ForwardDifferenceGradientObjectiveFunction(ObjectiveFunction.Value(function), lowerBound, upperBound);
			return new BfgsBMinimizer(gradientTolerance, parameterTolerance, functionProgressTolerance, maxIterations).FindMinimum(objective, lowerBound, upperBound, initialGuess).MinimizingPoint;
		}

		public static Vector<double> OfFunctionGradient(Func<Vector<double>, double> function, Func<Vector<double>, Vector<double>> gradient, Vector<double> initialGuess, double gradientTolerance = 1E-05, double parameterTolerance = 1E-05, double functionProgressTolerance = 1E-05, int maxIterations = 1000)
		{
			IObjectiveFunction objective = ObjectiveFunction.Gradient(function, gradient);
			return new BfgsMinimizer(gradientTolerance, parameterTolerance, functionProgressTolerance, maxIterations).FindMinimum(objective, initialGuess).MinimizingPoint;
		}

		public static Vector<double> OfFunctionGradient(Func<Vector<double>, Tuple<double, Vector<double>>> functionGradient, Vector<double> initialGuess, double gradientTolerance = 1E-05, double parameterTolerance = 1E-05, double functionProgressTolerance = 1E-05, int maxIterations = 1000)
		{
			IObjectiveFunction objective = ObjectiveFunction.Gradient(functionGradient);
			return new BfgsMinimizer(gradientTolerance, parameterTolerance, functionProgressTolerance, maxIterations).FindMinimum(objective, initialGuess).MinimizingPoint;
		}

		public static Vector<double> OfFunctionGradientConstrained(Func<Vector<double>, double> function, Func<Vector<double>, Vector<double>> gradient, Vector<double> lowerBound, Vector<double> upperBound, Vector<double> initialGuess, double gradientTolerance = 1E-05, double parameterTolerance = 1E-05, double functionProgressTolerance = 1E-05, int maxIterations = 1000)
		{
			IObjectiveFunction objective = ObjectiveFunction.Gradient(function, gradient);
			return new BfgsBMinimizer(gradientTolerance, parameterTolerance, functionProgressTolerance, maxIterations).FindMinimum(objective, lowerBound, upperBound, initialGuess).MinimizingPoint;
		}

		public static Vector<double> OfFunctionGradientConstrained(Func<Vector<double>, Tuple<double, Vector<double>>> functionGradient, Vector<double> lowerBound, Vector<double> upperBound, Vector<double> initialGuess, double gradientTolerance = 1E-05, double parameterTolerance = 1E-05, double functionProgressTolerance = 1E-05, int maxIterations = 1000)
		{
			IObjectiveFunction objective = ObjectiveFunction.Gradient(functionGradient);
			return new BfgsBMinimizer(gradientTolerance, parameterTolerance, functionProgressTolerance, maxIterations).FindMinimum(objective, lowerBound, upperBound, initialGuess).MinimizingPoint;
		}

		public static Vector<double> OfFunctionGradientHessian(Func<Vector<double>, double> function, Func<Vector<double>, Vector<double>> gradient, Func<Vector<double>, Matrix<double>> hessian, Vector<double> initialGuess, double gradientTolerance = 1E-08, int maxIterations = 1000)
		{
			return NewtonMinimizer.Minimum(ObjectiveFunction.GradientHessian(function, gradient, hessian), initialGuess, gradientTolerance, maxIterations).MinimizingPoint;
		}

		public static Vector<double> OfFunctionGradientHessian(Func<Vector<double>, Tuple<double, Vector<double>, Matrix<double>>> functionGradientHessian, Vector<double> initialGuess, double gradientTolerance = 1E-08, int maxIterations = 1000)
		{
			return NewtonMinimizer.Minimum(ObjectiveFunction.GradientHessian(functionGradientHessian), initialGuess, gradientTolerance, maxIterations).MinimizingPoint;
		}
	}
	public static class FindRoots
	{
		public static double OfFunction(Func<double, double> f, double lowerBound, double upperBound, double accuracy = 1E-08, int maxIterations = 100)
		{
			if (!ZeroCrossingBracketing.ExpandReduce(f, ref lowerBound, ref upperBound, 1.6, maxIterations, maxIterations * 10))
			{
				throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
			}
			if (Brent.TryFindRoot(f, lowerBound, upperBound, accuracy, maxIterations, out var root))
			{
				return root;
			}
			if (Bisection.TryFindRoot(f, lowerBound, upperBound, accuracy, maxIterations, out root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
		}

		public static double OfFunctionDerivative(Func<double, double> f, Func<double, double> df, double lowerBound, double upperBound, double accuracy = 1E-08, int maxIterations = 100)
		{
			if (RobustNewtonRaphson.TryFindRoot(f, df, lowerBound, upperBound, accuracy, maxIterations, 20, out var root))
			{
				return root;
			}
			return OfFunction(f, lowerBound, upperBound, accuracy, maxIterations);
		}

		public static Tuple<Complex, Complex> Quadratic(double c, double b, double a)
		{
			if (b == 0.0)
			{
				Complex complex = new Complex((0.0 - c) / a, 0.0).SquareRoot();
				return new Tuple<Complex, Complex>(complex, -complex);
			}
			Complex complex2 = ((b > 0.0) ? (-0.5 * (b + new Complex(b * b - 4.0 * a * c, 0.0).SquareRoot())) : (-0.5 * (b - new Complex(b * b - 4.0 * a * c, 0.0).SquareRoot())));
			return new Tuple<Complex, Complex>(complex2 / a, c / complex2);
		}

		public static Tuple<Complex, Complex, Complex> Cubic(double d, double c, double b, double a)
		{
			return MathNet.Numerics.RootFinding.Cubic.Roots(d, c, b, a);
		}

		public static Complex[] Polynomial(double[] coefficients)
		{
			return new Polynomial(coefficients).Roots();
		}

		public static Complex[] Polynomial(Polynomial polynomial)
		{
			return polynomial.Roots();
		}

		public static double[] ChebychevPolynomialFirstKind(int degree, double intervalBegin = -1.0, double intervalEnd = 1.0)
		{
			if (degree < 1)
			{
				return new double[0];
			}
			double num = 0.5 * (intervalBegin + intervalEnd);
			double num2 = 0.5 * (intervalEnd - intervalBegin);
			double num3 = Math.PI / (double)(2 * degree);
			double[] array = new double[degree];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = num + num2 * Math.Cos((double)(2 * i + 1) * num3);
			}
			return array;
		}

		public static double[] ChebychevPolynomialSecondKind(int degree, double intervalBegin = -1.0, double intervalEnd = 1.0)
		{
			if (degree < 1)
			{
				return new double[0];
			}
			double num = 0.5 * (intervalBegin + intervalEnd);
			double num2 = 0.5 * (intervalEnd - intervalBegin);
			double num3 = Math.PI / (double)(degree + 1);
			double[] array = new double[degree];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = num + num2 * Math.Cos((double)(i + 1) * num3);
			}
			return array;
		}
	}
	public static class Fit
	{
		public static Tuple<double, double> Line(double[] x, double[] y)
		{
			return SimpleRegression.Fit(x, y);
		}

		public static Func<double, double> LineFunc(double[] x, double[] y)
		{
			Tuple<double, double> tuple = SimpleRegression.Fit(x, y);
			double intercept = tuple.Item1;
			double slope = tuple.Item2;
			return (double z) => intercept + slope * z;
		}

		public static double LineThroughOrigin(double[] x, double[] y)
		{
			return SimpleRegression.FitThroughOrigin(x, y);
		}

		public static Func<double, double> LineThroughOriginFunc(double[] x, double[] y)
		{
			double slope = SimpleRegression.FitThroughOrigin(x, y);
			return (double z) => slope * z;
		}

		public static Tuple<double, double> Exponential(double[] x, double[] y, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			double[] y2 = Generate.Map(y, Math.Log);
			double[] array = LinearCombination(x, y2, method, (double t) => 1.0, (double t) => t);
			return Tuple.Create(Math.Exp(array[0]), array[1]);
		}

		public static Func<double, double> ExponentialFunc(double[] x, double[] y, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			Tuple<double, double> tuple = Exponential(x, y, method);
			double a = tuple.Item1;
			double r = tuple.Item2;
			return (double z) => a * Math.Exp(r * z);
		}

		public static Tuple<double, double> Logarithm(double[] x, double[] y, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			double[] array = LinearCombination(Generate.Map(x, Math.Log), y, method, (double t) => 1.0, (double t) => t);
			return Tuple.Create(array[0], array[1]);
		}

		public static Func<double, double> LogarithmFunc(double[] x, double[] y, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			Tuple<double, double> tuple = Logarithm(x, y, method);
			double a = tuple.Item1;
			double b = tuple.Item2;
			return (double z) => a + b * Math.Log(z);
		}

		public static Tuple<double, double> Power(double[] x, double[] y, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			double[] y2 = Generate.Map(y, Math.Log);
			double[] array = LinearCombination(x, y2, method, (double t) => 1.0, Math.Log);
			return Tuple.Create(Math.Exp(array[0]), array[1]);
		}

		public static Func<double, double> PowerFunc(double[] x, double[] y, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			Tuple<double, double> tuple = Power(x, y, method);
			double a = tuple.Item1;
			double b = tuple.Item2;
			return (double z) => a * Math.Pow(z, b);
		}

		public static double[] Polynomial(double[] x, double[] y, int order, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			return MultipleRegression.DirectMethod(Matrix<double>.Build.Dense(x.Length, order + 1, (int i, int j) => Math.Pow(x[i], j)), Vector<double>.Build.Dense(y), method).ToArray();
		}

		public static Func<double, double> PolynomialFunc(double[] x, double[] y, int order, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			double[] parameters = Polynomial(x, y, order, method);
			return (double z) => MathNet.Numerics.Polynomial.Evaluate(z, parameters);
		}

		public static double[] PolynomialWeighted(double[] x, double[] y, double[] w, int order)
		{
			return WeightedRegression.Weighted(Matrix<double>.Build.Dense(x.Length, order + 1, (int i, int j) => Math.Pow(x[i], j)), Vector<double>.Build.Dense(y), Matrix<double>.Build.Diagonal(w)).ToArray();
		}

		public static double[] LinearCombination(double[] x, double[] y, params Func<double, double>[] functions)
		{
			return MultipleRegression.QR(Matrix<double>.Build.Dense(x.Length, functions.Length, (int i, int j) => functions[j](x[i])), Vector<double>.Build.Dense(y)).ToArray();
		}

		public static Func<double, double> LinearCombinationFunc(double[] x, double[] y, params Func<double, double>[] functions)
		{
			double[] parameters = LinearCombination(x, y, functions);
			return (double z) => functions.Zip(parameters, (Func<double, double> f, double p) => p * f(z)).Sum();
		}

		public static double[] LinearCombination(double[] x, double[] y, DirectRegressionMethod method, params Func<double, double>[] functions)
		{
			return MultipleRegression.DirectMethod(Matrix<double>.Build.Dense(x.Length, functions.Length, (int i, int j) => functions[j](x[i])), Vector<double>.Build.Dense(y), method).ToArray();
		}

		public static Func<double, double> LinearCombinationFunc(double[] x, double[] y, DirectRegressionMethod method, params Func<double, double>[] functions)
		{
			double[] parameters = LinearCombination(x, y, method, functions);
			return (double z) => functions.Zip(parameters, (Func<double, double> f, double p) => p * f(z)).Sum();
		}

		public static double[] MultiDim(double[][] x, double[] y, bool intercept = false, DirectRegressionMethod method = DirectRegressionMethod.NormalEquations)
		{
			return MultipleRegression.DirectMethod(x, y, intercept, method);
		}

		public static Func<double[], double> MultiDimFunc(double[][] x, double[] y, bool intercept = false, DirectRegressionMethod method = DirectRegressionMethod.NormalEquations)
		{
			double[] parameters = MultipleRegression.DirectMethod(x, y, intercept, method);
			return (double[] z) => LinearAlgebraControl.Provider.DotProduct(parameters, z);
		}

		public static double[] MultiDimWeighted(double[][] x, double[] y, double[] w)
		{
			return WeightedRegression.Weighted(x, y, w);
		}

		public static double[] LinearMultiDim(double[][] x, double[] y, params Func<double[], double>[] functions)
		{
			return MultipleRegression.QR(Matrix<double>.Build.Dense(x.Length, functions.Length, (int i, int j) => functions[j](x[i])), Vector<double>.Build.Dense(y)).ToArray();
		}

		public static Func<double[], double> LinearMultiDimFunc(double[][] x, double[] y, params Func<double[], double>[] functions)
		{
			double[] parameters = LinearMultiDim(x, y, functions);
			return (double[] z) => functions.Zip(parameters, (Func<double[], double> f, double p) => p * f(z)).Sum();
		}

		public static double[] LinearMultiDim(double[][] x, double[] y, DirectRegressionMethod method, params Func<double[], double>[] functions)
		{
			return MultipleRegression.DirectMethod(Matrix<double>.Build.Dense(x.Length, functions.Length, (int i, int j) => functions[j](x[i])), Vector<double>.Build.Dense(y), method).ToArray();
		}

		public static Func<double[], double> LinearMultiDimFunc(double[][] x, double[] y, DirectRegressionMethod method, params Func<double[], double>[] functions)
		{
			double[] parameters = LinearMultiDim(x, y, method, functions);
			return (double[] z) => functions.Zip(parameters, (Func<double[], double> f, double p) => p * f(z)).Sum();
		}

		public static double[] LinearGeneric<T>(T[] x, double[] y, params Func<T, double>[] functions)
		{
			return MultipleRegression.QR(Matrix<double>.Build.Dense(x.Length, functions.Length, (int i, int j) => functions[j](x[i])), Vector<double>.Build.Dense(y)).ToArray();
		}

		public static Func<T, double> LinearGenericFunc<T>(T[] x, double[] y, params Func<T, double>[] functions)
		{
			double[] parameters = LinearGeneric(x, y, functions);
			return (T z) => functions.Zip(parameters, (Func<T, double> f, double p) => p * f(z)).Sum();
		}

		public static double[] LinearGeneric<T>(T[] x, double[] y, DirectRegressionMethod method, params Func<T, double>[] functions)
		{
			return MultipleRegression.DirectMethod(Matrix<double>.Build.Dense(x.Length, functions.Length, (int i, int j) => functions[j](x[i])), Vector<double>.Build.Dense(y), method).ToArray();
		}

		public static Func<T, double> LinearGenericFunc<T>(T[] x, double[] y, DirectRegressionMethod method, params Func<T, double>[] functions)
		{
			double[] parameters = LinearGeneric(x, y, method, functions);
			return (T z) => functions.Zip(parameters, (Func<T, double> f, double p) => p * f(z)).Sum();
		}

		public static double Curve(double[] x, double[] y, Func<double, double, double> f, double initialGuess, double tolerance = 1E-08, int maxIterations = 1000)
		{
			return FindMinimum.OfScalarFunction((double p) => Distance.Euclidean(Generate.Map(x, (double t) => f(p, t)), y), initialGuess, tolerance, maxIterations);
		}

		public static Tuple<double, double> Curve(double[] x, double[] y, Func<double, double, double, double> f, double initialGuess0, double initialGuess1, double tolerance = 1E-08, int maxIterations = 1000)
		{
			return FindMinimum.OfFunction((double p0, double p1) => Distance.Euclidean(Generate.Map(x, (double t) => f(p0, p1, t)), y), initialGuess0, initialGuess1, tolerance, maxIterations);
		}

		public static Tuple<double, double, double> Curve(double[] x, double[] y, Func<double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double tolerance = 1E-08, int maxIterations = 1000)
		{
			return FindMinimum.OfFunction((double p0, double p1, double p2) => Distance.Euclidean(Generate.Map(x, (double t) => f(p0, p1, p2, t)), y), initialGuess0, initialGuess1, initialGuess2, tolerance, maxIterations);
		}

		public static Func<double, double> CurveFunc(double[] x, double[] y, Func<double, double, double> f, double initialGuess, double tolerance = 1E-08, int maxIterations = 1000)
		{
			double parameters = Curve(x, y, f, initialGuess, tolerance, maxIterations);
			return (double z) => f(parameters, z);
		}

		public static Func<double, double> CurveFunc(double[] x, double[] y, Func<double, double, double, double> f, double initialGuess0, double initialGuess1, double tolerance = 1E-08, int maxIterations = 1000)
		{
			Tuple<double, double> parameters = Curve(x, y, f, initialGuess0, initialGuess1, tolerance, maxIterations);
			return (double z) => f(parameters.Item1, parameters.Item2, z);
		}

		public static Func<double, double> CurveFunc(double[] x, double[] y, Func<double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double tolerance = 1E-08, int maxIterations = 1000)
		{
			Tuple<double, double, double> parameters = Curve(x, y, f, initialGuess0, initialGuess1, initialGuess2, tolerance, maxIterations);
			return (double z) => f(parameters.Item1, parameters.Item2, parameters.Item3, z);
		}
	}
	public static class Generate
	{
		public static T[] Map<TA, T>(TA[] points, Func<TA, T> map)
		{
			T[] array = new T[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				array[i] = map(points[i]);
			}
			return array;
		}

		public static IEnumerable<T> MapSequence<TA, T>(IEnumerable<TA> points, Func<TA, T> map)
		{
			return points.Select(map);
		}

		public static T[] Map2<TA, TB, T>(TA[] pointsA, TB[] pointsB, Func<TA, TB, T> map)
		{
			if (pointsA.Length != pointsB.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "pointsB");
			}
			T[] array = new T[pointsA.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = map(pointsA[i], pointsB[i]);
			}
			return array;
		}

		public static IEnumerable<T> Map2Sequence<TA, TB, T>(IEnumerable<TA> pointsA, IEnumerable<TB> pointsB, Func<TA, TB, T> map)
		{
			return pointsA.Zip(pointsB, map);
		}

		public static double[] LinearSpaced(int length, double start, double stop)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			switch (length)
			{
			case 0:
				return new double[0];
			case 1:
				return new double[1] { stop };
			default:
			{
				double num = (stop - start) / (double)(length - 1);
				double[] array = new double[length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = start + (double)i * num;
				}
				array[array.Length - 1] = stop;
				return array;
			}
			}
		}

		public static T[] LinearSpacedMap<T>(int length, double start, double stop, Func<double, T> map)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			switch (length)
			{
			case 0:
				return new T[0];
			case 1:
				return new T[1] { map(stop) };
			default:
			{
				double num = (stop - start) / (double)(length - 1);
				T[] array = new T[length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = map(start + (double)i * num);
				}
				array[array.Length - 1] = map(stop);
				return array;
			}
			}
		}

		public static double[] LogSpaced(int length, double startExponent, double stopExponent)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			switch (length)
			{
			case 0:
				return new double[0];
			case 1:
				return new double[1] { Math.Pow(10.0, stopExponent) };
			default:
			{
				double num = (stopExponent - startExponent) / (double)(length - 1);
				double[] array = new double[length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Math.Pow(10.0, startExponent + (double)i * num);
				}
				array[array.Length - 1] = Math.Pow(10.0, stopExponent);
				return array;
			}
			}
		}

		public static T[] LogSpacedMap<T>(int length, double startExponent, double stopExponent, Func<double, T> map)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			switch (length)
			{
			case 0:
				return new T[0];
			case 1:
				return new T[1] { map(Math.Pow(10.0, stopExponent)) };
			default:
			{
				double num = (stopExponent - startExponent) / (double)(length - 1);
				T[] array = new T[length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = map(Math.Pow(10.0, startExponent + (double)i * num));
				}
				array[array.Length - 1] = map(Math.Pow(10.0, stopExponent));
				return array;
			}
			}
		}

		public static double[] LinearRange(int start, int stop)
		{
			if (start == stop)
			{
				return new double[1] { start };
			}
			if (start < stop)
			{
				double[] array = new double[stop - start + 1];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = start + i;
				}
				return array;
			}
			double[] array2 = new double[start - stop + 1];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = start - j;
			}
			return array2;
		}

		public static int[] LinearRangeInt32(int start, int stop)
		{
			if (start == stop)
			{
				return new int[1] { start };
			}
			if (start < stop)
			{
				int[] array = new int[stop - start + 1];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = start + i;
				}
				return array;
			}
			int[] array2 = new int[start - stop + 1];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = start - j;
			}
			return array2;
		}

		public static double[] LinearRange(int start, int step, int stop)
		{
			if (start == stop)
			{
				return new double[1] { start };
			}
			if ((start < stop && step < 0) || (start > stop && step > 0) || (double)step == 0.0)
			{
				return new double[0];
			}
			double[] array = new double[(stop - start) / step + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = start + i * step;
			}
			return array;
		}

		public static int[] LinearRangeInt32(int start, int step, int stop)
		{
			if (start == stop)
			{
				return new int[1] { start };
			}
			if ((start < stop && step < 0) || (start > stop && step > 0) || (double)step == 0.0)
			{
				return new int[0];
			}
			int[] array = new int[(stop - start) / step + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = start + i * step;
			}
			return array;
		}

		public static double[] LinearRange(double start, double step, double stop)
		{
			if (start == stop)
			{
				return new double[1] { start };
			}
			if ((start < stop && step < 0.0) || (start > stop && step > 0.0) || step == 0.0)
			{
				return new double[0];
			}
			double[] array = new double[(int)Math.Floor((stop - start) / step + 1.0)];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = start + (double)i * step;
			}
			return array;
		}

		public static T[] LinearRangeMap<T>(double start, double step, double stop, Func<double, T> map)
		{
			if (start == stop)
			{
				return new T[1] { map(start) };
			}
			if ((start < stop && step < 0.0) || (start > stop && step > 0.0) || step == 0.0)
			{
				return new T[0];
			}
			T[] array = new T[(int)Math.Floor((stop - start) / step + 1.0)];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = map(start + (double)i * step);
			}
			return array;
		}

		public static double[] Periodic(int length, double samplingRate, double frequency, double amplitude = 1.0, double phase = 0.0, int delay = 0)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double num = frequency / samplingRate * amplitude;
			phase = Euclid.Modulus(phase - (double)delay * num, amplitude);
			double[] array = new double[length];
			int num2 = 0;
			int num3 = 0;
			while (num2 < array.Length)
			{
				double num4 = phase + (double)num3 * num;
				if (num4 >= amplitude)
				{
					num4 %= amplitude;
					phase = num4;
					num3 = 0;
				}
				array[num2] = num4;
				num2++;
				num3++;
			}
			return array;
		}

		public static T[] PeriodicMap<T>(int length, Func<double, T> map, double samplingRate, double frequency, double amplitude = 1.0, double phase = 0.0, int delay = 0)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double num = frequency / samplingRate * amplitude;
			phase = Euclid.Modulus(phase - (double)delay * num, amplitude);
			T[] array = new T[length];
			int num2 = 0;
			int num3 = 0;
			while (num2 < array.Length)
			{
				double num4 = phase + (double)num3 * num;
				if (num4 >= amplitude)
				{
					num4 %= amplitude;
					phase = num4;
					num3 = 0;
				}
				array[num2] = map(num4);
				num2++;
				num3++;
			}
			return array;
		}

		public static IEnumerable<double> PeriodicSequence(double samplingRate, double frequency, double amplitude = 1.0, double phase = 0.0, int delay = 0)
		{
			double step = frequency / samplingRate * amplitude;
			phase = Euclid.Modulus(phase - (double)delay * step, amplitude);
			int i = 0;
			while (true)
			{
				double num = phase + (double)i++ * step;
				if (num >= amplitude)
				{
					num %= amplitude;
					phase = num;
					i = 1;
				}
				yield return num;
			}
		}

		public static IEnumerable<T> PeriodicMapSequence<T>(Func<double, T> map, double samplingRate, double frequency, double amplitude = 1.0, double phase = 0.0, int delay = 0)
		{
			double step = frequency / samplingRate * amplitude;
			phase = Euclid.Modulus(phase - (double)delay * step, amplitude);
			int i = 0;
			while (true)
			{
				double num = phase + (double)i++ * step;
				if (num >= amplitude)
				{
					num %= amplitude;
					phase = num;
					i = 1;
				}
				yield return map(num);
			}
		}

		public static double[] Sinusoidal(int length, double samplingRate, double frequency, double amplitude, double mean = 0.0, double phase = 0.0, int delay = 0)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double num = frequency / samplingRate * (Math.PI * 2.0);
			phase = (phase - (double)delay * num) % (Math.PI * 2.0);
			double[] array = new double[length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = mean + amplitude * Math.Sin(phase + (double)i * num);
			}
			return array;
		}

		public static IEnumerable<double> SinusoidalSequence(double samplingRate, double frequency, double amplitude, double mean = 0.0, double phase = 0.0, int delay = 0)
		{
			double step = frequency / samplingRate * (Math.PI * 2.0);
			phase = (phase - (double)delay * step) % (Math.PI * 2.0);
			while (true)
			{
				for (int i = 0; i < 1000; i++)
				{
					yield return mean + amplitude * Math.Sin(phase + (double)i * step);
				}
				phase = (phase + 1000.0 * step) % (Math.PI * 2.0);
			}
		}

		public static double[] Square(int length, int highDuration, int lowDuration, double lowValue, double highValue, int delay = 0)
		{
			int num = highDuration + lowDuration;
			return PeriodicMap(length, (double x) => (!(x < (double)highDuration)) ? lowValue : highValue, 1.0, 1.0 / (double)num, num, 0.0, delay);
		}

		public static IEnumerable<double> SquareSequence(int highDuration, int lowDuration, double lowValue, double highValue, int delay = 0)
		{
			int num = highDuration + lowDuration;
			return PeriodicMapSequence((double x) => (!(x < (double)highDuration)) ? lowValue : highValue, 1.0, 1.0 / (double)num, num, 0.0, delay);
		}

		public static double[] Triangle(int length, int raiseDuration, int fallDuration, double lowValue, double highValue, int delay = 0)
		{
			int num = raiseDuration + fallDuration;
			double num2 = highValue - lowValue;
			double raise = num2 / (double)raiseDuration;
			double fall = num2 / (double)fallDuration;
			return PeriodicMap(length, (double x) => (!(x < (double)raiseDuration)) ? (highValue - (x - (double)raiseDuration) * fall) : (lowValue + x * raise), 1.0, 1.0 / (double)num, num, 0.0, delay);
		}

		public static IEnumerable<double> TriangleSequence(int raiseDuration, int fallDuration, double lowValue, double highValue, int delay = 0)
		{
			int num = raiseDuration + fallDuration;
			double num2 = highValue - lowValue;
			double raise = num2 / (double)raiseDuration;
			double fall = num2 / (double)fallDuration;
			return PeriodicMapSequence((double x) => (!(x < (double)raiseDuration)) ? (highValue - (x - (double)raiseDuration) * fall) : (lowValue + x * raise), 1.0, 1.0 / (double)num, num, 0.0, delay);
		}

		public static double[] Sawtooth(int length, int period, double lowValue, double highValue, int delay = 0)
		{
			double num = highValue - lowValue;
			return PeriodicMap(length, (double x) => x + lowValue, 1.0, 1.0 / (double)period, num * (double)period / (double)(period - 1), 0.0, delay);
		}

		public static IEnumerable<double> SawtoothSequence(int period, double lowValue, double highValue, int delay = 0)
		{
			double num = highValue - lowValue;
			return PeriodicMapSequence((double x) => x + lowValue, 1.0, 1.0 / (double)period, num * (double)period / (double)(period - 1), 0.0, delay);
		}

		public static T[] Repeat<T>(int length, T value)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			T[] data = new T[length];
			CommonParallel.For(0, data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					data[i] = value;
				}
			});
			return data;
		}

		public static IEnumerable<T> RepeatSequence<T>(T value)
		{
			while (true)
			{
				yield return value;
			}
		}

		public static double[] Step(int length, double amplitude, int delay)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			for (int i = Math.Max(0, delay); i < array.Length; i++)
			{
				array[i] = amplitude;
			}
			return array;
		}

		public static IEnumerable<double> StepSequence(double amplitude, int delay)
		{
			for (int i = 0; i < delay; i++)
			{
				yield return 0.0;
			}
			while (true)
			{
				yield return amplitude;
			}
		}

		public static double[] Impulse(int length, double amplitude, int delay)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			if (delay >= 0 && delay < length)
			{
				array[delay] = amplitude;
			}
			return array;
		}

		public static IEnumerable<double> ImpulseSequence(double amplitude, int delay)
		{
			if (delay >= 0)
			{
				for (int i = 0; i < delay; i++)
				{
					yield return 0.0;
				}
				yield return amplitude;
			}
			while (true)
			{
				yield return 0.0;
			}
		}

		public static double[] PeriodicImpulse(int length, int period, double amplitude, int delay)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			for (delay = Euclid.Modulus(delay, period); delay < length; delay += period)
			{
				array[delay] = amplitude;
			}
			return array;
		}

		public static IEnumerable<double> PeriodicImpulseSequence(int period, double amplitude, int delay)
		{
			delay = Euclid.Modulus(delay, period);
			for (int j = 0; j < delay; j++)
			{
				yield return 0.0;
			}
			while (true)
			{
				yield return amplitude;
				for (int j = 1; j < period; j++)
				{
					yield return 0.0;
				}
			}
		}

		public static T[] Unfold<T, TState>(int length, Func<TState, Tuple<T, TState>> f, TState state)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			T[] array = new T[length];
			for (int i = 0; i < array.Length; i++)
			{
				Tuple<T, TState> tuple = f(state);
				array[i] = tuple.Item1;
				state = tuple.Item2;
			}
			return array;
		}

		public static IEnumerable<T> UnfoldSequence<T, TState>(Func<TState, Tuple<T, TState>> f, TState state)
		{
			while (true)
			{
				Tuple<T, TState> tuple = f(state);
				state = tuple.Item2;
				yield return tuple.Item1;
			}
		}

		public static BigInteger[] Fibonacci(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			BigInteger[] array = new BigInteger[length];
			if (array.Length != 0)
			{
				array[0] = BigInteger.Zero;
			}
			if (array.Length > 1)
			{
				array[1] = BigInteger.One;
			}
			for (int i = 2; i < array.Length; i++)
			{
				array[i] = array[i - 1] + array[i - 2];
			}
			return array;
		}

		public static IEnumerable<BigInteger> FibonacciSequence()
		{
			BigInteger a = BigInteger.Zero;
			yield return a;
			BigInteger b = BigInteger.One;
			yield return b;
			while (true)
			{
				a += b;
				yield return a;
				b = a + b;
				yield return b;
			}
		}

		public static double[] Uniform(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			return SystemRandomSource.FastDoubles(length);
		}

		public static IEnumerable<double> UniformSequence()
		{
			return SystemRandomSource.DoubleSequence();
		}

		public static T[] UniformMap<T>(int length, Func<double, T> map)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			return Map(SystemRandomSource.FastDoubles(length), map);
		}

		public static IEnumerable<T> UniformMapSequence<T>(Func<double, T> map)
		{
			return SystemRandomSource.DoubleSequence().Select(map);
		}

		public static T[] UniformMap2<T>(int length, Func<double, double, T> map)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] pointsA = SystemRandomSource.FastDoubles(length);
			double[] pointsB = SystemRandomSource.FastDoubles(length);
			return Map2(pointsA, pointsB, map);
		}

		public static IEnumerable<T> UniformMap2Sequence<T>(Func<double, double, T> map)
		{
			SystemRandomSource rnd1 = SystemRandomSource.Default;
			for (int i = 0; i < 128; i++)
			{
				yield return map(rnd1.NextDouble(), rnd1.NextDouble());
			}
			System.Random rnd2 = new System.Random(RandomSeed.Robust());
			while (true)
			{
				yield return map(rnd2.NextDouble(), rnd2.NextDouble());
			}
		}

		public static double[] Standard(int length)
		{
			return Normal(length, 0.0, 1.0);
		}

		public static IEnumerable<double> StandardSequence()
		{
			return NormalSequence(0.0, 1.0);
		}

		public static double[] Normal(int length, double mean, double standardDeviation)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			MathNet.Numerics.Distributions.Normal.Samples(SystemRandomSource.Default, array, mean, standardDeviation);
			return array;
		}

		public static IEnumerable<double> NormalSequence(double mean, double standardDeviation)
		{
			return MathNet.Numerics.Distributions.Normal.Samples(SystemRandomSource.Default, mean, standardDeviation);
		}

		public static double[] Random(int length, IContinuousDistribution distribution)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			distribution.Samples(array);
			return array;
		}

		public static IEnumerable<double> Random(IContinuousDistribution distribution)
		{
			return distribution.Samples();
		}

		public static float[] RandomSingle(int length, IContinuousDistribution distribution)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			distribution.Samples(array);
			return Map(array, (double v) => (float)v);
		}

		public static IEnumerable<float> RandomSingle(IContinuousDistribution distribution)
		{
			return from v in distribution.Samples()
				select (float)v;
		}

		public static Complex[] RandomComplex(int length, IContinuousDistribution distribution)
		{
			return RandomMap2(length, distribution, (double r, double i) => new Complex(r, i));
		}

		public static IEnumerable<Complex> RandomComplex(IContinuousDistribution distribution)
		{
			return RandomMap2Sequence(distribution, (double r, double i) => new Complex(r, i));
		}

		public static Complex32[] RandomComplex32(int length, IContinuousDistribution distribution)
		{
			return RandomMap2(length, distribution, (double r, double i) => new Complex32((float)r, (float)i));
		}

		public static IEnumerable<Complex32> RandomComplex32(IContinuousDistribution distribution)
		{
			return RandomMap2Sequence(distribution, (double r, double i) => new Complex32((float)r, (float)i));
		}

		public static T[] RandomMap<T>(int length, IContinuousDistribution distribution, Func<double, T> map)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			distribution.Samples(array);
			return Map(array, map);
		}

		public static IEnumerable<T> RandomMapSequence<T>(IContinuousDistribution distribution, Func<double, T> map)
		{
			return distribution.Samples().Select(map);
		}

		public static T[] RandomMap2<T>(int length, IContinuousDistribution distribution, Func<double, double, T> map)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			double[] array = new double[length];
			double[] array2 = new double[length];
			distribution.Samples(array);
			distribution.Samples(array2);
			return Map2(array, array2, map);
		}

		public static IEnumerable<T> RandomMap2Sequence<T>(IContinuousDistribution distribution, Func<double, double, T> map)
		{
			return distribution.Samples().Zip(distribution.Samples(), map);
		}
	}
	internal static class GlobalizationHelper
	{
		internal static CultureInfo GetCultureInfo(this IFormatProvider formatProvider)
		{
			if (formatProvider == null)
			{
				return CultureInfo.CurrentCulture;
			}
			return (formatProvider as CultureInfo) ?? (formatProvider.GetFormat(typeof(CultureInfo)) as CultureInfo) ?? CultureInfo.CurrentCulture;
		}

		internal static NumberFormatInfo GetNumberFormatInfo(this IFormatProvider formatProvider)
		{
			return NumberFormatInfo.GetInstance(formatProvider);
		}

		internal static TextInfo GetTextInfo(this IFormatProvider formatProvider)
		{
			if (formatProvider == null)
			{
				return CultureInfo.CurrentCulture.TextInfo;
			}
			return (formatProvider.GetFormat(typeof(TextInfo)) as TextInfo) ?? formatProvider.GetCultureInfo().TextInfo;
		}

		internal static void Tokenize(LinkedListNode<string> node, string[] keywords, int skip)
		{
			for (int i = skip; i < keywords.Length; i++)
			{
				string text = keywords[i];
				int num;
				while ((num = node.Value.IndexOf(text, StringComparison.Ordinal)) >= 0)
				{
					if (num != 0)
					{
						string value = node.Value.Substring(0, num).Trim();
						Tokenize(node.List.AddBefore(node, value), keywords, i + 1);
						node.Value = node.Value.Substring(num);
					}
					if (text.Length == node.Value.Length)
					{
						return;
					}
					string value2 = node.Value.Substring(text.Length).Trim();
					node.List.AddBefore(node, text);
					node.Value = value2;
				}
			}
		}

		internal static double ParseDouble(ref LinkedListNode<string> token, CultureInfo culture)
		{
			if (token.Value.EndsWith("e", ignoreCase: true, culture))
			{
				if (token.Next == null || token.Next.Next == null)
				{
					throw new FormatException();
				}
				token.Value = token.Value + token.Next.Value + token.Next.Next.Value;
				LinkedList<string> list = token.List;
				list.Remove(token.Next.Next);
				list.Remove(token.Next);
			}
			if (!double.TryParse(token.Value, NumberStyles.Any, culture, out var result))
			{
				throw new FormatException();
			}
			token = token.Next;
			return result;
		}

		internal static float ParseSingle(ref LinkedListNode<string> token, CultureInfo culture)
		{
			if (token.Value.EndsWith("e", ignoreCase: true, culture))
			{
				if (token.Next == null || token.Next.Next == null)
				{
					throw new FormatException();
				}
				token.Value = token.Value + token.Next.Value + token.Next.Next.Value;
				LinkedList<string> list = token.List;
				list.Remove(token.Next.Next);
				list.Remove(token.Next);
			}
			if (!float.TryParse(token.Value, NumberStyles.Any, culture, out var result))
			{
				throw new FormatException();
			}
			token = token.Next;
			return result;
		}
	}
	public static class GoodnessOfFit
	{
		public static double RSquared(IEnumerable<double> modelledValues, IEnumerable<double> observedValues)
		{
			double num = Correlation.Pearson(modelledValues, observedValues);
			return num * num;
		}

		public static double R(IEnumerable<double> modelledValues, IEnumerable<double> observedValues)
		{
			return Correlation.Pearson(modelledValues, observedValues);
		}

		public static double PopulationStandardError(IEnumerable<double> modelledValues, IEnumerable<double> observedValues)
		{
			return StandardError(modelledValues, observedValues, 0);
		}

		public static double StandardError(IEnumerable<double> modelledValues, IEnumerable<double> observedValues, int degreesOfFreedom)
		{
			using IEnumerator<double> enumerator = modelledValues.GetEnumerator();
			using IEnumerator<double> enumerator2 = observedValues.GetEnumerator();
			double num = 0.0;
			double num2 = 0.0;
			while (enumerator.MoveNext())
			{
				if (!enumerator2.MoveNext())
				{
					throw new ArgumentOutOfRangeException("modelledValues", "The array arguments must have the same length.");
				}
				double current = enumerator.Current;
				double current2 = enumerator2.Current;
				double num3 = current - current2;
				num2 += num3 * num3;
				num += 1.0;
			}
			if ((double)degreesOfFreedom >= num)
			{
				throw new ArgumentOutOfRangeException("degreesOfFreedom", "The sample size must be larger than the given degrees of freedom.");
			}
			return Math.Sqrt(num2 / (num - (double)degreesOfFreedom));
		}

		public static double CoefficientOfDetermination(IEnumerable<double> modelledValues, IEnumerable<double> observedValues)
		{
			int num = 0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			using (IEnumerator<double> enumerator = observedValues.GetEnumerator())
			{
				using IEnumerator<double> enumerator2 = modelledValues.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (!enumerator2.MoveNext())
					{
						throw new ArgumentOutOfRangeException("modelledValues", "The array arguments must have the same length.");
					}
					double current = enumerator.Current;
					double current2 = enumerator2.Current;
					double num5 = current - num2;
					double num6 = num5 / (double)(++num);
					num2 += num6;
					num3 += num6 * num5 * (double)(num - 1);
					num4 += (current - current2) * (current - current2);
				}
				if (enumerator2.MoveNext())
				{
					throw new ArgumentOutOfRangeException("observedValues", "The array arguments must have the same length.");
				}
			}
			return 1.0 - num4 / num3;
		}
	}
	public static class Integrate
	{
		public static double OnClosedInterval(Func<double, double> f, double intervalBegin, double intervalEnd, double targetAbsoluteError)
		{
			return DoubleExponentialTransformation.Integrate(f, intervalBegin, intervalEnd, targetAbsoluteError);
		}

		public static double OnClosedInterval(Func<double, double> f, double intervalBegin, double intervalEnd)
		{
			return DoubleExponentialTransformation.Integrate(f, intervalBegin, intervalEnd, 1E-08);
		}

		public static double OnRectangle(Func<double, double, double> f, double invervalBeginA, double invervalEndA, double invervalBeginB, double invervalEndB, int order)
		{
			return GaussLegendreRule.Integrate(f, invervalBeginA, invervalEndA, invervalBeginB, invervalEndB, order);
		}

		public static double OnRectangle(Func<double, double, double> f, double invervalBeginA, double invervalEndA, double invervalBeginB, double invervalEndB)
		{
			return GaussLegendreRule.Integrate(f, invervalBeginA, invervalEndA, invervalBeginB, invervalEndB, 32);
		}

		public static double DoubleExponential(Func<double, double> f, double intervalBegin, double intervalEnd, double targetAbsoluteError = 1E-08)
		{
			if (intervalBegin > intervalEnd)
			{
				return 0.0 - DoubleExponential(f, intervalEnd, intervalBegin, targetAbsoluteError);
			}
			if (double.IsInfinity(intervalBegin) && double.IsInfinity(intervalEnd))
			{
				return DoubleExponentialTransformation.Integrate((double t) => f(t / (1.0 - t * t)) * (1.0 + t * t) / ((1.0 - t * t) * (1.0 - t * t)), -1.0, 1.0, targetAbsoluteError);
			}
			if (double.IsInfinity(intervalEnd))
			{
				return DoubleExponentialTransformation.Integrate((double s) => 2.0 * s * f(intervalBegin + s / (1.0 - s) * (s / (1.0 - s))) / ((1.0 - s) * (1.0 - s) * (1.0 - s)), 0.0, 1.0, targetAbsoluteError);
			}
			if (double.IsInfinity(intervalBegin))
			{
				return DoubleExponentialTransformation.Integrate((double s) => -2.0 * s * f(intervalEnd - s / (1.0 + s) * (s / (1.0 + s))) / ((1.0 + s) * (1.0 + s) * (1.0 + s)), -1.0, 0.0, targetAbsoluteError);
			}
			return DoubleExponentialTransformation.Integrate(f, intervalBegin, intervalEnd, targetAbsoluteError);
		}

		public static double GaussLegendre(Func<double, double> f, double intervalBegin, double intervalEnd, int order = 128)
		{
			if (intervalBegin > intervalEnd)
			{
				return 0.0 - GaussLegendre(f, intervalEnd, intervalBegin, order);
			}
			if (double.IsInfinity(intervalBegin) && double.IsInfinity(intervalEnd))
			{
				return GaussLegendreRule.Integrate((double t) => f(t / (1.0 - t * t)) * (1.0 + t * t) / ((1.0 - t * t) * (1.0 - t * t)), -1.0, 1.0, order);
			}
			if (double.IsInfinity(intervalEnd))
			{
				return GaussLegendreRule.Integrate((double s) => 2.0 * s * f(intervalBegin + s / (1.0 - s) * (s / (1.0 - s))) / ((1.0 - s) * (1.0 - s) * (1.0 - s)), 0.0, 1.0, order);
			}
			if (double.IsInfinity(intervalBegin))
			{
				return GaussLegendreRule.Integrate((double s) => -2.0 * s * f(intervalEnd - s / (1.0 + s) * (s / (1.0 + s))) / ((1.0 + s) * (1.0 + s) * (1.0 + s)), -1.0, 0.0, order);
			}
			return GaussLegendreRule.Integrate((double t) => f((intervalEnd - intervalBegin) / 4.0 * t * (3.0 - t * t) + (intervalEnd + intervalBegin) / 2.0) * 3.0 * (intervalEnd - intervalBegin) / 4.0 * (1.0 - t * t), -1.0, 1.0, order);
		}

		public static double GaussKronrod(Func<double, double> f, double intervalBegin, double intervalEnd, double targetRelativeError = 1E-08, int maximumDepth = 15, int order = 15)
		{
			double error;
			double L1Norm;
			return GaussKronrodRule.Integrate(f, intervalBegin, intervalEnd, out error, out L1Norm, targetRelativeError, maximumDepth, order);
		}

		public static double GaussKronrod(Func<double, double> f, double intervalBegin, double intervalEnd, out double error, out double L1Norm, double targetRelativeError = 1E-08, int maximumDepth = 15, int order = 15)
		{
			return GaussKronrodRule.Integrate(f, intervalBegin, intervalEnd, out error, out L1Norm, targetRelativeError, maximumDepth, order);
		}
	}
	public static class ContourIntegrate
	{
		public static Complex DoubleExponential(Func<double, Complex> f, double intervalBegin, double intervalEnd, double targetAbsoluteError = 1E-08)
		{
			if (intervalBegin > intervalEnd)
			{
				return -DoubleExponential(f, intervalEnd, intervalBegin, targetAbsoluteError);
			}
			if (double.IsInfinity(intervalBegin) && double.IsInfinity(intervalEnd))
			{
				return DoubleExponentialTransformation.ContourIntegrate((double t) => f(t / (1.0 - t * t)) * (1.0 + t * t) / ((1.0 - t * t) * (1.0 - t * t)), -1.0, 1.0, targetAbsoluteError);
			}
			if (double.IsInfinity(intervalEnd))
			{
				return DoubleExponentialTransformation.ContourIntegrate((double s) => 2.0 * s * f(intervalBegin + s / (1.0 - s) * (s / (1.0 - s))) / ((1.0 - s) * (1.0 - s) * (1.0 - s)), 0.0, 1.0, targetAbsoluteError);
			}
			if (double.IsInfinity(intervalBegin))
			{
				return DoubleExponentialTransformation.ContourIntegrate((double s) => -2.0 * s * f(intervalEnd - s / (1.0 + s) * (s / (1.0 + s))) / ((1.0 + s) * (1.0 + s) * (1.0 + s)), -1.0, 0.0, targetAbsoluteError);
			}
			return DoubleExponentialTransformation.ContourIntegrate(f, intervalBegin, intervalEnd, targetAbsoluteError);
		}

		public static Complex GaussLegendre(Func<double, Complex> f, double intervalBegin, double intervalEnd, int order = 128)
		{
			if (intervalBegin > intervalEnd)
			{
				return -GaussLegendre(f, intervalEnd, intervalBegin, order);
			}
			if (double.IsInfinity(intervalBegin) && double.IsInfinity(intervalEnd))
			{
				return GaussLegendreRule.ContourIntegrate((double t) => f(t / (1.0 - t * t)) * (1.0 + t * t) / ((1.0 - t * t) * (1.0 - t * t)), -1.0, 1.0, order);
			}
			if (double.IsInfinity(intervalEnd))
			{
				return GaussLegendreRule.ContourIntegrate((double s) => 2.0 * s * f(intervalBegin + s / (1.0 - s) * (s / (1.0 - s))) / ((1.0 - s) * (1.0 - s) * (1.0 - s)), 0.0, 1.0, order);
			}
			if (double.IsInfinity(intervalBegin))
			{
				return GaussLegendreRule.ContourIntegrate((double s) => -2.0 * s * f(intervalEnd - s / (1.0 + s) * (s / (1.0 + s))) / ((1.0 + s) * (1.0 + s) * (1.0 + s)), -1.0, 0.0, order);
			}
			return GaussLegendreRule.ContourIntegrate((double t) => f((intervalEnd - intervalBegin) / 4.0 * t * (3.0 - t * t) + (intervalEnd + intervalBegin) / 2.0) * 3 * (intervalEnd - intervalBegin) / 4 * (1.0 - t * t), -1.0, 1.0, order);
		}

		public static Complex GaussKronrod(Func<double, Complex> f, double intervalBegin, double intervalEnd, double targetRelativeError = 1E-08, int maximumDepth = 15, int order = 15)
		{
			double error;
			double L1Norm;
			return GaussKronrodRule.ContourIntegrate(f, intervalBegin, intervalEnd, out error, out L1Norm, targetRelativeError, maximumDepth, order);
		}

		public static Complex GaussKronrod(Func<double, Complex> f, double intervalBegin, double intervalEnd, out double error, out double L1Norm, double targetRelativeError = 1E-08, int maximumDepth = 15, int order = 15)
		{
			return GaussKronrodRule.ContourIntegrate(f, intervalBegin, intervalEnd, out error, out L1Norm, targetRelativeError, maximumDepth, order);
		}
	}
	public static class Interpolate
	{
		public static IInterpolation Common(IEnumerable<double> points, IEnumerable<double> values)
		{
			return Barycentric.InterpolateRationalFloaterHormann(points, values);
		}

		public static IInterpolation RationalWithoutPoles(IEnumerable<double> points, IEnumerable<double> values)
		{
			return Barycentric.InterpolateRationalFloaterHormann(points, values);
		}

		public static IInterpolation RationalWithPoles(IEnumerable<double> points, IEnumerable<double> values)
		{
			return BulirschStoerRationalInterpolation.Interpolate(points, values);
		}

		public static IInterpolation PolynomialEquidistant(IEnumerable<double> points, IEnumerable<double> values)
		{
			return Barycentric.InterpolatePolynomialEquidistant(points, values);
		}

		public static IInterpolation Polynomial(IEnumerable<double> points, IEnumerable<double> values)
		{
			return NevillePolynomialInterpolation.Interpolate(points, values);
		}

		public static IInterpolation Linear(IEnumerable<double> points, IEnumerable<double> values)
		{
			return LinearSpline.Interpolate(points, values);
		}

		public static IInterpolation LogLinear(IEnumerable<double> points, IEnumerable<double> values)
		{
			return MathNet.Numerics.Interpolation.LogLinear.Interpolate(points, values);
		}

		public static IInterpolation CubicSpline(IEnumerable<double> points, IEnumerable<double> values)
		{
			return MathNet.Numerics.Interpolation.CubicSpline.InterpolateNatural(points, values);
		}

		public static IInterpolation CubicSplineRobust(IEnumerable<double> points, IEnumerable<double> values)
		{
			return MathNet.Numerics.Interpolation.CubicSpline.InterpolateAkima(points, values);
		}

		public static IInterpolation CubicSplineMonotone(IEnumerable<double> points, IEnumerable<double> values)
		{
			return MathNet.Numerics.Interpolation.CubicSpline.InterpolatePchip(points, values);
		}

		public static IInterpolation CubicSplineWithDerivatives(IEnumerable<double> points, IEnumerable<double> values, IEnumerable<double> firstDerivatives)
		{
			return MathNet.Numerics.Interpolation.CubicSpline.InterpolateHermite(points, values, firstDerivatives);
		}

		public static IInterpolation Step(IEnumerable<double> points, IEnumerable<double> values)
		{
			return StepInterpolation.Interpolate(points, values);
		}
	}
	[Serializable]
	public class Permutation
	{
		private readonly int[] _indices;

		public int Dimension => _indices.Length;

		public int this[int idx] => _indices[idx];

		public Permutation(int[] indices)
		{
			if (!CheckForProperPermutation(indices))
			{
				throw new ArgumentException("The integer array does not represent a valid permutation.", "indices");
			}
			_indices = (int[])indices.Clone();
		}

		public Permutation Inverse()
		{
			int[] array = new int[Dimension];
			for (int i = 0; i < array.Length; i++)
			{
				array[_indices[i]] = i;
			}
			return new Permutation(array);
		}

		public static Permutation FromInversions(int[] inv)
		{
			int[] array = new int[inv.Length];
			for (int i = 0; i < inv.Length; i++)
			{
				array[i] = i;
			}
			for (int num = inv.Length - 1; num >= 0; num--)
			{
				if (array[num] != inv[num])
				{
					int num2 = array[num];
					array[num] = array[inv[num]];
					array[inv[num]] = num2;
				}
			}
			return new Permutation(array);
		}

		public int[] ToInversions()
		{
			int[] array = (int[])_indices.Clone();
			int i;
			for (i = 0; i < array.Length; i++)
			{
				if (array[i] != i)
				{
					int num = Array.FindIndex(array, i + 1, (int x) => x == i);
					int num2 = array[i];
					array[i] = num;
					array[num] = num2;
				}
			}
			return array;
		}

		private static bool CheckForProperPermutation(int[] indices)
		{
			bool[] array = new bool[indices.Length];
			for (int i = 0; i < indices.Length; i++)
			{
				if (indices[i] >= indices.Length || indices[i] < 0)
				{
					return false;
				}
				array[indices[i]] = true;
			}
			for (int j = 0; j < indices.Length; j++)
			{
				if (!array[j])
				{
					return false;
				}
			}
			return true;
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics")]
	public class Polynomial : IFormattable, IEquatable<Polynomial>, ICloneable
	{
		[DataMember(Order = 2)]
		public string VariableName = "x";

		[DataMember(Order = 1)]
		public double[] Coefficients { get; private set; }

		public int Degree => EvaluateDegree(Coefficients);

		public static Polynomial Zero => new Polynomial();

		public Polynomial(int n)
		{
			if (n < 0)
			{
				throw new ArgumentOutOfRangeException("n", "n must be non-negative");
			}
			Coefficients = new double[n];
		}

		public Polynomial()
		{
			Coefficients = new double[0];
		}

		public Polynomial(double coefficient)
		{
			if (coefficient == 0.0)
			{
				Coefficients = new double[0];
				return;
			}
			Coefficients = new double[1] { coefficient };
		}

		public Polynomial(params double[] coefficients)
		{
			Coefficients = coefficients;
		}

		public Polynomial(IEnumerable<double> coefficients)
			: this(coefficients.ToArray())
		{
		}

		public static Polynomial Fit(double[] x, double[] y, int order, DirectRegressionMethod method = DirectRegressionMethod.QR)
		{
			return new Polynomial(MathNet.Numerics.Fit.Polynomial(x, y, order, method));
		}

		private static int EvaluateDegree(double[] coefficients)
		{
			for (int num = coefficients.Length - 1; num >= 0; num--)
			{
				if (coefficients[num] != 0.0)
				{
					return num;
				}
			}
			return -1;
		}

		public static double Evaluate(double z, params double[] coefficients)
		{
			if (coefficients == null)
			{
				throw new ArgumentNullException("coefficients");
			}
			int num = coefficients.Length;
			if (num == 0)
			{
				return 0.0;
			}
			double num2 = coefficients[num - 1];
			for (int num3 = num - 2; num3 >= 0; num3--)
			{
				num2 *= z;
				num2 += coefficients[num3];
			}
			return num2;
		}

		public static Complex Evaluate(Complex z, params double[] coefficients)
		{
			if (coefficients == null)
			{
				throw new ArgumentNullException("coefficients");
			}
			int num = coefficients.Length;
			if (num == 0)
			{
				return 0;
			}
			Complex result = coefficients[num - 1];
			for (int num2 = num - 2; num2 >= 0; num2--)
			{
				result *= z;
				result += (Complex)coefficients[num2];
			}
			return result;
		}

		public static Complex Evaluate(Complex z, params Complex[] coefficients)
		{
			if (coefficients == null)
			{
				throw new ArgumentNullException("coefficients");
			}
			int num = coefficients.Length;
			if (num == 0)
			{
				return 0;
			}
			Complex result = coefficients[num - 1];
			for (int num2 = num - 2; num2 >= 0; num2--)
			{
				result *= z;
				result += coefficients[num2];
			}
			return result;
		}

		public double Evaluate(double z)
		{
			return Evaluate(z, Coefficients);
		}

		public Complex Evaluate(Complex z)
		{
			return Evaluate(z, Coefficients);
		}

		public IEnumerable<double> Evaluate(IEnumerable<double> z)
		{
			return z.Select(Evaluate);
		}

		public IEnumerable<Complex> Evaluate(IEnumerable<Complex> z)
		{
			return z.Select(Evaluate);
		}

		public Polynomial Differentiate()
		{
			int degree = Degree;
			if (degree < 0)
			{
				return this;
			}
			if (degree == 0)
			{
				return Zero;
			}
			double[] array = new double[degree];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Coefficients[i + 1] * (double)(i + 1);
			}
			return new Polynomial(array);
		}

		public Polynomial Integrate()
		{
			int degree = Degree;
			if (degree < 0)
			{
				return this;
			}
			double[] array = new double[degree + 2];
			for (int i = 1; i < array.Length; i++)
			{
				array[i] = Coefficients[i - 1] / (double)i;
			}
			return new Polynomial(array);
		}

		public Complex[] Roots()
		{
			switch (Degree)
			{
			case -1:
			case 0:
				return new Complex[0];
			case 1:
				return new Complex[1]
				{
					new Complex((0.0 - Coefficients[0]) / Coefficients[1], 0.0)
				};
			default:
				return EigenvalueMatrix().Evd(Symmetricity.Asymmetric).EigenValues.AsArray();
			}
		}

		public MathNet.Numerics.LinearAlgebra.Double.DenseMatrix EigenvalueMatrix()
		{
			int degree = Degree;
			if (degree < 2)
			{
				return null;
			}
			double num = Coefficients[degree];
			double[] array = new double[degree];
			for (int num2 = degree - 1; num2 >= 0; num2--)
			{
				array[num2] = (0.0 - Coefficients[num2]) / num;
			}
			MathNet.Numerics.LinearAlgebra.Double.DenseMatrix subMatrix = MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.CreateDiagonal(degree - 1, degree - 1, 1.0);
			MathNet.Numerics.LinearAlgebra.Double.DenseMatrix denseMatrix = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix(degree);
			denseMatrix.SetSubMatrix(1, 0, subMatrix);
			denseMatrix.SetRow(0, array.Reverse().ToArray());
			return denseMatrix;
		}

		public static Polynomial Add(Polynomial a, Polynomial b)
		{
			double[] coefficients = a.Coefficients;
			double[] coefficients2 = b.Coefficients;
			double[] array = new double[Math.Max(a.Degree, b.Degree) + 1];
			int num = Math.Min(Math.Min(coefficients.Length, coefficients2.Length), array.Length);
			for (int i = 0; i < num; i++)
			{
				array[i] = coefficients[i] + coefficients2[i];
			}
			int num2 = Math.Min(coefficients.Length, array.Length);
			for (int j = num; j < num2; j++)
			{
				array[j] = coefficients[j];
			}
			int num3 = Math.Min(coefficients2.Length, array.Length);
			for (int k = num; k < num3; k++)
			{
				array[k] = coefficients2[k];
			}
			return new Polynomial(array);
		}

		public static Polynomial Add(Polynomial a, double b)
		{
			double[] coefficients = a.Coefficients;
			double[] array = new double[Math.Max(a.Degree, 0) + 1];
			int num = Math.Min(coefficients.Length, array.Length);
			for (int i = 0; i < num; i++)
			{
				array[i] = coefficients[i];
			}
			array[0] += b;
			return new Polynomial(array);
		}

		public static Polynomial Subtract(Polynomial a, Polynomial b)
		{
			double[] coefficients = a.Coefficients;
			double[] coefficients2 = b.Coefficients;
			double[] array = new double[Math.Max(a.Degree, b.Degree) + 1];
			int num = Math.Min(Math.Min(coefficients.Length, coefficients2.Length), array.Length);
			for (int i = 0; i < num; i++)
			{
				array[i] = coefficients[i] - coefficients2[i];
			}
			int num2 = Math.Min(coefficients.Length, array.Length);
			for (int j = num; j < num2; j++)
			{
				array[j] = coefficients[j];
			}
			int num3 = Math.Min(coefficients2.Length, array.Length);
			for (int k = num; k < num3; k++)
			{
				array[k] = 0.0 - coefficients2[k];
			}
			return new Polynomial(array);
		}

		public static Polynomial Subtract(Polynomial a, double b)
		{
			return Add(a, 0.0 - b);
		}

		public static Polynomial Subtract(double b, Polynomial a)
		{
			double[] coefficients = a.Coefficients;
			double[] array = new double[Math.Max(a.Degree, 0) + 1];
			int num = Math.Min(coefficients.Length, array.Length);
			for (int i = 0; i < num; i++)
			{
				array[i] = 0.0 - coefficients[i];
			}
			array[0] += b;
			return new Polynomial(array);
		}

		public static Polynomial Negate(Polynomial a)
		{
			double[] coefficients = a.Coefficients;
			double[] array = new double[a.Degree + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.0 - coefficients[i];
			}
			return new Polynomial(array);
		}

		public static Polynomial Multiply(Polynomial a, Polynomial b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			int degree = a.Degree;
			int degree2 = b.Degree;
			if (degree < 0 || degree2 < 0)
			{
				return Zero;
			}
			double[] coefficients = a.Coefficients;
			double[] coefficients2 = b.Coefficients;
			double[] array = new double[degree + degree2 + 1];
			for (int i = 0; i <= degree; i++)
			{
				for (int j = 0; j <= degree2; j++)
				{
					array[i + j] += coefficients[i] * coefficients2[j];
				}
			}
			return new Polynomial(array);
		}

		public static Polynomial Multiply(Polynomial a, double k)
		{
			double[] coefficients = a.Coefficients;
			double[] array = new double[a.Degree + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = coefficients[i] * k;
			}
			return new Polynomial(array);
		}

		public static Polynomial Divide(Polynomial a, double k)
		{
			double[] coefficients = a.Coefficients;
			double[] array = new double[a.Degree + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = coefficients[i] / k;
			}
			return new Polynomial(array);
		}

		public static Tuple<Polynomial, Polynomial> DivideRemainder(Polynomial a, Polynomial b)
		{
			int degree = b.Degree;
			if (degree < 0)
			{
				throw new DivideByZeroException("b polynomial ends with zero");
			}
			int degree2 = a.Degree;
			if (degree2 < 0)
			{
				return Tuple.Create(a, a);
			}
			if (degree == 0)
			{
				return Tuple.Create(Divide(a, b.Coefficients[0]), Zero);
			}
			if (degree2 < degree)
			{
				return Tuple.Create(Zero, a);
			}
			double[] array = a.Coefficients.ToArray();
			double[] array2 = b.Coefficients.ToArray();
			double num = array2[degree];
			double[] array3 = new double[degree];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = array2[i] / num;
			}
			int num2 = degree2 - degree;
			int num3 = degree2;
			while (num2 >= 0)
			{
				double num4 = array[num3];
				for (int j = num2; j < num3; j++)
				{
					array[j] -= array3[j - num2] * num4;
				}
				num2--;
				num3--;
			}
			int num5 = num3 + 1;
			int num6 = degree2 - num3;
			double[] array4 = new double[num6];
			for (int k = 0; k < num6; k++)
			{
				array4[k] = array[k + num5] / num;
			}
			double[] array5 = new double[num5];
			for (int l = 0; l < num5; l++)
			{
				array5[l] = array[l];
			}
			return Tuple.Create(new Polynomial(array4), new Polynomial(array5));
		}

		public static Polynomial PointwiseDivide(Polynomial a, Polynomial b)
		{
			double[] coefficients = a.Coefficients;
			double[] coefficients2 = b.Coefficients;
			double[] array = new double[a.Degree + 1];
			int num = Math.Min(Math.Min(coefficients.Length, coefficients2.Length), array.Length);
			for (int i = 0; i < num; i++)
			{
				array[i] = coefficients[i] / coefficients2[i];
			}
			for (int j = num; j < array.Length; j++)
			{
				array[j] = coefficients[j] / 0.0;
			}
			return new Polynomial(array);
		}

		public static Polynomial PointwiseMultiply(Polynomial a, Polynomial b)
		{
			double[] coefficients = a.Coefficients;
			double[] coefficients2 = b.Coefficients;
			double[] array = new double[Math.Min(a.Degree, b.Degree) + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = coefficients[i] * coefficients2[i];
			}
			return new Polynomial(array);
		}

		public Tuple<Polynomial, Polynomial> DivideRemainder(Polynomial b)
		{
			return DivideRemainder(this, b);
		}

		public static Polynomial operator +(Polynomial a, Polynomial b)
		{
			return Add(a, b);
		}

		public static Polynomial operator +(Polynomial a, double k)
		{
			return Add(a, k);
		}

		public static Polynomial operator +(double k, Polynomial a)
		{
			return Add(a, k);
		}

		public static Polynomial operator -(Polynomial a, Polynomial b)
		{
			return Subtract(a, b);
		}

		public static Polynomial operator -(Polynomial a, double k)
		{
			return Subtract(a, k);
		}

		public static Polynomial operator -(double k, Polynomial a)
		{
			return Subtract(k, a);
		}

		public static Polynomial operator -(Polynomial a)
		{
			return Negate(a);
		}

		public static Polynomial operator *(Polynomial a, Polynomial b)
		{
			return Multiply(a, b);
		}

		public static Polynomial operator *(Polynomial a, double k)
		{
			return Multiply(a, k);
		}

		public static Polynomial operator *(double k, Polynomial a)
		{
			return Multiply(a, k);
		}

		public static Polynomial operator /(Polynomial a, double k)
		{
			return Divide(a, k);
		}

		public override string ToString()
		{
			return ToString("G", CultureInfo.CurrentCulture);
		}

		public string ToStringDescending()
		{
			return ToStringDescending("G", CultureInfo.CurrentCulture);
		}

		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		public string ToStringDescending(string format)
		{
			return ToStringDescending(format, CultureInfo.CurrentCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			return ToString("G", formatProvider);
		}

		public string ToStringDescending(IFormatProvider formatProvider)
		{
			return ToStringDescending("G", formatProvider);
		}

		public string ToString(string format, IFormatProvider formatProvider)
		{
			if (Degree < 0)
			{
				return "0";
			}
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			for (int i = 0; i < Coefficients.Length; i++)
			{
				double num = Coefficients[i];
				if (num == 0.0)
				{
					continue;
				}
				if (flag)
				{
					stringBuilder.Append(num.ToString(format, formatProvider));
					if (i > 0)
					{
						stringBuilder.Append(VariableName);
					}
					if (i > 1)
					{
						stringBuilder.Append("^");
						stringBuilder.Append(i);
					}
					flag = false;
					continue;
				}
				if (num < 0.0)
				{
					stringBuilder.Append(" - ");
					stringBuilder.Append((0.0 - num).ToString(format, formatProvider));
				}
				else
				{
					stringBuilder.Append(" + ");
					stringBuilder.Append(num.ToString(format, formatProvider));
				}
				if (i > 0)
				{
					stringBuilder.Append(VariableName);
				}
				if (i > 1)
				{
					stringBuilder.Append("^");
					stringBuilder.Append(i);
				}
			}
			return stringBuilder.ToString();
		}

		public string ToStringDescending(string format, IFormatProvider formatProvider)
		{
			if (Degree < 0)
			{
				return "0";
			}
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			for (int num = Coefficients.Length - 1; num >= 0; num--)
			{
				double num2 = Coefficients[num];
				if (num2 != 0.0)
				{
					if (flag)
					{
						stringBuilder.Append(num2.ToString(format, formatProvider));
						if (num > 0)
						{
							stringBuilder.Append(VariableName);
						}
						if (num > 1)
						{
							stringBuilder.Append("^");
							stringBuilder.Append(num);
						}
						flag = false;
					}
					else
					{
						if (num2 < 0.0)
						{
							stringBuilder.Append(" - ");
							stringBuilder.Append((0.0 - num2).ToString(format, formatProvider));
						}
						else
						{
							stringBuilder.Append(" + ");
							stringBuilder.Append(num2.ToString(format, formatProvider));
						}
						if (num > 0)
						{
							stringBuilder.Append(VariableName);
						}
						if (num > 1)
						{
							stringBuilder.Append("^");
							stringBuilder.Append(num);
						}
					}
				}
			}
			return stringBuilder.ToString();
		}

		public bool Equals(Polynomial other)
		{
			if (other == null)
			{
				return false;
			}
			if (this == other)
			{
				return true;
			}
			int degree = Degree;
			if (degree != other.Degree)
			{
				return false;
			}
			for (int i = 0; i <= degree; i++)
			{
				if (!Coefficients[i].Equals(other.Coefficients[i]))
				{
					return false;
				}
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (this == obj)
			{
				return true;
			}
			if (obj.GetType() != typeof(Polynomial))
			{
				return false;
			}
			return Equals((Polynomial)obj);
		}

		public override int GetHashCode()
		{
			int num = Math.Min(Degree + 1, 25);
			int num2 = 17;
			for (int i = 0; i < num; i++)
			{
				num2 = num2 * 31 + Coefficients[i].GetHashCode();
			}
			return num2;
		}

		public Polynomial Clone()
		{
			double[] array = new double[EvaluateDegree(Coefficients) + 1];
			Array.Copy(Coefficients, array, array.Length);
			return new Polynomial(array);
		}

		object ICloneable.Clone()
		{
			return Clone();
		}
	}
	public static class Precision
	{
		[StructLayout(LayoutKind.Explicit)]
		private struct SingleIntUnion
		{
			[FieldOffset(0)]
			public float Single;

			[FieldOffset(0)]
			public int Int32;
		}

		private const int DoubleWidth = 53;

		private const int SingleWidth = 24;

		public static readonly double DoublePrecision = Math.Pow(2.0, -53.0);

		public static readonly double PositiveDoublePrecision = 2.0 * DoublePrecision;

		public static readonly double SinglePrecision = Math.Pow(2.0, -24.0);

		public static readonly double PositiveSinglePrecision = 2.0 * SinglePrecision;

		public static readonly double MachineEpsilon = MeasureMachineEpsilon();

		public static readonly double PositiveMachineEpsilon = MeasurePositiveMachineEpsilon();

		public static readonly int DoubleDecimalPlaces = (int)Math.Floor(Math.Abs(Math.Log10(DoublePrecision)));

		public static readonly int SingleDecimalPlaces = (int)Math.Floor(Math.Abs(Math.Log10(SinglePrecision)));

		private static readonly double DefaultDoubleAccuracy = DoublePrecision * 10.0;

		private static readonly float DefaultSingleAccuracy = (float)(SinglePrecision * 10.0);

		public static int CompareTo(this double a, double b, double maximumAbsoluteError)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return a.CompareTo(b);
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a.CompareTo(b);
			}
			if (a.AlmostEqual(b, maximumAbsoluteError))
			{
				return 0;
			}
			return a.CompareTo(b);
		}

		public static int CompareTo(this double a, double b, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return a.CompareTo(b);
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a.CompareTo(b);
			}
			if (a.AlmostEqual(b, decimalPlaces))
			{
				return 0;
			}
			return a.CompareTo(b);
		}

		public static int CompareToRelative(this double a, double b, double maximumError)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return a.CompareTo(b);
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a.CompareTo(b);
			}
			if (a.AlmostEqualRelative(b, maximumError))
			{
				return 0;
			}
			return a.CompareTo(b);
		}

		public static int CompareToRelative(this double a, double b, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return a.CompareTo(b);
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a.CompareTo(b);
			}
			if (a.AlmostEqualRelative(b, decimalPlaces))
			{
				return 0;
			}
			return a.CompareTo(b);
		}

		public static int CompareToNumbersBetween(this double a, double b, long maxNumbersBetween)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return a.CompareTo(b);
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a.CompareTo(b);
			}
			if (a.AlmostEqualNumbersBetween(b, maxNumbersBetween))
			{
				return 0;
			}
			return a.CompareTo(b);
		}

		public static bool IsLarger(this double a, double b, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareTo(b, decimalPlaces) > 0;
		}

		public static bool IsLarger(this float a, float b, int decimalPlaces)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareTo(a, b, decimalPlaces) > 0;
		}

		public static bool IsLarger(this double a, double b, double maximumAbsoluteError)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareTo(b, maximumAbsoluteError) > 0;
		}

		public static bool IsLarger(this float a, float b, double maximumAbsoluteError)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareTo(a, b, maximumAbsoluteError) > 0;
		}

		public static bool IsLargerRelative(this double a, double b, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareToRelative(b, decimalPlaces) > 0;
		}

		public static bool IsLargerRelative(this float a, float b, int decimalPlaces)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareToRelative(a, b, decimalPlaces) > 0;
		}

		public static bool IsLargerRelative(this double a, double b, double maximumError)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareToRelative(b, maximumError) > 0;
		}

		public static bool IsLargerRelative(this float a, float b, double maximumError)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareToRelative(a, b, maximumError) > 0;
		}

		public static bool IsLargerNumbersBetween(this double a, double b, long maxNumbersBetween)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareToNumbersBetween(b, maxNumbersBetween) > 0;
		}

		public static bool IsLargerNumbersBetween(this float a, float b, long maxNumbersBetween)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareToNumbersBetween(a, b, maxNumbersBetween) > 0;
		}

		public static bool IsSmaller(this double a, double b, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareTo(b, decimalPlaces) < 0;
		}

		public static bool IsSmaller(this float a, float b, int decimalPlaces)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareTo(a, b, decimalPlaces) < 0;
		}

		public static bool IsSmaller(this double a, double b, double maximumAbsoluteError)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareTo(b, maximumAbsoluteError) < 0;
		}

		public static bool IsSmaller(this float a, float b, double maximumAbsoluteError)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareTo(a, b, maximumAbsoluteError) < 0;
		}

		public static bool IsSmallerRelative(this double a, double b, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareToRelative(b, decimalPlaces) < 0;
		}

		public static bool IsSmallerRelative(this float a, float b, int decimalPlaces)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareToRelative(a, b, decimalPlaces) < 0;
		}

		public static bool IsSmallerRelative(this double a, double b, double maximumError)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareToRelative(b, maximumError) < 0;
		}

		public static bool IsSmallerRelative(this float a, float b, double maximumError)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareToRelative(a, b, maximumError) < 0;
		}

		public static bool IsSmallerNumbersBetween(this double a, double b, long maxNumbersBetween)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return a.CompareToNumbersBetween(b, maxNumbersBetween) < 0;
		}

		public static bool IsSmallerNumbersBetween(this float a, float b, long maxNumbersBetween)
		{
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			return CompareToNumbersBetween(a, b, maxNumbersBetween) < 0;
		}

		public static bool IsFinite(this double value)
		{
			if (!double.IsNaN(value))
			{
				return !double.IsInfinity(value);
			}
			return false;
		}

		public static int Magnitude(this double value)
		{
			if (value.Equals(0.0))
			{
				return 0;
			}
			double num = Math.Log10(Math.Abs(value));
			int num2 = (int)Truncate(num);
			if (!(num < 0.0) || (double)num2 == num)
			{
				return num2;
			}
			return num2 - 1;
		}

		public static int Magnitude(this float value)
		{
			if (value.Equals(0f))
			{
				return 0;
			}
			float num = Convert.ToSingle(Math.Log10(Math.Abs(value)));
			int num2 = (int)Truncate(num);
			if (!(num < 0f) || (float)num2 == num)
			{
				return num2;
			}
			return num2 - 1;
		}

		public static double ScaleUnitMagnitude(this double value)
		{
			if (value.Equals(0.0))
			{
				return value;
			}
			int num = value.Magnitude();
			return value * Math.Pow(10.0, -num);
		}

		private static long AsDirectionalInt64(double value)
		{
			long num = BitConverter.DoubleToInt64Bits(value);
			if (num < 0)
			{
				return long.MinValue - num;
			}
			return num;
		}

		private static int AsDirectionalInt32(float value)
		{
			int num = SingleToInt32Bits(value);
			if (num < 0)
			{
				return int.MinValue - num;
			}
			return num;
		}

		public static double Increment(this double value, int count = 1)
		{
			if (double.IsInfinity(value) || double.IsNaN(value) || count == 0)
			{
				return value;
			}
			if (count < 0)
			{
				return value.Decrement(-count);
			}
			long num = BitConverter.DoubleToInt64Bits(value);
			num = ((num >= 0) ? (num + count) : (num - count));
			if (num == long.MinValue)
			{
				return 0.0;
			}
			return BitConverter.Int64BitsToDouble(num);
		}

		public static double Decrement(this double value, int count = 1)
		{
			if (double.IsInfinity(value) || double.IsNaN(value) || count == 0)
			{
				return value;
			}
			if (count < 0)
			{
				return value.Decrement(-count);
			}
			long num = BitConverter.DoubleToInt64Bits(value);
			if (num == 0L)
			{
				num = long.MinValue;
			}
			num = ((num >= 0) ? (num - count) : (num + count));
			return BitConverter.Int64BitsToDouble(num);
		}

		public static double CoerceZero(this double a, int maxNumbersBetween)
		{
			return a.CoerceZero((long)maxNumbersBetween);
		}

		public static double CoerceZero(this double a, long maxNumbersBetween)
		{
			if (maxNumbersBetween < 0)
			{
				throw new ArgumentOutOfRangeException("maxNumbersBetween");
			}
			if (double.IsInfinity(a) || double.IsNaN(a))
			{
				return a;
			}
			if (0.0.NumbersBetween(a) <= (ulong)maxNumbersBetween)
			{
				return 0.0;
			}
			return a;
		}

		public static double CoerceZero(this double a, double maximumAbsoluteError)
		{
			if (maximumAbsoluteError < 0.0)
			{
				throw new ArgumentOutOfRangeException("maximumAbsoluteError");
			}
			if (double.IsInfinity(a) || double.IsNaN(a))
			{
				return a;
			}
			if (Math.Abs(a) < maximumAbsoluteError)
			{
				return 0.0;
			}
			return a;
		}

		public static double CoerceZero(this double a)
		{
			return a.CoerceZero(DoublePrecision);
		}

		public static Tuple<double, double> RangeOfMatchingFloatingPointNumbers(this double value, long maxNumbersBetween)
		{
			if (maxNumbersBetween < 1)
			{
				throw new ArgumentOutOfRangeException("maxNumbersBetween");
			}
			if (double.IsInfinity(value))
			{
				return new Tuple<double, double>(value, value);
			}
			if (double.IsNaN(value))
			{
				return new Tuple<double, double>(double.NaN, double.NaN);
			}
			long num = BitConverter.DoubleToInt64Bits(value);
			if (num < 0)
			{
				double item = ((Math.Abs(long.MinValue - num) < maxNumbersBetween) ? BitConverter.Int64BitsToDouble(maxNumbersBetween + (long.MinValue - num)) : BitConverter.Int64BitsToDouble(num - maxNumbersBetween));
				return new Tuple<double, double>((Math.Abs(num) < maxNumbersBetween) ? double.MinValue : BitConverter.Int64BitsToDouble(num + maxNumbersBetween), item);
			}
			double item2 = ((long.MaxValue - num < maxNumbersBetween) ? double.MaxValue : BitConverter.Int64BitsToDouble(num + maxNumbersBetween));
			return new Tuple<double, double>((num > maxNumbersBetween) ? BitConverter.Int64BitsToDouble(num - maxNumbersBetween) : BitConverter.Int64BitsToDouble(long.MinValue + (maxNumbersBetween - num)), item2);
		}

		public static double MaximumMatchingFloatingPointNumber(this double value, long maxNumbersBetween)
		{
			return value.RangeOfMatchingFloatingPointNumbers(maxNumbersBetween).Item2;
		}

		public static double MinimumMatchingFloatingPointNumber(this double value, long maxNumbersBetween)
		{
			return value.RangeOfMatchingFloatingPointNumbers(maxNumbersBetween).Item1;
		}

		public static Tuple<long, long> RangeOfMatchingNumbers(this double value, double relativeDifference)
		{
			if (relativeDifference < 0.0)
			{
				throw new ArgumentOutOfRangeException("relativeDifference");
			}
			if (double.IsInfinity(value))
			{
				throw new ArgumentOutOfRangeException("value");
			}
			if (double.IsNaN(value))
			{
				throw new ArgumentOutOfRangeException("value");
			}
			if (value.Equals(0.0))
			{
				long num = BitConverter.DoubleToInt64Bits(relativeDifference);
				return new Tuple<long, long>(num, num);
			}
			long num2 = AsDirectionalInt64(value + relativeDifference * Math.Abs(value));
			long num3 = AsDirectionalInt64(value - relativeDifference * Math.Abs(value));
			long num4 = AsDirectionalInt64(value);
			return new Tuple<long, long>(Math.Abs(num4 - num3), Math.Abs(num2 - num4));
		}

		[CLSCompliant(false)]
		public static ulong NumbersBetween(this double a, double b)
		{
			if (double.IsNaN(a) || double.IsInfinity(a))
			{
				throw new ArgumentOutOfRangeException("a");
			}
			if (double.IsNaN(b) || double.IsInfinity(b))
			{
				throw new ArgumentOutOfRangeException("b");
			}
			long num = AsDirectionalInt64(a);
			long num2 = AsDirectionalInt64(b);
			if (!(a >= b))
			{
				return (ulong)(num2 - num);
			}
			return (ulong)(num - num2);
		}

		public static double EpsilonOf(this double value)
		{
			if (double.IsInfinity(value) || double.IsNaN(value))
			{
				return double.NaN;
			}
			long num = BitConverter.DoubleToInt64Bits(value);
			if (num == 0L)
			{
				num++;
				return BitConverter.Int64BitsToDouble(num) - value;
			}
			if (num-- < 0)
			{
				return BitConverter.Int64BitsToDouble(num) - value;
			}
			return value - BitConverter.Int64BitsToDouble(num);
		}

		public static float EpsilonOf(this float value)
		{
			if (float.IsInfinity(value) || float.IsNaN(value))
			{
				return float.NaN;
			}
			int num = SingleToInt32Bits(value);
			if (num == 0)
			{
				num++;
				return Int32BitsToSingle(num) - value;
			}
			if (num-- < 0)
			{
				return Int32BitsToSingle(num) - value;
			}
			return value - Int32BitsToSingle(num);
		}

		public static double PositiveEpsilonOf(this double value)
		{
			return 2.0 * value.EpsilonOf();
		}

		public static float PositiveEpsilonOf(this float value)
		{
			return 2f * value.EpsilonOf();
		}

		private static double MeasureMachineEpsilon()
		{
			double num = 1.0;
			while (1.0 - num / 2.0 < 1.0)
			{
				num /= 2.0;
			}
			return num;
		}

		private static double MeasurePositiveMachineEpsilon()
		{
			double num = 1.0;
			while (1.0 + num / 2.0 > 1.0)
			{
				num /= 2.0;
			}
			return num;
		}

		public static double RoundToMultiple(this double number, double basis)
		{
			return Math.Round(number / basis, MidpointRounding.AwayFromZero) * basis;
		}

		public static float RoundToMultiple(this float number, float basis)
		{
			return (float)((double)number).RoundToMultiple((double)basis);
		}

		public static decimal RoundToMultiple(this decimal number, decimal basis)
		{
			return Math.Round(number / basis, MidpointRounding.AwayFromZero) * basis;
		}

		public static double RoundToPower(this double number, double basis)
		{
			if (!(number < 0.0))
			{
				return Math.Pow(basis, Math.Round(Math.Log(number, basis), MidpointRounding.AwayFromZero));
			}
			return 0.0 - Math.Pow(basis, Math.Round(Math.Log(0.0 - number, basis), MidpointRounding.AwayFromZero));
		}

		public static float RoundToPower(this float number, float basis)
		{
			return (float)((double)number).RoundToPower((double)basis);
		}

		public static double Round(this double number, int digits)
		{
			if (digits < 0)
			{
				return number.RoundToMultiple(Math.Pow(10.0, -digits));
			}
			return Math.Round(number, digits, MidpointRounding.AwayFromZero);
		}

		public static float Round(this float number, int digits)
		{
			return (float)((double)number).Round(digits);
		}

		public static decimal Round(this decimal number, int digits)
		{
			if (digits < 0)
			{
				return number.RoundToMultiple((decimal)Math.Pow(10.0, -digits));
			}
			return Math.Round(number, digits, MidpointRounding.AwayFromZero);
		}

		public static int Round(this int number, int digits)
		{
			if (digits < 0)
			{
				return (int)Round((decimal)number, digits);
			}
			return number;
		}

		[CLSCompliant(false)]
		public static uint Round(this uint number, int digits)
		{
			if (digits < 0)
			{
				return (uint)Round((decimal)number, digits);
			}
			return number;
		}

		public static long Round(this long number, int digits)
		{
			if (digits < 0)
			{
				return (long)Round((decimal)number, digits);
			}
			return number;
		}

		[CLSCompliant(false)]
		public static ulong Round(this ulong number, int digits)
		{
			if (digits < 0)
			{
				return (ulong)Round((decimal)number, digits);
			}
			return number;
		}

		public static short Round(this short number, int digits)
		{
			if (digits < 0)
			{
				return (short)Round((decimal)number, digits);
			}
			return number;
		}

		[CLSCompliant(false)]
		public static ushort Round(this ushort number, int digits)
		{
			if (digits < 0)
			{
				return (ushort)Round((decimal)number, digits);
			}
			return number;
		}

		public static BigInteger Round(this BigInteger number, int digits)
		{
			if (digits >= 0)
			{
				return number;
			}
			BigInteger bigInteger = number / BigInteger.Pow(10, -digits - 1);
			BigInteger bigInteger2 = bigInteger / 10;
			if (bigInteger - bigInteger2 * 10 >= 5L)
			{
				bigInteger2 += (BigInteger)1;
			}
			return bigInteger2 * BigInteger.Pow(10, -digits);
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		private static double Truncate(double value)
		{
			return Math.Truncate(value);
		}

		private static int SingleToInt32Bits(float value)
		{
			SingleIntUnion singleIntUnion = default(SingleIntUnion);
			singleIntUnion.Single = value;
			return singleIntUnion.Int32;
		}

		private static float Int32BitsToSingle(int value)
		{
			SingleIntUnion singleIntUnion = default(SingleIntUnion);
			singleIntUnion.Int32 = value;
			return singleIntUnion.Single;
		}

		public static bool AlmostEqualNorm(this double a, double b, double diff, double maximumAbsoluteError)
		{
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a == b;
			}
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			return Math.Abs(diff) < maximumAbsoluteError;
		}

		public static bool AlmostEqualNorm<T>(this T a, T b, double maximumAbsoluteError) where T : IPrecisionSupport<T>
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), maximumAbsoluteError);
		}

		public static bool AlmostEqualNormRelative(this double a, double b, double diff, double maximumError)
		{
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a == b;
			}
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			if (Math.Abs(a) < DoublePrecision || Math.Abs(b) < DoublePrecision)
			{
				return Math.Abs(diff) < maximumError;
			}
			if ((a == 0.0 && Math.Abs(b) < maximumError) || (b == 0.0 && Math.Abs(a) < maximumError))
			{
				return true;
			}
			return Math.Abs(diff) < maximumError * Math.Max(Math.Abs(a), Math.Abs(b));
		}

		public static bool AlmostEqualNormRelative<T>(this T a, T b, double maximumError) where T : IPrecisionSupport<T>
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), maximumError);
		}

		public static bool AlmostEqual(this double a, double b, double maximumAbsoluteError)
		{
			return a.AlmostEqualNorm(b, a - b, maximumAbsoluteError);
		}

		public static bool AlmostEqual(this float a, float b, double maximumAbsoluteError)
		{
			return AlmostEqualNorm(a, b, a - b, maximumAbsoluteError);
		}

		public static bool AlmostEqual(this Complex a, Complex b, double maximumAbsoluteError)
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), maximumAbsoluteError);
		}

		public static bool AlmostEqual(this Complex32 a, Complex32 b, double maximumAbsoluteError)
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), maximumAbsoluteError);
		}

		public static bool AlmostEqualRelative(this double a, double b, double maximumError)
		{
			return a.AlmostEqualNormRelative(b, a - b, maximumError);
		}

		public static bool AlmostEqualRelative(this float a, float b, double maximumError)
		{
			return AlmostEqualNormRelative(a, b, a - b, maximumError);
		}

		public static bool AlmostEqualRelative(this Complex a, Complex b, double maximumError)
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), maximumError);
		}

		public static bool AlmostEqualRelative(this Complex32 a, Complex32 b, double maximumError)
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), maximumError);
		}

		public static bool AlmostEqual(this double a, double b)
		{
			return a.AlmostEqualNorm(b, a - b, DefaultDoubleAccuracy);
		}

		public static bool AlmostEqual(this float a, float b)
		{
			return AlmostEqualNorm(a, b, a - b, DefaultSingleAccuracy);
		}

		public static bool AlmostEqual(this Complex a, Complex b)
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), DefaultDoubleAccuracy);
		}

		public static bool AlmostEqual(this Complex32 a, Complex32 b)
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), DefaultSingleAccuracy);
		}

		public static bool AlmostEqualRelative(this double a, double b)
		{
			return a.AlmostEqualNormRelative(b, a - b, DefaultDoubleAccuracy);
		}

		public static bool AlmostEqualRelative(this float a, float b)
		{
			return AlmostEqualNormRelative(a, b, a - b, DefaultSingleAccuracy);
		}

		public static bool AlmostEqualRelative(this Complex a, Complex b)
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), DefaultDoubleAccuracy);
		}

		public static bool AlmostEqualRelative(this Complex32 a, Complex32 b)
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), DefaultSingleAccuracy);
		}

		public static bool AlmostEqualNorm(this double a, double b, double diff, int decimalPlaces)
		{
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a == b;
			}
			return Math.Abs(diff) < Math.Pow(10.0, -decimalPlaces) / 2.0;
		}

		public static bool AlmostEqualNorm<T>(this T a, T b, int decimalPlaces) where T : IPrecisionSupport<T>
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), decimalPlaces);
		}

		public static bool AlmostEqualNormRelative(this double a, double b, double diff, int decimalPlaces)
		{
			if (decimalPlaces < 0)
			{
				throw new ArgumentOutOfRangeException("decimalPlaces");
			}
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a == b;
			}
			if (a.Equals(b))
			{
				return true;
			}
			if (Math.Abs(a) < DoublePrecision || Math.Abs(b) < DoublePrecision)
			{
				return Math.Abs(diff) < Math.Pow(10.0, -decimalPlaces) / 2.0;
			}
			int val = a.Magnitude();
			int val2 = b.Magnitude();
			int num = Math.Max(val, val2);
			if (num > Math.Min(val, val2) + 1)
			{
				return false;
			}
			return Math.Abs(diff) < Math.Pow(10.0, num - decimalPlaces) / 2.0;
		}

		public static bool AlmostEqualNormRelative<T>(this T a, T b, int decimalPlaces) where T : IPrecisionSupport<T>
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), decimalPlaces);
		}

		public static bool AlmostEqual(this double a, double b, int decimalPlaces)
		{
			return a.AlmostEqualNorm(b, a - b, decimalPlaces);
		}

		public static bool AlmostEqual(this float a, float b, int decimalPlaces)
		{
			return AlmostEqualNorm(a, b, a - b, decimalPlaces);
		}

		public static bool AlmostEqual(this Complex a, Complex b, int decimalPlaces)
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), decimalPlaces);
		}

		public static bool AlmostEqual(this Complex32 a, Complex32 b, int decimalPlaces)
		{
			return a.Norm().AlmostEqualNorm(b.Norm(), a.NormOfDifference(b), decimalPlaces);
		}

		public static bool AlmostEqualRelative(this double a, double b, int decimalPlaces)
		{
			return a.AlmostEqualNormRelative(b, a - b, decimalPlaces);
		}

		public static bool AlmostEqualRelative(this float a, float b, int decimalPlaces)
		{
			return AlmostEqualNormRelative(a, b, a - b, decimalPlaces);
		}

		public static bool AlmostEqualRelative(this Complex a, Complex b, int decimalPlaces)
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), decimalPlaces);
		}

		public static bool AlmostEqualRelative(this Complex32 a, Complex32 b, int decimalPlaces)
		{
			return a.Norm().AlmostEqualNormRelative(b.Norm(), a.NormOfDifference(b), decimalPlaces);
		}

		public static bool AlmostEqualNumbersBetween(this double a, double b, long maxNumbersBetween)
		{
			if (maxNumbersBetween < 1)
			{
				throw new ArgumentOutOfRangeException("maxNumbersBetween");
			}
			if (double.IsInfinity(a) || double.IsInfinity(b))
			{
				return a == b;
			}
			if (double.IsNaN(a) || double.IsNaN(b))
			{
				return false;
			}
			long num = AsDirectionalInt64(a);
			long num2 = AsDirectionalInt64(b);
			if (!(a > b))
			{
				return num + maxNumbersBetween >= num2;
			}
			return num2 + maxNumbersBetween >= num;
		}

		public static bool AlmostEqualNumbersBetween(this float a, float b, int maxNumbersBetween)
		{
			if (maxNumbersBetween < 1)
			{
				throw new ArgumentOutOfRangeException("maxNumbersBetween");
			}
			if (float.IsInfinity(a) || float.IsInfinity(b))
			{
				return a == b;
			}
			if (float.IsNaN(a) || float.IsNaN(b))
			{
				return false;
			}
			int num = AsDirectionalInt32(a);
			int num2 = AsDirectionalInt32(b);
			if (!(a > b))
			{
				return num + maxNumbersBetween >= num2;
			}
			return num2 + maxNumbersBetween >= num;
		}

		public static bool ListAlmostEqual(this IList<double> a, IList<double> b, double maximumAbsoluteError)
		{
			return ListForAll(a, b, AlmostEqual, maximumAbsoluteError);
		}

		public static bool ListAlmostEqual(this IList<float> a, IList<float> b, double maximumAbsoluteError)
		{
			return ListForAll(a, b, AlmostEqual, maximumAbsoluteError);
		}

		public static bool ListAlmostEqual(this IList<Complex> a, IList<Complex> b, double maximumAbsoluteError)
		{
			return ListForAll(a, b, AlmostEqual, maximumAbsoluteError);
		}

		public static bool ListAlmostEqual(this IList<Complex32> a, IList<Complex32> b, double maximumAbsoluteError)
		{
			return ListForAll(a, b, AlmostEqual, maximumAbsoluteError);
		}

		public static bool ListAlmostEqualRelative(this IList<double> a, IList<double> b, double maximumError)
		{
			return ListForAll(a, b, AlmostEqualRelative, maximumError);
		}

		public static bool ListAlmostEqualRelative(this IList<float> a, IList<float> b, double maximumError)
		{
			return ListForAll(a, b, AlmostEqualRelative, maximumError);
		}

		public static bool ListAlmostEqualRelative(this IList<Complex> a, IList<Complex> b, double maximumError)
		{
			return ListForAll(a, b, AlmostEqualRelative, maximumError);
		}

		public static bool ListAlmostEqualRelative(this IList<Complex32> a, IList<Complex32> b, double maximumError)
		{
			return ListForAll(a, b, AlmostEqualRelative, maximumError);
		}

		public static bool ListAlmostEqual(this IList<double> a, IList<double> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqual, decimalPlaces);
		}

		public static bool ListAlmostEqual(this IList<float> a, IList<float> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqual, decimalPlaces);
		}

		public static bool ListAlmostEqual(this IList<Complex> a, IList<Complex> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqual, decimalPlaces);
		}

		public static bool ListAlmostEqual(this IList<Complex32> a, IList<Complex32> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqual, decimalPlaces);
		}

		public static bool ListAlmostEqualRelative(this IList<double> a, IList<double> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqualRelative, decimalPlaces);
		}

		public static bool ListAlmostEqualRelative(this IList<float> a, IList<float> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqualRelative, decimalPlaces);
		}

		public static bool ListAlmostEqualRelative(this IList<Complex> a, IList<Complex> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqualRelative, decimalPlaces);
		}

		public static bool ListAlmostEqualRelative(this IList<Complex32> a, IList<Complex32> b, int decimalPlaces)
		{
			return ListForAll(a, b, AlmostEqualRelative, decimalPlaces);
		}

		public static bool ListAlmostEqualNorm<T>(this IList<T> a, IList<T> b, double maximumAbsoluteError) where T : IPrecisionSupport<T>
		{
			if (a == null && b == null)
			{
				return true;
			}
			if (a == null || b == null || a.Count != b.Count)
			{
				return false;
			}
			for (int i = 0; i < a.Count; i++)
			{
				if (!a[i].AlmostEqualNorm(b[i], maximumAbsoluteError))
				{
					return false;
				}
			}
			return true;
		}

		public static bool ListAlmostEqualNormRelative<T>(this IList<T> a, IList<T> b, double maximumError) where T : IPrecisionSupport<T>
		{
			if (a == null && b == null)
			{
				return true;
			}
			if (a == null || b == null || a.Count != b.Count)
			{
				return false;
			}
			for (int i = 0; i < a.Count; i++)
			{
				if (!a[i].AlmostEqualNormRelative(b[i], maximumError))
				{
					return false;
				}
			}
			return true;
		}

		private static bool ListForAll<T, TP>(IList<T> a, IList<T> b, Func<T, T, TP, bool> predicate, TP parameter)
		{
			if (a == null && b == null)
			{
				return true;
			}
			if (a == null || b == null || a.Count != b.Count)
			{
				return false;
			}
			for (int i = 0; i < a.Count; i++)
			{
				if (!predicate(a[i], b[i], parameter))
				{
					return false;
				}
			}
			return true;
		}

		public static bool AlmostEqual<T>(this Vector<T> a, Vector<T> b, double maximumAbsoluteError) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNorm(b.L2Norm(), (a - b).L2Norm(), maximumAbsoluteError);
		}

		public static bool AlmostEqualRelative<T>(this Vector<T> a, Vector<T> b, double maximumError) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNormRelative(b.L2Norm(), (a - b).L2Norm(), maximumError);
		}

		public static bool AlmostEqual<T>(this Vector<T> a, Vector<T> b, int decimalPlaces) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNorm(b.L2Norm(), (a - b).L2Norm(), decimalPlaces);
		}

		public static bool AlmostEqualRelative<T>(this Vector<T> a, Vector<T> b, int decimalPlaces) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNormRelative(b.L2Norm(), (a - b).L2Norm(), decimalPlaces);
		}

		public static bool AlmostEqual<T>(this Matrix<T> a, Matrix<T> b, double maximumAbsoluteError) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNorm(b.L2Norm(), (a - b).L2Norm(), maximumAbsoluteError);
		}

		public static bool AlmostEqualRelative<T>(this Matrix<T> a, Matrix<T> b, double maximumError) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNormRelative(b.L2Norm(), (a - b).L2Norm(), maximumError);
		}

		public static bool AlmostEqual<T>(this Matrix<T> a, Matrix<T> b, int decimalPlaces) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNorm(b.L2Norm(), (a - b).L2Norm(), decimalPlaces);
		}

		public static bool AlmostEqualRelative<T>(this Matrix<T> a, Matrix<T> b, int decimalPlaces) where T : struct, IEquatable<T>, IFormattable
		{
			return a.L2Norm().AlmostEqualNormRelative(b.L2Norm(), (a - b).L2Norm(), decimalPlaces);
		}
	}
	public interface IPrecisionSupport<in T>
	{
		double Norm();

		double NormOfDifference(T otherValue);
	}
	public static class Sorting
	{
		public static void Sort<T>(IList<T> keys, IComparer<T> comparer = null)
		{
			int count = keys.Count;
			if (count <= 1)
			{
				return;
			}
			if (comparer == null)
			{
				comparer = Comparer<T>.Default;
			}
			if (count == 2)
			{
				if (comparer.Compare(keys[0], keys[1]) > 0)
				{
					Swap(keys, 0, 1);
				}
			}
			else if (count <= 10)
			{
				for (int i = 1; i < count; i++)
				{
					T val = keys[i];
					int num = i - 1;
					while (num >= 0 && comparer.Compare(keys[num], val) > 0)
					{
						keys[num + 1] = keys[num];
						num--;
					}
					keys[num + 1] = val;
				}
			}
			else if (keys is T[] array)
			{
				Array.Sort(array, comparer);
			}
			else if (keys is List<T> list)
			{
				list.Sort(comparer);
			}
			else
			{
				QuickSort(keys, comparer, 0, count - 1);
			}
		}

		public static void Sort<TKey, TItem>(IList<TKey> keys, IList<TItem> items, IComparer<TKey> comparer = null)
		{
			int count = keys.Count;
			if (count <= 1)
			{
				return;
			}
			if (comparer == null)
			{
				comparer = Comparer<TKey>.Default;
			}
			if (count == 2)
			{
				if (comparer.Compare(keys[0], keys[1]) > 0)
				{
					Swap(keys, 0, 1);
					Swap(items, 0, 1);
				}
			}
			else if (count <= 10)
			{
				for (int i = 1; i < count; i++)
				{
					TKey val = keys[i];
					TItem value = items[i];
					int num = i - 1;
					while (num >= 0 && comparer.Compare(keys[num], val) > 0)
					{
						keys[num + 1] = keys[num];
						items[num + 1] = items[num];
						num--;
					}
					keys[num + 1] = val;
					items[num + 1] = value;
				}
			}
			else if (keys is TKey[] keys2 && items is TItem[] items2)
			{
				Array.Sort(keys2, items2, comparer);
			}
			else
			{
				QuickSort(keys, items, comparer, 0, count - 1);
			}
		}

		public static void Sort<TKey, TItem1, TItem2>(IList<TKey> keys, IList<TItem1> items1, IList<TItem2> items2, IComparer<TKey> comparer = null)
		{
			int count = keys.Count;
			if (count <= 1)
			{
				return;
			}
			if (comparer == null)
			{
				comparer = Comparer<TKey>.Default;
			}
			if (count == 2)
			{
				if (comparer.Compare(keys[0], keys[1]) > 0)
				{
					Swap(keys, 0, 1);
					Swap(items1, 0, 1);
					Swap(items2, 0, 1);
				}
			}
			else if (count <= 10)
			{
				for (int i = 1; i < count; i++)
				{
					TKey val = keys[i];
					TItem1 value = items1[i];
					TItem2 value2 = items2[i];
					int num = i - 1;
					while (num >= 0 && comparer.Compare(keys[num], val) > 0)
					{
						keys[num + 1] = keys[num];
						items1[num + 1] = items1[num];
						items2[num + 1] = items2[num];
						num--;
					}
					keys[num + 1] = val;
					items1[num + 1] = value;
					items2[num + 1] = value2;
				}
			}
			else
			{
				QuickSort(keys, items1, items2, comparer, 0, count - 1);
			}
		}

		public static void Sort<T>(IList<T> keys, int index, int count, IComparer<T> comparer = null)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0 || index + count > keys.Count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count <= 1)
			{
				return;
			}
			if (comparer == null)
			{
				comparer = Comparer<T>.Default;
			}
			if (count == 2)
			{
				if (comparer.Compare(keys[index], keys[index + 1]) > 0)
				{
					Swap(keys, index, index + 1);
				}
			}
			else if (count <= 10)
			{
				int num = index + count;
				for (int i = index + 1; i < num; i++)
				{
					T val = keys[i];
					int num2 = i - 1;
					while (num2 >= index && comparer.Compare(keys[num2], val) > 0)
					{
						keys[num2 + 1] = keys[num2];
						num2--;
					}
					keys[num2 + 1] = val;
				}
			}
			else if (keys is T[] array)
			{
				Array.Sort(array, index, count, comparer);
			}
			else if (keys is List<T> list)
			{
				list.Sort(index, count, comparer);
			}
			else
			{
				QuickSort(keys, comparer, index, count - 1);
			}
		}

		public static void Sort<TKey, TItem>(IList<TKey> keys, IList<TItem> items, int index, int count, IComparer<TKey> comparer = null)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0 || index + count > keys.Count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count <= 1)
			{
				return;
			}
			if (comparer == null)
			{
				comparer = Comparer<TKey>.Default;
			}
			if (count == 2)
			{
				if (comparer.Compare(keys[index], keys[index + 1]) > 0)
				{
					Swap(keys, index, index + 1);
					Swap(items, index, index + 1);
				}
			}
			else if (count <= 10)
			{
				int num = index + count;
				for (int i = index + 1; i < num; i++)
				{
					TKey val = keys[i];
					TItem value = items[i];
					int num2 = i - 1;
					while (num2 >= index && comparer.Compare(keys[num2], val) > 0)
					{
						keys[num2 + 1] = keys[num2];
						items[num2 + 1] = items[num2];
						num2--;
					}
					keys[num2 + 1] = val;
					items[num2 + 1] = value;
				}
			}
			else if (keys is TKey[] keys2 && items is TItem[] items2)
			{
				Array.Sort(keys2, items2, index, count, comparer);
			}
			else
			{
				QuickSort(keys, items, comparer, index, count - 1);
			}
		}

		public static void Sort<TKey, TItem1, TItem2>(IList<TKey> keys, IList<TItem1> items1, IList<TItem2> items2, int index, int count, IComparer<TKey> comparer = null)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0 || index + count > keys.Count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count <= 1)
			{
				return;
			}
			if (comparer == null)
			{
				comparer = Comparer<TKey>.Default;
			}
			if (count == 2)
			{
				if (comparer.Compare(keys[index], keys[index + 1]) > 0)
				{
					Swap(keys, index, index + 1);
					Swap(items1, index, index + 1);
					Swap(items2, index, index + 1);
				}
			}
			else if (count <= 10)
			{
				int num = index + count;
				for (int i = index + 1; i < num; i++)
				{
					TKey val = keys[i];
					TItem1 value = items1[i];
					TItem2 value2 = items2[i];
					int num2 = i - 1;
					while (num2 >= index && comparer.Compare(keys[num2], val) > 0)
					{
						keys[num2 + 1] = keys[num2];
						items1[num2 + 1] = items1[num2];
						items2[num2 + 1] = items2[num2];
						num2--;
					}
					keys[num2 + 1] = val;
					items1[num2 + 1] = value;
					items2[num2 + 1] = value2;
				}
			}
			else
			{
				QuickSort(keys, items1, items2, comparer, index, count - 1);
			}
		}

		public static void SortAll<T1, T2>(IList<T1> primary, IList<T2> secondary, IComparer<T1> primaryComparer = null, IComparer<T2> secondaryComparer = null)
		{
			if (primaryComparer == null)
			{
				primaryComparer = Comparer<T1>.Default;
			}
			if (secondaryComparer == null)
			{
				secondaryComparer = Comparer<T2>.Default;
			}
			QuickSortAll(primary, secondary, primaryComparer, secondaryComparer, 0, primary.Count - 1);
		}

		private static void QuickSort<T>(IList<T> keys, IComparer<T> comparer, int left, int right)
		{
			do
			{
				int num = left;
				int num2 = right;
				int num3 = num + (num2 - num >> 1);
				if (comparer.Compare(keys[num], keys[num3]) > 0)
				{
					Swap(keys, num, num3);
				}
				if (comparer.Compare(keys[num], keys[num2]) > 0)
				{
					Swap(keys, num, num2);
				}
				if (comparer.Compare(keys[num3], keys[num2]) > 0)
				{
					Swap(keys, num3, num2);
				}
				T val = keys[num3];
				while (true)
				{
					if (comparer.Compare(keys[num], val) < 0)
					{
						num++;
						continue;
					}
					while (comparer.Compare(val, keys[num2]) < 0)
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						Swap(keys, num, num2);
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						QuickSort(keys, comparer, left, num2);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						QuickSort(keys, comparer, num, right);
					}
					right = num2;
				}
			}
			while (left < right);
		}

		private static void QuickSort<T, TItems>(IList<T> keys, IList<TItems> items, IComparer<T> comparer, int left, int right)
		{
			do
			{
				int num = left;
				int num2 = right;
				int num3 = num + (num2 - num >> 1);
				if (comparer.Compare(keys[num], keys[num3]) > 0)
				{
					Swap(keys, num, num3);
					Swap(items, num, num3);
				}
				if (comparer.Compare(keys[num], keys[num2]) > 0)
				{
					Swap(keys, num, num2);
					Swap(items, num, num2);
				}
				if (comparer.Compare(keys[num3], keys[num2]) > 0)
				{
					Swap(keys, num3, num2);
					Swap(items, num3, num2);
				}
				T val = keys[num3];
				while (true)
				{
					if (comparer.Compare(keys[num], val) < 0)
					{
						num++;
						continue;
					}
					while (comparer.Compare(val, keys[num2]) < 0)
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						Swap(keys, num, num2);
						Swap(items, num, num2);
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						QuickSort(keys, items, comparer, left, num2);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						QuickSort(keys, items, comparer, num, right);
					}
					right = num2;
				}
			}
			while (left < right);
		}

		private static void QuickSort<T, TItems1, TItems2>(IList<T> keys, IList<TItems1> items1, IList<TItems2> items2, IComparer<T> comparer, int left, int right)
		{
			do
			{
				int num = left;
				int num2 = right;
				int num3 = num + (num2 - num >> 1);
				if (comparer.Compare(keys[num], keys[num3]) > 0)
				{
					Swap(keys, num, num3);
					Swap(items1, num, num3);
					Swap(items2, num, num3);
				}
				if (comparer.Compare(keys[num], keys[num2]) > 0)
				{
					Swap(keys, num, num2);
					Swap(items1, num, num2);
					Swap(items2, num, num2);
				}
				if (comparer.Compare(keys[num3], keys[num2]) > 0)
				{
					Swap(keys, num3, num2);
					Swap(items1, num3, num2);
					Swap(items2, num3, num2);
				}
				T val = keys[num3];
				while (true)
				{
					if (comparer.Compare(keys[num], val) < 0)
					{
						num++;
						continue;
					}
					while (comparer.Compare(val, keys[num2]) < 0)
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						Swap(keys, num, num2);
						Swap(items1, num, num2);
						Swap(items2, num, num2);
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						QuickSort(keys, items1, items2, comparer, left, num2);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						QuickSort(keys, items1, items2, comparer, num, right);
					}
					right = num2;
				}
			}
			while (left < right);
		}

		private static void QuickSortAll<T1, T2>(IList<T1> primary, IList<T2> secondary, IComparer<T1> primaryComparer, IComparer<T2> secondaryComparer, int left, int right)
		{
			do
			{
				int num = left;
				int num2 = right;
				int num3 = num + (num2 - num >> 1);
				int num4 = primaryComparer.Compare(primary[num], primary[num3]);
				if (num4 > 0 || (num4 == 0 && secondaryComparer.Compare(secondary[num], secondary[num3]) > 0))
				{
					Swap(primary, num, num3);
					Swap(secondary, num, num3);
				}
				int num5 = primaryComparer.Compare(primary[num], primary[num2]);
				if (num5 > 0 || (num5 == 0 && secondaryComparer.Compare(secondary[num], secondary[num2]) > 0))
				{
					Swap(primary, num, num2);
					Swap(secondary, num, num2);
				}
				int num6 = primaryComparer.Compare(primary[num3], primary[num2]);
				if (num6 > 0 || (num6 == 0 && secondaryComparer.Compare(secondary[num3], secondary[num2]) > 0))
				{
					Swap(primary, num3, num2);
					Swap(secondary, num3, num2);
				}
				T1 val = primary[num3];
				T2 val2 = secondary[num3];
				while (true)
				{
					int num7;
					if ((num7 = primaryComparer.Compare(primary[num], val)) < 0 || (num7 == 0 && secondaryComparer.Compare(secondary[num], val2) < 0))
					{
						num++;
						continue;
					}
					int num8;
					while ((num8 = primaryComparer.Compare(val, primary[num2])) < 0 || (num8 == 0 && secondaryComparer.Compare(val2, secondary[num2]) < 0))
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						Swap(primary, num, num2);
						Swap(secondary, num, num2);
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						QuickSortAll(primary, secondary, primaryComparer, secondaryComparer, left, num2);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						QuickSortAll(primary, secondary, primaryComparer, secondaryComparer, num, right);
					}
					right = num2;
				}
			}
			while (left < right);
		}

		private static void Swap<T>(IList<T> keys, int a, int b)
		{
			if (a != b)
			{
				T value = keys[a];
				keys[a] = keys[b];
				keys[b] = value;
			}
		}
	}
	public static class SpecialFunctions
	{
		private static class Amos
		{
			public static Complex Cairy(Complex z)
			{
				int id = 0;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double air = double.NaN;
				double aii = double.NaN;
				AmosHelper.zairy(z.Real, z.Imaginary, id, kode, ref air, ref aii, ref nz, ref ierr);
				return new Complex(air, aii);
			}

			public static Complex ScaledCairy(Complex z)
			{
				int id = 0;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double air = double.NaN;
				double aii = double.NaN;
				AmosHelper.zairy(z.Real, z.Imaginary, id, kode, ref air, ref aii, ref nz, ref ierr);
				return new Complex(air, aii);
			}

			public static double ScaledCairy(double z)
			{
				if (z < 0.0)
				{
					return double.NaN;
				}
				int id = 0;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double air = double.NaN;
				double aii = double.NaN;
				AmosHelper.zairy(z, 0.0, id, kode, ref air, ref aii, ref nz, ref ierr);
				return air;
			}

			public static Complex CairyPrime(Complex z)
			{
				int id = 1;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double air = double.NaN;
				double aii = double.NaN;
				AmosHelper.zairy(z.Real, z.Imaginary, id, kode, ref air, ref aii, ref nz, ref ierr);
				return new Complex(air, aii);
			}

			public static Complex ScaledCairyPrime(Complex z)
			{
				int id = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double air = double.NaN;
				double aii = double.NaN;
				AmosHelper.zairy(z.Real, z.Imaginary, id, kode, ref air, ref aii, ref nz, ref ierr);
				return new Complex(air, aii);
			}

			public static double ScaledCairyPrime(double z)
			{
				if (z < 0.0)
				{
					return double.NaN;
				}
				int id = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double air = double.NaN;
				double aii = double.NaN;
				AmosHelper.zairy(z, 0.0, id, kode, ref air, ref aii, ref nz, ref ierr);
				return air;
			}

			public static Complex Cbiry(Complex z)
			{
				int id = 0;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double bir = double.NaN;
				double bii = double.NaN;
				AmosHelper.zbiry(z.Real, z.Imaginary, id, kode, ref bir, ref bii, ref nz, ref ierr);
				return new Complex(bir, bii);
			}

			public static Complex ScaledCbiry(Complex z)
			{
				int id = 0;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double bir = double.NaN;
				double bii = double.NaN;
				AmosHelper.zbiry(z.Real, z.Imaginary, id, kode, ref bir, ref bii, ref nz, ref ierr);
				return new Complex(bir, bii);
			}

			public static Complex CbiryPrime(Complex z)
			{
				int id = 1;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double bir = double.NaN;
				double bii = double.NaN;
				AmosHelper.zbiry(z.Real, z.Imaginary, id, kode, ref bir, ref bii, ref nz, ref ierr);
				return new Complex(bir, bii);
			}

			public static Complex ScaledCbiryPrime(Complex z)
			{
				int id = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double bir = double.NaN;
				double bii = double.NaN;
				AmosHelper.zbiry(z.Real, z.Imaginary, id, kode, ref bir, ref bii, ref nz, ref ierr);
				return new Complex(bir, bii);
			}

			public static Complex Cbesj(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num = -1;
				}
				int num2 = 1;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num2];
				double[] array2 = new double[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				AmosHelper.zbesj(z.Real, z.Imaginary, v, kode, num2, array, array2, ref nz, ref ierr);
				Complex jy = new Complex(array[0], array2[0]);
				if (ierr == 2)
				{
					jy = ScaledCbesj(v, z);
					jy = new Complex(jy.Real * double.PositiveInfinity, jy.Imaginary * double.PositiveInfinity);
				}
				if (num == -1 && !ReflectJY(ref jy, v))
				{
					double[] array3 = new double[num2];
					double[] array4 = new double[num2];
					double[] array5 = new double[num2];
					double[] array6 = new double[num2];
					for (int j = 0; j < num2; j++)
					{
						array3[j] = double.NaN;
						array4[j] = double.NaN;
						array5[j] = double.NaN;
						array6[j] = double.NaN;
					}
					AmosHelper.zbesy(z.Real, z.Imaginary, v, kode, num2, array3, array4, ref nz, array5, array6, ref ierr);
					jy = RotateJY(y: new Complex(array3[0], array4[0]), j: jy, v: v);
				}
				return jy;
			}

			public static double Cbesj(double v, double z)
			{
				if (z < 0.0 && v != (double)(int)v)
				{
					return double.NaN;
				}
				return Cbesj(v, new Complex(z, 0.0)).Real;
			}

			public static Complex ScaledCbesj(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num = -1;
				}
				int num2 = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num2];
				double[] array2 = new double[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				AmosHelper.zbesj(z.Real, z.Imaginary, v, kode, num2, array, array2, ref nz, ref ierr);
				Complex jy = new Complex(array[0], array2[0]);
				if (num == -1 && !ReflectJY(ref jy, v))
				{
					double[] array3 = new double[num2];
					double[] array4 = new double[num2];
					double[] array5 = new double[num2];
					double[] array6 = new double[num2];
					for (int j = 0; j < num2; j++)
					{
						array3[j] = double.NaN;
						array4[j] = double.NaN;
						array5[j] = double.NaN;
						array6[j] = double.NaN;
					}
					AmosHelper.zbesy(z.Real, z.Imaginary, v, kode, num2, array3, array4, ref nz, array5, array6, ref ierr);
					return RotateJY(y: new Complex(array3[0], array4[0]), j: jy, v: v);
				}
				return jy;
			}

			public static double ScaledCbesj(double v, double z)
			{
				if (z < 0.0 && v != (double)(int)v)
				{
					return double.NaN;
				}
				return ScaledCbesj(v, new Complex(z, 0.0)).Real;
			}

			public static Complex Cbesy(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num = -1;
				}
				int num2 = 1;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				Complex jy;
				if (z.Real == 0.0 && z.Imaginary == 0.0)
				{
					jy = new Complex(double.NegativeInfinity, 0.0);
				}
				else
				{
					double[] array = new double[num2];
					double[] array2 = new double[num2];
					double[] array3 = new double[num2];
					double[] array4 = new double[num2];
					for (int i = 0; i < num2; i++)
					{
						array[i] = double.NaN;
						array2[i] = double.NaN;
						array3[i] = double.NaN;
						array4[i] = double.NaN;
					}
					AmosHelper.zbesy(z.Real, z.Imaginary, v, kode, num2, array, array2, ref nz, array3, array4, ref ierr);
					jy = new Complex(array[0], array2[0]);
					if (ierr == 2 && z.Real >= 0.0 && z.Imaginary == 0.0)
					{
						jy = new Complex(double.NegativeInfinity, 0.0);
					}
				}
				if (num == -1 && !ReflectJY(ref jy, v))
				{
					double[] array5 = new double[num2];
					double[] array6 = new double[num2];
					for (int j = 0; j < num2; j++)
					{
						array5[j] = double.NaN;
						array6[j] = double.NaN;
					}
					AmosHelper.zbesj(z.Real, z.Imaginary, v, kode, num2, array5, array6, ref nz, ref ierr);
					return RotateJY(y: new Complex(array5[0], array6[0]), j: jy, v: 0.0 - v);
				}
				return jy;
			}

			public static double Cbesy(double v, double x)
			{
				if (x < 0.0)
				{
					return double.NaN;
				}
				Complex z = new Complex(x, 0.0);
				return Cbesy(v, z).Real;
			}

			public static Complex ScaledCbesy(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num = -1;
				}
				int num2 = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num2];
				double[] array2 = new double[num2];
				double[] array3 = new double[num2];
				double[] array4 = new double[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
					array3[i] = double.NaN;
					array4[i] = double.NaN;
				}
				AmosHelper.zbesy(z.Real, z.Imaginary, v, kode, num2, array, array2, ref nz, array3, array4, ref ierr);
				Complex jy = new Complex(array[0], array2[0]);
				if (ierr == 2 && z.Real >= 0.0 && z.Imaginary == 0.0)
				{
					jy = new Complex(double.PositiveInfinity, 0.0);
				}
				if (num == -1 && !ReflectJY(ref jy, v))
				{
					double[] array5 = new double[num2];
					double[] array6 = new double[num2];
					for (int j = 0; j < num2; j++)
					{
						array5[j] = double.NaN;
						array6[j] = double.NaN;
					}
					AmosHelper.zbesj(z.Real, z.Imaginary, v, kode, num2, array5, array6, ref nz, ref ierr);
					return RotateJY(y: new Complex(array5[0], array6[0]), j: jy, v: 0.0 - v);
				}
				return jy;
			}

			public static double ScaledCbesy(double v, double x)
			{
				if (x < 0.0)
				{
					return double.NaN;
				}
				return ScaledCbesy(v, new Complex(x, 0.0)).Real;
			}

			public static Complex Cbesi(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num = -1;
				}
				int num2 = 1;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num2];
				double[] array2 = new double[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				AmosHelper.zbesi(z.Real, z.Imaginary, v, kode, num2, array, array2, ref nz, ref ierr);
				Complex complex = new Complex(array[0], array2[0]);
				if (ierr == 2)
				{
					if (z.Imaginary == 0.0 && (z.Real >= 0.0 || v == Math.Floor(v)))
					{
						complex = ((!(z.Real < 0.0) || v / 2.0 == Math.Floor(v / 2.0)) ? new Complex(double.PositiveInfinity, 0.0) : new Complex(double.NegativeInfinity, 0.0));
					}
					else
					{
						complex = ScaledCbesi(v * (double)num, z);
						complex = new Complex(complex.Real * double.PositiveInfinity, complex.Imaginary * double.PositiveInfinity);
					}
				}
				if (num == -1 && !ReflectI(complex, v))
				{
					double[] array3 = new double[num2];
					double[] array4 = new double[num2];
					AmosHelper.zbesk(z.Real, z.Imaginary, v, kode, num2, array3, array4, ref nz, ref ierr);
					Complex k = new Complex(array3[0], array4[0]);
					complex = RotateI(complex, k, v);
				}
				return complex;
			}

			public static Complex ScaledCbesi(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num = -1;
				}
				int num2 = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num2];
				double[] array2 = new double[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				AmosHelper.zbesi(z.Real, z.Imaginary, v, kode, num2, array, array2, ref nz, ref ierr);
				Complex complex = new Complex(array[0], array2[0]);
				if (num == -1 && !ReflectI(complex, v))
				{
					double[] array3 = new double[num2];
					double[] array4 = new double[num2];
					AmosHelper.zbesk(z.Real, z.Imaginary, v, kode, num2, array3, array4, ref nz, ref ierr);
					Complex z2 = new Complex(array3[0], array4[0]);
					z2 = Rotate(z2, (0.0 - z.Imaginary) / Math.PI);
					if (z.Real > 0.0)
					{
						z2 = new Complex(z2.Real * Math.Exp(-2.0 * z.Real), z2.Imaginary * Math.Exp(-2.0 * z.Real));
					}
					return RotateI(complex, z2, v);
				}
				return complex;
			}

			public static double ScaledCbesi(double v, double x)
			{
				if (v != Math.Floor(v) && x < 0.0)
				{
					return double.NaN;
				}
				return ScaledCbesi(v, new Complex(x, 0.0)).Real;
			}

			public static Complex Cbesk(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (v < 0.0)
				{
					v = 0.0 - v;
				}
				int num = 1;
				int kode = 1;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num];
				double[] array2 = new double[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				AmosHelper.zbesk(z.Real, z.Imaginary, v, kode, num, array, array2, ref nz, ref ierr);
				Complex result = new Complex(array[0], array2[0]);
				switch (ierr)
				{
				case 1:
					if (z.Real == 0.0 && z.Imaginary == 0.0)
					{
						result = new Complex(double.PositiveInfinity, 0.0);
					}
					break;
				case 2:
					if (z.Real >= 0.0 && z.Imaginary == 0.0)
					{
						result = new Complex(double.PositiveInfinity, 0.0);
					}
					break;
				}
				return result;
			}

			public static double Cbesk(double v, double z)
			{
				if (z < 0.0)
				{
					return double.NaN;
				}
				if (z == 0.0)
				{
					return double.PositiveInfinity;
				}
				if (z > 710.0 * (1.0 + Math.Abs(v)))
				{
					return 0.0;
				}
				Complex z2 = new Complex(z, 0.0);
				return Cbesk(v, z2).Real;
			}

			public static Complex ScaledCbesk(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (v < 0.0)
				{
					v = 0.0 - v;
				}
				int num = 1;
				int kode = 2;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num];
				double[] array2 = new double[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				AmosHelper.zbesk(z.Real, z.Imaginary, v, kode, num, array, array2, ref nz, ref ierr);
				Complex result = new Complex(array[0], array2[0]);
				if (ierr == 2 && z.Real >= 0.0 && z.Imaginary == 0.0)
				{
					result = new Complex(double.PositiveInfinity, 0.0);
				}
				return result;
			}

			public static double ScaledCbesk(double v, double z)
			{
				if (z < 0.0)
				{
					return double.NaN;
				}
				if (z == 0.0)
				{
					return double.PositiveInfinity;
				}
				Complex z2 = new Complex(z, 0.0);
				return ScaledCbesk(v, z2).Real;
			}

			public static Complex Cbesh1(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				int kode = 1;
				int m = 1;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num];
				double[] array2 = new double[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				int num2 = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num2 = -1;
				}
				AmosHelper.zbesh(z.Real, z.Imaginary, v, kode, m, num, array, array2, ref nz, ref ierr);
				Complex complex = new Complex(array[0], array2[0]);
				if (num2 == -1)
				{
					return Rotate(complex, v);
				}
				return complex;
			}

			public static Complex ScaledCbesh1(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				int kode = 2;
				int m = 1;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num];
				double[] array2 = new double[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				int num2 = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num2 = -1;
				}
				AmosHelper.zbesh(z.Real, z.Imaginary, v, kode, m, num, array, array2, ref nz, ref ierr);
				Complex complex = new Complex(array[0], array2[0]);
				if (num2 == -1)
				{
					return Rotate(complex, v);
				}
				return complex;
			}

			public static Complex Cbesh2(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (v == 0.0 && z.Real == 0.0 && z.Imaginary == 0.0)
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				int kode = 1;
				int m = 2;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num];
				double[] array2 = new double[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				int num2 = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num2 = -1;
				}
				AmosHelper.zbesh(z.Real, z.Imaginary, v, kode, m, num, array, array2, ref nz, ref ierr);
				Complex complex = new Complex(array[0], array2[0]);
				if (num2 == -1)
				{
					return Rotate(complex, 0.0 - v);
				}
				return complex;
			}

			public static Complex ScaledCbesh2(double v, Complex z)
			{
				if (double.IsNaN(v) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (v == 0.0 && z.Real == 0.0 && z.Imaginary == 0.0)
				{
					return new Complex(double.NaN, double.NaN);
				}
				int num = 1;
				int kode = 2;
				int m = 2;
				int nz = 0;
				int ierr = 0;
				double[] array = new double[num];
				double[] array2 = new double[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = double.NaN;
					array2[i] = double.NaN;
				}
				int num2 = 1;
				if (v < 0.0)
				{
					v = 0.0 - v;
					num2 = -1;
				}
				AmosHelper.zbesh(z.Real, z.Imaginary, v, kode, m, num, array, array2, ref nz, ref ierr);
				Complex complex = new Complex(array[0], array2[0]);
				if (num2 == -1)
				{
					return Rotate(complex, 0.0 - v);
				}
				return complex;
			}

			private static double SinPi(double x)
			{
				if (Math.Floor(x) == x && Math.Abs(x) < 100000000000000.0)
				{
					return 0.0;
				}
				return Math.Sin(Math.PI * x);
			}

			private static double CosPi(double x)
			{
				if (Math.Floor(x + 0.5) == x + 0.5 && Math.Abs(x) < 100000000000000.0)
				{
					return 0.0;
				}
				return Math.Cos(Math.PI * x);
			}

			private static Complex Rotate(Complex z, double v)
			{
				double num = CosPi(v);
				double num2 = SinPi(v);
				return new Complex(z.Real * num - z.Imaginary * num2, z.Real * num2 + z.Imaginary * num);
			}

			private static Complex RotateJY(Complex j, Complex y, double v)
			{
				double num = CosPi(v);
				double num2 = SinPi(v);
				return new Complex(j.Real * num - y.Real * num2, j.Imaginary * num - y.Imaginary * num2);
			}

			private static bool ReflectJY(ref Complex jy, double v)
			{
				if (v != Math.Floor(v))
				{
					return false;
				}
				if ((int)(v - 16384.0 * Math.Floor(v / 16384.0)) % 2 == 1)
				{
					jy = new Complex(0.0 - jy.Real, 0.0 - jy.Imaginary);
				}
				return true;
			}

			private static bool ReflectI(Complex ik, double v)
			{
				if (v != Math.Floor(v))
				{
					return false;
				}
				return true;
			}

			private static Complex RotateI(Complex i, Complex k, double v)
			{
				double num = Math.Sin(v * Math.PI) * (2.0 / Math.PI);
				return new Complex(i.Real + num * k.Real, i.Imaginary + num * k.Imaginary);
			}
		}

		private static class AmosHelper
		{
			public static int zairy(double zr, double zi, int id, int kode, ref double air, ref double aii, ref int nz, ref int ierr)
			{
				double bi = 0.0;
				double br = 0.0;
				double bi2 = 0.0;
				double br2 = 0.0;
				int nz2 = 0;
				double[] array = new double[1];
				double[] array2 = new double[1];
				air = 0.0;
				aii = 0.0;
				ierr = 0;
				nz = 0;
				if (id < 0 || id > 1)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				double num = zabs(zr, zi);
				double num2 = Math.Max(d1mach(4), 1E-18);
				double num3 = id;
				int i;
				double num8;
				if (!(num > 1.0))
				{
					double num4 = 1.0;
					double num5 = 0.0;
					double num6 = 1.0;
					double num7 = 0.0;
					if (!(num < num2))
					{
						num8 = num * num;
						if (!(num8 < num2 / num))
						{
							double num9 = 1.0;
							double num10 = 0.0;
							double num11 = 1.0;
							double num12 = 0.0;
							double num13 = 1.0;
							br2 = zr * zr - zi * zi;
							bi2 = zr * zi + zi * zr;
							double num14 = br2 * zr - bi2 * zi;
							double num15 = br2 * zi + bi2 * zr;
							double num16 = num * num8;
							double num17 = 2.0 + num3;
							double num18 = 3.0 - num3 - num3;
							double num19 = 4.0 - num3;
							double num20 = 3.0 + num3 + num3;
							double num21 = num17 * num20;
							double num22 = num18 * num19;
							double num23 = Math.Min(num21, num22);
							num17 = 24.0 + 9.0 * num3;
							num18 = 30.0 - 9.0 * num3;
							for (i = 1; i <= 25; i++)
							{
								br2 = (num9 * num14 - num10 * num15) / num21;
								num10 = (num9 * num15 + num10 * num14) / num21;
								num9 = br2;
								num4 += num9;
								num5 += num10;
								br2 = (num11 * num14 - num12 * num15) / num22;
								num12 = (num11 * num15 + num12 * num14) / num22;
								num11 = br2;
								num6 += num11;
								num7 += num12;
								num13 = num13 * num16 / num23;
								num21 += num17;
								num22 += num18;
								num23 = Math.Min(num21, num22);
								if (num13 < num2 * num23)
								{
									break;
								}
								num17 += 18.0;
								num18 += 18.0;
							}
						}
						double ar;
						double ai;
						double num24;
						if (id != 1)
						{
							air = num4 * 0.3550280538878172 - 0.2588194037928068 * (zr * num6 - zi * num7);
							aii = num5 * 0.3550280538878172 - 0.2588194037928068 * (zr * num7 + zi * num6);
							if (kode == 1)
							{
								return 0;
							}
							zsqrt(zr, zi, ref br2, ref bi2);
							ar = 2.0 / 3.0 * (zr * br2 - zi * bi2);
							ai = 2.0 / 3.0 * (zr * bi2 + zi * br2);
							zexp(ar, ai, ref br2, ref bi2);
							num24 = air * br2 - aii * bi2;
							aii = air * bi2 + aii * br2;
							air = num24;
							return 0;
						}
						air = (0.0 - num6) * 0.2588194037928068;
						aii = (0.0 - num7) * 0.2588194037928068;
						if (!(num <= num2))
						{
							br2 = zr * num4 - zi * num5;
							bi2 = zr * num5 + zi * num4;
							double num25 = 0.3550280538878172 / (num3 + 1.0);
							air += num25 * (br2 * zr - bi2 * zi);
							aii += num25 * (br2 * zi + bi2 * zr);
						}
						if (kode == 1)
						{
							return 0;
						}
						zsqrt(zr, zi, ref br2, ref bi2);
						ar = 2.0 / 3.0 * (zr * br2 - zi * bi2);
						ai = 2.0 / 3.0 * (zr * bi2 + zi * br2);
						zexp(ar, ai, ref br2, ref bi2);
						num24 = br2 * air - bi2 * aii;
						aii = br2 * aii + bi2 * air;
						air = num24;
						return 0;
					}
					num8 = 1000.0 * d1mach(1);
					num4 = 0.0;
					num5 = 0.0;
					if (id != 1)
					{
						if (!(num <= num8))
						{
							num4 = 0.2588194037928068 * zr;
							num5 = 0.2588194037928068 * zi;
						}
						air = 0.3550280538878172 - num4;
						aii = 0.0 - num5;
						return 0;
					}
					air = -0.2588194037928068;
					aii = 0.0;
					num8 = Math.Sqrt(num8);
					if (!(num <= num8))
					{
						num4 = (zr * zr - zi * zi) * 0.5;
						num5 = zr * zi;
					}
					air += 0.3550280538878172 * num4;
					aii += 0.3550280538878172 * num5;
					return 0;
				}
				double fnu = (1.0 + num3) / 3.0;
				int value = i1mach(15);
				int value2 = i1mach(16);
				double num26 = d1mach(5);
				i = Math.Min(Math.Abs(value), Math.Abs(value2));
				double num27 = ((double)i * num26 - 3.0) * 2.303;
				value = i1mach(14) - 1;
				num8 = num26 * (double)value;
				double num28 = Math.Min(num8, 18.0);
				num8 *= 2.303;
				double num29 = num27 + Math.Max(0.0 - num8, -41.45);
				double rl = 1.2 * num28 + 3.0;
				double num30 = Math.Log(num);
				num8 = 0.5 / num2;
				double val = (double)i1mach(9) * 0.5;
				num8 = Math.Min(num8, val);
				num8 = Math.Pow(num8, 2.0 / 3.0);
				if (!(num > num8))
				{
					num8 = Math.Sqrt(num8);
					if (num > num8)
					{
						ierr = 3;
					}
					zsqrt(zr, zi, ref br, ref bi);
					double ar = 2.0 / 3.0 * (zr * br - zi * bi);
					double ai = 2.0 / 3.0 * (zr * bi + zi * br);
					int num31 = 0;
					double num32 = 1.0;
					double num17 = ai;
					if (!(zr >= 0.0))
					{
						double num18 = ar;
						double num19 = 0.0 - Math.Abs(num18);
						ar = num19;
						ai = num17;
					}
					if (zi == 0.0 && !(zr > 0.0))
					{
						ar = 0.0;
						ai = num17;
					}
					num8 = ar;
					if (!(num8 >= 0.0) || !(zr > 0.0))
					{
						if (kode != 2 && !(num8 > 0.0 - num29))
						{
							num8 = 0.0 - num8 + num30 * 0.25;
							num31 = 1;
							num32 = num2;
							if (num8 > num27)
							{
								goto IL_086f;
							}
						}
						int mr = 1;
						if (zi < 0.0)
						{
							mr = -1;
						}
						zacai(ar, ai, fnu, kode, mr, 1, array2, array, ref nz2, rl, num2, num27, num29);
						if (nz2 < 0)
						{
							if (nz2 != -1)
							{
								nz = 0;
								ierr = 5;
								return 0;
							}
							goto IL_086f;
						}
						nz += nz2;
					}
					else
					{
						if (kode != 2 && !(num8 < num29))
						{
							num8 = 0.0 - num8 - 0.25 * num30;
							num31 = 2;
							num32 = 1.0 / num2;
							if (num8 < 0.0 - num27)
							{
								nz = 1;
								air = 0.0;
								aii = 0.0;
								return 0;
							}
						}
						zbknu(ar, ai, fnu, kode, 1, array2, array, ref nz, num2, num27, num29);
					}
					double num4 = array2[0] * 0.18377629847393068;
					double num5 = array[0] * 0.18377629847393068;
					if (num31 == 0)
					{
						if (id != 1)
						{
							air = br * num4 - bi * num5;
							aii = br * num5 + bi * num4;
							return 0;
						}
						air = 0.0 - (zr * num4 - zi * num5);
						aii = 0.0 - (zr * num5 + zi * num4);
						return 0;
					}
					num4 *= num32;
					num5 *= num32;
					if (id != 1)
					{
						br2 = num4 * br - num5 * bi;
						num5 = num4 * bi + num5 * br;
						num4 = br2;
						air = num4 / num32;
						aii = num5 / num32;
						return 0;
					}
					br2 = 0.0 - (num4 * zr - num5 * zi);
					num5 = 0.0 - (num4 * zi + num5 * zr);
					num4 = br2;
					air = num4 / num32;
					aii = num5 / num32;
					return 0;
				}
				ierr = 4;
				nz = 0;
				return 0;
				IL_086f:
				nz = 0;
				ierr = 2;
				return 0;
			}

			public static int zbiry(double zr, double zi, int id, int kode, ref double bir, ref double bii, ref int nz, ref int ierr)
			{
				double bi = 0.0;
				double br = 0.0;
				double bi2 = 0.0;
				double br2 = 0.0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				ierr = 0;
				nz = 0;
				if (id < 0 || id > 1)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				double num = zabs(zr, zi);
				double num2 = Math.Max(d1mach(4), 1E-18);
				double num3 = id;
				int i;
				double num8;
				if (!(num > 1.0))
				{
					double num4 = 1.0;
					double num5 = 0.0;
					double num6 = 1.0;
					double num7 = 0.0;
					if (!(num < num2))
					{
						num8 = num * num;
						if (!(num8 < num2 / num))
						{
							double num9 = 1.0;
							double num10 = 0.0;
							double num11 = 1.0;
							double num12 = 0.0;
							double num13 = 1.0;
							br2 = zr * zr - zi * zi;
							bi2 = zr * zi + zi * zr;
							double num14 = br2 * zr - bi2 * zi;
							double num15 = br2 * zi + bi2 * zr;
							double num16 = num * num8;
							double num17 = 2.0 + num3;
							double num18 = 3.0 - num3 - num3;
							double num19 = 4.0 - num3;
							double num20 = 3.0 + num3 + num3;
							double num21 = num17 * num20;
							double num22 = num18 * num19;
							double num23 = Math.Min(num21, num22);
							num17 = 24.0 + 9.0 * num3;
							num18 = 30.0 - 9.0 * num3;
							for (i = 1; i <= 25; i++)
							{
								br2 = (num9 * num14 - num10 * num15) / num21;
								num10 = (num9 * num15 + num10 * num14) / num21;
								num9 = br2;
								num4 += num9;
								num5 += num10;
								br2 = (num11 * num14 - num12 * num15) / num22;
								num12 = (num11 * num15 + num12 * num14) / num22;
								num11 = br2;
								num6 += num11;
								num7 += num12;
								num13 = num13 * num16 / num23;
								num21 += num17;
								num22 += num18;
								num23 = Math.Min(num21, num22);
								if (num13 < num2 * num23)
								{
									break;
								}
								num17 += 18.0;
								num18 += 18.0;
							}
						}
						double num24;
						double num25;
						double num26;
						if (id != 1)
						{
							bir = 0.6149266274460007 * num4 + 0.4482883573538264 * (zr * num6 - zi * num7);
							bii = 0.6149266274460007 * num5 + 0.4482883573538264 * (zr * num7 + zi * num6);
							if (kode == 1)
							{
								return 0;
							}
							zsqrt(zr, zi, ref br2, ref bi2);
							num24 = 2.0 / 3.0 * (zr * br2 - zi * bi2);
							num25 = 2.0 / 3.0 * (zr * bi2 + zi * br2);
							num8 = num24;
							num8 = 0.0 - Math.Abs(num8);
							num26 = Math.Exp(num8);
							bir *= num26;
							bii *= num26;
							return 0;
						}
						bir = num6 * 0.4482883573538264;
						bii = num7 * 0.4482883573538264;
						if (!(num <= num2))
						{
							double num27 = 0.6149266274460007 / (1.0 + num3);
							br2 = num4 * zr - num5 * zi;
							bi2 = num4 * zi + num5 * zr;
							bir += num27 * (br2 * zr - bi2 * zi);
							bii += num27 * (br2 * zi + bi2 * zr);
						}
						if (kode == 1)
						{
							return 0;
						}
						zsqrt(zr, zi, ref br2, ref bi2);
						num24 = 2.0 / 3.0 * (zr * br2 - zi * bi2);
						num25 = 2.0 / 3.0 * (zr * bi2 + zi * br2);
						num8 = num24;
						num8 = 0.0 - Math.Abs(num8);
						num26 = Math.Exp(num8);
						bir *= num26;
						bii *= num26;
						return 0;
					}
					num8 = (bir = 0.6149266274460007 * (1.0 - num3) + num3 * 0.4482883573538264);
					bii = 0.0;
					return 0;
				}
				double num28 = (1.0 + num3) / 3.0;
				int value = i1mach(15);
				int value2 = i1mach(16);
				double num29 = d1mach(5);
				i = Math.Min(Math.Abs(value), Math.Abs(value2));
				double num30 = 2.303 * ((double)i * num29 - 3.0);
				value = i1mach(14) - 1;
				num8 = num29 * (double)value;
				double num31 = Math.Min(num8, 18.0);
				num8 *= 2.303;
				double num32 = num30 + Math.Max(0.0 - num8, -41.45);
				double rl = 1.2 * num31 + 3.0;
				double fnul = 10.0 + 6.0 * (num31 - 3.0);
				num8 = 0.5 / num2;
				double val = (double)i1mach(9) * 0.5;
				num8 = Math.Min(num8, val);
				num8 = Math.Pow(num8, 2.0 / 3.0);
				if (!(num > num8))
				{
					num8 = Math.Sqrt(num8);
					if (num > num8)
					{
						ierr = 3;
					}
					zsqrt(zr, zi, ref br, ref bi);
					double num24 = 2.0 / 3.0 * (zr * br - zi * bi);
					double num25 = 2.0 / 3.0 * (zr * bi + zi * br);
					double num33 = 1.0;
					double num17 = num25;
					if (!(zr >= 0.0))
					{
						double num18 = num24;
						double num19 = 0.0 - Math.Abs(num18);
						num24 = num19;
						num25 = num17;
					}
					if (zi == 0.0 && !(zr > 0.0))
					{
						num24 = 0.0;
						num25 = num17;
					}
					num8 = num24;
					if (kode != 2)
					{
						val = Math.Abs(num8);
						if (!(val < num32))
						{
							val += 0.25 * Math.Log(num);
							num33 = num2;
							if (val > num30)
							{
								goto IL_0836;
							}
						}
					}
					double num34 = 0.0;
					if (!(num8 >= 0.0) || !(zr > 0.0))
					{
						num34 = Math.PI;
						if (zi < 0.0)
						{
							num34 = -Math.PI;
						}
						num24 = 0.0 - num24;
						num25 = 0.0 - num25;
					}
					zbinu(num24, num25, num28, kode, 1, array, array2, ref nz, rl, fnul, num2, num30, num32);
					if (nz >= 0)
					{
						num8 = num34 * num28;
						double num14 = num33;
						br2 = Math.Cos(num8);
						bi2 = Math.Sin(num8);
						double num4 = (br2 * array[0] - bi2 * array2[0]) * num14;
						double num5 = (br2 * array2[0] + bi2 * array[0]) * num14;
						num28 = (2.0 - num3) / 3.0;
						zbinu(num24, num25, num28, kode, 2, array, array2, ref nz, rl, fnul, num2, num30, num32);
						array[0] *= num14;
						array2[0] *= num14;
						array[1] *= num14;
						array2[1] *= num14;
						zdiv(array[0], array2[0], num24, num25, ref br2, ref bi2);
						double num6 = (num28 + num28) * br2 + array[1];
						double num7 = (num28 + num28) * bi2 + array2[1];
						num8 = num34 * (num28 - 1.0);
						br2 = Math.Cos(num8);
						bi2 = Math.Sin(num8);
						num4 = 0.5773502691896257 * (num4 + num6 * br2 - num7 * bi2);
						num5 = 0.5773502691896257 * (num5 + num6 * bi2 + num7 * br2);
						if (id != 1)
						{
							br2 = br * num4 - bi * num5;
							num5 = br * num5 + bi * num4;
							num4 = br2;
							bir = num4 / num33;
							bii = num5 / num33;
							return 0;
						}
						br2 = zr * num4 - zi * num5;
						num5 = zr * num5 + zi * num4;
						num4 = br2;
						bir = num4 / num33;
						bii = num5 / num33;
						return 0;
					}
					if (nz != -1)
					{
						nz = 0;
						ierr = 5;
						return 0;
					}
					goto IL_0836;
				}
				ierr = 4;
				nz = 0;
				return 0;
				IL_0836:
				ierr = 2;
				nz = 0;
				return 0;
			}

			public static int zbesj(double zr, double zi, double fnu, int kode, int n, double[] cyr, double[] cyi, ref int nz, ref int ierr)
			{
				ierr = 0;
				nz = 0;
				if (fnu < 0.0)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (n < 1)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				double num = Math.Max(d1mach(4), 1E-18);
				int value = i1mach(15);
				int value2 = i1mach(16);
				double num2 = d1mach(5);
				double num3 = ((double)Math.Min(Math.Abs(value), Math.Abs(value2)) * num2 - 3.0) * 2.303;
				value = i1mach(14) - 1;
				double num4 = num2 * (double)value;
				double num5 = Math.Min(num4, 18.0);
				num4 *= 2.303;
				double alim = num3 + Math.Max(0.0 - num4, -41.45);
				double rl = num5 * 1.2 + 3.0;
				double fnul = (num5 - 3.0) * 6.0 + 10.0;
				double num6 = zabs(zr, zi);
				double num7 = fnu + (double)(n - 1);
				num4 = 0.5 / num;
				double val = 0.5 * (double)i1mach(9);
				num4 = Math.Min(num4, val);
				if (!(num6 > num4) && !(num7 > num4))
				{
					num4 = Math.Sqrt(num4);
					if (num6 > num4)
					{
						ierr = 3;
					}
					if (num7 > num4)
					{
						ierr = 3;
					}
					double num8 = 1.0;
					int num9 = (int)fnu;
					int num10 = num9 / 2;
					int num11 = num9 - (num10 << 1);
					double num12 = (fnu - (double)(num9 - num11)) * (Math.PI / 2.0);
					double num13 = Math.Cos(num12);
					double num14 = Math.Sin(num12);
					if (num10 % 2 != 0)
					{
						num13 = 0.0 - num13;
						num14 = 0.0 - num14;
					}
					double num15 = zi;
					double num16 = 0.0 - zr;
					if (!(zi >= 0.0))
					{
						num15 = 0.0 - num15;
						num16 = 0.0 - num16;
						num14 = 0.0 - num14;
						num8 = 0.0 - num8;
					}
					zbinu(num15, num16, fnu, kode, n, cyr, cyi, ref nz, rl, fnul, num, num3, alim);
					if (nz >= 0)
					{
						int num17 = n - nz;
						if (num17 == 0)
						{
							return 0;
						}
						double num18 = 1.0 / num;
						double num19 = d1mach(1) * num18 * 1000.0;
						for (int i = 1; i <= num17; i++)
						{
							num4 = cyr[i - 1];
							val = cyi[i - 1];
							double num20 = 1.0;
							if (!(Math.Max(Math.Abs(num4), Math.Abs(val)) > num19))
							{
								num4 *= num18;
								val *= num18;
								num20 = num;
							}
							double num21 = num4 * num13 - val * num14;
							double num22 = num4 * num14 + val * num13;
							cyr[i - 1] = num21 * num20;
							cyi[i - 1] = num22 * num20;
							num21 = (0.0 - num14) * num8;
							num14 = num13 * num8;
							num13 = num21;
						}
						return 0;
					}
					if (nz != -2)
					{
						nz = 0;
						ierr = 2;
						return 0;
					}
					nz = 0;
					ierr = 5;
					return 0;
				}
				nz = 0;
				ierr = 4;
				return 0;
			}

			public static int zbesy(double zr, double zi, double fnu, int kode, int n, double[] cyr, double[] cyi, ref int nz, double[] cwrkr, double[] cwrki, ref int ierr)
			{
				int nz2 = 0;
				int nz3 = 0;
				ierr = 0;
				nz = 0;
				if (zr == 0.0 && zi == 0.0)
				{
					ierr = 1;
				}
				if (fnu < 0.0)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (n < 1)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				double num = 0.5;
				zbesh(zr, zi, fnu, kode, 1, n, cyr, cyi, ref nz2, ref ierr);
				if (ierr == 0 || ierr == 3)
				{
					zbesh(zr, zi, fnu, kode, 2, n, cwrkr, cwrki, ref nz3, ref ierr);
					if (ierr == 0 || ierr == 3)
					{
						nz = Math.Min(nz2, nz3);
						if (kode != 2)
						{
							for (int i = 1; i <= n; i++)
							{
								double num2 = cwrkr[i - 1] - cyr[i - 1];
								double num3 = cwrki[i - 1] - cyi[i - 1];
								cyr[i - 1] = (0.0 - num3) * num;
								cyi[i - 1] = num2 * num;
							}
							return 0;
						}
						double num4 = Math.Max(d1mach(4), 1E-18);
						int value = i1mach(15);
						int num5 = Math.Min(val2: Math.Abs(i1mach(16)), val1: Math.Abs(value));
						double num6 = d1mach(5);
						double num7 = 2.303 * ((double)num5 * num6 - 3.0);
						double num8 = Math.Cos(zr);
						double num9 = Math.Sin(zr);
						double num10 = 0.0;
						double num11 = Math.Abs(zi + zi);
						if (num11 < num7)
						{
							num10 = Math.Exp(0.0 - num11);
						}
						double num12;
						double num13;
						double num14;
						double num15;
						if (!(zi < 0.0))
						{
							num12 = num8 * num10;
							num13 = num9 * num10;
							num14 = num8;
							num15 = 0.0 - num9;
						}
						else
						{
							num12 = num8;
							num13 = num9;
							num14 = num8 * num10;
							num15 = (0.0 - num9) * num10;
						}
						nz = 0;
						double num16 = 1.0 / num4;
						double num17 = d1mach(1) * num16 * 1000.0;
						for (int i = 1; i <= n; i++)
						{
							double num18 = cwrkr[i - 1];
							double num19 = cwrki[i - 1];
							double num20 = 1.0;
							if (!(Math.Max(Math.Abs(num18), Math.Abs(num19)) > num17))
							{
								num18 *= num16;
								num19 *= num16;
								num20 = num4;
							}
							double num2 = (num18 * num14 - num19 * num15) * num20;
							double num3 = (num18 * num15 + num19 * num14) * num20;
							num18 = cyr[i - 1];
							num19 = cyi[i - 1];
							num20 = 1.0;
							if (!(Math.Max(Math.Abs(num18), Math.Abs(num19)) > num17))
							{
								num18 *= num16;
								num19 *= num16;
								num20 = num4;
							}
							num2 -= (num18 * num12 - num19 * num13) * num20;
							num3 -= (num18 * num13 + num19 * num12) * num20;
							cyr[i - 1] = (0.0 - num3) * num;
							cyi[i - 1] = num2 * num;
							if (num2 == 0.0 && num3 == 0.0 && num10 == 0.0)
							{
								nz++;
							}
						}
						return 0;
					}
				}
				nz = 0;
				return 0;
			}

			public static int zbesi(double zr, double zi, double fnu, int kode, int n, double[] cyr, double[] cyi, ref int nz, ref int ierr)
			{
				ierr = 0;
				nz = 0;
				if (fnu < 0.0)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (n < 1)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				double num = Math.Max(d1mach(4), 1E-18);
				int value = i1mach(15);
				int value2 = i1mach(16);
				double num2 = d1mach(5);
				int num3 = Math.Min(Math.Abs(value), Math.Abs(value2));
				double num4 = 2.303 * ((double)num3 * num2 - 3.0);
				value = i1mach(14) - 1;
				double num5 = num2 * (double)value;
				double num6 = Math.Min(num5, 18.0);
				num5 *= 2.303;
				double alim = num4 + Math.Max(0.0 - num5, -41.45);
				double rl = num6 * 1.2 + 3.0;
				double fnul = 10.0 + 6.0 * (num6 - 3.0);
				double num7 = zabs(zr, zi);
				double num8 = fnu + (double)(n - 1);
				num5 = 0.5 / num;
				double val = (double)i1mach(9) * 0.5;
				num5 = Math.Min(num5, val);
				if (!(num7 > num5) && !(num8 > num5))
				{
					num5 = Math.Sqrt(num5);
					if (num7 > num5)
					{
						ierr = 3;
					}
					if (num8 > num5)
					{
						ierr = 3;
					}
					double zr2 = zr;
					double zi2 = zi;
					double num9 = 1.0;
					double num10 = 0.0;
					if (!(zr >= 0.0))
					{
						zr2 = 0.0 - zr;
						zi2 = 0.0 - zi;
						int num11 = (int)fnu;
						double num12 = (fnu - (double)num11) * Math.PI;
						if (zi < 0.0)
						{
							num12 = 0.0 - num12;
						}
						num9 = Math.Cos(num12);
						num10 = Math.Sin(num12);
						if (num11 % 2 != 0)
						{
							num9 = 0.0 - num9;
							num10 = 0.0 - num10;
						}
					}
					zbinu(zr2, zi2, fnu, kode, n, cyr, cyi, ref nz, rl, fnul, num, num4, alim);
					if (nz >= 0)
					{
						if (zr >= 0.0)
						{
							return 0;
						}
						int num13 = n - nz;
						if (num13 == 0)
						{
							return 0;
						}
						double num14 = 1.0 / num;
						double num15 = d1mach(1) * num14 * 1000.0;
						for (int i = 1; i <= num13; i++)
						{
							num5 = cyr[i - 1];
							val = cyi[i - 1];
							double num16 = 1.0;
							if (!(Math.Max(Math.Abs(num5), Math.Abs(val)) > num15))
							{
								num5 *= num14;
								val *= num14;
								num16 = num;
							}
							double num17 = num5 * num9 - val * num10;
							double num18 = num5 * num10 + val * num9;
							cyr[i - 1] = num17 * num16;
							cyi[i - 1] = num18 * num16;
							num9 = 0.0 - num9;
							num10 = 0.0 - num10;
						}
						return 0;
					}
					if (nz != -2)
					{
						nz = 0;
						ierr = 2;
						return 0;
					}
					nz = 0;
					ierr = 5;
					return 0;
				}
				nz = 0;
				ierr = 4;
				return 0;
			}

			public static int zbesk(double zr, double zi, double fnu, int kode, int n, double[] cyr, double[] cyi, ref int nz, ref int ierr)
			{
				int nuf = 0;
				int nz2 = 0;
				ierr = 0;
				nz = 0;
				if (zi == 0.0 && zr == 0.0)
				{
					ierr = 1;
				}
				if (fnu < 0.0)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (n < 1)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				int num = n;
				double num2 = Math.Max(d1mach(4), 1E-18);
				int value = i1mach(15);
				int value2 = i1mach(16);
				double num3 = d1mach(5);
				int num4 = Math.Min(Math.Abs(value), Math.Abs(value2));
				double num5 = 2.303 * ((double)num4 * num3 - 3.0);
				value = i1mach(14) - 1;
				double num6 = num3 * (double)value;
				double num7 = Math.Min(num6, 18.0);
				num6 *= 2.303;
				double alim = num5 + Math.Max(0.0 - num6, -41.45);
				double num8 = (num7 - 3.0) * 6.0 + 10.0;
				double rl = 1.2 * num7 + 3.0;
				double num9 = zabs(zr, zi);
				double num10 = fnu + (double)(num - 1);
				num6 = 0.5 / num2;
				double val = (double)i1mach(9) * 0.5;
				num6 = Math.Min(num6, val);
				if (!(num9 > num6) && !(num10 > num6))
				{
					num6 = Math.Sqrt(num6);
					if (num9 > num6)
					{
						ierr = 3;
					}
					if (num10 > num6)
					{
						ierr = 3;
					}
					double num11 = d1mach(1) * 1000.0;
					if (num9 < num11)
					{
						goto IL_02fe;
					}
					if (!(fnu > num8))
					{
						if (!(num10 <= 1.0))
						{
							if (num10 > 2.0)
							{
								zuoik(zr, zi, fnu, kode, 2, num, cyr, cyi, ref nuf, num2, num5, alim);
								if (nuf >= 0)
								{
									nz += nuf;
									num -= nuf;
									if (num != 0)
									{
										goto IL_0231;
									}
									if (!(zr < 0.0))
									{
										return 0;
									}
								}
								goto IL_02fe;
							}
							if (!(num9 > num2))
							{
								double d = num9 * 0.5;
								if ((0.0 - num10) * Math.Log(d) > num5)
								{
									goto IL_02fe;
								}
							}
						}
						goto IL_0231;
					}
					int mr = 0;
					if (!(zr >= 0.0))
					{
						mr = 1;
						if (zi < 0.0)
						{
							mr = -1;
						}
					}
					zbunk(zr, zi, fnu, kode, mr, num, cyr, cyi, ref nz2, num2, num5, alim);
					if (nz2 >= 0)
					{
						nz += nz2;
						return 0;
					}
					goto IL_0308;
				}
				nz = 0;
				ierr = 4;
				return 0;
				IL_0231:
				if (!(zr < 0.0))
				{
					zbknu(zr, zi, fnu, kode, num, cyr, cyi, ref nz2, num2, num5, alim);
					if (nz2 >= 0)
					{
						nz = nz2;
						return 0;
					}
				}
				else
				{
					if (nz != 0)
					{
						goto IL_02fe;
					}
					int mr = 1;
					if (zi < 0.0)
					{
						mr = -1;
					}
					zacon(zr, zi, fnu, kode, mr, num, cyr, cyi, ref nz2, rl, num8, num2, num5, alim);
					if (nz2 >= 0)
					{
						nz = nz2;
						return 0;
					}
				}
				goto IL_0308;
				IL_0308:
				if (nz2 != -1)
				{
					nz = 0;
					ierr = 5;
					return 0;
				}
				goto IL_02fe;
				IL_02fe:
				nz = 0;
				ierr = 2;
				return 0;
			}

			public static int zbesh(double zr, double zi, double fnu, int kode, int m, int n, double[] cyr, double[] cyi, ref int nz, ref int ierr)
			{
				int nuf = 0;
				int nz2 = 0;
				ierr = 0;
				nz = 0;
				if (zr == 0.0 && zi == 0.0)
				{
					ierr = 1;
				}
				if (fnu < 0.0)
				{
					ierr = 1;
				}
				if (m < 1 || m > 2)
				{
					ierr = 1;
				}
				if (kode < 1 || kode > 2)
				{
					ierr = 1;
				}
				if (n < 1)
				{
					ierr = 1;
				}
				if (ierr != 0)
				{
					return 0;
				}
				int num = n;
				double num2 = Math.Max(d1mach(4), 1E-18);
				int value = i1mach(15);
				int value2 = i1mach(16);
				double num3 = d1mach(5);
				int num4 = Math.Min(Math.Abs(value), Math.Abs(value2));
				double num5 = 2.303 * ((double)num4 * num3 - 3.0);
				value = i1mach(14) - 1;
				double num6 = num3 * (double)value;
				double num7 = Math.Min(num6, 18.0);
				num6 *= 2.303;
				double alim = num5 + Math.Max(0.0 - num6, -41.45);
				double num8 = (num7 - 3.0) * 6.0 + 10.0;
				double rl = num7 * 1.2 + 3.0;
				double num9 = fnu + (double)(num - 1);
				int num10 = 3 - m - m;
				double num11 = num10;
				double num12 = num11 * zi;
				double num13 = (0.0 - num11) * zr;
				double num14 = zabs(zr, zi);
				num6 = 0.5 / num2;
				double val = (double)i1mach(9) * 0.5;
				num6 = Math.Min(num6, val);
				double num15;
				double d;
				if (!(num14 > num6) && !(num9 > num6))
				{
					num6 = Math.Sqrt(num6);
					if (num14 > num6)
					{
						ierr = 3;
					}
					if (num9 > num6)
					{
						ierr = 3;
					}
					num15 = d1mach(1) * 1000.0;
					if (num14 < num15)
					{
						goto IL_0484;
					}
					if (!(fnu > num8))
					{
						if (!(num9 <= 1.0))
						{
							if (num9 > 2.0)
							{
								zuoik(num12, num13, fnu, kode, 2, num, cyr, cyi, ref nuf, num2, num5, alim);
								if (nuf >= 0)
								{
									nz += nuf;
									num -= nuf;
									if (num != 0)
									{
										goto IL_0257;
									}
									if (!(num12 < 0.0))
									{
										return 0;
									}
								}
								goto IL_0484;
							}
							if (!(num14 > num2))
							{
								d = 0.5 * num14;
								if ((0.0 - num9) * Math.Log(d) > num5)
								{
									goto IL_0484;
								}
							}
						}
						goto IL_0257;
					}
					int mr = 0;
					if (!(num12 >= 0.0) || (num12 == 0.0 && !(num13 >= 0.0) && m == 2))
					{
						mr = -num10;
						if (num12 == 0.0 && !(num13 >= 0.0))
						{
							num12 = 0.0 - num12;
							num13 = 0.0 - num13;
						}
					}
					zbunk(num12, num13, fnu, kode, mr, num, cyr, cyi, ref nz2, num2, num5, alim);
					if (nz2 >= 0)
					{
						nz += nz2;
						goto IL_035b;
					}
					goto IL_048e;
				}
				nz = 0;
				ierr = 4;
				return 0;
				IL_0484:
				nz = 0;
				ierr = 2;
				return 0;
				IL_0257:
				if (!(num12 < 0.0) && (num12 != 0.0 || !(num13 < 0.0) || m != 2))
				{
					zbknu(num12, num13, fnu, kode, num, cyr, cyi, ref nz, num2, num5, alim);
				}
				else
				{
					int mr = -num10;
					zacon(num12, num13, fnu, kode, mr, num, cyr, cyi, ref nz2, rl, num8, num2, num5, alim);
					if (nz2 < 0)
					{
						goto IL_048e;
					}
					nz = nz2;
				}
				goto IL_035b;
				IL_048e:
				if (nz2 != -1)
				{
					nz = 0;
					ierr = 5;
					return 0;
				}
				goto IL_0484;
				IL_035b:
				double num16 = dsign(Math.PI / 2.0, 0.0 - num11);
				int num17 = (int)fnu;
				int num18 = num17 / 2;
				int num19 = num17 - 2 * num18;
				d = (fnu - (double)(num17 - num19)) * num16;
				double num20 = 1.0 / num16;
				double num21 = num20 * Math.Cos(d);
				double num22 = (0.0 - num20) * Math.Sin(d);
				if (num18 % 2 != 0)
				{
					num22 = 0.0 - num22;
					num21 = 0.0 - num21;
				}
				double num23 = 0.0 - num11;
				double num24 = 1.0 / num2;
				double num25 = num15 * num24;
				for (int i = 1; i <= num; i++)
				{
					num6 = cyr[i - 1];
					val = cyi[i - 1];
					double num26 = 1.0;
					if (!(Math.Max(Math.Abs(num6), Math.Abs(val)) > num25))
					{
						num6 *= num24;
						val *= num24;
						num26 = num2;
					}
					double num27 = num6 * num22 - val * num21;
					double num28 = num6 * num21 + val * num22;
					cyr[i - 1] = num27 * num26;
					cyi[i - 1] = num28 * num26;
					num27 = (0.0 - num21) * num23;
					num21 = num22 * num23;
					num22 = num27;
				}
				return 0;
			}

			public static double dgamln(double z, ref int ierr)
			{
				double[] array = new double[100]
				{
					0.0, 0.0, 0.6931471805599453, 1.791759469228055, 3.1780538303479458, 4.787491742782046, 6.579251212010101, 8.525161361065415, 10.60460290274525, 12.801827480081469,
					15.104412573075516, 17.502307845873887, 19.987214495661885, 22.552163853123425, 25.19122118273868, 27.89927138384089, 30.671860106080672, 33.50507345013689, 36.39544520803305, 39.339884187199495,
					42.335616460753485, 45.38013889847691, 48.47118135183523, 51.60667556776438, 54.78472939811232, 58.00360522298052, 61.261701761002, 64.55753862700634, 67.88974313718154, 71.25703896716801,
					74.65823634883016, 78.0922235533153, 81.55795945611504, 85.05446701758152, 88.58082754219768, 92.1361756036871, 95.7196945421432, 99.33061245478743, 102.96819861451381, 106.63176026064346,
					110.32063971475739, 114.0342117814617, 117.77188139974507, 121.53308151543864, 125.3172711493569, 129.12393363912722, 132.95257503561632, 136.80272263732635, 140.67392364823425, 144.5657439463449,
					148.47776695177302, 152.40959258449735, 156.3608363030788, 160.3311282166309, 164.32011226319517, 168.32744544842765, 172.3527971391628, 176.39584840699735, 180.45629141754378, 184.53382886144948,
					188.6281734236716, 192.7390472878449, 196.86618167289, 201.00931639928152, 205.1681994826412, 209.34258675253685, 213.53224149456327, 217.73693411395422, 221.95644181913033, 226.1905483237276,
					230.43904356577696, 234.70172344281826, 238.97838956183432, 243.2688490029827, 247.57291409618688, 251.8904022097232, 256.22113555000954, 260.5649409718632, 264.9216497985528, 269.2910976510198,
					273.6731242856937, 278.0675734403661, 282.4742926876304, 286.893133295427, 291.3239500942703, 295.76660135076065, 300.22094864701415, 304.6868567656687, 309.1641935801469, 313.65282994987905,
					318.1526396202093, 322.66349912672615, 327.1852877037752, 331.7178871969285, 336.26118197919845, 340.815058870799, 345.37940706226686, 349.95411804077025, 354.5390855194408, 359.1342053695754
				};
				double[] array2 = new double[22]
				{
					1.0 / 12.0,
					-1.0 / 360.0,
					0.0007936507936507937,
					-0.0005952380952380953,
					0.0008417508417508417,
					-0.0019175269175269176,
					1.0 / 156.0,
					-0.029550653594771242,
					0.17964437236883057,
					-1.3924322169059011,
					13.402864044168393,
					-156.84828462600203,
					2193.1033333333335,
					-36108.77125372499,
					691472.268851313,
					-15238221.539407415,
					382900751.39141417,
					-10882266035.784391,
					347320283765.00226,
					-12369602142269.275,
					488788064793079.3,
					-21320333960919372.0
				};
				int num = 0;
				ierr = 0;
				if (!(z <= 0.0))
				{
					if (!(z > 101.0))
					{
						num = (int)z;
						if (!(z - (double)num > 0.0) && num <= 100)
						{
							return array[num - 1];
						}
					}
					double val = d1mach(4);
					val = Math.Max(val, 5E-19);
					int num2 = i1mach(14);
					double val2 = Math.Min(d1mach(5) * (double)num2, 20.0);
					val2 = Math.Max(val2, 3.0);
					val2 += -3.0;
					double num3 = (int)(1.8 + 0.3875 * val2) + 1;
					double num4 = z;
					double num5 = 0.0;
					if (!(z >= num3))
					{
						num5 = num3 - (double)num;
						num4 = z + num5;
					}
					double num6 = 1.0 / num4;
					double num7 = array2[0] * num6;
					double num8 = num7;
					if (!(num6 < val))
					{
						double num9 = num6 * num6;
						double num10 = num7 * val;
						for (int i = 2; i <= 22; i++)
						{
							num6 *= num9;
							double num11 = array2[i - 1] * num6;
							if (Math.Abs(num11) < num10)
							{
								break;
							}
							num8 += num11;
						}
					}
					double num12;
					if (num5 == 0.0)
					{
						num12 = Math.Log(z);
						return z * (num12 - 1.0) + (1.8378770664093456 - num12) * 0.5 + num8;
					}
					num6 = 1.0;
					num = (int)num5;
					for (int j = 1; j <= num; j++)
					{
						num6 *= z + (double)(j - 1);
					}
					num12 = Math.Log(num4);
					return num4 * (num12 - 1.0) - Math.Log(num6) + (1.8378770664093456 - num12) * 0.5 + num8;
				}
				ierr = 1;
				return d1mach(2);
			}

			private static double d1mach(int i)
			{
				return i switch
				{
					1 => 2.2250738585072014E-308, 
					2 => double.MaxValue, 
					3 => 1.1102230246251565E-16, 
					4 => 2.220446049250313E-16, 
					5 => Math.Log10(2.0), 
					_ => 0.0, 
				};
			}

			private static int i1mach(int i)
			{
				return i switch
				{
					9 => int.MaxValue, 
					14 => 53, 
					15 => -1021, 
					16 => 1024, 
					_ => 0, 
				};
			}

			private static double dsign(double a, double b)
			{
				double num = ((a >= 0.0) ? a : (0.0 - a));
				if (!(b >= 0.0))
				{
					return 0.0 - num;
				}
				return num;
			}

			private static double zabs(double zr, double zi)
			{
				double num = Math.Abs(zr);
				double num2 = Math.Abs(zi);
				if ((num + num2) * 1.0 != 0.0)
				{
					double num3;
					if (!(num > num2))
					{
						num3 = num / num2;
						return num2 * Math.Sqrt(1.0 + num3 * num3);
					}
					num3 = num2 / num;
					return num * Math.Sqrt(1.0 + num3 * num3);
				}
				return 0.0;
			}

			private static int zdiv(double ar, double ai, double br, double bi, ref double cr, ref double ci)
			{
				double num = 1.0 / zabs(br, bi);
				double num2 = br * num;
				double num3 = bi * num;
				double num4 = (ar * num2 + ai * num3) * num;
				double num5 = (ai * num2 - ar * num3) * num;
				cr = num4;
				ci = num5;
				return 0;
			}

			private static int zexp(double ar, double ai, ref double br, ref double bi)
			{
				double num = Math.Exp(ar);
				double num2 = num * Math.Cos(ai);
				double num3 = num * Math.Sin(ai);
				br = num2;
				bi = num3;
				return 0;
			}

			private static int zlog(double ar, double ai, ref double br, ref double bi, ref int ierr)
			{
				double num = Math.PI / 2.0;
				double num2 = Math.PI;
				ierr = 0;
				if (ar != 0.0)
				{
					if (ai != 0.0)
					{
						double num3 = Math.Atan(ai / ar);
						if (!(num3 <= 0.0))
						{
							if (ar < 0.0)
							{
								num3 -= num2;
							}
						}
						else if (ar < 0.0)
						{
							num3 += num2;
						}
						double d = zabs(ar, ai);
						br = Math.Log(d);
						bi = num3;
						return 0;
					}
					if (!(ar > 0.0))
					{
						br = Math.Log(Math.Abs(ar));
						bi = num2;
						return 0;
					}
					br = Math.Log(ar);
					bi = 0.0;
					return 0;
				}
				if (ai != 0.0)
				{
					bi = num;
					br = Math.Log(Math.Abs(ai));
					if (ai < 0.0)
					{
						bi = 0.0 - bi;
					}
					return 0;
				}
				ierr = 1;
				return 0;
			}

			private static int zmlt(double ar, double ai, double br, double bi, ref double cr, ref double ci)
			{
				double num = ar * br - ai * bi;
				double num2 = ar * bi + ai * br;
				cr = num;
				ci = num2;
				return 0;
			}

			private static int zsqrt(double ar, double ai, ref double br, ref double bi)
			{
				double d = zabs(ar, ai);
				d = Math.Sqrt(d);
				if (ar != 0.0)
				{
					if (ai != 0.0)
					{
						double num = Math.Atan(ai / ar);
						if (!(num <= 0.0))
						{
							if (ar < 0.0)
							{
								num -= Math.PI;
							}
						}
						else if (ar < 0.0)
						{
							num += Math.PI;
						}
						num *= 0.5;
						br = d * Math.Cos(num);
						bi = d * Math.Sin(num);
						return 0;
					}
					if (!(ar > 0.0))
					{
						br = 0.0;
						bi = Math.Sqrt(Math.Abs(ar));
						return 0;
					}
					br = Math.Sqrt(ar);
					bi = 0.0;
					return 0;
				}
				if (!(ai > 0.0))
				{
					if (!(ai < 0.0))
					{
						br = 0.0;
						bi = 0.0;
						return 0;
					}
					br = d * 0.7071067811865476;
					bi = (0.0 - d) * 0.7071067811865476;
					return 0;
				}
				br = d * 0.7071067811865476;
				bi = d * 0.7071067811865476;
				return 0;
			}

			private static int zacai(double zr, double zi, double fnu, int kode, int mr, int n, double[] yr, double[] yi, ref int nz, double rl, double tol, double elim, double alim)
			{
				int nz2 = 0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				nz = 0;
				double num = 0.0 - zr;
				double num2 = 0.0 - zi;
				double num3 = zabs(zr, zi);
				double num4 = fnu + (double)(n - 1);
				if (num3 <= 2.0 || !(num3 * num3 * 0.25 > num4 + 1.0))
				{
					zseri(num, num2, fnu, kode, n, yr, yi, ref nz2, tol, elim, alim);
					goto IL_00c0;
				}
				if (!(num3 < rl))
				{
					zasyi(num, num2, fnu, kode, n, yr, yi, ref nz2, rl, tol, elim, alim);
					if (nz2 >= 0)
					{
						goto IL_00c0;
					}
				}
				else
				{
					zmlri(num, num2, fnu, kode, n, yr, yi, ref nz2, tol);
					if (nz2 >= 0)
					{
						goto IL_00c0;
					}
				}
				goto IL_01d7;
				IL_01d7:
				nz = -1;
				if (nz2 == -2)
				{
					nz = -2;
				}
				return 0;
				IL_00c0:
				zbknu(num, num2, fnu, kode, 1, array, array2, ref nz2, tol, elim, alim);
				if (nz2 == 0)
				{
					double b = mr;
					double num5 = 0.0 - dsign(Math.PI, b);
					double num6 = 0.0;
					double num7 = num5;
					if (kode != 1)
					{
						double num8 = 0.0 - num2;
						num6 = (0.0 - num7) * Math.Sin(num8);
						num7 *= Math.Cos(num8);
					}
					int num9 = (int)fnu;
					double num10 = (fnu - (double)num9) * num5;
					double num11 = Math.Cos(num10);
					double num12 = Math.Sin(num10);
					if (num9 % 2 != 0)
					{
						num11 = 0.0 - num11;
						num12 = 0.0 - num12;
					}
					double s1r = array[0];
					double s1i = array2[0];
					double s2r = yr[0];
					double s2i = yi[0];
					if (kode != 1)
					{
						int iuf = 0;
						double ascle = d1mach(1) * 1000.0 / tol;
						zs1s2(num, num2, ref s1r, ref s1i, ref s2r, ref s2i, ref nz2, ascle, alim, ref iuf);
						nz += nz2;
					}
					yr[0] = num11 * s1r - num12 * s1i + num6 * s2r - num7 * s2i;
					yi[0] = num11 * s1i + num12 * s1r + num6 * s2i + num7 * s2r;
					return 0;
				}
				goto IL_01d7;
			}

			private static int zacon(double zr, double zi, double fnu, int kode, int mr, int n, double[] yr, double[] yi, ref int nz, double rl, double fnul, double tol, double elim, double alim)
			{
				double ci = 0.0;
				double cr = 0.0;
				double num = 0.0;
				double num2 = 0.0;
				double ci2 = 0.0;
				double cr2 = 0.0;
				int nz2 = 0;
				double[] array = new double[3];
				double[] array2 = new double[3];
				double[] array3 = new double[3];
				double[] array4 = new double[2];
				double[] array5 = new double[2];
				nz = 0;
				double num3 = 0.0 - zr;
				double num4 = 0.0 - zi;
				int n2 = n;
				zbinu(num3, num4, fnu, kode, n2, yr, yi, ref nz2, rl, fnul, tol, elim, alim);
				if (nz2 >= 0)
				{
					n2 = Math.Min(2, n);
					zbknu(num3, num4, fnu, kode, n2, array5, array4, ref nz2, tol, elim, alim);
					if (nz2 == 0)
					{
						double num5 = array5[0];
						double num6 = array4[0];
						double b = mr;
						double num7 = 0.0 - dsign(Math.PI, b);
						double cr3 = 0.0;
						double ci3 = num7;
						double br;
						double bi;
						if (kode != 1)
						{
							double num8 = 0.0 - num4;
							br = Math.Cos(num8);
							bi = Math.Sin(num8);
							zmlt(cr3, ci3, br, bi, ref cr3, ref ci3);
						}
						int num9 = (int)fnu;
						double num10 = (fnu - (double)num9) * num7;
						br = Math.Cos(num10);
						bi = Math.Sin(num10);
						double num11 = br;
						double num12 = bi;
						if (num9 % 2 != 0)
						{
							num11 = 0.0 - num11;
							num12 = 0.0 - num12;
						}
						int iuf = 0;
						double s1r = num5;
						double s1i = num6;
						double s2r = yr[0];
						double s2i = yi[0];
						double num13 = 1000.0 * d1mach(1) / tol;
						if (kode != 1)
						{
							zs1s2(num3, num4, ref s1r, ref s1i, ref s2r, ref s2i, ref nz2, num13, alim, ref iuf);
							nz += nz2;
							double num14 = s1r;
							double num15 = s1i;
						}
						zmlt(num11, num12, s1r, s1i, ref cr2, ref ci2);
						zmlt(cr3, ci3, s2r, s2i, ref cr, ref ci);
						yr[0] = cr2 + cr;
						yi[0] = ci2 + ci;
						if (n == 1)
						{
							return 0;
						}
						num11 = 0.0 - num11;
						num12 = 0.0 - num12;
						double num16 = array5[1];
						double num17 = array4[1];
						s1r = num16;
						s1i = num17;
						s2r = yr[1];
						s2i = yi[1];
						if (kode != 1)
						{
							zs1s2(num3, num4, ref s1r, ref s1i, ref s2r, ref s2i, ref nz2, num13, alim, ref iuf);
							nz += nz2;
							num2 = s1r;
							num = s1i;
						}
						zmlt(num11, num12, s1r, s1i, ref cr2, ref ci2);
						zmlt(cr3, ci3, s2r, s2i, ref cr, ref ci);
						yr[1] = cr2 + cr;
						yi[1] = ci2 + ci;
						if (n == 2)
						{
							return 0;
						}
						num11 = 0.0 - num11;
						num12 = 0.0 - num12;
						double num18 = zabs(num3, num4);
						double num19 = 1.0 / num18;
						cr2 = num3 * num19;
						ci2 = (0.0 - num4) * num19;
						double num20 = (cr2 + cr2) * num19;
						double num21 = (ci2 + ci2) * num19;
						double num22 = fnu + 1.0;
						double num23 = num22 * num20;
						double num24 = num22 * num21;
						double num25 = 1.0 / tol;
						array3[0] = num25;
						array3[1] = 1.0;
						array3[2] = tol;
						array2[0] = tol;
						array2[1] = 1.0;
						array2[2] = num25;
						array[0] = num13;
						array[1] = 1.0 / num13;
						array[2] = d1mach(2);
						double num26 = zabs(num16, num17);
						int num27 = 2;
						if (!(num26 > array[0]))
						{
							num27 = 1;
						}
						else if (!(num26 < array[1]))
						{
							num27 = 3;
						}
						double num28 = array[num27 - 1];
						num5 *= array3[num27 - 1];
						num6 *= array3[num27 - 1];
						num16 *= array3[num27 - 1];
						num17 *= array3[num27 - 1];
						double num29 = array2[num27 - 1];
						for (int i = 3; i <= n; i++)
						{
							cr2 = num16;
							ci2 = num17;
							num16 = num23 * cr2 - num24 * ci2 + num5;
							num17 = num23 * ci2 + num24 * cr2 + num6;
							num5 = cr2;
							num6 = ci2;
							s1r = num16 * num29;
							s1i = num17 * num29;
							cr2 = s1r;
							ci2 = s1i;
							s2r = yr[i - 1];
							s2i = yi[i - 1];
							if (kode != 1 && iuf >= 0)
							{
								zs1s2(num3, num4, ref s1r, ref s1i, ref s2r, ref s2i, ref nz2, num13, alim, ref iuf);
								nz += nz2;
								double num14 = num2;
								double num15 = num;
								num2 = s1r;
								num = s1i;
								if (iuf == 3)
								{
									iuf = -4;
									num5 = num14 * array3[num27 - 1];
									num6 = num15 * array3[num27 - 1];
									num16 = num2 * array3[num27 - 1];
									num17 = num * array3[num27 - 1];
									cr2 = num2;
									ci2 = num;
								}
							}
							cr = num11 * s1r - num12 * s1i;
							ci = num11 * s1i + num12 * s1r;
							yr[i - 1] = cr + cr3 * s2r - ci3 * s2i;
							yi[i - 1] = ci + cr3 * s2i + ci3 * s2r;
							num23 += num20;
							num24 += num21;
							num11 = 0.0 - num11;
							num12 = 0.0 - num12;
							if (num27 < 3)
							{
								cr = Math.Abs(s1r);
								ci = Math.Abs(s1i);
								if (!(Math.Max(cr, ci) <= num28))
								{
									num27++;
									num28 = array[num27 - 1];
									num5 *= num29;
									num6 *= num29;
									num16 = cr2;
									num17 = ci2;
									num5 *= array3[num27 - 1];
									num6 *= array3[num27 - 1];
									num16 *= array3[num27 - 1];
									num17 *= array3[num27 - 1];
									num29 = array2[num27 - 1];
								}
							}
						}
						return 0;
					}
				}
				nz = -1;
				if (nz2 == -2)
				{
					nz = -2;
				}
				return 0;
			}

			private static int zasyi(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, double rl, double tol, double elim, double alim)
			{
				double bi = 0.0;
				double br = 0.0;
				nz = 0;
				double num = zabs(zr, zi);
				double num2 = Math.Sqrt(d1mach(1) * 1000.0);
				int num3 = Math.Min(2, n);
				double num4 = fnu + (double)(n - num3);
				double num5 = 1.0 / num;
				double br2 = zr * num5;
				double bi2 = (0.0 - zi) * num5;
				double br3 = 1.0 / (2.0 * Math.PI) * br2 * num5;
				double bi3 = 1.0 / (2.0 * Math.PI) * bi2 * num5;
				zsqrt(br3, bi3, ref br3, ref bi3);
				double num6 = zr;
				double ai = zi;
				if (kode == 2)
				{
					num6 = 0.0;
					ai = zi;
				}
				if (!(Math.Abs(num6) > elim))
				{
					double num7 = num4 + num4;
					int num8 = 1;
					if (!(Math.Abs(num6) > alim) || n <= 2)
					{
						num8 = 0;
						zexp(num6, ai, ref br2, ref bi2);
						zmlt(br3, bi3, br2, bi2, ref br3, ref bi3);
					}
					double num9 = 0.0;
					if (num7 > num2)
					{
						num9 = num7 * num7;
					}
					double num10 = zr * 8.0;
					double num11 = zi * 8.0;
					double num12 = 8.0 * num;
					double num13 = tol / num12;
					int num14 = (int)(rl + rl) + 2;
					double num15 = 0.0;
					double num16 = 0.0;
					double num19;
					if (zi != 0.0)
					{
						int num17 = (int)fnu;
						double num18 = (fnu - (double)num17) * Math.PI;
						num17 = num17 + n - num3;
						num19 = 0.0 - Math.Sin(num18);
						double num20 = Math.Cos(num18);
						if (zi < 0.0)
						{
							num20 = 0.0 - num20;
						}
						num15 = num19;
						num16 = num20;
						if (num17 % 2 != 0)
						{
							num15 = 0.0 - num15;
							num16 = 0.0 - num16;
						}
					}
					int i;
					for (i = 1; i <= num3; i++)
					{
						double num21 = num9 - 1.0;
						double num22 = num13 * Math.Abs(num21);
						double num23 = 1.0;
						double num24 = 1.0;
						double num25 = 0.0;
						double num26 = 1.0;
						double num27 = 0.0;
						br = 1.0;
						bi = 0.0;
						num19 = 0.0;
						double num28 = 1.0;
						double num29 = num12;
						double num30 = num10;
						double num31 = num11;
						int num32 = 1;
						while (true)
						{
							if (num32 <= num14)
							{
								zdiv(br, bi, num30, num31, ref br2, ref bi2);
								br = br2 * num21;
								bi = bi2 * num21;
								num26 += br;
								num27 += bi;
								num23 = 0.0 - num23;
								num24 += br * num23;
								num25 += bi * num23;
								num30 += num10;
								num31 += num11;
								num28 = num28 * Math.Abs(num21) / num29;
								num29 += num12;
								num19 += 8.0;
								num21 -= num19;
								if (num28 <= num22)
								{
									break;
								}
								num32++;
								continue;
							}
							nz = -2;
							return 0;
						}
						double num33 = num24;
						double num34 = num25;
						if (!(zr + zr >= elim))
						{
							double num35 = zr + zr;
							double num36 = zi + zi;
							zexp(0.0 - num35, 0.0 - num36, ref br2, ref bi2);
							zmlt(br2, bi2, num15, num16, ref br2, ref bi2);
							zmlt(br2, bi2, num26, num27, ref br2, ref bi2);
							num33 += br2;
							num34 += bi2;
						}
						num9 = num9 + num4 * 8.0 + 4.0;
						num15 = 0.0 - num15;
						num16 = 0.0 - num16;
						int num37 = n - num3 + i;
						yr[num37 - 1] = num33 * br3 - num34 * bi3;
						yi[num37 - 1] = num33 * bi3 + num34 * br3;
					}
					if (n <= 2)
					{
						return 0;
					}
					i = n - 2;
					num19 = i;
					br2 = zr * num5;
					bi2 = (0.0 - zi) * num5;
					double num38 = (br2 + br2) * num5;
					double num39 = (bi2 + bi2) * num5;
					for (int j = 3; j <= n; j++)
					{
						yr[i - 1] = (num19 + fnu) * (num38 * yr[i] - num39 * yi[i]) + yr[i + 1];
						yi[i - 1] = (num19 + fnu) * (num38 * yi[i] + num39 * yr[i]) + yi[i + 1];
						num19 -= 1.0;
						i--;
					}
					if (num8 == 0)
					{
						return 0;
					}
					zexp(num6, ai, ref br, ref bi);
					for (int j = 1; j <= n; j++)
					{
						br2 = yr[j - 1] * br - yi[j - 1] * bi;
						yi[j - 1] = yr[j] * bi + yi[j - 1] * br;
						yr[j - 1] = br2;
					}
					return 0;
				}
				nz = -1;
				return 0;
			}

			private static int zbinu(double zr, double zi, double fnu, int kode, int n, double[] cyr, double[] cyi, ref int nz, double rl, double fnul, double tol, double elim, double alim)
			{
				int nlast = 0;
				int num = 0;
				int nz2 = 0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				nz = 0;
				double num2 = zabs(zr, zi);
				int num3 = n;
				double num4 = fnu + (double)(n - 1);
				if (num2 <= 2.0 || !(num2 * num2 * 0.25 > num4 + 1.0))
				{
					zseri(zr, zi, fnu, kode, num3, cyr, cyi, ref nz2, tol, elim, alim);
					int num5 = Math.Abs(nz2);
					nz += num5;
					num3 -= num5;
					if (num3 == 0)
					{
						return 0;
					}
					if (nz2 >= 0)
					{
						goto IL_021f;
					}
					num4 = fnu + (double)(num3 - 1);
				}
				if (!(num2 < rl))
				{
					if (num4 <= 1.0 || !(num2 + num2 < num4 * num4))
					{
						zasyi(zr, zi, fnu, kode, num3, cyr, cyi, ref nz2, rl, tol, elim, alim);
						if (nz2 >= 0)
						{
							goto IL_021f;
						}
						goto IL_0221;
					}
				}
				else if (num4 <= 1.0)
				{
					goto IL_013b;
				}
				zuoik(zr, zi, fnu, kode, 1, num3, cyr, cyi, ref nz2, tol, elim, alim);
				if (nz2 >= 0)
				{
					nz += nz2;
					num3 -= nz2;
					if (num3 == 0)
					{
						return 0;
					}
					num4 = fnu + (double)(num3 - 1);
					if (num4 > fnul || num2 > fnul)
					{
						num = (int)(fnul - num4) + 1;
						num = Math.Max(num, 0);
						zbuni(zr, zi, fnu, kode, num3, cyr, cyi, ref nz2, num, ref nlast, fnul, tol, elim, alim);
						if (nz2 < 0)
						{
							goto IL_0221;
						}
						nz += nz2;
						if (nlast == 0)
						{
							goto IL_021f;
						}
						num3 = nlast;
					}
					if (!(num2 > rl))
					{
						goto IL_013b;
					}
					zuoik(zr, zi, fnu, kode, 2, 2, array2, array, ref nz2, tol, elim, alim);
					if (nz2 < 0)
					{
						nz = num3;
						for (int i = 1; i <= num3; i++)
						{
							cyr[i - 1] = 0.0;
							cyi[i - 1] = 0.0;
						}
						return 0;
					}
					if (nz2 <= 0)
					{
						zwrsk(zr, zi, fnu, kode, num3, cyr, cyi, ref nz2, array2, array, tol, elim, alim);
						if (nz2 >= 0)
						{
							goto IL_021f;
						}
					}
				}
				goto IL_0221;
				IL_021f:
				return 0;
				IL_0221:
				nz = -1;
				if (nz2 == -2)
				{
					nz = -2;
				}
				return 0;
				IL_013b:
				zmlri(zr, zi, fnu, kode, num3, cyr, cyi, ref nz2, tol);
				if (nz2 >= 0)
				{
					goto IL_021f;
				}
				goto IL_0221;
			}

			private static int zbknu(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, double tol, double elim, double alim)
			{
				double[] array = new double[8] { 0.5772156649015329, -0.04200263503409524, -0.04219773455554433, 0.0072189432466631, -0.00021524167411495098, -2.013485478078824E-05, 1.133027231981696E-06, 6.116095104481416E-09 };
				double cchi = 0.0;
				double cchr = 0.0;
				double num = 0.0;
				double num2 = 0.0;
				double ci = 0.0;
				double cr = 0.0;
				double cshi = 0.0;
				double cshr = 0.0;
				double ci2 = 0.0;
				double cr2 = 0.0;
				double num3 = 0.0;
				double ci3 = 0.0;
				double cr3 = 0.0;
				double bi = 0.0;
				double br = 0.0;
				double ci4 = 0.0;
				double cr4 = 0.0;
				int ierr = 0;
				int nz2 = 0;
				double[] array2 = new double[2];
				double[] array3 = new double[2];
				double[] array4 = new double[3];
				double[] array5 = new double[3];
				double[] array6 = new double[3];
				double num4 = zabs(zr, zi);
				double num5 = 1.0 / tol;
				array4[0] = num5;
				array4[1] = 1.0;
				array4[2] = tol;
				array5[0] = tol;
				array5[1] = 1.0;
				array5[2] = num5;
				array6[0] = 1000.0 * d1mach(1) / tol;
				array6[1] = 1.0 / array6[0];
				array6[2] = d1mach(2);
				nz = 0;
				int num6 = 0;
				int num7 = kode;
				double num8 = 1.0 / num4;
				double br2 = zr * num8;
				double bi2 = (0.0 - zi) * num8;
				double num9 = (br2 + br2) * num8;
				double num10 = (bi2 + bi2) * num8;
				int num11 = (int)(fnu + 0.5);
				double num12 = fnu - (double)num11;
				int num32;
				double num27;
				double num28;
				double num16;
				if (Math.Abs(num12) != 0.5)
				{
					num3 = 0.0;
					if (Math.Abs(num12) > tol)
					{
						num3 = num12 * num12;
					}
					if (!(num4 > 2.0))
					{
						double num13 = 1.0;
						zlog(num9, num10, ref br, ref bi, ref ierr);
						double num14 = br * num12;
						double num15 = bi * num12;
						zshch(num14, num15, ref cshr, ref cshi, ref cchr, ref cchi);
						if (num12 != 0.0)
						{
							num13 = num12 * Math.PI;
							num13 /= Math.Sin(num13);
							br = cshr / num12;
							bi = cshi / num12;
						}
						double z = 1.0 + num12;
						num16 = Math.Exp(0.0 - dgamln(z, ref ierr));
						double num17 = 1.0 / (num16 * num13);
						double num21;
						double num18;
						if (!(Math.Abs(num12) > 0.1))
						{
							num18 = 1.0;
							double num19 = array[0];
							for (int i = 2; i <= 8; i++)
							{
								num18 *= num3;
								double num20 = array[i - 1] * num18;
								num19 += num20;
								if (Math.Abs(num20) < tol)
								{
									break;
								}
							}
							num21 = 0.0 - num19;
						}
						else
						{
							num21 = (num17 - num16) / (num12 + num12);
						}
						double num22 = (num17 + num16) * 0.5;
						double br3 = num13 * (cchr * num21 + br * num22);
						double bi3 = num13 * (cchi * num21 + bi * num22);
						zexp(num14, num15, ref br2, ref bi2);
						double num23 = 0.5 * br2 / num16;
						double num24 = 0.5 * bi2 / num16;
						zdiv(0.5, 0.0, br2, bi2, ref cr3, ref ci3);
						double num25 = cr3 / num17;
						double num26 = ci3 / num17;
						num27 = br3;
						num28 = bi3;
						cr4 = num23;
						ci4 = num24;
						num18 = 1.0;
						double num29 = 1.0;
						num2 = 1.0;
						num = 0.0;
						double num30 = 1.0 - num3;
						if (num11 <= 0 && n <= 1)
						{
							if (!(num4 < tol))
							{
								zmlt(zr, zi, zr, zi, ref cr2, ref ci2);
								cr2 = 0.25 * cr2;
								ci2 = 0.25 * ci2;
								num17 = 0.25 * num4 * num4;
								do
								{
									br3 = (br3 * num18 + num23 + num25) / num30;
									bi3 = (bi3 * num18 + num24 + num26) / num30;
									br2 = 1.0 / (num18 - num12);
									num23 *= br2;
									num24 *= br2;
									br2 = 1.0 / (num18 + num12);
									num25 *= br2;
									num26 *= br2;
									br2 = num2 * cr2 - num * ci2;
									double num31 = 1.0 / num18;
									num = (num2 * ci2 + num * cr2) * num31;
									num2 = br2 * num31;
									num27 = num2 * br3 - num * bi3 + num27;
									num28 = num2 * bi3 + num * br3 + num28;
									num29 = num29 * num17 * num31;
									num30 = num30 + num18 + num18 + 1.0;
									num18 += 1.0;
								}
								while (num29 > tol);
							}
							yr[0] = num27;
							yi[0] = num28;
							if (num7 == 1)
							{
								return 0;
							}
							zexp(zr, zi, ref br2, ref bi2);
							zmlt(num27, num28, br2, bi2, ref yr[0], ref yi[0]);
							return 0;
						}
						if (!(num4 < tol))
						{
							zmlt(zr, zi, zr, zi, ref cr2, ref ci2);
							cr2 = 0.25 * cr2;
							ci2 = 0.25 * ci2;
							num17 = 0.25 * num4 * num4;
							do
							{
								br3 = (br3 * num18 + num23 + num25) / num30;
								bi3 = (bi3 * num18 + num24 + num26) / num30;
								br2 = 1.0 / (num18 - num12);
								num23 *= br2;
								num24 *= br2;
								br2 = 1.0 / (num18 + num12);
								num25 *= br2;
								num26 *= br2;
								br2 = num2 * cr2 - num * ci2;
								double num31 = 1.0 / num18;
								num = (num2 * ci2 + num * cr2) * num31;
								num2 = br2 * num31;
								num27 = num2 * br3 - num * bi3 + num27;
								num28 = num2 * bi3 + num * br3 + num28;
								br2 = num23 - br3 * num18;
								bi2 = num24 - bi3 * num18;
								cr4 = num2 * br2 - num * bi2 + cr4;
								ci4 = num2 * bi2 + num * br2 + ci4;
								num29 = num29 * num17 * num31;
								num30 = num30 + num18 + num18 + 1.0;
								num18 += 1.0;
							}
							while (num29 > tol);
						}
						num32 = 2;
						num29 = fnu + 1.0;
						num18 = num29 * Math.Abs(br);
						if (num18 > alim)
						{
							num32 = 3;
						}
						br2 = array4[num32 - 1];
						double ar = cr4 * br2;
						double ai = ci4 * br2;
						zmlt(ar, ai, num9, num10, ref cr4, ref ci4);
						num27 *= br2;
						num28 *= br2;
						if (num7 != 1)
						{
							zexp(zr, zi, ref br3, ref bi3);
							zmlt(num27, num28, br3, bi3, ref num27, ref num28);
							zmlt(cr4, ci4, br3, bi3, ref cr4, ref ci4);
						}
						goto IL_0c63;
					}
				}
				zsqrt(zr, zi, ref br2, ref bi2);
				zdiv(1.2533141373155003, 0.0, br2, bi2, ref cr, ref ci);
				num32 = 2;
				if (num7 != 2)
				{
					if (!(zr > alim))
					{
						br2 = Math.Exp(0.0 - zr) * array4[num32 - 1];
						bi2 = (0.0 - br2) * Math.Sin(zi);
						br2 *= Math.Cos(zi);
						zmlt(cr, ci, br2, bi2, ref cr, ref ci);
					}
					else
					{
						num7 = 2;
						num6 = 1;
						num32 = 2;
					}
				}
				double num44;
				double num45;
				int num38;
				double num37;
				if (Math.Abs(num12) != 0.5)
				{
					double num18 = Math.Cos(Math.PI * num12);
					num18 = Math.Abs(num18);
					if (num18 != 0.0)
					{
						double num33 = Math.Abs(0.25 - num3);
						if (num33 != 0.0)
						{
							double num17 = i1mach(14) - 1;
							num17 = num17 * d1mach(5) * 3.321928094;
							num17 = Math.Max(num17, 12.0);
							num17 = Math.Min(num17, 60.0);
							num16 = 2.0 / 3.0 * num17 - 6.0;
							if (zr == 0.0)
							{
								num17 = Math.PI / 2.0;
							}
							else
							{
								num17 = Math.Atan(zi / zr);
								num17 = Math.Abs(num17);
							}
							double num35;
							double num36;
							double ar;
							if (!(num16 > num4))
							{
								double num34 = num18 / (Math.PI * num4 * tol);
								num35 = 1.0;
								if (!(num34 < 1.0))
								{
									num36 = 2.0;
									num2 = num4 + num4 + 2.0;
									num37 = 0.0;
									ar = 1.0;
									num38 = 1;
									while (true)
									{
										if (num38 <= 30)
										{
											num18 = num33 / num36;
											double num39 = num2 / (num35 + 1.0);
											cr3 = ar;
											ar = num39 * ar - num37 * num18;
											num37 = cr3;
											num2 += 2.0;
											num36 = num36 + num35 + num35 + 2.0;
											num33 = num33 + num35 + num35;
											num35 += 1.0;
											br2 = Math.Abs(ar) * num35;
											if (num34 < br2)
											{
												break;
											}
											num38++;
											continue;
										}
										nz = -2;
										return 0;
									}
									num35 += 6.0 / Math.PI * num17 * Math.Sqrt(num16 / num4);
									num33 = Math.Abs(0.25 - num3);
								}
							}
							else
							{
								double z = Math.Sqrt(num4);
								num18 = 1.8976999933151775 * num18 / (tol * Math.Sqrt(z));
								double d = 3.0 * num17 / (1.0 + num4);
								double d2 = 14.7 * num17 / (28.0 + num4);
								num18 = (Math.Log(num18) + num4 * Math.Cos(d) / (1.0 + 0.008 * num4)) / Math.Cos(d2);
								num35 = 97.0 / 800.0 * num18 * num18 / num4 + 1.5;
							}
							int i = (int)num35;
							num35 = i;
							num36 = num35 * num35;
							num37 = 0.0;
							double num40 = 0.0;
							ar = tol;
							double ai = 0.0;
							double num41 = ar;
							double num42 = ai;
							for (num38 = 1; num38 <= i; num38++)
							{
								double num29 = num36 - num35;
								num18 = (num36 + num35) / (num29 + num33);
								double num31 = 2.0 / (num35 + 1.0);
								double num39 = (num35 + zr) * num31;
								double num43 = zi * num31;
								cr3 = ar;
								ci3 = ai;
								ar = (cr3 * num39 - ci3 * num43 - num37) * num18;
								ai = (ci3 * num39 + cr3 * num43 - num40) * num18;
								num37 = cr3;
								num40 = ci3;
								num41 += ar;
								num42 += ai;
								num36 = num29 - num35 + 1.0;
								num35 -= 1.0;
							}
							double num20 = zabs(num41, num42);
							cr3 = 1.0 / num20;
							num27 = ar * cr3;
							num28 = ai * cr3;
							num41 *= cr3;
							num42 = (0.0 - num42) * cr3;
							zmlt(cr, ci, num27, num28, ref br2, ref bi2);
							zmlt(br2, bi2, num41, num42, ref num27, ref num28);
							if (num11 <= 0 && n <= 1)
							{
								num44 = zr;
								num45 = zi;
								if (num6 != 1)
								{
									goto IL_0db1;
								}
								goto IL_1099;
							}
							num20 = zabs(ar, ai);
							cr3 = 1.0 / num20;
							num37 *= cr3;
							num40 *= cr3;
							ar *= cr3;
							ai = (0.0 - ai) * cr3;
							zmlt(num37, num40, ar, ai, ref cr3, ref ci3);
							br2 = num12 + 0.5 - cr3;
							bi2 = 0.0 - ci3;
							zdiv(br2, bi2, zr, zi, ref br2, ref bi2);
							br2 += 1.0;
							zmlt(br2, bi2, num27, num28, ref cr4, ref ci4);
							goto IL_0c63;
						}
					}
				}
				num27 = cr;
				num28 = ci;
				cr4 = cr;
				ci4 = ci;
				goto IL_0c63;
				IL_0def:
				int num46 = num46 + 1;
				if (num46 > n)
				{
					return 0;
				}
				num37 = array5[num32 - 1];
				double num47 = array6[num32 - 1];
				for (num38 = num46; num38 <= n; num38++)
				{
					double ar = cr4;
					double ai = ci4;
					cr4 = num2 * ar - num * ai + num27;
					ci4 = num * ar + num2 * ai + num28;
					num27 = ar;
					num28 = ai;
					num2 += num9;
					num += num10;
					ar = cr4 * num37;
					ai = ci4 * num37;
					yr[num38 - 1] = ar;
					yi[num38 - 1] = ai;
					if (num32 < 3)
					{
						br2 = Math.Abs(ar);
						bi2 = Math.Abs(ai);
						if (!(Math.Max(br2, bi2) <= num47))
						{
							num32++;
							num47 = array6[num32 - 1];
							num27 *= num37;
							num28 *= num37;
							cr4 = ar;
							ci4 = ai;
							br2 = array4[num32 - 1];
							num27 *= br2;
							num28 *= br2;
							cr4 *= br2;
							ci4 *= br2;
							num37 = array5[num32 - 1];
						}
					}
				}
				return 0;
				IL_0db1:
				br2 = array5[num32 - 1];
				yr[0] = num27 * br2;
				yi[0] = num28 * br2;
				if (n == 1)
				{
					return 0;
				}
				yr[1] = cr4 * br2;
				yi[1] = ci4 * br2;
				if (n == 2)
				{
					return 0;
				}
				num46 = 2;
				goto IL_0def;
				IL_0cba:
				num37 = array5[num32 - 1];
				num47 = array6[num32 - 1];
				int num48;
				for (num38 = num48; num38 <= num11; num38++)
				{
					br2 = cr4;
					bi2 = ci4;
					cr4 = num2 * br2 - num * bi2 + num27;
					ci4 = num2 * bi2 + num * br2 + num28;
					num27 = br2;
					num28 = bi2;
					num2 += num9;
					num += num10;
					if (num32 < 3)
					{
						double ar = cr4 * num37;
						double ai = ci4 * num37;
						br2 = Math.Abs(ar);
						bi2 = Math.Abs(ai);
						if (!(Math.Max(br2, bi2) <= num47))
						{
							num32++;
							num47 = array6[num32 - 1];
							num27 *= num37;
							num28 *= num37;
							cr4 = ar;
							ci4 = ai;
							br2 = array4[num32 - 1];
							num27 *= br2;
							num28 *= br2;
							cr4 *= br2;
							ci4 *= br2;
							num37 = array5[num32 - 1];
						}
					}
				}
				if (n == 1)
				{
					num27 = cr4;
					num28 = ci4;
				}
				goto IL_0db1;
				IL_1099:
				yr[0] = num27;
				yi[0] = num28;
				if (n != 1)
				{
					yr[1] = cr4;
					yi[1] = ci4;
				}
				num47 = array6[0];
				zkscl(num44, num45, fnu, n, yr, yi, ref nz, num9, num10, num47, tol, elim);
				num11 = n - nz;
				if (num11 <= 0)
				{
					return 0;
				}
				num46 = nz + 1;
				num27 = yr[num46 - 1];
				num28 = yi[num46 - 1];
				yr[num46 - 1] = num27 * array5[0];
				yi[num46 - 1] = num28 * array5[0];
				if (num11 == 1)
				{
					return 0;
				}
				num46 = nz + 2;
				cr4 = yr[num46 - 1];
				ci4 = yi[num46 - 1];
				yr[num46 - 1] = cr4 * array5[0];
				yi[num46 - 1] = ci4 * array5[0];
				if (num11 == 2)
				{
					return 0;
				}
				num16 = fnu + (double)(num46 - 1);
				num2 = num16 * num9;
				num = num16 * num10;
				num32 = 1;
				goto IL_0def;
				IL_1048:
				num32 = 1;
				num48 = num38 + 1;
				int num49;
				cr4 = array2[num49 - 1];
				ci4 = array3[num49 - 1];
				num49 = 3 - num49;
				num27 = array2[num49 - 1];
				num28 = array3[num49 - 1];
				if (num48 <= num11)
				{
					goto IL_0cba;
				}
				if (n == 1)
				{
					num27 = cr4;
					num28 = ci4;
				}
				goto IL_0db1;
				IL_0c63:
				br2 = num12 + 1.0;
				num2 = br2 * num9;
				num = br2 * num10;
				if (n == 1)
				{
					num11--;
				}
				if (num11 <= 0)
				{
					if (n <= 1)
					{
						num27 = cr4;
						num28 = ci4;
					}
					num44 = zr;
					num45 = zi;
					if (num6 != 1)
					{
						goto IL_0db1;
					}
				}
				else
				{
					num48 = 1;
					if (num6 != 1)
					{
						goto IL_0cba;
					}
					double num50 = 0.5 * elim;
					double num51 = Math.Exp(0.0 - elim);
					num47 = array6[0];
					num44 = zr;
					num45 = zi;
					int num52 = -1;
					num49 = 2;
					for (num38 = 1; num38 <= num11; num38++)
					{
						br2 = cr4;
						bi2 = ci4;
						cr4 = br2 * num2 - bi2 * num + num27;
						ci4 = bi2 * num2 + br2 * num + num28;
						num27 = br2;
						num28 = bi2;
						num2 += num9;
						num += num10;
						double num53 = Math.Log(zabs(cr4, ci4));
						double ar = 0.0 - num44 + num53;
						if (!(ar < 0.0 - elim))
						{
							zlog(cr4, ci4, ref br2, ref bi2, ref ierr);
							ar = 0.0 - num44 + br2;
							double ai = 0.0 - num45 + bi2;
							double num54 = Math.Exp(ar) / tol;
							num37 = num54 * Math.Cos(ai);
							double num40 = num54 * Math.Sin(ai);
							zuchk(num37, num40, ref nz2, num47, tol);
							if (nz2 == 0)
							{
								num49 = 3 - num49;
								array2[num49 - 1] = num37;
								array3[num49 - 1] = num40;
								if (num52 != num38 - 1)
								{
									num52 = num38;
									continue;
								}
								goto IL_1048;
							}
						}
						if (!(num53 < num50))
						{
							num44 -= elim;
							num27 *= num51;
							num28 *= num51;
							cr4 *= num51;
							ci4 *= num51;
						}
					}
					if (n == 1)
					{
						num27 = cr4;
						num28 = ci4;
					}
				}
				goto IL_1099;
			}

			private static int zbuni(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, int nui, ref int nlast, double fnul, double tol, double elim, double alim)
			{
				int nz2 = 0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				double[] array3 = new double[3];
				nz = 0;
				double num = Math.Abs(zr) * 1.7321;
				double num2 = Math.Abs(zi);
				int num3 = 1;
				if (num2 > num)
				{
					num3 = 2;
				}
				if (nui != 0)
				{
					double num4 = nui;
					double num5 = fnu + (double)(n - 1);
					double fnu2 = num5 + num4;
					if (num3 != 2)
					{
						zuni1(zr, zi, fnu2, kode, 2, array2, array, ref nz2, ref nlast, fnul, tol, elim, alim);
					}
					else
					{
						zuni2(zr, zi, fnu2, kode, 2, array2, array, ref nz2, ref nlast, fnul, tol, elim, alim);
					}
					if (nz2 >= 0)
					{
						if (nz2 == 0)
						{
							double num6 = zabs(array2[0], array[0]);
							array3[0] = d1mach(1) * 1000.0 / tol;
							array3[1] = 1.0 / array3[0];
							array3[2] = array3[1];
							int num7 = 2;
							double num8 = array3[1];
							double num9 = 1.0;
							if (!(num6 > array3[0]))
							{
								num7 = 1;
								num8 = array3[0];
								num9 = 1.0 / tol;
							}
							else if (!(num6 < array3[1]))
							{
								num7 = 3;
								num8 = array3[2];
								num9 = tol;
							}
							double num10 = 1.0 / num9;
							double num11 = array2[1] * num9;
							double num12 = array[1] * num9;
							double num13 = array2[0] * num9;
							double num14 = array[0] * num9;
							double num15 = 1.0 / zabs(zr, zi);
							num6 = zr * num15;
							double num16 = (0.0 - zi) * num15;
							double num17 = (num6 + num6) * num15;
							double num18 = (num16 + num16) * num15;
							for (int i = 1; i <= nui; i++)
							{
								num6 = num13;
								num16 = num14;
								num13 = (num5 + num4) * (num17 * num6 - num18 * num16) + num11;
								num14 = (num5 + num4) * (num17 * num16 + num18 * num6) + num12;
								num11 = num6;
								num12 = num16;
								num4 += -1.0;
								if (num7 < 3)
								{
									num6 = num13 * num10;
									num16 = num14 * num10;
									double val = Math.Abs(num6);
									double val2 = Math.Abs(num16);
									if (!(Math.Max(val, val2) <= num8))
									{
										num7++;
										num8 = array3[num7 - 1];
										num11 *= num10;
										num12 *= num10;
										num13 = num6;
										num14 = num16;
										num9 *= tol;
										num10 = 1.0 / num9;
										num11 *= num9;
										num12 *= num9;
										num13 *= num9;
										num14 *= num9;
									}
								}
							}
							yr[n - 1] = num13 * num10;
							yi[n - 1] = num14 * num10;
							if (n == 1)
							{
								return 0;
							}
							int num19 = n - 1;
							num4 = num19;
							int num20 = num19;
							for (int i = 1; i <= num19; i++)
							{
								num6 = num13;
								num16 = num14;
								num13 = (fnu + num4) * (num17 * num6 - num18 * num16) + num11;
								num14 = (fnu + num4) * (num17 * num16 + num18 * num6) + num12;
								num11 = num6;
								num12 = num16;
								num6 = num13 * num10;
								num16 = num14 * num10;
								yr[num20 - 1] = num6;
								yi[num20 - 1] = num16;
								num4 += -1.0;
								num20--;
								if (num7 < 3)
								{
									double val3 = Math.Abs(num6);
									double val2 = Math.Abs(num16);
									if (!(Math.Max(val3, val2) <= num8))
									{
										num7++;
										num8 = array3[num7 - 1];
										num11 *= num10;
										num12 *= num10;
										num13 = num6;
										num14 = num16;
										num9 *= tol;
										num10 = 1.0 / num9;
										num11 *= num9;
										num12 *= num9;
										num13 *= num9;
										num14 *= num9;
									}
								}
							}
							return 0;
						}
						nlast = n;
						return 0;
					}
				}
				else
				{
					if (num3 != 2)
					{
						zuni1(zr, zi, fnu, kode, n, yr, yi, ref nz2, ref nlast, fnul, tol, elim, alim);
					}
					else
					{
						zuni2(zr, zi, fnu, kode, n, yr, yi, ref nz2, ref nlast, fnul, tol, elim, alim);
					}
					if (nz2 >= 0)
					{
						nz = nz2;
						return 0;
					}
				}
				nz = -1;
				if (nz2 == -2)
				{
					nz = -2;
				}
				return 0;
			}

			private static int zbunk(double zr, double zi, double fnu, int kode, int mr, int n, double[] yr, double[] yi, ref int nz, double tol, double elim, double alim)
			{
				nz = 0;
				double num = Math.Abs(zr) * 1.7321;
				if (!(Math.Abs(zi) > num))
				{
					zunk1(zr, zi, fnu, kode, mr, n, yr, yi, ref nz, tol, elim, alim);
				}
				else
				{
					zunk2(zr, zi, fnu, kode, mr, n, yr, yi, ref nz, tol, elim, alim);
				}
				return 0;
			}

			private static int zkscl(double zrr, double zri, double fnu, int n, double[] yr, double[] yi, ref int nz, double rzr, double rzi, double ascle, double tol, double elim)
			{
				double bi = 0.0;
				double br = 0.0;
				int ierr = 0;
				int nz2 = 0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				nz = 0;
				int num = 0;
				int num2 = Math.Min(2, n);
				double num3;
				double num4;
				int i;
				for (i = 1; i <= num2; i++)
				{
					num3 = yr[i - 1];
					num4 = yi[i - 1];
					array2[i - 1] = num3;
					array[i - 1] = num4;
					double d = zabs(num3, num4);
					double num5 = 0.0 - zrr + Math.Log(d);
					nz++;
					yr[i - 1] = 0.0;
					yi[i - 1] = 0.0;
					if (!(num5 < 0.0 - elim))
					{
						zlog(num3, num4, ref br, ref bi, ref ierr);
						br -= zrr;
						bi -= zri;
						double num6 = Math.Exp(br) / tol;
						br = num6 * Math.Cos(bi);
						bi = num6 * Math.Sin(bi);
						zuchk(br, bi, ref nz2, ascle, tol);
						if (nz2 == 0)
						{
							yr[i - 1] = br;
							yi[i - 1] = bi;
							num = i;
							nz--;
						}
					}
				}
				if (n == 1)
				{
					return 0;
				}
				if (num <= 1)
				{
					yr[0] = 0.0;
					yi[0] = 0.0;
					nz = 2;
				}
				if (n == 2)
				{
					return 0;
				}
				if (nz == 0)
				{
					return 0;
				}
				double num7 = fnu + 1.0;
				double num8 = num7 * rzr;
				double num9 = num7 * rzi;
				num3 = array2[0];
				num4 = array[0];
				double num10 = array2[1];
				double num11 = array[1];
				double num12 = elim * 0.5;
				double num13 = Math.Exp(0.0 - elim);
				double num14 = zrr;
				i = 3;
				while (true)
				{
					if (i <= n)
					{
						int num15 = i;
						br = num10;
						bi = num11;
						num10 = num8 * br - num9 * bi + num3;
						num11 = num9 * br + num8 * bi + num4;
						num3 = br;
						num4 = bi;
						num8 += rzr;
						num9 += rzi;
						double d = zabs(num10, num11);
						double num16 = Math.Log(d);
						double num17 = 0.0 - num14 + num16;
						nz++;
						yr[i - 1] = 0.0;
						yi[i - 1] = 0.0;
						if (!(num17 < 0.0 - elim))
						{
							zlog(num10, num11, ref br, ref bi, ref ierr);
							br -= num14;
							bi -= zri;
							double num18 = Math.Exp(br) / tol;
							br = num18 * Math.Cos(bi);
							bi = num18 * Math.Sin(bi);
							zuchk(br, bi, ref nz2, ascle, tol);
							if (nz2 == 0)
							{
								yr[i - 1] = br;
								yi[i - 1] = bi;
								nz--;
								if (num != num15 - 1)
								{
									num = num15;
									goto IL_02ba;
								}
								nz = num15 - 2;
								break;
							}
						}
						if (!(num16 < num12))
						{
							num14 -= elim;
							num3 *= num13;
							num4 *= num13;
							num10 *= num13;
							num11 *= num13;
						}
						goto IL_02ba;
					}
					nz = n;
					if (num == n)
					{
						nz = n - 1;
					}
					break;
					IL_02ba:
					i++;
				}
				for (i = 1; i <= nz; i++)
				{
					yr[i - 1] = 0.0;
					yi[i - 1] = 0.0;
				}
				return 0;
			}

			private static int zmlri(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, double tol)
			{
				double ci = 0.0;
				double cr = 0.0;
				int ierr = 0;
				double num = d1mach(1) / tol;
				nz = 0;
				double num2 = zabs(zr, zi);
				int num3 = (int)num2;
				int num4 = (int)fnu;
				int num5 = num4 + n - 1;
				double num6 = (double)num3 + 1.0;
				double num7 = 1.0 / num2;
				double br = zr * num7;
				double bi = (0.0 - zi) * num7;
				double num8 = br * num6 * num7;
				double num9 = bi * num6 * num7;
				double num10 = (br + br) * num7;
				double num11 = (bi + bi) * num7;
				double num12 = 0.0;
				double num13 = 0.0;
				double num14 = 1.0;
				double num15 = 0.0;
				double num16 = (num6 + 1.0) * num7;
				double num17 = num16 + Math.Sqrt(num16 * num16 - 1.0);
				double num18 = num17 * num17;
				double num19 = (num18 + num18) / ((num18 - 1.0) * (num17 - 1.0));
				num19 /= tol;
				double num20 = num6;
				int num21 = 1;
				while (num21 <= 80)
				{
					double num22 = num14;
					double num23 = num15;
					num14 = num12 - (num8 * num22 - num9 * num23);
					num15 = num13 - (num9 * num22 + num8 * num23);
					num12 = num22;
					num13 = num23;
					num8 += num10;
					num9 += num11;
					double num24 = zabs(num14, num15);
					if (!(num24 > num19 * num20 * num20))
					{
						num20 += 1.0;
						num21++;
						continue;
					}
					num21++;
					int i = 0;
					if (num5 >= num3)
					{
						num12 = 0.0;
						num13 = 0.0;
						num14 = 1.0;
						num15 = 0.0;
						num6 = (double)num5 + 1.0;
						br = zr * num7;
						bi = (0.0 - zi) * num7;
						num8 = br * num6 * num7;
						num9 = bi * num6 * num7;
						num16 = num6 * num7;
						num19 = Math.Sqrt(num16 / tol);
						int num25 = 1;
						for (i = 1; i <= 80; i++)
						{
							num22 = num14;
							num23 = num15;
							num14 = num12 - (num8 * num22 - num9 * num23);
							num15 = num13 - (num8 * num23 + num9 * num22);
							num12 = num22;
							num13 = num23;
							num8 += num10;
							num9 += num11;
							num24 = zabs(num14, num15);
							if (num24 < num19)
							{
								continue;
							}
							if (num25 != 2)
							{
								num16 = zabs(num8, num9);
								double val = num16 + Math.Sqrt(num16 * num16 - 1.0);
								double val2 = num24 / zabs(num12, num13);
								num17 = Math.Min(val, val2);
								num19 *= Math.Sqrt(num17 / (num17 * num17 - 1.0));
								num25 = 2;
								continue;
							}
							goto IL_02c6;
						}
						break;
					}
					goto IL_02c6;
					IL_02c6:
					i++;
					int num26 = Math.Max(num21 + num3, i + num5);
					double num27 = num26;
					num12 = 0.0;
					num13 = 0.0;
					num14 = num;
					num15 = 0.0;
					double num28 = fnu - (double)num4;
					double num29 = num28 + num28;
					double d = dgamln(num27 + num29 + 1.0, ref ierr) - dgamln(num27 + 1.0, ref ierr) - dgamln(num29 + 1.0, ref ierr);
					d = Math.Exp(d);
					double num30 = 0.0;
					double num31 = 0.0;
					int num32 = num26 - num5;
					for (num21 = 1; num21 <= num32; num21++)
					{
						num22 = num14;
						num23 = num15;
						num14 = num12 + (num27 + num28) * (num10 * num22 - num11 * num23);
						num15 = num13 + (num27 + num28) * (num11 * num22 + num10 * num23);
						num12 = num22;
						num13 = num23;
						num20 = 1.0 - num29 / (num27 + num29);
						num16 = d * num20;
						num30 += (num16 + d) * num12;
						num31 += (num16 + d) * num13;
						d = num16;
						num27 += -1.0;
					}
					yr[n - 1] = num14;
					yi[n - 1] = num15;
					if (n != 1)
					{
						for (num21 = 2; num21 <= n; num21++)
						{
							num22 = num14;
							num23 = num15;
							num14 = num12 + (num27 + num28) * (num10 * num22 - num11 * num23);
							num15 = num13 + (num27 + num28) * (num11 * num22 + num10 * num23);
							num12 = num22;
							num13 = num23;
							num20 = 1.0 - num29 / (num27 + num29);
							num16 = d * num20;
							num30 += (num16 + d) * num12;
							num31 += (num16 + d) * num13;
							d = num16;
							num27 += -1.0;
							int num33 = n - num21 + 1;
							yr[num33 - 1] = num14;
							yi[num33 - 1] = num15;
						}
					}
					if (num4 > 0)
					{
						for (num21 = 1; num21 <= num4; num21++)
						{
							num22 = num14;
							num23 = num15;
							num14 = num12 + (num27 + num28) * (num10 * num22 - num11 * num23);
							num15 = num13 + (num27 + num28) * (num10 * num23 + num11 * num22);
							num12 = num22;
							num13 = num23;
							num20 = 1.0 - num29 / (num27 + num29);
							num16 = d * num20;
							num30 += (num16 + d) * num12;
							num31 += (num16 + d) * num13;
							d = num16;
							num27 += -1.0;
						}
					}
					num22 = zr;
					num23 = zi;
					if (kode == 2)
					{
						num22 = 0.0;
					}
					zlog(num10, num11, ref br, ref bi, ref ierr);
					num12 = (0.0 - num28) * br + num22;
					num13 = (0.0 - num28) * bi + num23;
					num24 = dgamln(num28 + 1.0, ref ierr);
					num22 = num12 - num24;
					num23 = num13;
					num14 += num30;
					num15 += num31;
					num24 = zabs(num14, num15);
					num12 = 1.0 / num24;
					zexp(num22, num23, ref br, ref bi);
					num8 = br * num12;
					num9 = bi * num12;
					num22 = num14 * num12;
					num23 = (0.0 - num15) * num12;
					zmlt(num8, num9, num22, num23, ref cr, ref ci);
					for (num21 = 1; num21 <= n; num21++)
					{
						br = yr[num21 - 1] * cr - yi[num21 - 1] * ci;
						yi[num21 - 1] = yr[num21 - 1] * ci + yi[num21 - 1] * cr;
						yr[num21 - 1] = br;
					}
					return 0;
				}
				nz = -2;
				return 0;
			}

			private static int zrati(double zr, double zi, double fnu, int n, double[] cyr, double[] cyi, double tol)
			{
				double num = zabs(zr, zi);
				int num2 = (int)fnu + n - 1;
				int num3 = (int)num;
				double val = num3 + 1;
				double val2 = num2;
				double num4 = Math.Max(val, val2);
				int num5 = num2 - num3 - 1;
				int num6 = 1;
				int num7 = 1;
				double num8 = 1.0 / num;
				double num9 = num8 * (zr + zr) * num8;
				double num10 = (0.0 - num8) * (zi + zi) * num8;
				double num11 = num9 * num4;
				double num12 = num10 * num4;
				double num13 = 0.0 - num11;
				double num14 = 0.0 - num12;
				double num15 = 1.0;
				double num16 = 0.0;
				num11 += num9;
				num12 += num10;
				if (num5 > 0)
				{
					num5 = 0;
				}
				double num17 = zabs(num13, num14);
				double num18 = zabs(num15, num16);
				double num19 = Math.Sqrt((num17 + num17) / (num18 * tol));
				double num20 = num19;
				double num21 = 1.0 / num18;
				num15 *= num21;
				num16 *= num21;
				num13 *= num21;
				num14 *= num21;
				num17 *= num21;
				double num23;
				while (true)
				{
					num7++;
					num18 = num17;
					num8 = num13;
					double num22 = num14;
					num13 = num15 - (num11 * num8 - num12 * num22);
					num14 = num16 - (num11 * num22 + num12 * num8);
					num15 = num8;
					num16 = num22;
					num11 += num9;
					num12 += num10;
					num17 = zabs(num13, num14);
					if (!(num18 <= num20))
					{
						if (num6 == 2)
						{
							break;
						}
						num23 = zabs(num11, num12) * 0.5;
						double val3 = num23 + Math.Sqrt(num23 * num23 - 1.0);
						double num24 = Math.Min(num17 / num18, val3);
						num20 = num19 * Math.Sqrt(num24 / (num24 * num24 - 1.0));
						num6 = 2;
					}
				}
				int num25 = num7 + 1 - num5;
				num23 = num25;
				num11 = num23;
				num12 = 0.0;
				double num26 = fnu + (double)(n - 1);
				num15 = 1.0 / num17;
				num16 = 0.0;
				num13 = 0.0;
				num14 = 0.0;
				for (int i = 1; i <= num25; i++)
				{
					num8 = num15;
					double num22 = num16;
					num21 = num26 + num11;
					double num27 = num9 * num21;
					double num28 = num10 * num21;
					num15 = num8 * num27 - num22 * num28 + num13;
					num16 = num8 * num28 + num22 * num27 + num14;
					num13 = num8;
					num14 = num22;
					num11 -= 1.0;
				}
				if (num15 == 0.0 && num16 == 0.0)
				{
					num15 = tol;
					num16 = tol;
				}
				zdiv(num13, num14, num15, num16, ref cyr[n - 1], ref cyi[n - 1]);
				if (n == 1)
				{
					return 0;
				}
				num7 = n - 1;
				num23 = num7;
				num11 = num23;
				num12 = 0.0;
				double num29 = fnu * num9;
				double num30 = fnu * num10;
				for (int i = 2; i <= n; i++)
				{
					num8 = num29 + (num11 * num9 - num12 * num10) + cyr[num7];
					double num22 = num30 + (num11 * num10 + num12 * num9) + cyi[num7];
					num23 = zabs(num8, num22);
					if (num23 == 0.0)
					{
						num8 = tol;
						num22 = tol;
						num23 = tol * 1.4142135623730951;
					}
					double num31 = 1.0 / num23;
					cyr[num7 - 1] = num31 * num8 * num31;
					cyi[num7 - 1] = (0.0 - num31) * num22 * num31;
					num11 -= 1.0;
					num7--;
				}
				return 0;
			}

			private static int zs1s2(double zrr, double zri, ref double s1r, ref double s1i, ref double s2r, ref double s2i, ref int nz, double ascle, double alim, ref int iuf)
			{
				double bi = 0.0;
				double br = 0.0;
				int ierr = 0;
				nz = 0;
				double num = zabs(s1r, s1i);
				double val = zabs(s2r, s2i);
				if ((s1r != 0.0 || s1i != 0.0) && num != 0.0)
				{
					double num2 = 0.0 - zrr - zrr + Math.Log(num);
					double ar = s1r;
					double ai = s1i;
					s1r = 0.0;
					s1i = 0.0;
					num = 0.0;
					if (!(num2 < 0.0 - alim))
					{
						zlog(ar, ai, ref br, ref bi, ref ierr);
						br = br - zrr - zrr;
						bi = bi - zri - zri;
						zexp(br, bi, ref s1r, ref s1i);
						num = zabs(s1r, s1i);
						iuf++;
					}
				}
				if (Math.Max(num, val) > ascle)
				{
					return 0;
				}
				s1r = 0.0;
				s1i = 0.0;
				s2r = 0.0;
				s2i = 0.0;
				nz = 1;
				iuf = 0;
				return 0;
			}

			private static int zseri(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, double tol, double elim, double alim)
			{
				double num = 0.0;
				double bi = 0.0;
				double br = 0.0;
				double num2 = 0.0;
				double ci = 0.0;
				double cr = 0.0;
				double num3 = 0.0;
				int ierr = 0;
				int nz2 = 0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				nz = 0;
				double num4 = zabs(zr, zi);
				if (num4 != 0.0)
				{
					double num5 = d1mach(1) * 1000.0;
					double num6 = Math.Sqrt(num5);
					double num7 = 1.0;
					int num8 = 0;
					if (!(num4 < num5))
					{
						double num9 = zr * 0.5;
						double num10 = zi * 0.5;
						double cr2 = 0.0;
						double ci2 = 0.0;
						if (!(num4 <= num6))
						{
							zmlt(num9, num10, num9, num10, ref cr2, ref ci2);
						}
						double num11 = zabs(cr2, ci2);
						int num12 = n;
						zlog(num9, num10, ref br, ref bi, ref ierr);
						while (true)
						{
							double num13 = fnu + (double)(num12 - 1);
							double num14 = num13 + 1.0;
							double num15 = br * num13;
							double num16 = bi * num13;
							double num17 = dgamln(num14, ref ierr);
							num15 -= num17;
							if (kode == 2)
							{
								num15 -= zr;
							}
							if (num15 > 0.0 - elim)
							{
								if (!(num15 > 0.0 - alim))
								{
									num8 = 1;
									num2 = 1.0 / tol;
									num7 = tol;
									num = num5 * num2;
								}
								double num18 = Math.Exp(num15);
								if (num8 == 1)
								{
									num18 *= num2;
								}
								double num19 = num18 * Math.Cos(num16);
								double num20 = num18 * Math.Sin(num16);
								double num21 = tol * num11 / num14;
								int num22 = Math.Min(2, num12);
								int num23 = 1;
								while (true)
								{
									if (num23 <= num22)
									{
										num13 = fnu + (double)(num12 - num23);
										num14 = num13 + 1.0;
										double num24 = 1.0;
										num3 = 0.0;
										if (!(num11 < tol * num14))
										{
											num15 = 1.0;
											num16 = 0.0;
											num17 = num14 + 2.0;
											double num25 = num14;
											num18 = 2.0;
											do
											{
												double num26 = 1.0 / num25;
												cr = num15 * cr2 - num16 * ci2;
												ci = num15 * ci2 + num16 * cr2;
												num15 = cr * num26;
												num16 = ci * num26;
												num24 += num15;
												num3 += num16;
												num25 += num17;
												num17 += 2.0;
												num18 = num18 * num11 * num26;
											}
											while (num18 > num21);
										}
										double num27 = num24 * num19 - num3 * num20;
										double num28 = num24 * num20 + num3 * num19;
										array2[num23 - 1] = num27;
										array[num23 - 1] = num28;
										if (num8 != 0)
										{
											zuchk(num27, num28, ref nz2, num, tol);
											if (nz2 != 0)
											{
												break;
											}
										}
										int num29 = num12 - num23 + 1;
										yr[num29 - 1] = num27 * num7;
										yi[num29 - 1] = num28 * num7;
										if (num23 != num22)
										{
											zdiv(num19, num20, num9, num10, ref cr, ref ci);
											num19 = cr * num13;
											num20 = ci * num13;
										}
										num23++;
										continue;
									}
									if (num12 <= 2)
									{
										return 0;
									}
									int num30 = num12 - 2;
									num17 = num30;
									double num31 = 1.0 / num4;
									cr = zr * num31;
									ci = (0.0 - zi) * num31;
									double num32 = (cr + cr) * num31;
									double num33 = (ci + ci) * num31;
									int num34;
									if (num8 != 1)
									{
										num34 = 3;
									}
									else
									{
										double num24 = array2[0];
										num3 = array[0];
										double num27 = array2[1];
										double num28 = array[1];
										int num35 = 3;
										while (true)
										{
											if (num35 <= num12)
											{
												br = num27;
												bi = num28;
												num27 = num24 + (num17 + fnu) * (num32 * br - num33 * bi);
												num28 = num3 + (num17 + fnu) * (num32 * bi + num33 * br);
												num24 = br;
												num3 = bi;
												br = num27 * num7;
												bi = num28 * num7;
												yr[num30 - 1] = br;
												yi[num30 - 1] = bi;
												num17 += -1.0;
												num30--;
												if (zabs(br, bi) > num)
												{
													break;
												}
												num35++;
												continue;
											}
											return 0;
										}
										num34 = num35 + 1;
										if (num34 > num12)
										{
											return 0;
										}
									}
									for (num23 = num34; num23 <= num12; num23++)
									{
										yr[num30 - 1] = (num17 + fnu) * (num32 * yr[num30] - num33 * yi[num30]) + yr[num30 + 1];
										yi[num30 - 1] = (num17 + fnu) * (num32 * yi[num30] + num33 * yr[num30]) + yi[num30 + 1];
										num17 += -1.0;
										num30--;
									}
									return 0;
								}
							}
							nz++;
							yr[num12 - 1] = 0.0;
							yi[num12 - 1] = 0.0;
							if (num11 > num13)
							{
								break;
							}
							num12--;
							if (num12 == 0)
							{
								return 0;
							}
						}
						nz = -nz;
						return 0;
					}
					nz = n;
					if (fnu == 0.0)
					{
						nz--;
					}
				}
				yr[0] = 0.0;
				yi[0] = 0.0;
				if (fnu == 0.0)
				{
					yr[0] = 1.0;
					yi[0] = 0.0;
				}
				if (n == 1)
				{
					return 0;
				}
				for (int num23 = 2; num23 <= n; num23++)
				{
					yr[num23 - 1] = 0.0;
					yi[num23 - 1] = 0.0;
				}
				return 0;
			}

			private static int zshch(double zr, double zi, ref double cshr, ref double cshi, ref double cchr, ref double cchi)
			{
				double num = Math.Sinh(zr);
				double num2 = Math.Cosh(zr);
				double num3 = Math.Sin(zi);
				double num4 = Math.Cos(zi);
				cshr = num * num4;
				cshi = num2 * num3;
				cchr = num2 * num4;
				cchi = num * num3;
				return 0;
			}

			private static int zuchk(double yr, double yi, ref int nz, double ascle, double tol)
			{
				nz = 0;
				double val = Math.Abs(yr);
				double val2 = Math.Abs(yi);
				double num = Math.Min(val, val2);
				if (num > ascle)
				{
					return 0;
				}
				double num2 = Math.Max(val, val2);
				num /= tol;
				if (num2 < num)
				{
					nz = 1;
				}
				return 0;
			}

			private static int zunhj(double zr, double zi, double fnu, int ipmtr, double tol, ref double phir, ref double phii, ref double argr, ref double argi, ref double zeta1r, ref double zeta1i, ref double zeta2r, ref double zeta2i, ref double asumr, ref double asumi, ref double bsumr, ref double bsumi)
			{
				double[] array = new double[14]
				{
					1.0,
					5.0 / 48.0,
					0.08355034722222222,
					0.12822657455632716,
					0.29184902646414046,
					0.8816272674437576,
					3.3214082818627677,
					14.995762986862555,
					78.92301301158652,
					474.4515388682643,
					3207.490090890662,
					24086.549640874004,
					198923.1191695098,
					1791902.0077753437
				};
				double[] array2 = new double[14]
				{
					1.0,
					-7.0 / 48.0,
					-0.09874131944444445,
					-0.14331205391589505,
					-0.31722720267841353,
					-0.9424291479571203,
					-3.5112030408263544,
					-15.727263620368046,
					-82.28143909718594,
					-492.3553705236705,
					-3316.2185685479726,
					-24827.67424520859,
					-204526.5873151298,
					-1838444.91706821
				};
				double[] array3 = new double[105]
				{
					1.0,
					-5.0 / 24.0,
					0.125,
					0.3342013888888889,
					-77.0 / 192.0,
					9.0 / 128.0,
					-1.0258125964506173,
					1.8464626736111112,
					-0.8912109375,
					0.0732421875,
					4.669584423426247,
					-11.207002616222994,
					8.78912353515625,
					-2.3640869140625,
					0.112152099609375,
					-28.212072558200244,
					84.63621767460073,
					-91.81824154324002,
					42.53499874538846,
					-7.368794359479632,
					0.22710800170898438,
					212.57013003921713,
					-765.2524681411817,
					1059.9904525279999,
					-699.5796273761325,
					218.1905117442116,
					-26.491430486951554,
					0.5725014209747314,
					-1919.457662318407,
					8061.722181737309,
					-13586.550006434138,
					11655.393336864534,
					-5305.646978613403,
					1200.9029132163525,
					-108.09091978839466,
					1.7277275025844574,
					20204.29133096615,
					-96980.59838863752,
					192547.00123253153,
					-203400.17728041555,
					122200.46498301746,
					-41192.65496889755,
					7109.514302489364,
					-493.915304773088,
					6.074042001273483,
					-242919.18790055133,
					1311763.6146629772,
					-2998015.9185381066,
					3763271.297656404,
					-2813563.226586534,
					1268365.2733216248,
					-331645.1724845636,
					45218.76898136273,
					-2499.8304818112097,
					24.380529699556064,
					3284469.853072038,
					-19706819.118432228,
					50952602.49266464,
					-74105148.21153265,
					66344512.27472903,
					-37567176.66076335,
					13288767.166421818,
					-2785618.1280864547,
					308186.4046126624,
					-13886.08975371704,
					110.01714026924674,
					-49329253.66450996,
					325573074.18576574,
					-939462359.6815784,
					1553596899.57058,
					-1621080552.1083372,
					1106842816.8230145,
					-495889784.2750303,
					142062907.7975331,
					-24474062.72573873,
					2243768.1779224495,
					-84005.43360302408,
					551.3358961220206,
					814789096.1183121,
					-5866481492.051847,
					18688207509.295826,
					-34632043388.158775,
					41280185579.753975,
					-33026599749.800724,
					17954213731.1556,
					-6563293792.619285,
					1559279864.8792574,
					-225105661.88941526,
					17395107.553978164,
					-549842.3275722887,
					3038.090510922384,
					-14679261247.695616,
					114498237732.0258,
					-399096175224.4665,
					819218669548.5773,
					-1098375156081.2233,
					1008158106865.3821,
					-645364869245.3765,
					287900649906.1506,
					-87867072178.02327,
					17634730606.83497,
					-2167164983.223795,
					143157876.71888897,
					-3871833.442572613,
					18257.755474293175
				};
				double[] array4 = new double[180]
				{
					-1.0 / 225.0,
					-0.000922077922077922,
					-8.848928848928849E-05,
					0.00016592768783244973,
					0.0002466913727417929,
					0.0002659955893462548,
					0.00026182429706150096,
					0.0002487304373446556,
					0.00023272104008323209,
					0.00021636248571236508,
					0.00020073885876275234,
					0.00018626763663754517,
					0.0001730607759178765,
					0.00016109170592901574,
					0.00015027477416090814,
					0.0001405034973912698,
					0.0001316688165459228,
					0.00012366744559825325,
					0.00011640527147473791,
					0.00010979829837271337,
					0.00010377241042299283,
					9.826260783693634E-05,
					9.321205172495032E-05,
					8.857108524787117E-05,
					8.429631057157003E-05,
					8.034975484077912E-05,
					7.669813453592074E-05,
					7.331221574817778E-05,
					7.016626251631414E-05,
					6.723756337901603E-05,
					0.000693735541354589,
					0.00023224174518292166,
					-1.419862735566912E-05,
					-0.00011644493167204864,
					-0.00015080355805304876,
					-0.00015512192491809622,
					-0.00014680975664646556,
					-0.00013381550386749137,
					-0.00011974497568425405,
					-0.00010618431920797402,
					-9.376995498911944E-05,
					-8.269230455881933E-05,
					-7.293743481552213E-05,
					-6.440423577210163E-05,
					-5.69611566009369E-05,
					-5.0473104430356164E-05,
					-4.481348680088828E-05,
					-3.9868872771759884E-05,
					-3.554005329720425E-05,
					-3.174142566090225E-05,
					-2.839967939041748E-05,
					-2.5452272063487058E-05,
					-2.2845929716472455E-05,
					-2.053527531064806E-05,
					-1.848162176276661E-05,
					-1.665193300213938E-05,
					-1.5017941298011949E-05,
					-1.3555403137904052E-05,
					-1.2243474647385812E-05,
					-1.1064188481130817E-05,
					-0.00035421197145774384,
					-0.00015616126394515941,
					3.044655035949364E-05,
					0.0001301986557732427,
					0.00016747110669971228,
					0.00017022258768359256,
					0.00015650142760859472,
					0.00013633917097744512,
					0.00011488669202982512,
					9.458690930346882E-05,
					7.644984192508983E-05,
					6.0757033496519734E-05,
					4.743942992905088E-05,
					3.627575120053443E-05,
					2.699397149792249E-05,
					1.9321093824793926E-05,
					1.3005667479396321E-05,
					7.826208667444966E-06,
					3.592574858193516E-06,
					1.4404004981425182E-07,
					-2.653967696979391E-06,
					-4.913468670984859E-06,
					-6.727392960912483E-06,
					-8.17269379678658E-06,
					-9.313047150935612E-06,
					-1.0201141879801643E-05,
					-1.0880596251059288E-05,
					-1.1387548150960355E-05,
					-1.1751967567455642E-05,
					-1.1998736487094414E-05,
					0.0003781941992017729,
					0.00020247195276181616,
					-6.379385063188624E-05,
					-0.0002385982306030059,
					-0.0003109162560273616,
					-0.00031368011524757634,
					-0.0002789502737913234,
					-0.00022856408261914138,
					-0.00017524528034084676,
					-0.00012554406306069035,
					-8.229828728202083E-05,
					-4.628607305881165E-05,
					-1.7233430236696227E-05,
					5.6069048230460226E-06,
					2.313954431482868E-05,
					3.626427458567939E-05,
					4.5800612449018877E-05,
					5.2459529495911405E-05,
					5.683962085458153E-05,
					5.9434982039310406E-05,
					6.0647852757842175E-05,
					6.080239077884365E-05,
					6.0157789453946036E-05,
					5.891996573446985E-05,
					5.72515823777593E-05,
					5.528043755858526E-05,
					5.310637738028802E-05,
					5.080693020123257E-05,
					4.8441864762009484E-05,
					4.6056858160747536E-05,
					-0.0006911413972882942,
					-0.0004299766330588719,
					0.000183067735980039,
					0.0006600881475420142,
					0.0008759649699511859,
					0.0008773352359582355,
					0.0007493695853789907,
					0.000563832329756981,
					0.0003680593199714432,
					0.0001884645355144556,
					3.7066305766490415E-05,
					-8.28520220232137E-05,
					-0.000172751952869173,
					-0.00023631487360587297,
					-0.0002779661506949067,
					-0.00030207951415545694,
					-0.0003125947126438201,
					-0.00031287255875806717,
					-0.0003056780384663244,
					-0.0002932264706145573,
					-0.0002772556555829348,
					-0.0002591039284670317,
					-0.00023978401439648034,
					-0.00022004826004542284,
					-0.00020044391109497149,
					-0.00018135869221097068,
					-0.00016305767447865748,
					-0.00014571267217520584,
					-0.0001294254219839246,
					-0.00011424569194244596,
					0.0019282196424877589,
					0.0013559257630202223,
					-0.000717858090421303,
					-0.0025808480257527035,
					-0.0034927113082616847,
					-0.003469862993409606,
					-0.002822852333513102,
					-0.0018810307640489134,
					-0.0008895317183839476,
					3.8791210263103525E-06,
					0.0007286885401196914,
					0.0012656637305345775,
					0.0016251815837267443,
					0.0018320315321637317,
					0.0019158838899052792,
					0.0019058884675554615,
					0.0018279898242182574,
					0.0017038950642112153,
					0.0015509712717109768,
					0.0013826142185227616,
					0.0012088142423006478,
					0.0010367653263834496,
					0.0008714379180686191,
					0.000716080155297701,
					0.0005726370025581294,
					0.0004420898194658023,
					0.00032472494850309055,
					0.00022034204273024659,
					0.00012841289840135388,
					4.8200592455209545E-05
				};
				double[] array5 = new double[210]
				{
					0.01799887214135533, 0.005599649110643881, 0.0028850140223113277, 0.0018009660676105393, 0.001247531105891992, 0.0009228788765729383, 0.0007144304217272874, 0.0005717872817897049, 0.00046943100760648155, 0.00039323283546291665,
					0.0003348188893182977, 0.00028895214849575154, 0.0002522116155495733, 0.00022228058079888332, 0.0001975418380330625, 0.00017683685501971802, 0.0001593168996618211, 0.00014434793019733397, 0.0001314480681199654, 0.00012024544494930288,
					0.0001104491445045994, 0.00010182877074056726, 9.419982242042375E-05, 8.741305457538345E-05, 8.134662621628014E-05, 7.590022696462193E-05, 7.099063006341535E-05, 6.654828748424682E-05, 6.25146958969275E-05, 5.884033944262518E-05,
					-0.0014928295321342917, -0.0008782047095463894, -0.0005029165495720346, -0.000294822138512746, -0.00017546399697078284, -0.00010400855046081644, -5.961419530464579E-05, -3.1203892907609836E-05, -1.2608973598023005E-05, -2.4289260857573037E-07,
					8.059961654142736E-06, 1.3650700926214739E-05, 1.7396412547292627E-05, 1.9867297884213378E-05, 2.1446326379082263E-05, 2.2395465923245652E-05, 2.2896778381471263E-05, 2.307853898111778E-05, 2.3032197608090914E-05, 2.2823607372034874E-05,
					2.250058811052924E-05, 2.2098101536199144E-05, 2.164184274481039E-05, 2.1150764925622083E-05, 2.0638874978217072E-05, 2.0116524199708165E-05, 1.9591345014117925E-05, 1.9068936791043675E-05, 1.8553371964163667E-05, 1.804757222596742E-05,
					0.0005522130767212928, 0.00044793258155238465, 0.0002795206539920206, 0.0001524681561984466, 6.932711056570436E-05, 1.762586830699914E-05, -1.3574499634326914E-05, -3.179724133504272E-05, -4.188618616966934E-05, -4.6900488937914104E-05,
					-4.8766544741378735E-05, -4.8701003118673505E-05, -4.747556208900866E-05, -4.558130581386284E-05, -4.33309644511266E-05, -4.0923019315775034E-05, -3.848226386032213E-05, -3.608571675354105E-05, -3.377933061233674E-05, -3.158885607721096E-05,
					-2.952695617508073E-05, -2.7597891482833575E-05, -2.5800617466688372E-05, -2.413083567612802E-05, -2.2582350951834605E-05, -2.1147965676891298E-05, -1.9820063888529493E-05, -1.8590987080106508E-05, -1.7453269984421023E-05, -1.63997823854498E-05,
					-0.0004746177965599598, -0.0004778645671473215, -0.00032039022806703763, -0.00016110501611996228, -4.257781012854352E-05, 3.445712942949675E-05, 7.97092684075675E-05, 0.0001031382367082722, 0.00011246677526220416, 0.0001131036421084814,
					0.00010865163484877427, 0.00010143795159766197, 9.29298396593364E-05, 8.4029313301609E-05, 7.52727991349134E-05, 6.696325219757309E-05, 5.925645473231947E-05, 5.2216930882697554E-05, 4.585394851653606E-05, 4.014455138914868E-05,
					3.504817300313281E-05, 3.0515799503434667E-05, 2.6495611995051603E-05, 2.2936363369099816E-05, 1.9789305666402162E-05, 1.7009198463641262E-05, 1.45547428261524E-05, 1.238866409958784E-05, 1.0477587607658323E-05, 8.791799549784793E-06,
					0.0007364658105725784, 0.000872790805146194, 0.0006226148625731351, 0.00028599815419430417, 3.847376728793661E-06, -0.00018790600363697156, -0.00029760364659455455, -0.00034599812683265633, -0.00035338247091603773, -0.00033571563577504876,
					-0.0003043211247890398, -0.00026672272304761283, -0.00022765421412281953, -0.00018992261185456235, -0.00015505891859909386, -0.00012377824076187363, -9.629261477176441E-05, -7.251783277144253E-05, -5.220700288956338E-05, -3.5034775051190054E-05,
					-2.0648976103555174E-05, -8.701060968497671E-06, 1.136986866751003E-06, 9.164264741227788E-06, 1.564777854288726E-05, 2.0822362948246685E-05, 2.4892338100459516E-05, 2.803405095741463E-05, 3.039877746298619E-05, 3.211567314067006E-05,
					-0.0018018219196388571, -0.0024340296293804253, -0.001834226635498568, -0.0007622045963540097, 0.00023907947525692722, 0.0009492661171768811, 0.0013446744970154036, 0.0014845749525944918, 0.001447323398306176, 0.0013026826128565718,
					0.0011035159737564268, 0.0008860474404197917, 0.0006730732081656654, 0.00047760387285658237, 0.00030599192635878935, 0.00016031569459472162, 4.007495552706133E-05, -5.666074616352516E-05, -0.00013250618677298264, -0.00019029618798961406,
					-0.0002328114503769374, -0.00026262881146466884, -0.00028205046986759866, -0.00029308156319286116, -0.0002974359621763166, -0.0002965573342393481, -0.0002916473633120909, -0.0002836962038377342, -0.00027351231709567335, -0.0002617501558067686,
					0.006385858912120509, 0.00962374215806378, 0.0076187806120700105, 0.0028321905554562804, -0.002098413520127201, -0.005738267642166265, -0.0077080424449541465, -0.008210116922648444, -0.007658245203469054, -0.006472097293910452,
					-0.004991324120049665, -0.0034561228971313326, -0.002017855800141708, -0.0007594306867819614, 0.0002841736315238591, 0.001108916675863374, 0.0017290149387272878, 0.002168125908026847, 0.002453577104945397, 0.0026128182105833488,
					0.002671410396562769, 0.0026520307339598045, 0.002574116528772873, 0.0024538912623609443, 0.002304600580717955, 0.0021368483768671267, 0.001958965284788709, 0.0017773700867945441, 0.0015969028076583906, 0.0014211197566443854
				};
				double[] array6 = new double[30]
				{
					0.6299605249474366, 0.25198420997897464, 0.15479030041565583, 0.11071306241615901, 0.08573093955273949, 0.06971613169586843, 0.05860856718937136, 0.05046988735363107, 0.04426005806891548, 0.039372066154350994,
					0.03542831959244554, 0.032181885750209825, 0.029464624079115768, 0.027158167711293448, 0.025176827297386177, 0.02345707553060789, 0.02195083901349072, 0.020621082823564625, 0.019438824089788084, 0.018381063380068317,
					0.017429321323196318, 0.016568583778661234, 0.015786528598791844, 0.01507295014940956, 0.014419325083995464, 0.013818480573534178, 0.013264337899427657, 0.012751712197049864, 0.012276154531876277, 0.01183382623984824
				};
				double ci = 0.0;
				double cr = 0.0;
				double bi = 0.0;
				double br = 0.0;
				double bi2 = 0.0;
				double br2 = 0.0;
				double bi3 = 0.0;
				double br3 = 0.0;
				double bi4 = 0.0;
				double br4 = 0.0;
				int ierr = 0;
				double[] array7 = new double[30];
				double[] array8 = new double[14];
				double[] array9 = new double[14];
				double[] array10 = new double[14];
				double[] array11 = new double[14];
				double[] array12 = new double[30];
				double[] array13 = new double[30];
				double[] array14 = new double[14];
				double[] array15 = new double[14];
				double num = 1.0 / fnu;
				double num2 = d1mach(1) * 1000.0;
				double num3 = fnu * num2;
				if (!(Math.Abs(zr) > num3) && !(Math.Abs(zi) > num3))
				{
					zeta1r = Math.Abs(Math.Log(num2)) * 2.0 + fnu;
					zeta1i = 0.0;
					zeta2r = fnu;
					zeta2i = 0.0;
					phir = 1.0;
					phii = 0.0;
					argr = 1.0;
					argi = 0.0;
					return 0;
				}
				double num4 = zr * num;
				double num5 = zi * num;
				double num6 = num * num;
				double num7 = Math.Pow(fnu, 1.0 / 3.0);
				double num8 = num7 * num7;
				double num9 = 1.0 / num7;
				double num10 = 1.0 - num4 * num4 + num5 * num5;
				double num11 = 0.0 - num4 * num5 - num4 * num5;
				double num12 = zabs(num10, num11);
				if (!(num12 > 0.25))
				{
					int num13 = 1;
					array13[0] = 1.0;
					array12[0] = 0.0;
					double num14 = array6[0];
					double num15 = 0.0;
					array7[0] = 1.0;
					if (!(num12 < tol))
					{
						num13 = 2;
						while (true)
						{
							if (num13 <= 30)
							{
								array13[num13 - 1] = array13[num13 - 2] * num10 - array12[num13 - 2] * num11;
								array12[num13 - 1] = array13[num13 - 2] * num11 + array12[num13 - 2] * num10;
								num14 += array13[num13 - 1] * array6[num13 - 1];
								num15 += array12[num13 - 1] * array6[num13 - 1];
								array7[num13 - 1] = array7[num13 - 2] * num12;
								if (array7[num13 - 1] < tol)
								{
									break;
								}
								num13++;
								continue;
							}
							num13 = 30;
							break;
						}
					}
					int num16 = num13;
					double num17 = num10 * num14 - num11 * num15;
					double num18 = num10 * num15 + num11 * num14;
					argr = num17 * num8;
					argi = num18 * num8;
					zsqrt(num14, num15, ref br3, ref bi3);
					zsqrt(num10, num11, ref br, ref bi);
					zeta2r = br * fnu;
					zeta2i = bi * fnu;
					br = 1.0 + 2.0 / 3.0 * (num17 * br3 - num18 * bi3);
					bi = 0.0 + 2.0 / 3.0 * (num17 * bi3 + num18 * br3);
					zeta1r = br * zeta2r - bi * zeta2i;
					zeta1i = br * zeta2i + bi * zeta2r;
					br3 += br3;
					bi3 += bi3;
					zsqrt(br3, bi3, ref br, ref bi);
					phir = br * num9;
					phii = bi * num9;
					if (ipmtr != 1)
					{
						double num19 = 0.0;
						double num20 = 0.0;
						for (num13 = 1; num13 <= num16; num13++)
						{
							num19 += array13[num13 - 1] * array5[num13 - 1];
							num20 += array12[num13 - 1] * array5[num13 - 1];
						}
						asumr = 0.0;
						asumi = 0.0;
						bsumr = num19;
						bsumi = num20;
						int num21 = 0;
						int num22 = 30;
						double num23 = tol * (Math.Abs(bsumr) + Math.Abs(bsumi));
						double num24 = tol;
						double num25 = 1.0;
						int num26 = 0;
						int num27 = 0;
						if (!(num6 < tol))
						{
							for (int i = 2; i <= 7; i++)
							{
								num24 /= num6;
								num25 *= num6;
								if (num26 != 1)
								{
									num14 = 0.0;
									num15 = 0.0;
									for (num13 = 1; num13 <= num16; num13++)
									{
										int num28 = num21 + num13;
										num14 += array13[num13 - 1] * array4[num28 - 1];
										num15 += array12[num13 - 1] * array4[num28 - 1];
										if (array7[num13 - 1] < num24)
										{
											break;
										}
									}
									asumr += num14 * num25;
									asumi += num15 * num25;
									if (num25 < tol)
									{
										num26 = 1;
									}
								}
								if (num27 != 1)
								{
									num19 = 0.0;
									num20 = 0.0;
									for (num13 = 1; num13 <= num16; num13++)
									{
										int num28 = num22 + num13;
										num19 += array13[num13 - 1] * array5[num28 - 1];
										num20 += array12[num13 - 1] * array5[num28 - 1];
										if (array7[num13 - 1] < num24)
										{
											break;
										}
									}
									bsumr += num19 * num25;
									bsumi += num20 * num25;
									if (num25 < num23)
									{
										num27 = 1;
									}
								}
								if (num26 == 1 && num27 == 1)
								{
									break;
								}
								num21 += 30;
								num22 += 30;
							}
						}
						asumr += 1.0;
						num25 = num * num9;
						bsumr *= num25;
						bsumi *= num25;
					}
				}
				else
				{
					zsqrt(num10, num11, ref br2, ref bi2);
					if (br2 < 0.0)
					{
						br2 = 0.0;
					}
					if (bi2 < 0.0)
					{
						bi2 = 0.0;
					}
					br = 1.0 + br2;
					bi = bi2;
					zdiv(br, bi, num4, num5, ref br3, ref bi3);
					zlog(br3, bi3, ref br4, ref bi4, ref ierr);
					if (bi4 < 0.0)
					{
						bi4 = 0.0;
					}
					if (bi4 > Math.PI / 2.0)
					{
						bi4 = Math.PI / 2.0;
					}
					if (br4 < 0.0)
					{
						br4 = 0.0;
					}
					double num29 = (br4 - br2) * 1.5;
					double num30 = (bi4 - bi2) * 1.5;
					zeta1r = br4 * fnu;
					zeta1i = bi4 * fnu;
					zeta2r = br2 * fnu;
					zeta2i = bi2 * fnu;
					double num31 = zabs(num29, num30);
					double num32 = 4.71238898038469;
					if (!(num29 >= 0.0) || !(num30 < 0.0))
					{
						num32 = Math.PI / 2.0;
						if (num29 != 0.0)
						{
							num32 = Math.Atan(num30 / num29);
							if (num29 < 0.0)
							{
								num32 += Math.PI;
							}
						}
					}
					double num25 = Math.Pow(num31, 2.0 / 3.0);
					num32 *= 2.0 / 3.0;
					double num17 = num25 * Math.Cos(num32);
					double num18 = num25 * Math.Sin(num32);
					if (num18 < 0.0)
					{
						num18 = 0.0;
					}
					argr = num17 * num8;
					argi = num18 * num8;
					zdiv(num29, num30, num17, num18, ref cr, ref ci);
					zdiv(cr, ci, br2, bi2, ref br3, ref bi3);
					double ar = br3 + br3;
					double ai = bi3 + bi3;
					zsqrt(ar, ai, ref br, ref bi);
					phir = br * num9;
					phii = bi * num9;
					if (ipmtr != 1)
					{
						double num33 = 1.0 / Math.Sqrt(num12);
						br = br2 * num33;
						bi = (0.0 - bi2) * num33;
						double num34 = br * num * num33;
						double num35 = bi * num * num33;
						double num36 = 1.0 / num31;
						br = num29 * num36;
						bi = (0.0 - num30) * num36;
						double num37 = br * num36 * num;
						double num38 = bi * num36 * num;
						br4 = num37 * array[1];
						bi4 = num38 * array[1];
						double num39 = 1.0 / num12;
						br = num10 * num39;
						bi = (0.0 - num11) * num39;
						double num40 = br * num39;
						double num41 = bi * num39;
						br = num40 * array3[1] + array3[2];
						bi = num41 * array3[1];
						array15[1] = br * num34 - bi * num35;
						array14[1] = br * num35 + bi * num34;
						bsumr = array15[1] + br4;
						bsumi = array14[1] + bi4;
						asumr = 0.0;
						asumi = 0.0;
						if (!(num < tol))
						{
							double num42 = num37;
							double num43 = num38;
							double num44 = num34;
							double num45 = num35;
							array15[0] = 1.0;
							array14[0] = 0.0;
							num25 = 1.0;
							double num23 = tol * (Math.Abs(bsumr) + Math.Abs(bsumi));
							int num46 = 0;
							int num47 = 2;
							int num48 = 3;
							int num26 = 0;
							int num27 = 0;
							for (int j = 2; j <= 12; j += 2)
							{
								int num49 = j + 1;
								for (int num13 = j; num13 <= num49; num13++)
								{
									num46++;
									num47++;
									num48++;
									br3 = array3[num48 - 1];
									bi3 = 0.0;
									for (int k = 2; k <= num47; k++)
									{
										num48++;
										br = br3 * num40 - num41 * bi3 + array3[num48 - 1];
										bi3 = br3 * num41 + bi3 * num40;
										br3 = br;
									}
									br = num44 * num34 - num45 * num35;
									num45 = num44 * num35 + num45 * num34;
									num44 = br;
									array15[num47 - 1] = num44 * br3 - num45 * bi3;
									array14[num47 - 1] = num45 * br3 + num44 * bi3;
									array9[num46 - 1] = num42 * array2[num46];
									array8[num46 - 1] = num43 * array2[num46];
									br = num42 * num37 - num43 * num38;
									num43 = num42 * num38 + num43 * num37;
									num42 = br;
									array11[num46 - 1] = num42 * array[num46 + 1];
									array10[num46 - 1] = num43 * array[num46 + 1];
								}
								num25 *= num6;
								if (num26 != 1)
								{
									double num14 = array15[num49 - 1];
									double num15 = array14[num49 - 1];
									int num50 = num49;
									for (int l = 1; l <= j; l++)
									{
										num50--;
										num14 = num14 + array9[l - 1] * array15[num50 - 1] - array8[l - 1] * array14[num50 - 1];
										num15 = num15 + array9[l - 1] * array14[num50 - 1] + array8[l - 1] * array15[num50 - 1];
									}
									asumr += num14;
									asumi += num15;
									num2 = Math.Abs(num14) + Math.Abs(num15);
									if (num25 < tol && num2 < tol)
									{
										num26 = 1;
									}
								}
								if (num27 != 1)
								{
									double num19 = array15[j + 1] + array15[num49 - 1] * br4 - array14[num49 - 1] * bi4;
									double num20 = array14[j + 1] + array15[num49 - 1] * bi4 + array14[num49 - 1] * br4;
									int num50 = num49;
									for (int l = 1; l <= j; l++)
									{
										num50--;
										num19 = num19 + array11[l - 1] * array15[num50 - 1] - array10[l - 1] * array14[num50 - 1];
										num20 = num20 + array11[l - 1] * array14[num50 - 1] + array10[l - 1] * array15[num50 - 1];
									}
									bsumr += num19;
									bsumi += num20;
									num2 = Math.Abs(num19) + Math.Abs(num20);
									if (num25 < num23 && num2 < num23)
									{
										num27 = 1;
									}
								}
								if (num26 == 1 && num27 == 1)
								{
									break;
								}
							}
						}
						asumr += 1.0;
						br = (0.0 - bsumr) * num9;
						bi = (0.0 - bsumi) * num9;
						zdiv(br, bi, cr, ci, ref bsumr, ref bsumi);
					}
				}
				return 0;
			}

			private static int zuni1(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, ref int nlast, double fnul, double tol, double elim, double alim)
			{
				double phii = 0.0;
				double phir = 0.0;
				double sumi = 0.0;
				double sumr = 0.0;
				double zeta1i = 0.0;
				double zeta1r = 0.0;
				double zeta2i = 0.0;
				double zeta2r = 0.0;
				int num = 0;
				int nuf = 0;
				int nz2 = 0;
				double[] array = new double[3];
				double[] array2 = new double[3];
				double[] array3 = new double[3];
				double[] cwrki = new double[16];
				double[] cwrkr = new double[16];
				double[] array4 = new double[2];
				double[] array5 = new double[2];
				nz = 0;
				int num2 = n;
				nlast = 0;
				double num3 = 1.0 / tol;
				array3[0] = num3;
				array3[1] = 1.0;
				array3[2] = tol;
				array2[0] = tol;
				array2[1] = 1.0;
				array2[2] = num3;
				array[0] = d1mach(1) * 1000.0 / tol;
				double num4 = Math.Max(fnu, 1.0);
				int init = 0;
				zunik(zr, zi, num4, 1, 1, tol, ref init, ref phir, ref phii, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref sumr, ref sumi, ref cwrkr, ref cwrki);
				double num8;
				if (kode != 1)
				{
					double num5 = zr + zeta2r;
					double num6 = zi + zeta2i;
					double num7 = num4 / zabs(num5, num6);
					num5 = num5 * num7 * num7;
					num6 = (0.0 - num6) * num7 * num7;
					num8 = 0.0 - zeta1r + num5;
					double num9 = 0.0 - zeta1i + num6;
				}
				else
				{
					num8 = 0.0 - zeta1r + zeta2r;
					double num9 = 0.0 - zeta1i + zeta2i;
				}
				double num10 = num8;
				if (!(Math.Abs(num10) > elim))
				{
					while (true)
					{
						int num11 = Math.Min(2, num2);
						int num14;
						double num12;
						double num13;
						for (int i = 1; i <= num11; array5[i - 1] = num12, array4[i - 1] = num13, num14 = num2 - i + 1, yr[num14 - 1] = num12 * array2[num - 1], yi[num14 - 1] = num13 * array2[num - 1], i++)
						{
							num4 = fnu + (double)(num2 - i);
							init = 0;
							zunik(zr, zi, num4, 1, 0, tol, ref init, ref phir, ref phii, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref sumr, ref sumi, ref cwrkr, ref cwrki);
							double num9;
							if (kode != 1)
							{
								double num5 = zr + zeta2r;
								double num6 = zi + zeta2i;
								double num7 = num4 / zabs(num5, num6);
								num5 = num5 * num7 * num7;
								num6 = (0.0 - num6) * num7 * num7;
								num8 = 0.0 - zeta1r + num5;
								num9 = 0.0 - zeta1i + num6 + zi;
							}
							else
							{
								num8 = 0.0 - zeta1r + zeta2r;
								num9 = 0.0 - zeta1i + zeta2i;
							}
							num10 = num8;
							if (!(Math.Abs(num10) > elim))
							{
								if (i == 1)
								{
									num = 2;
								}
								if (!(Math.Abs(num10) < alim))
								{
									double d = zabs(phir, phii);
									num10 += Math.Log(d);
									if (Math.Abs(num10) > elim)
									{
										goto IL_04f8;
									}
									if (i == 1)
									{
										num = 1;
									}
									if (!(num10 < 0.0) && i == 1)
									{
										num = 3;
									}
								}
								num12 = phir * sumr - phii * sumi;
								num13 = phir * sumi + phii * sumr;
								double num5 = Math.Exp(num8) * array3[num - 1];
								num8 = num5 * Math.Cos(num9);
								num9 = num5 * Math.Sin(num9);
								num5 = num12 * num8 - num13 * num9;
								num13 = num12 * num9 + num13 * num8;
								num12 = num5;
								if (num != 1)
								{
									continue;
								}
								zuchk(num12, num13, ref nz2, array[0], tol);
								if (nz2 == 0)
								{
									continue;
								}
							}
							goto IL_04f8;
						}
						if (num2 > 2)
						{
							double num7 = 1.0 / zabs(zr, zi);
							double num5 = zr * num7;
							double num6 = (0.0 - zi) * num7;
							double num15 = (num5 + num5) * num7;
							double num16 = (num6 + num6) * num7;
							array[1] = 1.0 / array[0];
							array[2] = d1mach(2);
							num8 = array5[0];
							double num9 = array4[0];
							num12 = array5[1];
							num13 = array4[1];
							double num17 = array2[num - 1];
							double num18 = array[num - 1];
							int num19 = num2 - 2;
							num4 = num19;
							for (int i = 3; i <= num2; i++)
							{
								double num20 = num12;
								double num21 = num13;
								num12 = num8 + (fnu + num4) * (num15 * num20 - num16 * num21);
								num13 = num9 + (fnu + num4) * (num15 * num21 + num16 * num20);
								num8 = num20;
								num9 = num21;
								num20 = num12 * num17;
								num21 = num13 * num17;
								yr[num19 - 1] = num20;
								yi[num19 - 1] = num21;
								num19--;
								num4 += -1.0;
								if (num < 3)
								{
									num5 = Math.Abs(num20);
									num6 = Math.Abs(num21);
									if (!(Math.Max(num5, num6) <= num18))
									{
										num++;
										num18 = array[num - 1];
										num8 *= num17;
										num9 *= num17;
										num12 = num20;
										num13 = num21;
										num8 *= array3[num - 1];
										num9 *= array3[num - 1];
										num12 *= array3[num - 1];
										num13 *= array3[num - 1];
										num17 = array2[num - 1];
									}
								}
							}
						}
						goto IL_04f6;
						IL_04f8:
						if (num10 > 0.0)
						{
							break;
						}
						yr[num2 - 1] = 0.0;
						yi[num2 - 1] = 0.0;
						nz++;
						num2--;
						if (num2 != 0)
						{
							zuoik(zr, zi, fnu, kode, 1, num2, yr, yi, ref nuf, tol, elim, alim);
							if (nuf < 0)
							{
								break;
							}
							num2 -= nuf;
							nz += nuf;
							if (num2 != 0)
							{
								num4 = fnu + (double)(num2 - 1);
								if (!(num4 >= fnul))
								{
									nlast = num2;
									return 0;
								}
								continue;
							}
						}
						goto IL_04f6;
						IL_04f6:
						return 0;
					}
				}
				else if (!(num10 > 0.0))
				{
					nz = n;
					for (int i = 1; i <= n; i++)
					{
						yr[i - 1] = 0.0;
						yi[i - 1] = 0.0;
					}
					return 0;
				}
				nz = -1;
				return 0;
			}

			private static int zuni2(double zr, double zi, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, ref int nlast, double fnul, double tol, double elim, double alim)
			{
				double aii = 0.0;
				double air = 0.0;
				double argi = 0.0;
				double argr = 0.0;
				double asumi = 0.0;
				double asumr = 0.0;
				double bsumi = 0.0;
				double bsumr = 0.0;
				double aii2 = 0.0;
				double air2 = 0.0;
				double phii = 0.0;
				double phir = 0.0;
				double zeta1i = 0.0;
				double zeta1r = 0.0;
				double zeta2i = 0.0;
				double zeta2r = 0.0;
				int num = 0;
				int nz2 = 0;
				int nz3 = 0;
				int nuf = 0;
				int nz4 = 0;
				int ierr = 0;
				double[] array = new double[4] { 0.0, 1.0, 0.0, -1.0 };
				double[] array2 = new double[4] { 1.0, 0.0, -1.0, 0.0 };
				double[] array3 = new double[3];
				double[] array4 = new double[3];
				double[] array5 = new double[3];
				double[] array6 = new double[2];
				double[] array7 = new double[2];
				nz = 0;
				int num2 = n;
				nlast = 0;
				double num3 = 1.0 / tol;
				array5[0] = num3;
				array5[1] = 1.0;
				array5[2] = tol;
				array4[0] = tol;
				array4[1] = 1.0;
				array4[2] = num3;
				array3[0] = d1mach(1) * 1000.0 / tol;
				double num4 = zi;
				double zi2 = 0.0 - zr;
				double num5 = zi;
				double num6 = -1.0;
				int num7 = (int)fnu;
				double num8 = Math.PI / 2.0 * (fnu - (double)num7);
				double num9 = Math.Cos(num8);
				double num10 = Math.Sin(num8);
				double num11 = num9;
				double num12 = num10;
				int num13 = num7 + n - 1;
				num13 = num13 % 4 + 1;
				double num14 = num9 * array2[num13 - 1] - num10 * array[num13 - 1];
				num10 = num9 * array[num13 - 1] + num10 * array2[num13 - 1];
				num9 = num14;
				if (!(zi > 0.0))
				{
					num4 = 0.0 - num4;
					num5 = 0.0 - num5;
					num6 = 0.0 - num6;
					num10 = 0.0 - num10;
				}
				double num15 = Math.Max(fnu, 1.0);
				zunhj(num4, zi2, num15, 1, tol, ref phir, ref phii, ref argr, ref argi, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref asumr, ref asumi, ref bsumr, ref bsumi);
				double num18;
				if (kode != 1)
				{
					num14 = zr + zeta2r;
					double num16 = num5 + zeta2i;
					double num17 = num15 / zabs(num14, num16);
					num14 = num14 * num17 * num17;
					num16 = (0.0 - num16) * num17 * num17;
					num18 = 0.0 - zeta1r + num14;
					double num19 = 0.0 - zeta1i + num16;
				}
				else
				{
					num18 = 0.0 - zeta1r + zeta2r;
					double num19 = 0.0 - zeta1i + zeta2i;
				}
				double num20 = num18;
				if (!(Math.Abs(num20) > elim))
				{
					while (true)
					{
						int num21 = Math.Min(2, num2);
						int num22 = 1;
						while (num22 <= num21)
						{
							num15 = fnu + (double)(num2 - num22);
							zunhj(num4, zi2, num15, 0, tol, ref phir, ref phii, ref argr, ref argi, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref asumr, ref asumi, ref bsumr, ref bsumi);
							double num19;
							if (kode != 1)
							{
								num14 = zr + zeta2r;
								double num16 = num5 + zeta2i;
								double num17 = num15 / zabs(num14, num16);
								num14 = num14 * num17 * num17;
								num16 = (0.0 - num16) * num17 * num17;
								num18 = 0.0 - zeta1r + num14;
								num19 = 0.0 - zeta1i + num16 + Math.Abs(zi);
							}
							else
							{
								num18 = 0.0 - zeta1r + zeta2r;
								num19 = 0.0 - zeta1i + zeta2i;
							}
							num20 = num18;
							if (!(Math.Abs(num20) > elim))
							{
								if (num22 == 1)
								{
									num = 2;
								}
								if (!(Math.Abs(num20) < alim))
								{
									double d = zabs(phir, phii);
									double d2 = zabs(argr, argi);
									num20 = num20 + Math.Log(d) - Math.Log(d2) * 0.25 - 1.2655121234846454;
									if (Math.Abs(num20) > elim)
									{
										goto IL_0701;
									}
									if (num22 == 1)
									{
										num = 1;
									}
									if (!(num20 < 0.0) && num22 == 1)
									{
										num = 3;
									}
								}
								zairy(argr, argi, 0, 2, ref air, ref aii, ref nz2, ref ierr);
								zairy(argr, argi, 1, 2, ref air2, ref aii2, ref nz3, ref ierr);
								num14 = air2 * bsumr - aii2 * bsumi;
								double num16 = air2 * bsumi + aii2 * bsumr;
								num14 += air * asumr - aii * asumi;
								num16 += air * asumi + aii * asumr;
								double num23 = phir * num14 - phii * num16;
								double num24 = phir * num16 + phii * num14;
								num14 = Math.Exp(num18) * array5[num - 1];
								num18 = num14 * Math.Cos(num19);
								num19 = num14 * Math.Sin(num19);
								num14 = num23 * num18 - num24 * num19;
								num24 = num23 * num19 + num24 * num18;
								num23 = num14;
								if (num == 1)
								{
									zuchk(num23, num24, ref nz4, array3[0], tol);
									if (nz4 != 0)
									{
										goto IL_0701;
									}
								}
								if (zi <= 0.0)
								{
									num24 = 0.0 - num24;
								}
								num14 = num23 * num9 - num24 * num10;
								num24 = num23 * num10 + num24 * num9;
								num23 = (array7[num22 - 1] = num14);
								array6[num22 - 1] = num24;
								int num25 = num2 - num22 + 1;
								yr[num25 - 1] = num23 * array4[num - 1];
								yi[num25 - 1] = num24 * array4[num - 1];
								num14 = (0.0 - num10) * num6;
								num10 = num9 * num6;
								num9 = num14;
								num22++;
								continue;
							}
							goto IL_0701;
						}
						if (num2 > 2)
						{
							double num26 = 1.0 / zabs(zr, zi);
							num14 = zr * num26;
							double num16 = (0.0 - zi) * num26;
							double num27 = (num14 + num14) * num26;
							double num28 = (num16 + num16) * num26;
							array3[1] = 1.0 / array3[0];
							array3[2] = d1mach(2);
							num18 = array7[0];
							double num19 = array6[0];
							double num23 = array7[1];
							double num24 = array6[1];
							double num29 = array4[num - 1];
							double num30 = array3[num - 1];
							int num31 = num2 - 2;
							num15 = num31;
							for (num22 = 3; num22 <= num2; num22++)
							{
								num9 = num23;
								num10 = num24;
								num23 = num18 + (fnu + num15) * (num27 * num9 - num28 * num10);
								num24 = num19 + (fnu + num15) * (num27 * num10 + num28 * num9);
								num18 = num9;
								num19 = num10;
								num9 = num23 * num29;
								num10 = num24 * num29;
								yr[num31 - 1] = num9;
								yi[num31 - 1] = num10;
								num31--;
								num15 += -1.0;
								if (num < 3)
								{
									num14 = Math.Abs(num9);
									num16 = Math.Abs(num10);
									if (!(Math.Max(num14, num16) <= num30))
									{
										num++;
										num30 = array3[num - 1];
										num18 *= num29;
										num19 *= num29;
										num23 = num9;
										num24 = num10;
										num18 *= array5[num - 1];
										num19 *= array5[num - 1];
										num23 *= array5[num - 1];
										num24 *= array5[num - 1];
										num29 = array4[num - 1];
									}
								}
							}
						}
						goto IL_06ff;
						IL_0701:
						if (num20 > 0.0)
						{
							break;
						}
						yr[num2 - 1] = 0.0;
						yi[num2 - 1] = 0.0;
						nz++;
						num2--;
						if (num2 != 0)
						{
							zuoik(zr, zi, fnu, kode, 1, num2, yr, yi, ref nuf, tol, elim, alim);
							if (nuf < 0)
							{
								break;
							}
							num2 -= nuf;
							nz += nuf;
							if (num2 != 0)
							{
								num15 = fnu + (double)(num2 - 1);
								if (!(num15 < fnul))
								{
									num13 = num7 + num2 - 1;
									num13 = num13 % 4 + 1;
									num9 = num11 * array2[num13 - 1] - num12 * array[num13 - 1];
									num10 = num11 * array[num13 - 1] + num12 * array2[num13 - 1];
									if (zi <= 0.0)
									{
										num10 = 0.0 - num10;
									}
									continue;
								}
								nlast = num2;
								return 0;
							}
						}
						goto IL_06ff;
						IL_06ff:
						return 0;
					}
				}
				else if (!(num20 > 0.0))
				{
					nz = n;
					for (int num22 = 1; num22 <= n; num22++)
					{
						yr[num22 - 1] = 0.0;
						yi[num22 - 1] = 0.0;
					}
					return 0;
				}
				nz = -1;
				return 0;
			}

			private static int zunik(double zrr, double zri, double fnu, int ikflg, int ipmtr, double tol, ref int init, ref double phir, ref double phii, ref double zeta1r, ref double zeta1i, ref double zeta2r, ref double zeta2i, ref double sumr, ref double sumi, ref double[] cwrkr, ref double[] cwrki)
			{
				double[] array = new double[2] { 0.3989422804014327, 1.2533141373155003 };
				double[] array2 = new double[120]
				{
					1.0,
					-5.0 / 24.0,
					0.125,
					0.3342013888888889,
					-77.0 / 192.0,
					9.0 / 128.0,
					-1.0258125964506173,
					1.8464626736111112,
					-0.8912109375,
					0.0732421875,
					4.669584423426247,
					-11.207002616222994,
					8.78912353515625,
					-2.3640869140625,
					0.112152099609375,
					-28.212072558200244,
					84.63621767460073,
					-91.81824154324002,
					42.53499874538846,
					-7.368794359479632,
					0.22710800170898438,
					212.57013003921713,
					-765.2524681411817,
					1059.9904525279999,
					-699.5796273761325,
					218.1905117442116,
					-26.491430486951554,
					0.5725014209747314,
					-1919.457662318407,
					8061.722181737309,
					-13586.550006434138,
					11655.393336864534,
					-5305.646978613403,
					1200.9029132163525,
					-108.09091978839466,
					1.7277275025844574,
					20204.29133096615,
					-96980.59838863752,
					192547.00123253153,
					-203400.17728041555,
					122200.46498301746,
					-41192.65496889755,
					7109.514302489364,
					-493.915304773088,
					6.074042001273483,
					-242919.18790055133,
					1311763.6146629772,
					-2998015.9185381066,
					3763271.297656404,
					-2813563.226586534,
					1268365.2733216248,
					-331645.1724845636,
					45218.76898136273,
					-2499.8304818112097,
					24.380529699556064,
					3284469.853072038,
					-19706819.118432228,
					50952602.49266464,
					-74105148.21153265,
					66344512.27472903,
					-37567176.66076335,
					13288767.166421818,
					-2785618.1280864547,
					308186.4046126624,
					-13886.08975371704,
					110.01714026924674,
					-49329253.66450996,
					325573074.18576574,
					-939462359.6815784,
					1553596899.57058,
					-1621080552.1083372,
					1106842816.8230145,
					-495889784.2750303,
					142062907.7975331,
					-24474062.72573873,
					2243768.1779224495,
					-84005.43360302408,
					551.3358961220206,
					814789096.1183121,
					-5866481492.051847,
					18688207509.295826,
					-34632043388.158775,
					41280185579.753975,
					-33026599749.800724,
					17954213731.1556,
					-6563293792.619285,
					1559279864.8792574,
					-225105661.88941526,
					17395107.553978164,
					-549842.3275722887,
					3038.090510922384,
					-14679261247.695616,
					114498237732.0258,
					-399096175224.4665,
					819218669548.5773,
					-1098375156081.2233,
					1008158106865.3821,
					-645364869245.3765,
					287900649906.1506,
					-87867072178.02327,
					17634730606.83497,
					-2167164983.223795,
					143157876.71888897,
					-3871833.442572613,
					18257.755474293175,
					286464035717.679,
					-2406297900028.504,
					9109341185239.898,
					-20516899410934.438,
					30565125519935.32,
					-31667088584785.16,
					23348364044581.84,
					-12320491305598.287,
					4612725780849.132,
					-1196552880196.1816,
					205914503232.41,
					-21822927757.529224,
					1247009293.5127103,
					-29188388.122220814,
					118838.42625678325
				};
				double bi = 0.0;
				double br = 0.0;
				double num = 0.0;
				double num2 = 0.0;
				double ci = 0.0;
				double cr = 0.0;
				double ci2 = 0.0;
				double cr2 = 0.0;
				int ierr = 0;
				zeta1r = 0.0;
				zeta1i = 0.0;
				double num6;
				double num7;
				double cr3;
				if (init == 0)
				{
					double num3 = 1.0 / fnu;
					double num4 = d1mach(1) * 1000.0;
					double num5 = fnu * num4;
					if (!(Math.Abs(zrr) > num5) && !(Math.Abs(zri) > num5))
					{
						zeta1r = 2.0 * Math.Abs(Math.Log(num4)) + fnu;
						zeta1i = 0.0;
						zeta2r = fnu;
						zeta2i = 0.0;
						phir = 1.0;
						phii = 0.0;
						return 0;
					}
					cr3 = zrr * num3;
					double ci3 = zri * num3;
					num6 = 1.0 + (cr3 * cr3 - ci3 * ci3);
					num7 = 0.0 + (cr3 * ci3 + ci3 * cr3);
					zsqrt(num6, num7, ref br, ref bi);
					num2 = 1.0 + br;
					num = 0.0 + bi;
					zdiv(num2, num, cr3, ci3, ref cr2, ref ci2);
					zlog(cr2, ci2, ref num2, ref num, ref ierr);
					zeta1r = fnu * num2;
					zeta1i = fnu * num;
					zeta2r = fnu * br;
					zeta2i = fnu * bi;
					zdiv(1.0, 0.0, br, bi, ref cr3, ref ci3);
					br = cr3 * num3;
					bi = ci3 * num3;
					zsqrt(br, bi, ref cwrkr[15], ref cwrki[15]);
					phir = cwrkr[15] * array[ikflg - 1];
					phii = cwrki[15] * array[ikflg - 1];
					if (ipmtr != 0)
					{
						return 0;
					}
					zdiv(1.0, 0.0, num6, num7, ref cr, ref ci);
					cwrkr[0] = 1.0;
					cwrki[0] = 0.0;
					double num8 = 1.0;
					double num9 = 0.0;
					num5 = 1.0;
					int num10 = 1;
					int num11 = 2;
					while (true)
					{
						if (num11 <= 15)
						{
							num6 = 0.0;
							num7 = 0.0;
							for (int i = 1; i <= num11; i++)
							{
								num10++;
								num2 = num6 * cr - num7 * ci + array2[num10 - 1];
								num7 = num6 * ci + num7 * cr;
								num6 = num2;
							}
							num2 = num8 * br - num9 * bi;
							num9 = num8 * bi + num9 * br;
							num8 = num2;
							cwrkr[num11 - 1] = num8 * num6 - num9 * num7;
							cwrki[num11 - 1] = num8 * num7 + num9 * num6;
							num5 *= num3;
							num4 = Math.Abs(cwrkr[num11 - 1]) + Math.Abs(cwrki[num11 - 1]);
							if (num5 < tol && num4 < tol)
							{
								break;
							}
							num11++;
							continue;
						}
						num11 = 15;
						break;
					}
					init = num11;
				}
				if (ikflg != 2)
				{
					num6 = 0.0;
					num7 = 0.0;
					for (int j = 1; j <= init; j++)
					{
						num6 += cwrkr[j - 1];
						num7 += cwrki[j - 1];
					}
					sumr = num6;
					sumi = num7;
					phir = cwrkr[15] * array[0];
					phii = cwrki[15] * array[0];
					return 0;
				}
				num6 = 0.0;
				num7 = 0.0;
				cr3 = 1.0;
				for (int j = 1; j <= init; j++)
				{
					num6 += cr3 * cwrkr[j - 1];
					num7 += cr3 * cwrki[j - 1];
					cr3 = 0.0 - cr3;
				}
				sumr = num6;
				sumi = num7;
				phir = cwrkr[15] * array[1];
				phii = cwrki[15] * array[1];
				return 0;
			}

			private static int zunk1(double zr, double zi, double fnu, int kode, int mr, int n, double[] yr, double[] yi, ref int nz, double tol, double elim, double alim)
			{
				double num = 0.0;
				double phii = 0.0;
				double phir = 0.0;
				double sumi = 0.0;
				double sumr = 0.0;
				double zeta1i = 0.0;
				double zeta1r = 0.0;
				double zeta2i = 0.0;
				double zeta2r = 0.0;
				int num2 = 0;
				int init = 0;
				int num3 = 0;
				int nz2 = 0;
				double[] array = new double[3];
				double[] array2 = new double[3];
				double[] array3 = new double[3];
				double[][] array4 = new double[3][]
				{
					new double[16],
					new double[16],
					new double[16]
				};
				double[][] array5 = new double[3][]
				{
					new double[16],
					new double[16],
					new double[16]
				};
				double[] array6 = new double[2];
				double[] array7 = new double[2];
				double[] array8 = new double[2];
				double[] array9 = new double[2];
				double[] array10 = new double[2];
				double[] array11 = new double[2];
				double[] array12 = new double[2];
				double[] array13 = new double[2];
				double[] array14 = new double[2];
				double[] array15 = new double[2];
				int[] array16 = new int[2];
				int num4 = 1;
				nz = 0;
				double num5 = 1.0 / tol;
				array3[0] = num5;
				array3[1] = 1.0;
				array3[2] = tol;
				array2[0] = tol;
				array2[1] = 1.0;
				array2[2] = num5;
				array[0] = 1000.0 * d1mach(1) / tol;
				array[1] = 1.0 / array[0];
				array[2] = d1mach(2);
				double num6 = zr;
				double num7 = zi;
				if (!(zr >= 0.0))
				{
					num6 = 0.0 - zr;
					num7 = 0.0 - zi;
				}
				int num8 = 2;
				int num9 = 1;
				while (true)
				{
					double num15;
					double num11;
					double num10;
					if (num9 <= n)
					{
						num8 = 3 - num8;
						num = fnu + (double)(num9 - 1);
						array16[num8 - 1] = 0;
						zunik(num6, num7, num, 2, 0, tol, ref array16[num8 - 1], ref array9[num8 - 1], ref array8[num8 - 1], ref array14[num8 - 1], ref array12[num8 - 1], ref array15[num8 - 1], ref array13[num8 - 1], ref array11[num8 - 1], ref array10[num8 - 1], ref array5[num8 - 1], ref array4[num8 - 1]);
						double num13;
						double num14;
						if (kode != 1)
						{
							num10 = num6 + array15[num8 - 1];
							num11 = num7 + array13[num8 - 1];
							double num12 = num / zabs(num10, num11);
							num10 = num10 * num12 * num12;
							num11 = (0.0 - num11) * num12 * num12;
							num13 = array14[num8 - 1] - num10;
							num14 = array12[num8 - 1] - num11;
						}
						else
						{
							num13 = array14[num8 - 1] - array15[num8 - 1];
							num14 = array12[num8 - 1] - array13[num8 - 1];
						}
						num15 = num13;
						if (Math.Abs(num15) > elim)
						{
							goto IL_0446;
						}
						if (num4 == 1)
						{
							num3 = 2;
						}
						if (!(Math.Abs(num15) < alim))
						{
							double d = zabs(array9[num8 - 1], array8[num8 - 1]);
							num15 += Math.Log(d);
							if (Math.Abs(num15) > elim)
							{
								goto IL_0446;
							}
							if (num4 == 1)
							{
								num3 = 1;
							}
							if (!(num15 < 0.0) && num4 == 1)
							{
								num3 = 3;
							}
						}
						double num16 = array9[num8 - 1] * array11[num8 - 1] - array8[num8 - 1] * array10[num8 - 1];
						double num17 = array9[num8 - 1] * array10[num8 - 1] + array8[num8 - 1] * array11[num8 - 1];
						num10 = Math.Exp(num13) * array3[num3 - 1];
						num13 = num10 * Math.Cos(num14);
						num14 = num10 * Math.Sin(num14);
						num10 = num16 * num13 - num17 * num14;
						num17 = num13 * num17 + num16 * num14;
						num16 = num10;
						if (num3 == 1)
						{
							zuchk(num16, num17, ref nz2, array[0], tol);
							if (nz2 != 0)
							{
								goto IL_0446;
							}
						}
						array7[num4 - 1] = num16;
						array6[num4 - 1] = num17;
						yr[num9 - 1] = num16 * array2[num3 - 1];
						yi[num9 - 1] = num17 * array2[num3 - 1];
						if (num4 != 2)
						{
							num4 = 2;
							goto IL_04e1;
						}
					}
					else
					{
						num9 = n;
					}
					double num18 = 1.0 / zabs(num6, num7);
					num10 = num6 * num18;
					num11 = (0.0 - num7) * num18;
					double num19 = (num10 + num10) * num18;
					double num20 = (num11 + num11) * num18;
					double num21 = num * num19;
					double num22 = num * num20;
					int num23 = num9 + 1;
					if (n >= num23)
					{
						num = fnu + (double)(n - 1);
						int ipmtr = 1;
						if (mr != 0)
						{
							ipmtr = 0;
						}
						zunik(num6, num7, num, 2, ipmtr, tol, ref init, ref phir, ref phii, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref sumr, ref sumi, ref array5[2], ref array4[2]);
						double num13;
						double num14;
						if (kode != 1)
						{
							num10 = num6 + zeta2r;
							num11 = num7 + zeta2i;
							double num12 = num / zabs(num10, num11);
							num10 = num10 * num12 * num12;
							num11 = (0.0 - num11) * num12 * num12;
							num13 = zeta1r - num10;
							num14 = zeta1i - num11;
						}
						else
						{
							num13 = zeta1r - zeta2r;
							num14 = zeta1i - zeta2i;
						}
						num15 = num13;
						if (Math.Abs(num15) > elim)
						{
							goto IL_061b;
						}
						if (!(Math.Abs(num15) < alim))
						{
							double d = zabs(phir, phii);
							num15 += Math.Log(d);
							if (!(Math.Abs(num15) < elim))
							{
								goto IL_061b;
							}
						}
						num13 = array7[0];
						num14 = array6[0];
						double num16 = array7[1];
						double num17 = array6[1];
						double num24 = array2[num3 - 1];
						double num25 = array[num3 - 1];
						for (num9 = num23; num9 <= n; num9++)
						{
							double num26 = num16;
							double num27 = num17;
							num16 = num21 * num26 - num22 * num27 + num13;
							num17 = num21 * num27 + num22 * num26 + num14;
							num13 = num26;
							num14 = num27;
							num21 += num19;
							num22 += num20;
							num26 = num16 * num24;
							num27 = num17 * num24;
							yr[num9 - 1] = num26;
							yi[num9 - 1] = num27;
							if (num3 < 3)
							{
								num10 = Math.Abs(num26);
								num11 = Math.Abs(num27);
								if (!(Math.Max(num10, num11) <= num25))
								{
									num3++;
									num25 = array[num3 - 1];
									num13 *= num24;
									num14 *= num24;
									num16 = num26;
									num17 = num27;
									num13 *= array3[num3 - 1];
									num14 *= array3[num3 - 1];
									num16 *= array3[num3 - 1];
									num17 *= array3[num3 - 1];
									num24 = array2[num3 - 1];
								}
							}
						}
					}
					if (mr == 0)
					{
						return 0;
					}
					nz = 0;
					double b = mr;
					double num28 = 0.0 - dsign(Math.PI, b);
					double num29 = num28;
					int num30 = (int)fnu;
					double num31 = fnu - (double)num30;
					int num32 = num30 + n - 1;
					double num33 = num31 * num28;
					double num34 = Math.Cos(num33);
					double num35 = Math.Sin(num33);
					if (num32 % 2 != 0)
					{
						num34 = 0.0 - num34;
						num35 = 0.0 - num35;
					}
					double ascle = array[0];
					int iuf = 0;
					int num36 = n;
					num4 = 1;
					num23--;
					int num37 = num23 - 1;
					int num38 = 1;
					while (true)
					{
						int num39;
						if (num38 <= n)
						{
							num = fnu + (double)(num36 - 1);
							num39 = 3;
							if (n <= 2)
							{
								goto IL_0820;
							}
							if (num36 != n || num23 >= n)
							{
								if (num36 == num23 || num36 == num37)
								{
									goto IL_0820;
								}
								init = 0;
							}
							goto IL_0898;
						}
						num38 = n;
						goto IL_0b38;
						IL_0afa:
						if (num15 > 0.0)
						{
							break;
						}
						double num16 = 0.0;
						double num17 = 0.0;
						goto IL_0a2d;
						IL_0820:
						init = array16[num8 - 1];
						phir = array9[num8 - 1];
						phii = array8[num8 - 1];
						zeta1r = array14[num8 - 1];
						zeta1i = array12[num8 - 1];
						zeta2r = array15[num8 - 1];
						zeta2i = array13[num8 - 1];
						sumr = array11[num8 - 1];
						sumi = array10[num8 - 1];
						num39 = num8;
						num8 = 3 - num8;
						goto IL_0898;
						IL_0898:
						zunik(num6, num7, num, 1, 0, tol, ref init, ref phir, ref phii, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref sumr, ref sumi, ref array5[num39 - 1], ref array4[num39 - 1]);
						double num13;
						double num14;
						if (kode != 1)
						{
							num10 = num6 + zeta2r;
							num11 = num7 + zeta2i;
							double num12 = num / zabs(num10, num11);
							num10 = num10 * num12 * num12;
							num11 = (0.0 - num11) * num12 * num12;
							num13 = 0.0 - zeta1r + num10;
							num14 = 0.0 - zeta1i + num11;
						}
						else
						{
							num13 = 0.0 - zeta1r + zeta2r;
							num14 = 0.0 - zeta1i + zeta2i;
						}
						num15 = num13;
						if (!(Math.Abs(num15) > elim))
						{
							if (num4 == 1)
							{
								num2 = 2;
							}
							if (!(Math.Abs(num15) < alim))
							{
								double d = zabs(phir, phii);
								num15 += Math.Log(d);
								if (Math.Abs(num15) > elim)
								{
									goto IL_0afa;
								}
								if (num4 == 1)
								{
									num2 = 1;
								}
								if (!(num15 < 0.0) && num4 == 1)
								{
									num2 = 3;
								}
							}
							num10 = phir * sumr - phii * sumi;
							num11 = phir * sumi + phii * sumr;
							num16 = (0.0 - num29) * num11;
							num17 = num29 * num10;
							num10 = Math.Exp(num13) * array3[num2 - 1];
							num13 = num10 * Math.Cos(num14);
							num14 = num10 * Math.Sin(num14);
							num10 = num16 * num13 - num17 * num14;
							num17 = num16 * num14 + num17 * num13;
							num16 = num10;
							if (num2 == 1)
							{
								zuchk(num16, num17, ref nz2, array[0], tol);
								if (nz2 != 0)
								{
									num16 = 0.0;
									num17 = 0.0;
								}
							}
							goto IL_0a2d;
						}
						goto IL_0afa;
						IL_0b38:
						int num40 = n - num38;
						if (num40 == 0)
						{
							return 0;
						}
						num13 = array7[0];
						num14 = array6[0];
						num16 = array7[1];
						num17 = array6[1];
						double num41 = array2[num2 - 1];
						double num25 = array[num2 - 1];
						num = num30 + num40;
						double num26;
						double num27;
						for (num9 = 1; num9 <= num40; num9++)
						{
							num26 = num16;
							num27 = num17;
							num16 = num13 + (num + num31) * (num19 * num26 - num20 * num27);
							num17 = num14 + (num + num31) * (num19 * num27 + num20 * num26);
							num13 = num26;
							num14 = num27;
							num -= 1.0;
							num26 = num16 * num41;
							num27 = num17 * num41;
							num21 = num26;
							num22 = num27;
							double num24 = yr[num36 - 1];
							double s1i = yi[num36 - 1];
							if (kode != 1)
							{
								zs1s2(num6, num7, ref num24, ref s1i, ref num26, ref num27, ref nz2, ascle, alim, ref iuf);
								nz += nz2;
							}
							yr[num36 - 1] = num24 * num34 - s1i * num35 + num26;
							yi[num36 - 1] = num24 * num35 + s1i * num34 + num27;
							num36--;
							num34 = 0.0 - num34;
							num35 = 0.0 - num35;
							if (num2 < 3)
							{
								num26 = Math.Abs(num21);
								num27 = Math.Abs(num22);
								if (!(Math.Max(num26, num27) <= num25))
								{
									num2++;
									num25 = array[num2 - 1];
									num13 *= num41;
									num14 *= num41;
									num16 = num21;
									num17 = num22;
									num13 *= array3[num2 - 1];
									num14 *= array3[num2 - 1];
									num16 *= array3[num2 - 1];
									num17 *= array3[num2 - 1];
									num41 = array2[num2 - 1];
								}
							}
						}
						return 0;
						IL_0b25:
						num38++;
						continue;
						IL_0a2d:
						array7[num4 - 1] = num16;
						array6[num4 - 1] = num17;
						num26 = num16;
						num27 = num17;
						num16 *= array2[num2 - 1];
						num17 *= array2[num2 - 1];
						num13 = yr[num36 - 1];
						num14 = yi[num36 - 1];
						if (kode != 1)
						{
							zs1s2(num6, num7, ref num13, ref num14, ref num16, ref num17, ref nz2, ascle, alim, ref iuf);
							nz += nz2;
						}
						yr[num36 - 1] = num13 * num34 - num14 * num35 + num16;
						yi[num36 - 1] = num34 * num14 + num35 * num13 + num17;
						num36--;
						num34 = 0.0 - num34;
						num35 = 0.0 - num35;
						if (num26 == 0.0 && num27 == 0.0)
						{
							num4 = 1;
							goto IL_0b25;
						}
						if (num4 != 2)
						{
							num4 = 2;
							goto IL_0b25;
						}
						goto IL_0b38;
					}
					break;
					IL_04e1:
					num9++;
					continue;
					IL_061b:
					if (Math.Abs(num15) > 0.0 || zr < 0.0)
					{
						break;
					}
					nz = n;
					for (num9 = 1; num9 <= n; num9++)
					{
						yr[num9 - 1] = 0.0;
						yi[num9 - 1] = 0.0;
					}
					return 0;
					IL_0446:
					if (num15 > 0.0 || zr < 0.0)
					{
						break;
					}
					num4 = 1;
					yr[num9 - 1] = 0.0;
					yi[num9 - 1] = 0.0;
					nz++;
					if (num9 != 1 && (yr[num9 - 2] != 0.0 || yi[num9 - 2] != 0.0))
					{
						yr[num9 - 2] = 0.0;
						yi[num9 - 2] = 0.0;
						nz++;
					}
					goto IL_04e1;
				}
				nz = -1;
				return 0;
			}

			private static int zunk2(double zr, double zi, double fnu, int kode, int mr, int n, double[] yr, double[] yi, ref int nz, double tol, double elim, double alim)
			{
				double aii = 0.0;
				double air = 0.0;
				double argi = 0.0;
				double argr = 0.0;
				double asumi = 0.0;
				double asumr = 0.0;
				double bsumi = 0.0;
				double bsumr = 0.0;
				double aii2 = 0.0;
				double air2 = 0.0;
				double num = 0.0;
				double phii = 0.0;
				double phir = 0.0;
				double zeta1i = 0.0;
				double zeta1r = 0.0;
				double zeta2i = 0.0;
				double zeta2r = 0.0;
				int num2 = 0;
				int num3 = 0;
				int nz2 = 0;
				int nz3 = 0;
				int nz4 = 0;
				int ierr = 0;
				double[] array = new double[2];
				double[] array2 = new double[2];
				double[] array3 = new double[2];
				double[] array4 = new double[2];
				double[] array5 = new double[2];
				double[] array6 = new double[2];
				double[] array7 = new double[3];
				double[] array8 = new double[4] { 0.0, -1.0, 0.0, 1.0 };
				double[] array9 = new double[4] { 1.0, 0.0, -1.0, 0.0 };
				double[] array10 = new double[3];
				double[] array11 = new double[3];
				double[] array12 = new double[2];
				double[] array13 = new double[2];
				double[] array14 = new double[2];
				double[] array15 = new double[2];
				double[] array16 = new double[2];
				double[] array17 = new double[2];
				double[] array18 = new double[2];
				double[] array19 = new double[2];
				int num4 = 1;
				nz = 0;
				double num5 = 1.0 / tol;
				array11[0] = num5;
				array11[1] = 1.0;
				array11[2] = tol;
				array10[0] = tol;
				array10[1] = 1.0;
				array10[2] = num5;
				array7[0] = d1mach(1) * 1000.0 / tol;
				array7[1] = 1.0 / array7[0];
				array7[2] = d1mach(2);
				double num6 = zr;
				double num7 = zi;
				if (!(zr >= 0.0))
				{
					num6 = 0.0 - zr;
					num7 = 0.0 - zi;
				}
				double num8 = num7;
				double num9 = num7;
				double zi2 = 0.0 - num6;
				double num10 = num6;
				double num11 = num7;
				int num12 = (int)fnu;
				double num13 = fnu - (double)num12;
				double num14 = -Math.PI / 2.0 * num13;
				double num15 = Math.Cos(num14);
				double num16 = Math.Sin(num14);
				double num17 = Math.PI / 2.0 * num16;
				double num18 = -Math.PI / 2.0 * num15;
				int num19 = num12 % 4 + 1;
				double num20 = num17 * array9[num19 - 1] - num18 * array8[num19 - 1];
				double num21 = num17 * array8[num19 - 1] + num18 * array9[num19 - 1];
				double num22 = 1.0 * num20 - 1.7320508075688772 * num21;
				double num23 = 1.0 * num21 + 1.7320508075688772 * num20;
				if (!(num8 > 0.0))
				{
					num9 = 0.0 - num9;
					num11 = 0.0 - num11;
				}
				int num24 = 2;
				int num25 = 1;
				while (true)
				{
					double num29;
					if (num25 <= n)
					{
						num24 = 3 - num24;
						num = fnu + (double)(num25 - 1);
						zunhj(num9, zi2, num, 0, tol, ref array15[num24 - 1], ref array14[num24 - 1], ref array2[num24 - 1], ref array[num24 - 1], ref array18[num24 - 1], ref array16[num24 - 1], ref array19[num24 - 1], ref array17[num24 - 1], ref array4[num24 - 1], ref array3[num24 - 1], ref array6[num24 - 1], ref array5[num24 - 1]);
						double num27;
						double num28;
						if (kode != 1)
						{
							num20 = num10 + array19[num24 - 1];
							num21 = num11 + array17[num24 - 1];
							double num26 = num / zabs(num20, num21);
							num20 = num20 * num26 * num26;
							num21 = (0.0 - num21) * num26 * num26;
							num27 = array18[num24 - 1] - num20;
							num28 = array16[num24 - 1] - num21;
						}
						else
						{
							num27 = array18[num24 - 1] - array19[num24 - 1];
							num28 = array16[num24 - 1] - array17[num24 - 1];
						}
						num29 = num27;
						if (Math.Abs(num29) > elim)
						{
							goto IL_06d5;
						}
						if (num4 == 1)
						{
							num3 = 2;
						}
						if (!(Math.Abs(num29) < alim))
						{
							double d = zabs(array15[num24 - 1], array14[num24 - 1]);
							double d2 = zabs(array2[num24 - 1], array[num24 - 1]);
							num29 = num29 + Math.Log(d) - Math.Log(d2) * 0.25 - 1.2655121234846454;
							if (Math.Abs(num29) > elim)
							{
								goto IL_06d5;
							}
							if (num4 == 1)
							{
								num3 = 1;
							}
							if (!(num29 < 0.0) && num4 == 1)
							{
								num3 = 3;
							}
						}
						num17 = array2[num24 - 1] * -0.5 - array[num24 - 1] * -0.8660254037844386;
						num18 = array2[num24 - 1] * -0.8660254037844386 + array[num24 - 1] * -0.5;
						zairy(num17, num18, 0, 2, ref air, ref aii, ref nz2, ref ierr);
						zairy(num17, num18, 1, 2, ref air2, ref aii2, ref nz3, ref ierr);
						num20 = air2 * array6[num24 - 1] - aii2 * array5[num24 - 1];
						num21 = air2 * array5[num24 - 1] + aii2 * array6[num24 - 1];
						double num30 = num20 * -0.5 - num21 * -0.8660254037844386;
						double num31 = num20 * -0.8660254037844386 + num21 * -0.5;
						num20 = num30 + (air * array4[num24 - 1] - aii * array3[num24 - 1]);
						num21 = num31 + (air * array3[num24 - 1] + aii * array4[num24 - 1]);
						double num32 = num20 * array15[num24 - 1] - num21 * array14[num24 - 1];
						num31 = num20 * array14[num24 - 1] + num21 * array15[num24 - 1];
						double num33 = num32 * num22 - num31 * num23;
						double num34 = num32 * num23 + num31 * num22;
						num20 = Math.Exp(num27) * array11[num3 - 1];
						num27 = num20 * Math.Cos(num28);
						num28 = num20 * Math.Sin(num28);
						num20 = num33 * num27 - num34 * num28;
						num34 = num27 * num34 + num33 * num28;
						num33 = num20;
						if (num3 == 1)
						{
							zuchk(num33, num34, ref nz4, array7[0], tol);
							if (nz4 != 0)
							{
								goto IL_06d5;
							}
						}
						if (num8 <= 0.0)
						{
							num34 = 0.0 - num34;
						}
						array13[num4 - 1] = num33;
						array12[num4 - 1] = num34;
						yr[num25 - 1] = num33 * array10[num3 - 1];
						yi[num25 - 1] = num34 * array10[num3 - 1];
						num20 = num23;
						num23 = 0.0 - num22;
						num22 = num20;
						if (num4 != 2)
						{
							num4 = 2;
							goto IL_077d;
						}
					}
					else
					{
						num25 = n;
					}
					double num35 = 1.0 / zabs(num6, num7);
					num20 = num6 * num35;
					num21 = (0.0 - num7) * num35;
					double num36 = (num20 + num20) * num35;
					double num37 = (num21 + num21) * num35;
					double num38 = num * num36;
					double num39 = num * num37;
					int num40 = num25 + 1;
					if (n >= num40)
					{
						num = fnu + (double)(n - 1);
						int ipmtr = 1;
						if (mr != 0)
						{
							ipmtr = 0;
						}
						zunhj(num9, zi2, num, ipmtr, tol, ref phir, ref phii, ref argr, ref argi, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref asumr, ref asumi, ref bsumr, ref bsumi);
						double num27;
						double num28;
						if (kode != 1)
						{
							num20 = num10 + zeta2r;
							num21 = num11 + zeta2i;
							double num26 = num / zabs(num20, num21);
							num20 = num20 * num26 * num26;
							num21 = (0.0 - num21) * num26 * num26;
							num27 = zeta1r - num20;
							num28 = zeta1i - num21;
						}
						else
						{
							num27 = zeta1r - zeta2r;
							num28 = zeta1i - zeta2i;
						}
						num29 = num27;
						if (Math.Abs(num29) > elim)
						{
							goto IL_08ad;
						}
						if (!(Math.Abs(num29) < alim))
						{
							double d = zabs(phir, phii);
							num29 += Math.Log(d);
							if (!(Math.Abs(num29) < elim))
							{
								goto IL_08ad;
							}
						}
						num27 = array13[0];
						num28 = array12[0];
						double num33 = array13[1];
						double num34 = array12[1];
						double num41 = array10[num3 - 1];
						double num42 = array7[num3 - 1];
						for (num25 = num40; num25 <= n; num25++)
						{
							num17 = num33;
							num18 = num34;
							num33 = num38 * num17 - num39 * num18 + num27;
							num34 = num38 * num18 + num39 * num17 + num28;
							num27 = num17;
							num28 = num18;
							num38 += num36;
							num39 += num37;
							num17 = num33 * num41;
							num18 = num34 * num41;
							yr[num25 - 1] = num17;
							yi[num25 - 1] = num18;
							if (num3 < 3)
							{
								num20 = Math.Abs(num17);
								num21 = Math.Abs(num18);
								if (!(Math.Max(num20, num21) <= num42))
								{
									num3++;
									num42 = array7[num3 - 1];
									num27 *= num41;
									num28 *= num41;
									num33 = num17;
									num34 = num18;
									num27 *= array11[num3 - 1];
									num28 *= array11[num3 - 1];
									num33 *= array11[num3 - 1];
									num34 *= array11[num3 - 1];
									num41 = array10[num3 - 1];
								}
							}
						}
					}
					if (mr == 0)
					{
						return 0;
					}
					nz = 0;
					double b = mr;
					double num43 = 0.0 - dsign(Math.PI, b);
					double num44 = num43;
					if (num8 <= 0.0)
					{
						num44 = 0.0 - num44;
					}
					int num45 = num12 + n - 1;
					double num46 = num13 * num43;
					double num47 = Math.Cos(num46);
					double num48 = Math.Sin(num46);
					if (num45 % 2 != 0)
					{
						num47 = 0.0 - num47;
						num48 = 0.0 - num48;
					}
					num22 = num16 * num44;
					num23 = num15 * num44;
					int num49 = num45 % 4 + 1;
					num17 = array9[num49 - 1];
					num18 = array8[num49 - 1];
					num20 = num22 * num17 + num23 * num18;
					num23 = (0.0 - num22) * num18 + num23 * num17;
					num22 = num20;
					double ascle = array7[0];
					int iuf = 0;
					num19 = n;
					num4 = 1;
					num40--;
					int num50 = num40 - 1;
					int num51 = 1;
					while (true)
					{
						if (num51 <= n)
						{
							num = fnu + (double)(num19 - 1);
							if (n <= 2)
							{
								goto IL_0aff;
							}
							if (num19 != n || num40 >= n)
							{
								if (num19 == num40 || num19 == num50)
								{
									goto IL_0aff;
								}
								zunhj(num9, zi2, num, 0, tol, ref phir, ref phii, ref argr, ref argi, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref asumr, ref asumi, ref bsumr, ref bsumi);
							}
							goto IL_0bb8;
						}
						num51 = n;
						goto IL_0ec9;
						IL_0e8b:
						if (num29 > 0.0)
						{
							break;
						}
						double num33 = 0.0;
						double num34 = 0.0;
						goto IL_0d9e;
						IL_0aff:
						phir = array15[num24 - 1];
						phii = array14[num24 - 1];
						argr = array2[num24 - 1];
						argi = array[num24 - 1];
						zeta1r = array18[num24 - 1];
						zeta1i = array16[num24 - 1];
						zeta2r = array19[num24 - 1];
						zeta2i = array17[num24 - 1];
						asumr = array4[num24 - 1];
						asumi = array3[num24 - 1];
						bsumr = array6[num24 - 1];
						bsumi = array5[num24 - 1];
						num24 = 3 - num24;
						goto IL_0bb8;
						IL_0bb8:
						double num27;
						double num28;
						if (kode != 1)
						{
							num20 = num10 + zeta2r;
							num21 = num11 + zeta2i;
							double num26 = num / zabs(num20, num21);
							num20 = num20 * num26 * num26;
							num21 = (0.0 - num21) * num26 * num26;
							num27 = 0.0 - zeta1r + num20;
							num28 = 0.0 - zeta1i + num21;
						}
						else
						{
							num27 = 0.0 - zeta1r + zeta2r;
							num28 = 0.0 - zeta1i + zeta2i;
						}
						num29 = num27;
						if (!(Math.Abs(num29) > elim))
						{
							if (num4 == 1)
							{
								num2 = 2;
							}
							if (!(Math.Abs(num29) < alim))
							{
								double d = zabs(phir, phii);
								double d2 = zabs(argr, argi);
								num29 = num29 + Math.Log(d) - 0.25 * Math.Log(d2) - 1.2655121234846454;
								if (Math.Abs(num29) > elim)
								{
									goto IL_0e8b;
								}
								if (num4 == 1)
								{
									num2 = 1;
								}
								if (!(num29 < 0.0) && num4 == 1)
								{
									num2 = 3;
								}
							}
							zairy(argr, argi, 0, 2, ref air, ref aii, ref nz2, ref ierr);
							zairy(argr, argi, 1, 2, ref air2, ref aii2, ref nz3, ref ierr);
							num20 = air2 * bsumr - aii2 * bsumi;
							num21 = air2 * bsumi + aii2 * bsumr;
							num20 += air * asumr - aii * asumi;
							num21 += air * asumi + aii * asumr;
							double num52 = num20 * phir - num21 * phii;
							double num31 = num20 * phii + num21 * phir;
							num33 = num52 * num22 - num31 * num23;
							num34 = num52 * num23 + num31 * num22;
							num20 = Math.Exp(num27) * array11[num2 - 1];
							num27 = num20 * Math.Cos(num28);
							num28 = num20 * Math.Sin(num28);
							num20 = num33 * num27 - num34 * num28;
							num34 = num33 * num28 + num34 * num27;
							num33 = num20;
							if (num2 == 1)
							{
								zuchk(num33, num34, ref nz4, array7[0], tol);
								if (nz4 != 0)
								{
									num33 = 0.0;
									num34 = 0.0;
								}
							}
							goto IL_0d9e;
						}
						goto IL_0e8b;
						IL_0eb6:
						num51++;
						continue;
						IL_0ec9:
						int num53 = n - num51;
						if (num53 == 0)
						{
							return 0;
						}
						num27 = array13[0];
						num28 = array12[0];
						num33 = array13[1];
						num34 = array12[1];
						num22 = array10[num2 - 1];
						double num42 = array7[num2 - 1];
						num = num12 + num53;
						for (num25 = 1; num25 <= num53; num25++)
						{
							num17 = num33;
							num18 = num34;
							num33 = num27 + (num + num13) * (num36 * num17 - num37 * num18);
							num34 = num28 + (num + num13) * (num36 * num18 + num37 * num17);
							num27 = num17;
							num28 = num18;
							num -= 1.0;
							num17 = num33 * num22;
							num18 = num34 * num22;
							num38 = num17;
							num39 = num18;
							double num41 = yr[num19 - 1];
							double s1i = yi[num19 - 1];
							if (kode != 1)
							{
								zs1s2(num6, num7, ref num41, ref s1i, ref num17, ref num18, ref nz4, ascle, alim, ref iuf);
								nz += nz4;
							}
							yr[num19 - 1] = num41 * num47 - s1i * num48 + num17;
							yi[num19 - 1] = num41 * num48 + s1i * num47 + num18;
							num19--;
							num47 = 0.0 - num47;
							num48 = 0.0 - num48;
							if (num2 < 3)
							{
								num17 = Math.Abs(num38);
								num18 = Math.Abs(num39);
								if (!(Math.Max(num17, num18) <= num42))
								{
									num2++;
									num42 = array7[num2 - 1];
									num27 *= num22;
									num28 *= num22;
									num33 = num38;
									num34 = num39;
									num27 *= array11[num2 - 1];
									num28 *= array11[num2 - 1];
									num33 *= array11[num2 - 1];
									num34 *= array11[num2 - 1];
									num22 = array10[num2 - 1];
								}
							}
						}
						return 0;
						IL_0d9e:
						if (num8 <= 0.0)
						{
							num34 = 0.0 - num34;
						}
						array13[num4 - 1] = num33;
						array12[num4 - 1] = num34;
						num17 = num33;
						num18 = num34;
						num33 *= array10[num2 - 1];
						num34 *= array10[num2 - 1];
						num27 = yr[num19 - 1];
						num28 = yi[num19 - 1];
						if (kode != 1)
						{
							zs1s2(num6, num7, ref num27, ref num28, ref num33, ref num34, ref nz4, ascle, alim, ref iuf);
							nz += nz4;
						}
						yr[num19 - 1] = num27 * num47 - num28 * num48 + num33;
						yi[num19 - 1] = num27 * num48 + num28 * num47 + num34;
						num19--;
						num47 = 0.0 - num47;
						num48 = 0.0 - num48;
						num20 = num23;
						num23 = 0.0 - num22;
						num22 = num20;
						if (num17 == 0.0 && num18 == 0.0)
						{
							num4 = 1;
							goto IL_0eb6;
						}
						if (num4 != 2)
						{
							num4 = 2;
							goto IL_0eb6;
						}
						goto IL_0ec9;
					}
					break;
					IL_06d5:
					if (num29 > 0.0 || zr < 0.0)
					{
						break;
					}
					num4 = 1;
					yr[num25 - 1] = 0.0;
					yi[num25 - 1] = 0.0;
					nz++;
					num20 = num23;
					num23 = 0.0 - num22;
					num22 = num20;
					if (num25 != 1 && (yr[num25 - 1] != 0.0 || yi[num25 - 1] != 0.0))
					{
						yr[num25 - 2] = 0.0;
						yi[num25 - 2] = 0.0;
						nz++;
					}
					goto IL_077d;
					IL_077d:
					num25++;
					continue;
					IL_08ad:
					if (num29 > 0.0 || zr < 0.0)
					{
						break;
					}
					nz = n;
					for (num25 = 1; num25 <= n; num25++)
					{
						yr[num25 - 1] = 0.0;
						yi[num25 - 1] = 0.0;
					}
					return 0;
				}
				nz = -1;
				return 0;
			}

			private static int zuoik(double zr, double zi, double fnu, int kode, int ikflg, int n, double[] yr, double[] yi, ref int nuf, double tol, double elim, double alim)
			{
				double d = 0.0;
				double argi = 0.0;
				double argr = 0.0;
				double asumi = 0.0;
				double asumr = 0.0;
				double bsumi = 0.0;
				double bsumr = 0.0;
				double phii = 0.0;
				double phir = 0.0;
				double br = 0.0;
				double bi = 0.0;
				double sumi = 0.0;
				double sumr = 0.0;
				double zeta1i = 0.0;
				double zeta1r = 0.0;
				double zeta2i = 0.0;
				double zeta2r = 0.0;
				double zi2 = 0.0;
				double num = 0.0;
				int ierr = 0;
				int nz = 0;
				double[] cwrkr = new double[16];
				double[] cwrki = new double[16];
				nuf = 0;
				int num2 = n;
				double num3 = zr;
				double num4 = zi;
				if (!(zr >= 0.0))
				{
					num3 = 0.0 - zr;
					num4 = 0.0 - zi;
				}
				double num5 = num3;
				double num6 = num4;
				double num7 = Math.Abs(zr) * 1.7321;
				double num8 = Math.Abs(zi);
				int num9 = 1;
				if (num8 > num7)
				{
					num9 = 2;
				}
				double fnu2 = Math.Max(fnu, 1.0);
				if (ikflg != 1)
				{
					double num10 = num2;
					fnu2 = Math.Max(fnu + num10 - 1.0, num10);
				}
				double num11;
				double num12;
				if (num9 != 2)
				{
					int init = 0;
					zunik(num3, num4, fnu2, ikflg, 1, tol, ref init, ref phir, ref phii, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref sumr, ref sumi, ref cwrkr, ref cwrki);
					num11 = 0.0 - zeta1r + zeta2r;
					num12 = 0.0 - zeta1i + zeta2i;
				}
				else
				{
					num = num4;
					zi2 = 0.0 - num3;
					if (!(zi > 0.0))
					{
						num = 0.0 - num;
					}
					zunhj(num, zi2, fnu2, 1, tol, ref phir, ref phii, ref argr, ref argi, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref asumr, ref asumi, ref bsumr, ref bsumi);
					num11 = 0.0 - zeta1r + zeta2r;
					num12 = 0.0 - zeta1i + zeta2i;
					d = zabs(argr, argi);
				}
				if (kode != 1)
				{
					num11 -= num5;
					num12 -= num6;
				}
				if (ikflg != 1)
				{
					num11 = 0.0 - num11;
					num12 = 0.0 - num12;
				}
				double d2 = zabs(phir, phii);
				double num13 = num11;
				if (!(num13 > elim))
				{
					if (num13 < alim)
					{
						if (!(num13 < 0.0 - elim))
						{
							if (num13 > 0.0 - alim)
							{
								goto IL_03ad;
							}
							num13 += Math.Log(d2);
							if (num9 == 2)
							{
								num13 = num13 - Math.Log(d) * 0.25 - 1.2655121234846454;
							}
							if (num13 > 0.0 - elim)
							{
								double ascle = d1mach(1) * 1000.0 / tol;
								zlog(phir, phii, ref br, ref bi, ref ierr);
								num11 += br;
								num12 += bi;
								if (num9 != 1)
								{
									zlog(argr, argi, ref br, ref bi, ref ierr);
									num11 = num11 - br * 0.25 - 1.2655121234846454;
									num12 -= bi * 0.25;
								}
								num7 = Math.Exp(num13) / tol;
								num8 = num12;
								num11 = num7 * Math.Cos(num8);
								num12 = num7 * Math.Sin(num8);
								zuchk(num11, num12, ref nz, ascle, tol);
								if (nz == 0)
								{
									goto IL_03ad;
								}
							}
						}
						for (int i = 1; i <= num2; i++)
						{
							yr[i - 1] = 0.0;
							yi[i - 1] = 0.0;
						}
						nuf = num2;
						return 0;
					}
					num13 += Math.Log(d2);
					if (num9 == 2)
					{
						num13 = num13 - Math.Log(d) * 0.25 - 1.2655121234846454;
					}
					if (!(num13 > elim))
					{
						goto IL_03ad;
					}
				}
				nuf = -1;
				return 0;
				IL_03ad:
				if (ikflg == 2)
				{
					return 0;
				}
				if (n == 1)
				{
					return 0;
				}
				while (true)
				{
					fnu2 = fnu + (double)(num2 - 1);
					if (num9 != 2)
					{
						int init = 0;
						zunik(num3, num4, fnu2, ikflg, 1, tol, ref init, ref phir, ref phii, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref sumr, ref sumi, ref cwrkr, ref cwrki);
						num11 = 0.0 - zeta1r + zeta2r;
						num12 = 0.0 - zeta1i + zeta2i;
					}
					else
					{
						zunhj(num, zi2, fnu2, 1, tol, ref phir, ref phii, ref argr, ref argi, ref zeta1r, ref zeta1i, ref zeta2r, ref zeta2i, ref asumr, ref asumi, ref bsumr, ref bsumi);
						num11 = 0.0 - zeta1r + zeta2r;
						num12 = 0.0 - zeta1i + zeta2i;
						d = zabs(argr, argi);
					}
					if (kode != 1)
					{
						num11 -= num5;
						num12 -= num6;
					}
					d2 = zabs(phir, phii);
					num13 = num11;
					if (!(num13 < 0.0 - elim))
					{
						if (num13 > 0.0 - alim)
						{
							return 0;
						}
						num13 += Math.Log(d2);
						if (num9 == 2)
						{
							num13 = num13 - Math.Log(d) * 0.25 - 1.2655121234846454;
						}
						if (num13 > 0.0 - elim)
						{
							double ascle = d1mach(1) * 1000.0 / tol;
							zlog(phir, phii, ref br, ref bi, ref ierr);
							num11 += br;
							num12 += bi;
							if (num9 != 1)
							{
								zlog(argr, argi, ref br, ref bi, ref ierr);
								num11 = num11 - br * 0.25 - 1.2655121234846454;
								num12 -= bi * 0.25;
							}
							num7 = Math.Exp(num13) / tol;
							num8 = num12;
							num11 = num7 * Math.Cos(num8);
							num12 = num7 * Math.Sin(num8);
							zuchk(num11, num12, ref nz, ascle, tol);
							if (nz == 0)
							{
								break;
							}
						}
					}
					yr[num2 - 1] = 0.0;
					yi[num2 - 1] = 0.0;
					num2--;
					nuf++;
					if (num2 == 0)
					{
						return 0;
					}
				}
				return 0;
			}

			private static int zwrsk(double zrr, double zri, double fnu, int kode, int n, double[] yr, double[] yi, ref int nz, double[] cwr, double[] cwi, double tol, double elim, double alim)
			{
				int nz2 = 0;
				nz = 0;
				zbknu(zrr, zri, fnu, kode, 2, cwr, cwi, ref nz2, tol, elim, alim);
				if (nz2 == 0)
				{
					zrati(zrr, zri, fnu, n, yr, yi, tol);
					double num = 1.0;
					double num2 = 0.0;
					if (kode != 1)
					{
						num = Math.Cos(zri);
						num2 = Math.Sin(zri);
					}
					double num3 = zabs(cwr[1], cwi[1]);
					double num4 = d1mach(1) * 1000.0 / tol;
					double num5 = 1.0;
					if (!(num3 > num4))
					{
						num5 = 1.0 / tol;
					}
					else
					{
						num4 = 1.0 / num4;
						if (!(num3 < num4))
						{
							num5 = tol;
						}
					}
					double num6 = cwr[0] * num5;
					double num7 = cwi[0] * num5;
					double num8 = cwr[1] * num5;
					double num9 = cwi[1] * num5;
					double num10 = yr[0];
					double num11 = yi[0];
					double num12 = num10 * num6 - num11 * num7;
					double num13 = num10 * num7 + num11 * num6;
					num12 += num8;
					num13 += num9;
					double num14 = zrr * num12 - zri * num13;
					double num15 = zrr * num13 + zri * num12;
					double num16 = zabs(num14, num15);
					double num17 = 1.0 / num16;
					num14 *= num17;
					num15 = (0.0 - num15) * num17;
					num12 = num * num17;
					num13 = num2 * num17;
					num = num12 * num14 - num13 * num15;
					num2 = num12 * num15 + num13 * num14;
					yr[0] = num * num5;
					yi[0] = num2 * num5;
					if (n == 1)
					{
						return 0;
					}
					for (int i = 2; i <= n; i++)
					{
						num12 = num10 * num - num11 * num2;
						num2 = num10 * num2 + num11 * num;
						num = num12;
						num10 = yr[i - 1];
						num11 = yi[i - 1];
						yr[i - 1] = num * num5;
						yi[i - 1] = num2 * num5;
					}
					return 0;
				}
				nz = -1;
				if (nz2 == -2)
				{
					nz = -2;
				}
				return 0;
			}
		}

		private static readonly double[] ErfImpAn = new double[8] { 0.0033791670955125737, -0.0007369565304816795, -0.3747323373929196, 0.08174424487335873, -0.04210893199365486, 0.007016570951209575, -0.004950912559824351, 0.0008716465990379225 };

		private static readonly double[] ErfImpAd = new double[8] { 1.0, -0.21808821808792464, 0.4125429727254421, -0.08418911478731067, 0.06553388564002416, -0.012001960445494177, 0.00408165558926174, -0.0006159007215577697 };

		private static readonly double[] ErfImpBn = new double[6] { -0.03617903907182625, 0.2922518834448827, 0.2814470417976045, 0.12561020886276694, 0.027413502826893053, 0.0025083967216806575 };

		private static readonly double[] ErfImpBd = new double[6] { 1.0, 1.8545005897903486, 1.4357580303783142, 0.5828276587530365, 0.12481047693294975, 0.011372417654635328 };

		private static readonly double[] ErfImpCn = new double[7] { -0.03978768926111369, 0.1531652124678783, 0.19126029560093624, 0.10276327061989304, 0.029637090615738836, 0.004609348678027549, 0.0003076078203486802 };

		private static readonly double[] ErfImpCd = new double[7] { 1.0, 1.955200729876277, 1.6476231719938486, 0.7682386070221262, 0.20979318593650978, 0.031956931689991336, 0.0021336316089578537 };

		private static readonly double[] ErfImpDn = new double[7] { -0.030083856055794972, 0.05385788298444545, 0.07262115416519142, 0.036762846988804936, 0.009646290155725275, 0.0013345348007529107, 7.780875997825043E-05 };

		private static readonly double[] ErfImpDd = new double[8] { 1.0, 1.7596709814716753, 1.3288357143796112, 0.5525285965087576, 0.13379305694133287, 0.017950964517628076, 0.0010471244001993736, -1.0664038182035734E-08 };

		private static readonly double[] ErfImpEn = new double[7] { -0.011790757013722784, 0.01426213209053881, 0.020223443590296084, 0.009306682999904321, 0.00213357802422066, 0.00025022987386460105, 1.2053491221958819E-05 };

		private static readonly double[] ErfImpEd = new double[7] { 1.0, 1.5037622520362048, 0.9653977862044629, 0.3392652304767967, 0.06897406495415698, 0.007710602624917683, 0.0003714211015310693 };

		private static readonly double[] ErfImpFn = new double[7] { -0.005469547955387293, 0.004041902787317071, 0.005496336955316117, 0.002126164726039454, 0.0003949840144950839, 3.655654770644424E-05, 1.3548589710993232E-06 };

		private static readonly double[] ErfImpFd = new double[8] { 1.0, 1.2101969777363077, 0.6209146682211439, 0.17303843066114277, 0.027655081377343203, 0.0024062597442430973, 8.918118172513365E-05, -4.655288362833827E-12 };

		private static readonly double[] ErfImpGn = new double[6] { -0.0027072253590577837, 0.00131875634250294, 0.0011992593326100233, 0.00027849619811344664, 2.6782298821833186E-05, 9.230436723150282E-07 };

		private static readonly double[] ErfImpGd = new double[7] { 1.0, 0.8146328085431416, 0.26890166585629954, 0.044987721610304114, 0.0038175966332024847, 0.00013157189788859692, 4.048153596757641E-12 };

		private static readonly double[] ErfImpHn = new double[6] { -0.001099467206917422, 0.00040642544275042267, 0.0002744994894169007, 4.652937706466594E-05, 3.2095542539576746E-06, 7.782860181450209E-08 };

		private static readonly double[] ErfImpHd = new double[6] { 1.0, 0.5881737106118461, 0.13936333128940975, 0.016632934041708368, 0.0010002392131023491, 2.4254837521587224E-05 };

		private static readonly double[] ErfImpIn = new double[5] { -0.0005690799360109496, 0.00016949854037376225, 5.184723545811009E-05, 3.8281931223192885E-06, 8.249899312818944E-08 };

		private static readonly double[] ErfImpId = new double[6] { 1.0, 0.33963725005113937, 0.04347264787031066, 0.002485493352246371, 5.356333053371529E-05, -1.1749094440545958E-13 };

		private static readonly double[] ErfImpJn = new double[5] { -0.00024131359948399134, 5.742249752025015E-05, 1.1599896292738377E-05, 5.817621344025938E-07, 8.539715550856736E-09 };

		private static readonly double[] ErfImpJd = new double[5] { 1.0, 0.23304413829968784, 0.02041869405464403, 0.0007971856475643983, 1.1701928167017232E-05 };

		private static readonly double[] ErfImpKn = new double[5] { -0.00014667469927776036, 1.6266655211228053E-05, 2.6911624850916523E-06, 9.79584479468092E-08, 1.0199464762572346E-09 };

		private static readonly double[] ErfImpKd = new double[5] { 1.0, 0.16590781294484722, 0.010336171619150588, 0.0002865930263738684, 2.9840157084090034E-06 };

		private static readonly double[] ErfImpLn = new double[5] { -5.839057976297718E-05, 4.125103251054962E-06, 4.3179092242025094E-07, 9.933651555900132E-09, 6.534805100201047E-11 };

		private static readonly double[] ErfImpLd = new double[5] { 1.0, 0.10507708607203992, 0.004142784286754756, 7.263387546445238E-05, 4.778184710473988E-07 };

		private static readonly double[] ErfImpMn = new double[4] { -1.9645779760922958E-05, 1.572438876668007E-06, 5.439025111927009E-08, 3.174724923691177E-10 };

		private static readonly double[] ErfImpMd = new double[5] { 1.0, 0.05280398924095763, 0.0009268760691517533, 5.410117232266303E-06, 5.350938458036424E-16 };

		private static readonly double[] ErfImpNn = new double[4] { -7.892247039787227E-06, 6.22088451660987E-07, 1.457284456768824E-08, 6.037155055427153E-11 };

		private static readonly double[] ErfImpNd = new double[4] { 1.0, 0.03753288463562937, 0.0004679195359746253, 1.9384703927584565E-06 };

		private static readonly double[] ErvInvImpAn = new double[8] { -0.0005087819496582806, -0.008368748197417368, 0.03348066254097446, -0.012692614766297404, -0.03656379714117627, 0.02198786811111689, 0.008226878746769157, -0.005387729650712429 };

		private static readonly double[] ErvInvImpAd = new double[10] { 1.0, -0.9700050433032906, -1.5657455823417585, 1.5622155839842302, 0.662328840472003, -0.7122890234154284, -0.05273963823400997, 0.07952836873415717, -0.0023339375937419, 0.0008862163904564247 };

		private static readonly double[] ErvInvImpBn = new double[9] { -0.20243350835593876, 0.10526468069939171, 8.3705032834312, 17.644729840837403, -18.851064805871424, -44.6382324441787, 17.445385985570866, 21.12946554483405, -3.6719225470772936 };

		private static readonly double[] ErvInvImpBd = new double[9] { 1.0, 6.242641248542475, 3.971343795334387, -28.66081804998, -20.14326346804852, 48.560921310873994, 10.826866735546016, -22.643693341313973, 1.7211476576120028 };

		private static readonly double[] ErvInvImpCn = new double[11]
		{
			-0.1311027816799519, -0.16379404719331705, 0.11703015634199525, 0.38707973897260434, 0.3377855389120359, 0.14286953440815717, 0.029015791000532906, 0.0021455899538880526, -6.794655751811263E-07, 2.8522533178221704E-08,
			-6.81149956853777E-10
		};

		private static readonly double[] ErvInvImpCd = new double[8] { 1.0, 3.4662540724256723, 5.381683457070069, 4.778465929458438, 2.5930192162362027, 0.848854343457902, 0.15226433829533179, 0.011059242293464892 };

		private static readonly double[] ErvInvImpDn = new double[9] { -0.0350353787183178, -0.0022242652921344794, 0.018557330651423107, 0.009508047013259196, 0.0018712349281955923, 0.00015754461742496055, 4.60469890584318E-06, -2.304047769118826E-10, 2.6633922742578204E-12 };

		private static readonly double[] ErvInvImpDd = new double[7] { 1.0, 1.3653349817554064, 0.7620591645536234, 0.22009110576413124, 0.03415891436709477, 0.00263861676657016, 7.646752923027944E-05 };

		private static readonly double[] ErvInvImpEn = new double[9] { -0.016743100507663373, -0.0011295143874558028, 0.001056288621524929, 0.00020938631748758808, 1.4962478375834237E-05, 4.4969678992770644E-07, 4.625961635228786E-09, -2.811287356288318E-14, 9.905570997331033E-17 };

		private static readonly double[] ErvInvImpEd = new double[7] { 1.0, 0.5914293448864175, 0.1381518657490833, 0.016074608709367652, 0.0009640118070051656, 2.7533547476472603E-05, 2.82243172016108E-07 };

		private static readonly double[] ErvInvImpFn = new double[8] { -0.002497821279189813, -7.79190719229054E-06, 2.5472303741302746E-05, 1.6239777734251093E-06, 3.963410113048012E-08, 4.116328311909442E-10, 1.4559628671867504E-12, -1.1676501239718427E-18 };

		private static readonly double[] ErvInvImpFd = new double[7] { 1.0, 0.2071231122144225, 0.01694108381209759, 0.0006905382656226846, 1.4500735981823264E-05, 1.4443775662814415E-07, 5.097612765997785E-10 };

		private static readonly double[] ErvInvImpGn = new double[8] { -0.0005390429110190785, -2.8398759004727723E-07, 8.994651148922914E-07, 2.2934585926592085E-08, 2.2556144486350015E-10, 9.478466275030226E-13, 1.3588013010892486E-15, -3.4889039339994887E-22 };

		private static readonly double[] ErvInvImpGd = new double[7] { 1.0, 0.08457462340018994, 0.002820929847262647, 4.682929219408942E-05, 3.999688121938621E-07, 1.6180929088790448E-09, 2.315586083102596E-12 };

		private const int FactorialMaxArgument = 170;

		private static readonly double[] _factorialCache = new double[171]
		{
			1.0, 1.0, 2.0, 6.0, 24.0, 120.0, 720.0, 5040.0, 40320.0, 362880.0,
			3628800.0, 39916800.0, 479001600.0, 6227020800.0, 87178291200.0, 1307674368000.0, 20922789888000.0, 355687428096000.0, 6402373705728000.0, 1.21645100408832E+17,
			2.43290200817664E+18, 5.109094217170944E+19, 1.1240007277776077E+21, 2.585201673888498E+22, 6.204484017332394E+23, 1.5511210043330986E+25, 4.0329146112660565E+26, 1.0888869450418352E+28, 3.0488834461171384E+29, 8.841761993739701E+30,
			2.6525285981219103E+32, 8.222838654177922E+33, 2.631308369336935E+35, 8.683317618811886E+36, 2.9523279903960412E+38, 1.0333147966386144E+40, 3.719933267899012E+41, 1.3763753091226343E+43, 5.23022617466601E+44, 2.0397882081197442E+46,
			8.159152832478977E+47, 3.3452526613163803E+49, 1.4050061177528798E+51, 6.041526306337383E+52, 2.6582715747884485E+54, 1.1962222086548019E+56, 5.5026221598120885E+57, 2.5862324151116818E+59, 1.2413915592536073E+61, 6.082818640342675E+62,
			3.0414093201713376E+64, 1.5511187532873822E+66, 8.065817517094388E+67, 4.2748832840600255E+69, 2.308436973392414E+71, 1.2696403353658276E+73, 7.109985878048635E+74, 4.052691950487722E+76, 2.350561331282879E+78, 1.3868311854568986E+80,
			8.320987112741392E+81, 5.075802138772248E+83, 3.146997326038794E+85, 1.98260831540444E+87, 1.2688693218588417E+89, 8.247650592082472E+90, 5.443449390774431E+92, 3.647111091818868E+94, 2.4800355424368305E+96, 1.711224524281413E+98,
			1.197857166996989E+100, 8.504785885678622E+101, 6.123445837688608E+103, 4.4701154615126834E+105, 3.3078854415193856E+107, 2.480914081139539E+109, 1.8854947016660498E+111, 1.4518309202828584E+113, 1.1324281178206295E+115, 8.946182130782973E+116,
			7.156945704626378E+118, 5.797126020747366E+120, 4.75364333701284E+122, 3.945523969720657E+124, 3.314240134565352E+126, 2.8171041143805494E+128, 2.4227095383672724E+130, 2.107757298379527E+132, 1.8548264225739836E+134, 1.6507955160908452E+136,
			1.4857159644817607E+138, 1.3520015276784023E+140, 1.24384140546413E+142, 1.1567725070816409E+144, 1.0873661566567424E+146, 1.0329978488239052E+148, 9.916779348709491E+149, 9.619275968248206E+151, 9.426890448883242E+153, 9.33262154439441E+155,
			9.33262154439441E+157, 9.425947759838354E+159, 9.614466715035121E+161, 9.902900716486175E+163, 1.0299016745145622E+166, 1.0813967582402903E+168, 1.1462805637347078E+170, 1.2265202031961373E+172, 1.3246418194518284E+174, 1.4438595832024928E+176,
			1.5882455415227421E+178, 1.7629525510902437E+180, 1.9745068572210728E+182, 2.2311927486598123E+184, 2.543559733472186E+186, 2.925093693493014E+188, 3.3931086844518965E+190, 3.969937160808719E+192, 4.6845258497542883E+194, 5.574585761207603E+196,
			6.689502913449124E+198, 8.09429852527344E+200, 9.875044200833598E+202, 1.2146304367025325E+205, 1.5061417415111404E+207, 1.8826771768889254E+209, 2.372173242880046E+211, 3.012660018457658E+213, 3.8562048236258025E+215, 4.9745042224772855E+217,
			6.466855489220472E+219, 8.471580690878817E+221, 1.118248651196004E+224, 1.4872707060906852E+226, 1.992942746161518E+228, 2.6904727073180495E+230, 3.659042881952547E+232, 5.01288874827499E+234, 6.917786472619486E+236, 9.615723196941086E+238,
			1.346201247571752E+241, 1.89814375907617E+243, 2.6953641378881614E+245, 3.8543707171800706E+247, 5.550293832739301E+249, 8.047926057471987E+251, 1.17499720439091E+254, 1.7272458904546376E+256, 2.5563239178728637E+258, 3.808922637630567E+260,
			5.7133839564458505E+262, 8.627209774233235E+264, 1.3113358856834518E+267, 2.006343905095681E+269, 3.089769613847349E+271, 4.789142901463391E+273, 7.47106292628289E+275, 1.1729568794264138E+278, 1.8532718694937338E+280, 2.946702272495037E+282,
			4.714723635992059E+284, 7.590705053947215E+286, 1.2296942187394488E+289, 2.0044015765453015E+291, 3.2872185855342945E+293, 5.423910666131586E+295, 9.003691705778433E+297, 1.5036165148649983E+300, 2.526075744973197E+302, 4.2690680090047027E+304,
			7.257415615307994E+306
		};

		private const int GammaN = 10;

		private const double GammaR = 10.900511;

		private static readonly double[] GammaDk = new double[11]
		{
			2.4857408913875355E-05, 1.0514237858172197, -3.4568709722201625, 4.512277094668948, -2.9828522532357664, 1.056397115771267, -0.19542877319164587, 0.01709705434044412, -0.0005719261174043057, 4.633994733599057E-06,
			-2.7199490848860772E-09
		};

		private static readonly double[] BesselI0A = new double[30]
		{
			-4.4153416464793395E-18, 3.3307945188222384E-17, -2.431279846547955E-16, 1.715391285555133E-15, -1.1685332877993451E-14, 7.676185498604936E-14, -4.856446783111929E-13, 2.95505266312964E-12, -1.726826291441556E-11, 9.675809035373237E-11,
			-5.189795601635263E-10, 2.6598237246823866E-09, -1.300025009986248E-08, 6.046995022541919E-08, -2.670793853940612E-07, 1.1173875391201037E-06, -4.4167383584587505E-06, 1.6448448070728896E-05, -5.754195010082104E-05, 0.00018850288509584165,
			-0.0005763755745385824, 0.0016394756169413357, -0.004324309995050576, 0.010546460394594998, -0.02373741480589947, 0.04930528423967071, -0.09490109704804764, 0.17162090152220877, -0.3046826723431984, 0.6767952744094761
		};

		private static readonly double[] BesselI0B = new double[25]
		{
			-7.233180487874754E-18, -4.830504485944182E-18, 4.46562142029676E-17, 3.461222867697461E-17, -2.8276239805165836E-16, -3.425485619677219E-16, 1.7725601330565263E-15, 3.8116806693526224E-15, -9.554846698828307E-15, -4.150569347287222E-14,
			1.54008621752141E-14, 3.8527783827421426E-13, 7.180124451383666E-13, -1.7941785315068062E-12, -1.3215811840447713E-11, -3.1499165279632416E-11, 1.1889147107846439E-11, 4.94060238822497E-10, 3.3962320257083865E-09, 2.266668990498178E-08,
			2.0489185894690638E-07, 2.8913705208347567E-06, 6.889758346916825E-05, 0.0033691164782556943, 0.8044904110141088
		};

		private static readonly double[] BesselI1A = new double[29]
		{
			2.7779141127610464E-18, -2.111421214358166E-17, 1.5536319577362005E-16, -1.1055969477353862E-15, 7.600684294735408E-15, -5.042185504727912E-14, 3.223793365945575E-13, -1.9839743977649436E-12, 1.1736186298890901E-11, -6.663489723502027E-11,
			3.625590281552117E-10, -1.8872497517228294E-09, 9.381537386495773E-09, -4.445059128796328E-08, 2.0032947535521353E-07, -8.568720264695455E-07, 3.4702513081376785E-06, -1.3273163656039436E-05, 4.781565107550054E-05, -0.00016176081582589674,
			0.0005122859561685758, -0.0015135724506312532, 0.004156422944312888, -0.010564084894626197, 0.024726449030626516, -0.05294598120809499, 0.1026436586898471, -0.17641651835783406, 0.25258718644363365
		};

		private static readonly double[] BesselI1B = new double[25]
		{
			7.517296310842105E-18, 4.414348323071708E-18, -4.6503053684893586E-17, -3.209525921993424E-17, 2.96262899764595E-16, 3.3082023109209285E-16, -1.8803547755107825E-15, -3.8144030724370075E-15, 1.0420276984128802E-14, 4.272440016711951E-14,
			-2.1015418427726643E-14, -4.0835511110921974E-13, -7.198551776245908E-13, 2.0356285441470896E-12, 1.4125807436613782E-11, 3.2526035830154884E-11, -1.8974958123505413E-11, -5.589743462196584E-10, -3.835380385964237E-09, -2.6314688468895196E-08,
			-2.512236237870209E-07, -3.882564808877691E-06, -0.00011058893876262371, -0.009761097491361469, 0.7785762350182801
		};

		private static readonly double[] BesselK0A = new double[10] { 1.374465435613523E-16, 4.25981614279661E-14, 1.0349695257633842E-11, 1.904516377220209E-09, 2.5347910790261494E-07, 2.286212103119452E-05, 0.001264615411446926, 0.0359799365153615, 0.3442898999246285, -0.5353273932339028 };

		private static readonly double[] BesselK0B = new double[25]
		{
			5.300433772686263E-18, -1.6475804301524212E-17, 5.2103915050390274E-17, -1.678231096805412E-16, 5.512055978524319E-16, -1.848593377343779E-15, 6.3400764774050706E-15, -2.2275133269916698E-14, 8.032890775363575E-14, -2.9800969231727303E-13,
			1.140340588208475E-12, -4.514597883373944E-12, 1.8559491149547177E-11, -7.957489244477107E-11, 3.577397281400301E-10, -1.69753450938906E-09, 8.574034017414225E-09, -4.660489897687948E-08, 2.766813639445015E-07, -1.8317555227191195E-06,
			1.39498137188765E-05, -0.00012849549581627802, 0.0015698838857300533, -0.0314481013119645, 2.4403030820659555
		};

		private static readonly double[] BesselK1A = new double[11]
		{
			-7.023863479386288E-18, -2.427449850519366E-15, -6.666901694199329E-13, -1.4114883926335278E-10, -2.213387630734726E-08, -2.4334061415659684E-06, -0.0001730288957513052, -0.006975723859639864, -0.12261118082265715, -0.3531559607765449,
			1.5253002273389478
		};

		private static readonly double[] BesselK1B = new double[25]
		{
			-5.756744483665017E-18, 1.7940508731475592E-17, -5.689462558442859E-17, 1.838093544366639E-16, -6.057047248373319E-16, 2.038703165624334E-15, -7.019837090418314E-15, 2.4771544244813043E-14, -8.976705182324994E-14, 3.3484196660784293E-13,
			-1.2891739609510289E-12, 5.13963967348173E-12, -2.1299678384275683E-11, 9.218315187605006E-11, -4.1903547593418965E-10, 2.015049755197033E-09, -1.0345762465678097E-08, 5.7410841254500495E-08, -3.5019606030878126E-07, 2.406484947837217E-06,
			-1.936197974166083E-05, 0.00019521551847135162, -0.002857816859622779, 0.10392373657681724, 2.7206261904844427
		};

		public static Complex AiryAi(Complex z)
		{
			return Amos.Cairy(z);
		}

		public static Complex AiryAiScaled(Complex z)
		{
			return Amos.ScaledCairy(z);
		}

		public static double AiryAi(double z)
		{
			return AiryAi(new Complex(z, 0.0)).Real;
		}

		public static double AiryAiScaled(double z)
		{
			return Amos.ScaledCairy(z);
		}

		public static Complex AiryAiPrime(Complex z)
		{
			return Amos.CairyPrime(z);
		}

		public static Complex AiryAiPrimeScaled(Complex z)
		{
			return Amos.ScaledCairyPrime(z);
		}

		public static double AiryAiPrime(double z)
		{
			return AiryAiPrime(new Complex(z, 0.0)).Real;
		}

		public static double AiryAiPrimeScaled(double z)
		{
			return Amos.ScaledCairyPrime(z);
		}

		public static Complex AiryBi(Complex z)
		{
			return Amos.Cbiry(z);
		}

		public static Complex AiryBiScaled(Complex z)
		{
			return Amos.ScaledCbiry(z);
		}

		public static double AiryBi(double z)
		{
			return AiryBi(new Complex(z, 0.0)).Real;
		}

		public static double AiryBiScaled(double z)
		{
			return AiryBiScaled(new Complex(z, 0.0)).Real;
		}

		public static Complex AiryBiPrime(Complex z)
		{
			return Amos.CbiryPrime(z);
		}

		public static Complex AiryBiPrimeScaled(Complex z)
		{
			return Amos.ScaledCbiryPrime(z);
		}

		public static double AiryBiPrime(double z)
		{
			return AiryBiPrime(new Complex(z, 0.0)).Real;
		}

		public static double AiryBiPrimeScaled(double z)
		{
			return AiryBiPrimeScaled(new Complex(z, 0.0)).Real;
		}

		public static Complex BesselJ(double n, Complex z)
		{
			return Amos.Cbesj(n, z);
		}

		public static Complex BesselJScaled(double n, Complex z)
		{
			return Amos.ScaledCbesj(n, z);
		}

		public static double BesselJ(double n, double z)
		{
			return Amos.Cbesj(n, z);
		}

		public static double BesselJScaled(double n, double z)
		{
			return Amos.ScaledCbesj(n, z);
		}

		public static Complex BesselY(double n, Complex z)
		{
			return Amos.Cbesy(n, z);
		}

		public static Complex BesselYScaled(double n, Complex z)
		{
			return Amos.ScaledCbesy(n, z);
		}

		public static double BesselY(double n, double z)
		{
			return Amos.Cbesy(n, z);
		}

		public static double BesselYScaled(double n, double z)
		{
			return Amos.ScaledCbesy(n, z);
		}

		public static Complex BesselI(double n, Complex z)
		{
			return Amos.Cbesi(n, z);
		}

		public static Complex BesselIScaled(double n, Complex z)
		{
			return Amos.ScaledCbesi(n, z);
		}

		public static double BesselI(double n, double z)
		{
			return BesselI(n, new Complex(z, 0.0)).Real;
		}

		public static double BesselIScaled(double n, double z)
		{
			return Amos.ScaledCbesi(n, z);
		}

		public static Complex BesselK(double n, Complex z)
		{
			return Amos.Cbesk(n, z);
		}

		public static Complex BesselKScaled(double n, Complex z)
		{
			return Amos.ScaledCbesk(n, z);
		}

		public static double BesselK(double n, double z)
		{
			return Amos.Cbesk(n, z);
		}

		public static double BesselKScaled(double n, double z)
		{
			return Amos.ScaledCbesk(n, z);
		}

		public static double BetaLn(double z, double w)
		{
			if (z <= 0.0)
			{
				throw new ArgumentException("Value must be positive.", "z");
			}
			if (w <= 0.0)
			{
				throw new ArgumentException("Value must be positive.", "w");
			}
			return GammaLn(z) + GammaLn(w) - GammaLn(z + w);
		}

		public static double Beta(double z, double w)
		{
			return Math.Exp(BetaLn(z, w));
		}

		public static double BetaIncomplete(double a, double b, double x)
		{
			return BetaRegularized(a, b, x) * Beta(a, b);
		}

		public static double BetaRegularized(double a, double b, double x)
		{
			if (a < 0.0)
			{
				throw new ArgumentOutOfRangeException("a", "Value must not be negative (zero is ok).");
			}
			if (b < 0.0)
			{
				throw new ArgumentOutOfRangeException("b", "Value must not be negative (zero is ok).");
			}
			if (x < 0.0 || x > 1.0)
			{
				throw new ArgumentOutOfRangeException("x", "Value is expected to be between 0.0 and 1.0 (including 0.0 and 1.0).");
			}
			double num = ((x == 0.0 || x == 1.0) ? 0.0 : Math.Exp(GammaLn(a + b) - GammaLn(a) - GammaLn(b) + a * Math.Log(x) + b * Math.Log(1.0 - x)));
			bool flag = x >= (a + 1.0) / (a + b + 2.0);
			double doublePrecision = Precision.DoublePrecision;
			double num2 = 0.0.Increment() / doublePrecision;
			if (flag)
			{
				x = 1.0 - x;
				double num3 = a;
				a = b;
				b = num3;
			}
			double num4 = a + b;
			double num5 = a + 1.0;
			double num6 = a - 1.0;
			double num7 = 1.0;
			double num8 = 1.0 - num4 * x / num5;
			if (Math.Abs(num8) < num2)
			{
				num8 = num2;
			}
			num8 = 1.0 / num8;
			double num9 = num8;
			int num10 = 1;
			int num11 = 2;
			while (num10 <= 50000)
			{
				double num12 = (double)num10 * (b - (double)num10) * x / ((num6 + (double)num11) * (a + (double)num11));
				num8 = 1.0 + num12 * num8;
				if (Math.Abs(num8) < num2)
				{
					num8 = num2;
				}
				num7 = 1.0 + num12 / num7;
				if (Math.Abs(num7) < num2)
				{
					num7 = num2;
				}
				num8 = 1.0 / num8;
				num9 *= num8 * num7;
				num12 = (0.0 - (a + (double)num10)) * (num4 + (double)num10) * x / ((a + (double)num11) * (num5 + (double)num11));
				num8 = 1.0 + num12 * num8;
				if (Math.Abs(num8) < num2)
				{
					num8 = num2;
				}
				num7 = 1.0 + num12 / num7;
				if (Math.Abs(num7) < num2)
				{
					num7 = num2;
				}
				num8 = 1.0 / num8;
				double num13 = num8 * num7;
				num9 *= num13;
				if (Math.Abs(num13 - 1.0) <= doublePrecision)
				{
					if (!flag)
					{
						return num * num9 / a;
					}
					return 1.0 - num * num9 / a;
				}
				num10++;
				num11 += 2;
			}
			if (!flag)
			{
				return num * num9 / a;
			}
			return 1.0 - num * num9 / a;
		}

		public static double Erf(double x)
		{
			if (x == 0.0)
			{
				return 0.0;
			}
			if (double.IsPositiveInfinity(x))
			{
				return 1.0;
			}
			if (double.IsNegativeInfinity(x))
			{
				return -1.0;
			}
			if (double.IsNaN(x))
			{
				return double.NaN;
			}
			return ErfImp(x, invert: false);
		}

		public static double Erfc(double x)
		{
			if (x == 0.0)
			{
				return 1.0;
			}
			if (double.IsPositiveInfinity(x))
			{
				return 0.0;
			}
			if (double.IsNegativeInfinity(x))
			{
				return 2.0;
			}
			if (double.IsNaN(x))
			{
				return double.NaN;
			}
			return ErfImp(x, invert: true);
		}

		public static double ErfInv(double z)
		{
			if (z == 0.0)
			{
				return 0.0;
			}
			if (z >= 1.0)
			{
				return double.PositiveInfinity;
			}
			if (z <= -1.0)
			{
				return double.NegativeInfinity;
			}
			double num;
			double q;
			double s;
			if (z < 0.0)
			{
				num = 0.0 - z;
				q = 1.0 - num;
				s = -1.0;
			}
			else
			{
				num = z;
				q = 1.0 - z;
				s = 1.0;
			}
			return ErfInvImpl(num, q, s);
		}

		private static double ErfImp(double z, bool invert)
		{
			if (z < 0.0)
			{
				if (!invert)
				{
					return 0.0 - ErfImp(0.0 - z, invert: false);
				}
				if (z < -0.5)
				{
					return 2.0 - ErfImp(0.0 - z, invert: true);
				}
				return 1.0 + ErfImp(0.0 - z, invert: false);
			}
			double num;
			if (z < 0.5)
			{
				num = ((!(z < 1E-10)) ? (z * 1.125 + z * Polynomial.Evaluate(z, ErfImpAn) / Polynomial.Evaluate(z, ErfImpAd)) : (z * 1.125 + z * 0.0033791670955125737));
			}
			else if (z < 110.0)
			{
				invert = !invert;
				double num2;
				double num3;
				if (z < 0.75)
				{
					num2 = Polynomial.Evaluate(z - 0.5, ErfImpBn) / Polynomial.Evaluate(z - 0.5, ErfImpBd);
					num3 = 0.3440242111682892;
				}
				else if (z < 1.25)
				{
					num2 = Polynomial.Evaluate(z - 0.75, ErfImpCn) / Polynomial.Evaluate(z - 0.75, ErfImpCd);
					num3 = 0.4199909269809723;
				}
				else if (z < 2.25)
				{
					num2 = Polynomial.Evaluate(z - 1.25, ErfImpDn) / Polynomial.Evaluate(z - 1.25, ErfImpDd);
					num3 = 0.48986250162124634;
				}
				else if (z < 3.5)
				{
					num2 = Polynomial.Evaluate(z - 2.25, ErfImpEn) / Polynomial.Evaluate(z - 2.25, ErfImpEd);
					num3 = 0.5317370891571045;
				}
				else if (z < 5.25)
				{
					num2 = Polynomial.Evaluate(z - 3.5, ErfImpFn) / Polynomial.Evaluate(z - 3.5, ErfImpFd);
					num3 = 0.5489973425865173;
				}
				else if (z < 8.0)
				{
					num2 = Polynomial.Evaluate(z - 5.25, ErfImpGn) / Polynomial.Evaluate(z - 5.25, ErfImpGd);
					num3 = 0.5571740865707397;
				}
				else if (z < 11.5)
				{
					num2 = Polynomial.Evaluate(z - 8.0, ErfImpHn) / Polynomial.Evaluate(z - 8.0, ErfImpHd);
					num3 = 0.5609807968139648;
				}
				else if (z < 17.0)
				{
					num2 = Polynomial.Evaluate(z - 11.5, ErfImpIn) / Polynomial.Evaluate(z - 11.5, ErfImpId);
					num3 = 0.5626493692398071;
				}
				else if (z < 24.0)
				{
					num2 = Polynomial.Evaluate(z - 17.0, ErfImpJn) / Polynomial.Evaluate(z - 17.0, ErfImpJd);
					num3 = 0.5634598135948181;
				}
				else if (z < 38.0)
				{
					num2 = Polynomial.Evaluate(z - 24.0, ErfImpKn) / Polynomial.Evaluate(z - 24.0, ErfImpKd);
					num3 = 0.5638477802276611;
				}
				else if (z < 60.0)
				{
					num2 = Polynomial.Evaluate(z - 38.0, ErfImpLn) / Polynomial.Evaluate(z - 38.0, ErfImpLd);
					num3 = 0.5640528202056885;
				}
				else if (z < 85.0)
				{
					num2 = Polynomial.Evaluate(z - 60.0, ErfImpMn) / Polynomial.Evaluate(z - 60.0, ErfImpMd);
					num3 = 0.5641309022903442;
				}
				else
				{
					num2 = Polynomial.Evaluate(z - 85.0, ErfImpNn) / Polynomial.Evaluate(z - 85.0, ErfImpNd);
					num3 = 0.5641584396362305;
				}
				double num4 = Math.Exp((0.0 - z) * z) / z;
				num = num4 * num3 + num4 * num2;
			}
			else
			{
				num = 0.0;
				invert = !invert;
			}
			if (invert)
			{
				num = 1.0 - num;
			}
			return num;
		}

		public static double ErfcInv(double z)
		{
			if (z <= 0.0)
			{
				return double.PositiveInfinity;
			}
			if (z >= 2.0)
			{
				return double.NegativeInfinity;
			}
			double num;
			double p;
			double s;
			if (z > 1.0)
			{
				num = 2.0 - z;
				p = 1.0 - num;
				s = -1.0;
			}
			else
			{
				p = 1.0 - z;
				num = z;
				s = 1.0;
			}
			return ErfInvImpl(p, num, s);
		}

		private static double ErfInvImpl(double p, double q, double s)
		{
			double num3;
			if (p <= 0.5)
			{
				double num = p * (p + 10.0);
				double num2 = Polynomial.Evaluate(p, ErvInvImpAn) / Polynomial.Evaluate(p, ErvInvImpAd);
				num3 = num * 0.08913147449493408 + num * num2;
			}
			else if (q >= 0.25)
			{
				double num4 = Math.Sqrt(-2.0 * Math.Log(q));
				double z = q - 0.25;
				double num5 = Polynomial.Evaluate(z, ErvInvImpBn) / Polynomial.Evaluate(z, ErvInvImpBd);
				num3 = num4 / (2.249481201171875 + num5);
			}
			else
			{
				double num6 = Math.Sqrt(0.0 - Math.Log(q));
				if (num6 < 3.0)
				{
					double z2 = num6 - 1.125;
					double num7 = Polynomial.Evaluate(z2, ErvInvImpCn) / Polynomial.Evaluate(z2, ErvInvImpCd);
					num3 = 0.807220458984375 * num6 + num7 * num6;
				}
				else if (num6 < 6.0)
				{
					double z3 = num6 - 3.0;
					double num8 = Polynomial.Evaluate(z3, ErvInvImpDn) / Polynomial.Evaluate(z3, ErvInvImpDd);
					num3 = 0.9399557113647461 * num6 + num8 * num6;
				}
				else if (num6 < 18.0)
				{
					double z4 = num6 - 6.0;
					double num9 = Polynomial.Evaluate(z4, ErvInvImpEn) / Polynomial.Evaluate(z4, ErvInvImpEd);
					num3 = 0.9836282730102539 * num6 + num9 * num6;
				}
				else if (num6 < 44.0)
				{
					double z5 = num6 - 18.0;
					double num10 = Polynomial.Evaluate(z5, ErvInvImpFn) / Polynomial.Evaluate(z5, ErvInvImpFd);
					num3 = 0.9971456527709961 * num6 + num10 * num6;
				}
				else
				{
					double z6 = num6 - 44.0;
					double num11 = Polynomial.Evaluate(z6, ErvInvImpGn) / Polynomial.Evaluate(z6, ErvInvImpGd);
					num3 = 0.9994134902954102 * num6 + num11 * num6;
				}
			}
			return s * num3;
		}

		public static double ExponentialIntegral(double x, int n)
		{
			if (n < 0 || x < 0.0)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"x and n must be positive: x={x}, n={n}"));
			}
			int num = 100;
			double num2 = n;
			double num3 = 1E-100;
			double num4 = 1.0;
			if (n == 0)
			{
				return Math.Exp(-1.0 * x) / x;
			}
			if (x == 0.0)
			{
				return 1.0 / (num2 - 1.0);
			}
			if (x > 1.0)
			{
				double num5 = x + (double)n;
				double num6 = 1.0 / num3;
				double num7 = 1.0 / num5;
				double num8 = num7;
				for (int i = 1; i <= num; i++)
				{
					double num9 = -1.0 * (double)i * (num2 - 1.0 + (double)i);
					num5 += 2.0;
					num7 = 1.0 / (num9 * num7 + num5);
					num6 = num5 + num9 / num6;
					double num10 = num6 * num7;
					num8 *= num10;
					if (Math.Abs(num10 - 1.0) < 1E-17)
					{
						return num8 * Math.Exp(0.0 - x);
					}
				}
				throw new ArithmeticException(FormattableString.Invariant($"Continued fraction failed to converge for x={x}, n={n})"));
			}
			double num11 = ((num2 - 1.0 != 0.0) ? (1.0 / (num2 - 1.0)) : (-1.0 * Math.Log(x) - 0.5772156649015329));
			for (int i = 1; i <= num; i++)
			{
				num4 *= -1.0 * x / (double)i;
				double num10;
				if ((double)i != num2 - 1.0)
				{
					num10 = (0.0 - num4) / ((double)i - (num2 - 1.0));
				}
				else
				{
					double num12 = -0.5772156649015329;
					for (int j = 1; (double)j <= num2 - 1.0; j++)
					{
						num12 += 1.0 / (double)j;
					}
					num10 = num4 * (-1.0 * Math.Log(x) + num12);
				}
				num11 += num10;
				if (Math.Abs(num10) < Math.Abs(num11) * 1E-17)
				{
					return num11;
				}
			}
			throw new ArithmeticException(FormattableString.Invariant($"Series failed to converge for x={x}, n={n})"));
		}

		public static double Factorial(int x)
		{
			if (x < 0)
			{
				throw new ArgumentOutOfRangeException("x", "Value must be positive (and not zero).");
			}
			if (x < _factorialCache.Length)
			{
				return _factorialCache[x];
			}
			return double.PositiveInfinity;
		}

		public static BigInteger Factorial(BigInteger x)
		{
			if (x < 0L)
			{
				throw new ArgumentOutOfRangeException("x", "Value must be positive (and not zero).");
			}
			if (x == 0L)
			{
				return BigInteger.One;
			}
			BigInteger result = x;
			while (--x > 1L)
			{
				result *= x;
			}
			return result;
		}

		public static double FactorialLn(int x)
		{
			if (x < 0)
			{
				throw new ArgumentOutOfRangeException("x", "Value must be positive (and not zero).");
			}
			if (x <= 1)
			{
				return 0.0;
			}
			if (x < _factorialCache.Length)
			{
				return Math.Log(_factorialCache[x]);
			}
			return GammaLn((double)x + 1.0);
		}

		public static double Binomial(int n, int k)
		{
			if (k < 0 || n < 0 || k > n)
			{
				return 0.0;
			}
			return Math.Floor(0.5 + Math.Exp(FactorialLn(n) - FactorialLn(k) - FactorialLn(n - k)));
		}

		public static double BinomialLn(int n, int k)
		{
			if (k < 0 || n < 0 || k > n)
			{
				return double.NegativeInfinity;
			}
			return FactorialLn(n) - FactorialLn(k) - FactorialLn(n - k);
		}

		public static double Multinomial(int n, int[] ni)
		{
			if (n < 0)
			{
				throw new ArgumentException("Value must be positive.", "n");
			}
			if (ni == null)
			{
				throw new ArgumentNullException("ni");
			}
			int num = 0;
			double num2 = FactorialLn(n);
			for (int i = 0; i < ni.Length; i++)
			{
				if (ni[i] < 0)
				{
					throw new ArgumentException("Value must be positive.", "ni[" + i + "]");
				}
				num2 -= FactorialLn(ni[i]);
				num += ni[i];
			}
			if (num != n)
			{
				throw new ArgumentException("The chosen parameter set is invalid (probably some value is out of range).", "ni");
			}
			return Math.Floor(0.5 + Math.Exp(num2));
		}

		public static double GammaLn(double z)
		{
			if (z < 0.5)
			{
				double num = GammaDk[0];
				for (int i = 1; i <= 10; i++)
				{
					num += GammaDk[i] / ((double)i - z);
				}
				return 1.1447298858494002 - Math.Log(Math.Sin(Math.PI * z)) - Math.Log(num) - 0.6207822376352452 - (0.5 - z) * Math.Log((0.5 - z + 10.900511) / Math.E);
			}
			double num2 = GammaDk[0];
			for (int j = 1; j <= 10; j++)
			{
				num2 += GammaDk[j] / (z + (double)j - 1.0);
			}
			return Math.Log(num2) + 0.6207822376352452 + (z - 0.5) * Math.Log((z - 0.5 + 10.900511) / Math.E);
		}

		public static double Gamma(double z)
		{
			if (z < 0.5)
			{
				double num = GammaDk[0];
				for (int i = 1; i <= 10; i++)
				{
					num += GammaDk[i] / ((double)i - z);
				}
				return Math.PI / (Math.Sin(Math.PI * z) * num * 1.8603827342052657 * Math.Pow((0.5 - z + 10.900511) / Math.E, 0.5 - z));
			}
			double num2 = GammaDk[0];
			for (int j = 1; j <= 10; j++)
			{
				num2 += GammaDk[j] / (z + (double)j - 1.0);
			}
			return num2 * 1.8603827342052657 * Math.Pow((z - 0.5 + 10.900511) / Math.E, z - 0.5);
		}

		public static double GammaUpperRegularized(double a, double x)
		{
			if (x < 1.0 || x <= a)
			{
				return 1.0 - GammaLowerRegularized(a, x);
			}
			double num = a * Math.Log(x) - x - GammaLn(a);
			if (num < -709.782712893384)
			{
				if (!(a < x))
				{
					return 1.0;
				}
				return 0.0;
			}
			num = Math.Exp(num);
			double num2 = 1.0 - a;
			double num3 = x + num2 + 1.0;
			double num4 = 0.0;
			double num5 = 1.0;
			double num6 = x;
			double num7 = x + 1.0;
			double num8 = num3 * x;
			double num9 = num7 / num8;
			double num14;
			do
			{
				num4 += 1.0;
				num2 += 1.0;
				num3 += 2.0;
				double num10 = num2 * num4;
				double num11 = num7 * num3 - num5 * num10;
				double num12 = num8 * num3 - num6 * num10;
				if (num12 != 0.0)
				{
					double num13 = num11 / num12;
					num14 = Math.Abs((num9 - num13) / num13);
					num9 = num13;
				}
				else
				{
					num14 = 1.0;
				}
				num5 = num7;
				num7 = num11;
				num6 = num8;
				num8 = num12;
				if (Math.Abs(num11) > 4503599627370496.0)
				{
					num5 *= 2.220446049250313E-16;
					num7 *= 2.220446049250313E-16;
					num6 *= 2.220446049250313E-16;
					num8 *= 2.220446049250313E-16;
				}
			}
			while (num14 > 1E-15);
			return num9 * num;
		}

		public static double GammaUpperIncomplete(double a, double x)
		{
			return GammaUpperRegularized(a, x) * Gamma(a);
		}

		public static double GammaLowerIncomplete(double a, double x)
		{
			return GammaLowerRegularized(a, x) * Gamma(a);
		}

		public static double GammaLowerRegularized(double a, double x)
		{
			if (a < 0.0)
			{
				throw new ArgumentOutOfRangeException("a", "Value must not be negative (zero is ok).");
			}
			if (x < 0.0)
			{
				throw new ArgumentOutOfRangeException("x", "Value must not be negative (zero is ok).");
			}
			if (a.AlmostEqual(0.0))
			{
				x.AlmostEqual(0.0);
				return 1.0;
			}
			if (x.AlmostEqual(0.0))
			{
				return 0.0;
			}
			double num = a * Math.Log(x) - x - GammaLn(a);
			if (num < -709.782712893384)
			{
				if (!(a < x))
				{
					return 0.0;
				}
				return 1.0;
			}
			if (x <= 1.0 || x <= a)
			{
				double num2 = a;
				double num3 = 1.0;
				double num4 = 1.0;
				do
				{
					num2 += 1.0;
					num3 = num3 * x / num2;
					num4 += num3;
				}
				while (num3 / num4 > 1E-15);
				return Math.Exp(num) * num4 / a;
			}
			int num5 = 0;
			double num6 = 1.0 - a;
			double num7 = x + num6 + 1.0;
			double num8 = 1.0;
			double num9 = x;
			double num10 = x + 1.0;
			double num11 = num7 * x;
			double num12 = num10 / num11;
			double num17;
			do
			{
				num5++;
				num6 += 1.0;
				num7 += 2.0;
				double num13 = num6 * (double)num5;
				double num14 = num10 * num7 - num8 * num13;
				double num15 = num11 * num7 - num9 * num13;
				if (num15 != 0.0)
				{
					double num16 = num14 / num15;
					num17 = Math.Abs((num12 - num16) / num16);
					num12 = num16;
				}
				else
				{
					num17 = 1.0;
				}
				num8 = num10;
				num10 = num14;
				num9 = num11;
				num11 = num15;
				if (Math.Abs(num14) > 4503599627370496.0)
				{
					num8 *= 2.220446049250313E-16;
					num10 *= 2.220446049250313E-16;
					num9 *= 2.220446049250313E-16;
					num11 *= 2.220446049250313E-16;
				}
			}
			while (num17 > 1E-15);
			return 1.0 - Math.Exp(num) * num12;
		}

		public static double GammaLowerRegularizedInv(double a, double y0)
		{
			if (double.IsNaN(a) || double.IsNaN(y0))
			{
				return double.NaN;
			}
			if (a < 0.0 || a.AlmostEqual(0.0))
			{
				throw new ArgumentOutOfRangeException("a");
			}
			if (y0 < 0.0 || y0 > 1.0)
			{
				throw new ArgumentOutOfRangeException("y0");
			}
			if (y0.AlmostEqual(0.0))
			{
				return 0.0;
			}
			if (y0.AlmostEqual(1.0))
			{
				return double.PositiveInfinity;
			}
			y0 = 1.0 - y0;
			double num = 4503599627370496.0;
			double num2 = 0.0;
			double num3 = 1.0;
			double num4 = 0.0;
			double num5 = 1.0 / (9.0 * a);
			double num6 = 1.0 - num5 - 1.3859292911256331 * ErfInv(2.0 * y0 - 1.0) * Math.Sqrt(num5);
			double num7 = a * num6 * num6 * num6;
			double num8 = GammaLn(a);
			for (int i = 0; i < 20; i++)
			{
				if (num7 < num2 || num7 > num)
				{
					num5 = 0.0625;
					break;
				}
				num6 = 1.0 - GammaLowerRegularized(a, num7);
				if (num6 < num4 || num6 > num3)
				{
					num5 = 0.0625;
					break;
				}
				if (num6 < y0)
				{
					num = num7;
					num4 = num6;
				}
				else
				{
					num2 = num7;
					num3 = num6;
				}
				num5 = (a - 1.0) * Math.Log(num7) - num7 - num8;
				if (num5 < -709.782712893384)
				{
					num5 = 0.0625;
					break;
				}
				num5 = 0.0 - Math.Exp(num5);
				num5 = (num6 - y0) / num5;
				if (Math.Abs(num5 / num7) < 1E-15)
				{
					return num7;
				}
				if (num5 > num7 / 4.0 && y0 < 0.05)
				{
					num5 = num7 / 10.0;
				}
				num7 -= num5;
			}
			if (num == 4503599627370496.0)
			{
				if (num7 <= 0.0)
				{
					num7 = 1.0;
				}
				while (num == 4503599627370496.0)
				{
					num7 = (1.0 + num5) * num7;
					num6 = 1.0 - GammaLowerRegularized(a, num7);
					if (num6 < y0)
					{
						num = num7;
						num4 = num6;
						break;
					}
					num5 += num5;
				}
			}
			int num9 = 0;
			num5 = 0.5;
			for (int j = 0; j < 400; j++)
			{
				num7 = num2 + num5 * (num - num2);
				num6 = 1.0 - GammaLowerRegularized(a, num7);
				num8 = (num - num2) / (num2 + num);
				if (Math.Abs(num8) < 5.000000000000001E-15)
				{
					return num7;
				}
				num8 = (num6 - y0) / y0;
				if (Math.Abs(num8) < 5.000000000000001E-15)
				{
					return num7;
				}
				if (num7 <= 0.0)
				{
					return 0.0;
				}
				if (num6 >= y0)
				{
					num2 = num7;
					num3 = num6;
					if (num9 >= 0)
					{
						num5 = ((num9 <= 1) ? ((y0 - num4) / (num3 - num4)) : (0.5 * num5 + 0.5));
					}
					else
					{
						num9 = 0;
						num5 = 0.5;
					}
					num9++;
				}
				else
				{
					num = num7;
					num4 = num6;
					if (num9 <= 0)
					{
						num5 = ((num9 >= -1) ? ((y0 - num4) / (num3 - num4)) : (0.5 * num5));
					}
					else
					{
						num9 = 0;
						num5 = 0.5;
					}
					num9--;
				}
			}
			return num7;
		}

		public static double DiGamma(double x)
		{
			if (double.IsNegativeInfinity(x) || double.IsNaN(x))
			{
				return double.NaN;
			}
			if (x <= 0.0 && Math.Floor(x) == x)
			{
				return double.NegativeInfinity;
			}
			if (x < 0.0)
			{
				return DiGamma(1.0 - x) + Math.PI / Math.Tan(-Math.PI * x);
			}
			if (x <= 1E-06)
			{
				return -0.5772156649015329 - 1.0 / x + 1.6449340668482264 * x;
			}
			double num = 0.0;
			while (x < 12.0)
			{
				num -= 1.0 / x;
				x += 1.0;
			}
			if (x >= 12.0)
			{
				double num2 = 1.0 / x;
				num += Math.Log(x) - 0.5 * num2;
				num2 *= num2;
				num -= num2 * (1.0 / 12.0 - num2 * (1.0 / 120.0 - num2 * (1.0 / 252.0 - num2 * (1.0 / 240.0 - num2 * (1.0 / 132.0)))));
			}
			return num;
		}

		public static double DiGammaInv(double p)
		{
			if (double.IsNaN(p))
			{
				return double.NaN;
			}
			if (double.IsNegativeInfinity(p))
			{
				return 0.0;
			}
			if (double.IsPositiveInfinity(p))
			{
				return double.PositiveInfinity;
			}
			double num = Math.Exp(p);
			for (double num2 = 1.0; num2 > 1E-15; num2 /= 2.0)
			{
				num += num2 * (double)Math.Sign(p - DiGamma(num));
			}
			return num;
		}

		public static double RisingFactorial(double x, int n)
		{
			double num = 1.0;
			for (int i = 0; i < n; i++)
			{
				num *= x + (double)i;
			}
			return num;
		}

		public static double FallingFactorial(double x, int n)
		{
			double num = 1.0;
			for (int i = 0; i < n; i++)
			{
				num *= x - (double)i;
			}
			return num;
		}

		public static double GeneralizedHypergeometric(double[] a, double[] b, int z)
		{
			double num = 0.0;
			int num2 = 0;
			double num3;
			do
			{
				num3 = HGIncrement(a, b, z, num2);
				num += num3;
				num2++;
			}
			while (Math.Abs(num3) > 1E-15 && Math.Abs(num3) > 0.0 && num3.IsFinite());
			return num;
		}

		private static double HGIncrement(double[] a, double[] b, int z, int currentN)
		{
			double num = 1.0;
			double num2 = 1.0;
			double[] array = new double[a.Length];
			double[] array2 = new double[b.Length];
			for (int i = 0; i < a.Length; i++)
			{
				num *= RisingFactorial(a[i], currentN);
				array[i] = RisingFactorial(a[i], currentN);
			}
			for (int j = 0; j < b.Length; j++)
			{
				num2 *= RisingFactorial(b[j], currentN);
				array2[j] = RisingFactorial(b[j], currentN);
			}
			double num3 = array.Where((double x) => x == 0.0).Count();
			double num4 = array2.Where((double x) => x == 0.0).Count();
			if (num3 > 0.0 && num3 >= num4)
			{
				return 0.0;
			}
			if (num4 > 0.0 && num4 > num3)
			{
				return double.PositiveInfinity;
			}
			return num / num2 * Math.Pow(z, currentN) / Factorial(currentN);
		}

		public static Complex HankelH1(double n, Complex z)
		{
			return Amos.Cbesh1(n, z);
		}

		public static Complex HankelH1Scaled(double n, Complex z)
		{
			return Amos.ScaledCbesh1(n, z);
		}

		public static Complex HankelH2(double n, Complex z)
		{
			return Amos.Cbesh2(n, z);
		}

		public static Complex HankelH2Scaled(double n, Complex z)
		{
			return Amos.ScaledCbesh2(n, z);
		}

		public static double Harmonic(int t)
		{
			return 0.5772156649015329 + DiGamma((double)t + 1.0);
		}

		public static double GeneralHarmonic(int n, double m)
		{
			double num = 0.0;
			for (int i = 0; i < n; i++)
			{
				num += Math.Pow(i + 1, 0.0 - m);
			}
			return num;
		}

		public static Complex KelvinBe(double nu, double x)
		{
			Complex complex = new Complex(-0.7071067811865476, 0.7071067811865476);
			return BesselJ(nu, complex * x);
		}

		public static double KelvinBer(double nu, double x)
		{
			return KelvinBe(nu, x).Real;
		}

		public static double KelvinBer(double x)
		{
			return KelvinBe(0.0, x).Real;
		}

		public static double KelvinBei(double nu, double x)
		{
			return KelvinBe(nu, x).Imaginary;
		}

		public static double KelvinBei(double x)
		{
			return KelvinBe(0.0, x).Imaginary;
		}

		public static double KelvinBerPrime(double nu, double x)
		{
			return 0.3535533905932738 * (0.0 - KelvinBer(nu - 1.0, x) + KelvinBer(nu + 1.0, x) - KelvinBei(nu - 1.0, x) + KelvinBei(nu + 1.0, x));
		}

		public static double KelvinBerPrime(double x)
		{
			return KelvinBerPrime(0.0, x);
		}

		public static double KelvinBeiPrime(double nu, double x)
		{
			return 0.3535533905932738 * (KelvinBer(nu - 1.0, x) - KelvinBer(nu + 1.0, x) - KelvinBei(nu - 1.0, x) + KelvinBei(nu + 1.0, x));
		}

		public static double KelvinBeiPrime(double x)
		{
			return KelvinBeiPrime(0.0, x);
		}

		public static Complex KelvinKe(double nu, double x)
		{
			Complex complex = new Complex(0.0, Math.PI / 2.0);
			Complex complex2 = new Complex(0.7071067811865476, 0.7071067811865476);
			return Complex.Exp((0.0 - nu) * complex) * BesselK(nu, complex2 * x);
		}

		public static double KelvinKer(double nu, double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return KelvinKe(nu, x).Real;
		}

		public static double KelvinKer(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return KelvinKe(0.0, x).Real;
		}

		public static double KelvinKei(double nu, double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return KelvinKe(nu, x).Imaginary;
		}

		public static double KelvinKei(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return KelvinKe(0.0, x).Imaginary;
		}

		public static double KelvinKerPrime(double nu, double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return 0.3535533905932738 * (0.0 - KelvinKer(nu - 1.0, x) + KelvinKer(nu + 1.0, x) - KelvinKei(nu - 1.0, x) + KelvinKei(nu + 1.0, x));
		}

		public static double KelvinKerPrime(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return KelvinKerPrime(0.0, x);
		}

		public static double KelvinKeiPrime(double nu, double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return 0.3535533905932738 * (KelvinKer(nu - 1.0, x) - KelvinKer(nu + 1.0, x) - KelvinKei(nu - 1.0, x) + KelvinKei(nu + 1.0, x));
		}

		public static double KelvinKeiPrime(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			return KelvinKeiPrime(0.0, x);
		}

		public static double Logistic(double p)
		{
			return 1.0 / (Math.Exp(0.0 - p) + 1.0);
		}

		public static double Logit(double p)
		{
			if (p < 0.0 || p > 1.0)
			{
				throw new ArgumentOutOfRangeException("p", "The argument must be between 0 and 1.");
			}
			return Math.Log(p / (1.0 - p));
		}

		public static double BesselI0(double x)
		{
			if (x < 0.0)
			{
				x = 0.0 - x;
			}
			if (x <= 8.0)
			{
				double x2 = x / 2.0 - 2.0;
				return Math.Exp(x) * Evaluate.ChebyshevA(BesselI0A, x2);
			}
			double x3 = 32.0 / x - 2.0;
			return Math.Exp(x) * Evaluate.ChebyshevA(BesselI0B, x3) / Math.Sqrt(x);
		}

		public static double BesselI1(double x)
		{
			double num = Math.Abs(x);
			if (num <= 8.0)
			{
				double x2 = num / 2.0 - 2.0;
				num = Evaluate.ChebyshevA(BesselI1A, x2) * num * Math.Exp(num);
			}
			else
			{
				double x3 = 32.0 / num - 2.0;
				num = Math.Exp(num) * Evaluate.ChebyshevA(BesselI1B, x3) / Math.Sqrt(num);
			}
			if (x < 0.0)
			{
				num = 0.0 - num;
			}
			return num;
		}

		public static double BesselK0(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			if (x <= 2.0)
			{
				double x2 = x * x - 2.0;
				return Evaluate.ChebyshevA(BesselK0A, x2) - Math.Log(0.5 * x) * BesselI0(x);
			}
			double x3 = 8.0 / x - 2.0;
			return Math.Exp(0.0 - x) * Evaluate.ChebyshevA(BesselK0B, x3) / Math.Sqrt(x);
		}

		public static double BesselK0e(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			if (x <= 2.0)
			{
				double x2 = x * x - 2.0;
				return Evaluate.ChebyshevA(BesselK0A, x2) - Math.Log(0.5 * x) * BesselI0(x) * Math.Exp(x);
			}
			double x3 = 8.0 / x - 2.0;
			return Evaluate.ChebyshevA(BesselK0B, x3) / Math.Sqrt(x);
		}

		public static double BesselK1(double x)
		{
			double num = 0.5 * x;
			if (num <= 0.0)
			{
				throw new ArithmeticException();
			}
			if (x <= 2.0)
			{
				double x2 = x * x - 2.0;
				return Math.Log(num) * BesselI1(x) + Evaluate.ChebyshevA(BesselK1A, x2) / x;
			}
			double x3 = 8.0 / x - 2.0;
			return Math.Exp(0.0 - x) * Evaluate.ChebyshevA(BesselK1B, x3) / Math.Sqrt(x);
		}

		public static double BesselK1e(double x)
		{
			if (x <= 0.0)
			{
				throw new ArithmeticException();
			}
			if (x <= 2.0)
			{
				double x2 = x * x - 2.0;
				return Math.Log(0.5 * x) * BesselI1(x) + Evaluate.ChebyshevA(BesselK1A, x2) / x * Math.Exp(x);
			}
			double x3 = 8.0 / x - 2.0;
			return Evaluate.ChebyshevA(BesselK1B, x3) / Math.Sqrt(x);
		}

		public static double StruveL0(double x)
		{
			if (x < 0.0)
			{
				return 0.0 - StruveL0(0.0 - x);
			}
			double[] coefficients = new double[28]
			{
				0.42127458349979924, -0.3385953639122061, 0.21898994812710715, -0.12349482820713185, 0.06214209793866959, -0.028178060281095475, 0.011574196766380912, -0.004316585743069212, 0.0014614234990729833, -0.0004479421180546148,
				0.00012364746105943762, -3.049028334797044E-05, 6.63941401521146E-06, -1.25538357703889E-06, 2.0073446451228E-07, -2.588260170637E-08, 2.41143742758E-09, -1.0159674352E-10, -1.202430736E-11, 2.62906137E-12,
				-1.531319E-13, -1.57476E-14, 3.15635E-15, -4.096E-17, -3.62E-17, 2.39E-18, 3.6E-19, -4E-20
			};
			double[] coefficients2 = new double[16]
			{
				2.008613082356059, 0.004037379665004385, -0.00025199480286580266, 1.605736682811176E-05, -1.03692182473444E-06, 6.765578876305E-08, -4.44999906756E-09, 2.9468889228E-10, -1.962180522E-11, 1.31330306E-12,
				-8.81919E-14, 5.95376E-15, -4.0389E-16, 2.651E-17, -2.08E-18, 1.1E-19
			};
			double[] coefficients3 = new double[24]
			{
				2.0032651024116066, 0.0019520685157649207, 0.0003823952356990833, 7.534280817054436E-05, 1.495957655897078E-05, 2.99940531210557E-06, 6.0769604822459E-07, 1.2399495544506E-07, 2.523262552649E-08, 5.04634857332E-09,
				9.791323623E-10, 1.8389115241E-10, 3.376309278E-11, 6.11179703E-12, 1.08472972E-12, 1.8861271E-13, 3.280345E-14, 5.65647E-15, 9.33E-16, 1.5881E-16,
				2.791E-17, 3.89E-18, 7E-19, 1.6E-19
			};
			if (x <= 16.0)
			{
				if (x < 4.4703484E-08)
				{
					return 2.0 / Math.PI * x;
				}
				double x2 = (4.0 * x - 24.0) / (x + 24.0);
				return 2.0 / Math.PI * x * Evaluate.ChebyshevSum(25, coefficients, x2) * Math.Exp(x);
			}
			double d;
			if (x > 2.5220158E+17)
			{
				d = 1.0;
			}
			else
			{
				double x3 = (x - 28.0) / (4.0 - x);
				d = Evaluate.ChebyshevSum(14, coefficients2, x3);
			}
			double num;
			if (x > 519823030.0)
			{
				num = 1.0;
			}
			else
			{
				double num2 = x * x;
				double x4 = (800.0 - num2) / (288.0 + num2);
				num = Evaluate.ChebyshevSum(21, coefficients3, x4);
			}
			double num3 = Math.Log(d) - 0.9189385332046728 - Math.Log(x) / 2.0 + x;
			if (num3 > Math.Log(1.797693E+308))
			{
				throw new ArithmeticException("ERROR IN MISCFUN FUNCTION STRVL0: ARGUMENT CAUSES OVERFLOW");
			}
			return Math.Exp(num3) - 2.0 / Math.PI * num / x;
		}

		public static double StruveL1(double x)
		{
			if (x < 0.0)
			{
				return StruveL1(0.0 - x);
			}
			double[] coefficients = new double[27]
			{
				0.3899602735122954, -0.3365809610197575, 0.23012467912501647, -0.13121594007960832, 0.06425922289912847, -0.02750032950616636, 0.01040234148637209, -0.003505322949363881, 0.001057484984214397, -0.00028609426403666555,
				6.925708785942208E-05, -1.489693951122717E-05, 2.81035582597128E-06, -4.5503879297776E-07, 6.09017156177E-08, -6.23543724808E-09, 3.8430012067E-10, 7.90543916E-12, -4.89824083E-12, 4.6356884E-13,
				6.84205E-15, -5.69748E-15, 3.5324E-16, 4.244E-17, -6.44E-18, -2.1E-19, 9E-20
			};
			double[] coefficients2 = new double[17]
			{
				1.9754037844165235, -0.011951305550882942, 0.00033639485269196045, -1.009115655481549E-05, 3.0638951321998E-07, -9.53704370396E-09, 2.9524735558E-10, -9.51078318E-12, 2.8203667E-13, -1.134175E-14,
				1.47E-18, -6.232E-17, -7.51E-18, -1.7E-19, 5.1E-19, 2.3E-19, 5E-20
			};
			double[] coefficients3 = new double[26]
			{
				1.9967936189678914, -0.0019066326140968614, -0.0003609462241017448, -6.84184730459982E-05, -1.299008228509426E-05, -2.47152188705765E-06, -4.7147839691972E-07, -9.020819982592E-08, -1.730458637504E-08, -3.32323670159E-09,
				-6.3736421735E-10, -1.2180239756E-10, -2.317346832E-11, -4.39068833E-12, -8.284711E-13, -1.5562249E-13, -2.913112E-14, -5.43965E-15, -1.01177E-15, -1.8767E-16,
				-3.484E-17, -6.43E-18, -1.18E-18, -2.2E-19, -4E-20, -1E-20
			};
			if (x <= 16.0)
			{
				if (x <= 3.3354714E-154)
				{
					return 0.0;
				}
				double num = x * x;
				if (x < 5.7711949E-08)
				{
					return num / 4.71238898038469;
				}
				double x2 = (4.0 * x - 24.0) / (x + 24.0);
				return num * Evaluate.ChebyshevSum(24, coefficients, x2) * Math.Exp(x) / 4.71238898038469;
			}
			double d;
			if (x > 2.7021597E+17)
			{
				d = 1.0;
			}
			else
			{
				double x3 = (x - 30.0) / (2.0 - x);
				d = Evaluate.ChebyshevSum(13, coefficients2, x3);
			}
			double num2;
			if (x > 519823025.0)
			{
				num2 = 1.0;
			}
			else
			{
				double num3 = x * x;
				double x4 = (800.0 - num3) / (288.0 + num3);
				num2 = Evaluate.ChebyshevSum(22, coefficients3, x4);
			}
			double num4 = Math.Log(d) - 0.9189385332046728 - Math.Log(x) / 2.0 + x;
			if (num4 > Math.Log(1.797693E+308))
			{
				throw new ArithmeticException("ERROR IN MISCFUN FUNCTION STRVL1: ARGUMENT CAUSES OVERFLOW");
			}
			return Math.Exp(num4) - 2.0 / Math.PI * num2;
		}

		public static double BesselI0MStruveL0(double x)
		{
			return BesselI0(x) - StruveL0(x);
		}

		public static double BesselI1MStruveL1(double x)
		{
			return BesselI1(x) - StruveL1(x);
		}

		public static Complex SphericalBesselJ(double n, Complex z)
		{
			if (double.IsNaN(n) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
			{
				return new Complex(double.NaN, double.NaN);
			}
			if (double.IsInfinity(z.Real))
			{
				if (z.Imaginary != 0.0)
				{
					return new Complex(double.PositiveInfinity, double.PositiveInfinity);
				}
				return Complex.Zero;
			}
			if (z.Real == 0.0 && z.Imaginary == 0.0)
			{
				return (n == 0.0) ? 1 : 0;
			}
			return 1.2533141373155003 * BesselJ(n + 0.5, z) / Complex.Sqrt(z);
		}

		public static double SphericalBesselJ(double n, double z)
		{
			if (double.IsNaN(n) || double.IsNaN(z))
			{
				return double.NaN;
			}
			if (n < 0.0)
			{
				return double.NaN;
			}
			if (double.IsInfinity(z))
			{
				return 0.0;
			}
			if (z == 0.0)
			{
				return (n == 0.0) ? 1 : 0;
			}
			return 1.2533141373155003 * BesselJ(n + 0.5, z) / Math.Sqrt(z);
		}

		public static Complex SphericalBesselY(double n, Complex z)
		{
			if (double.IsNaN(n) || double.IsNaN(z.Real) || double.IsNaN(z.Imaginary))
			{
				return new Complex(double.NaN, double.NaN);
			}
			if (double.IsInfinity(z.Real))
			{
				if (z.Imaginary != 0.0)
				{
					return new Complex(double.PositiveInfinity, double.PositiveInfinity);
				}
				return Complex.Zero;
			}
			if (z.Real == 0.0 && z.Imaginary == 0.0)
			{
				return new Complex(double.NaN, double.NaN);
			}
			return 1.2533141373155003 * BesselY(n + 0.5, z) / Complex.Sqrt(z);
		}

		public static double SphericalBesselY(double n, double z)
		{
			if (double.IsNaN(n) || double.IsNaN(z))
			{
				return double.NaN;
			}
			if (n < 0.0)
			{
				return double.NaN;
			}
			if (double.IsInfinity(z))
			{
				return 0.0;
			}
			if (z == 0.0)
			{
				return double.NegativeInfinity;
			}
			return 1.2533141373155003 * BesselY(n + 0.5, z) / Math.Sqrt(z);
		}

		public static double ExponentialMinusOne(double power)
		{
			double num = Math.Abs(power);
			if (num > 0.1)
			{
				return Math.Exp(power) - 1.0;
			}
			if (num < num.PositiveEpsilonOf())
			{
				return num;
			}
			int i = 0;
			double term = 1.0;
			return Evaluate.Series(delegate
			{
				i++;
				term *= power;
				term /= i;
				return term;
			});
		}

		public static Complex Hypotenuse(Complex a, Complex b)
		{
			if (a.Magnitude > b.Magnitude)
			{
				double num = b.Magnitude / a.Magnitude;
				return a.Magnitude * Math.Sqrt(1.0 + num * num);
			}
			if (b != 0.0)
			{
				double num2 = a.Magnitude / b.Magnitude;
				return b.Magnitude * Math.Sqrt(1.0 + num2 * num2);
			}
			return 0.0;
		}

		public static Complex32 Hypotenuse(Complex32 a, Complex32 b)
		{
			if (a.Magnitude > b.Magnitude)
			{
				float num = b.Magnitude / a.Magnitude;
				return a.Magnitude * (float)Math.Sqrt(1f + num * num);
			}
			if (b != 0f)
			{
				float num2 = a.Magnitude / b.Magnitude;
				return b.Magnitude * (float)Math.Sqrt(1f + num2 * num2);
			}
			return 0f;
		}

		public static double Hypotenuse(double a, double b)
		{
			if (Math.Abs(a) > Math.Abs(b))
			{
				double num = b / a;
				return Math.Abs(a) * Math.Sqrt(1.0 + num * num);
			}
			if (b != 0.0)
			{
				double num2 = a / b;
				return Math.Abs(b) * Math.Sqrt(1.0 + num2 * num2);
			}
			return 0.0;
		}

		public static float Hypotenuse(float a, float b)
		{
			if (Math.Abs(a) > Math.Abs(b))
			{
				float num = b / a;
				return Math.Abs(a) * (float)Math.Sqrt(1f + num * num);
			}
			if ((double)b != 0.0)
			{
				float num2 = a / b;
				return Math.Abs(b) * (float)Math.Sqrt(1f + num2 * num2);
			}
			return 0f;
		}
	}
	public static class Evaluate
	{
		[Obsolete("Use Polynomial.Evaluate instead. Will be removed in the next major version.")]
		public static double Polynomial(double z, params double[] coefficients)
		{
			return MathNet.Numerics.Polynomial.Evaluate(z, coefficients);
		}

		[Obsolete("Use Polynomial.Evaluate instead. Will be removed in the next major version.")]
		public static Complex Polynomial(Complex z, params double[] coefficients)
		{
			return MathNet.Numerics.Polynomial.Evaluate(z, coefficients);
		}

		[Obsolete("Use Polynomial.Evaluate instead. Will be removed in the next major version.")]
		public static Complex Polynomial(Complex z, params Complex[] coefficients)
		{
			return MathNet.Numerics.Polynomial.Evaluate(z, coefficients);
		}

		internal static double Series(Func<double> nextSummand)
		{
			double num = 0.0;
			double num2 = nextSummand();
			double num3;
			do
			{
				num3 = nextSummand();
				double num4 = num3 - num;
				double num5 = num2 + num4;
				num = num5 - num2;
				num -= num4;
				num2 = num5;
			}
			while (Math.Abs(num2) < Math.Abs(65536.0 * num3));
			return num2;
		}

		internal static double ChebyshevA(double[] coefficients, double x)
		{
			int num = 0;
			double num2 = coefficients[num++];
			double num3 = 0.0;
			int num4 = coefficients.Length - 1;
			double num5;
			do
			{
				num5 = num3;
				num3 = num2;
				num2 = x * num3 - num5 + coefficients[num++];
			}
			while (--num4 > 0);
			return 0.5 * (num2 - num5);
		}

		internal static double ChebyshevSum(int n, double[] coefficients, double x)
		{
			if (Math.Abs(x) < 0.6)
			{
				double num = 0.0;
				double num2 = 0.0;
				double num3 = 0.0;
				double num4 = x + x;
				for (int num5 = n; num5 >= 0; num5--)
				{
					num3 = num2;
					num2 = num;
					num = num4 * num2 + coefficients[num5] - num3;
				}
				return (num - num3) / 2.0;
			}
			if (x > 0.0)
			{
				double num6 = 0.0;
				double num7 = 0.0;
				double num8 = 0.0;
				double num9 = x - 0.5 - 0.5;
				num9 += num9;
				for (int num10 = n; num10 >= 0; num10--)
				{
					num8 = num7;
					double num11 = num6;
					num7 = num9 * num11 + coefficients[num10] + num8;
					num6 = num7 + num11;
				}
				return (num7 + num8) / 2.0;
			}
			double num12 = 0.0;
			double num13 = 0.0;
			double num14 = 0.0;
			double num15 = x + 0.5 + 0.5;
			num15 += num15;
			for (int num16 = n; num16 >= 0; num16--)
			{
				num14 = num13;
				double num17 = num12;
				num13 = num15 * num17 + coefficients[num16] - num14;
				num12 = num13 - num17;
			}
			return (num13 - num14) / 2.0;
		}
	}
	public static class TestFunctions
	{
		public static double Rosenbrock(double x, double y)
		{
			double num = 1.0 - x;
			double num2 = y - x * x;
			return num * num + 100.0 * num2 * num2;
		}

		public static double Rosenbrock(params double[] x)
		{
			double num = 0.0;
			for (int i = 1; i < x.Length; i++)
			{
				num += Rosenbrock(x[i - 1], x[i]);
			}
			return num;
		}

		public static double Himmelblau(double x, double y)
		{
			double num = x * x + y - 11.0;
			double num2 = x + y * y - 7.0;
			return num * num + num2 * num2;
		}

		public static double Rastrigin(params double[] x)
		{
			return x.Sum((double xi) => xi * xi - 10.0 * Math.Cos(Math.PI * 2.0 * xi)) + 10.0 * (double)x.Length;
		}

		public static double DropWave(double x, double y)
		{
			double num = x * x + y * y;
			return (0.0 - (1.0 + Math.Cos(12.0 * Math.Sqrt(num)))) / (0.5 * num + 2.0);
		}

		public static double Ackley(params double[] x)
		{
			double d = x.Sum((double xi) => xi * xi) / (double)x.Length;
			double d2 = x.Sum((double xi) => Math.Cos(Math.PI * 2.0 * xi)) / (double)x.Length;
			return -20.0 * Math.Exp(-0.2 * Math.Sqrt(d)) - Math.Exp(d2) + 20.0 + Math.E;
		}

		public static double Bohachevsky1(double x, double y)
		{
			return x * x + 2.0 * y * y - 0.3 * Math.Cos(Math.PI * 3.0 * x) - 0.4 * Math.Cos(Math.PI * 4.0 * y);
		}

		public static double Matyas(double x, double y)
		{
			return 0.26 * (x * x + y * y) - 0.48 * x * y;
		}

		public static double SixHumpCamel(double x, double y)
		{
			double num = x * x;
			double num2 = y * y;
			return (4.0 - 2.1 * num + num * num / 3.0) * num + x * y + (-4.0 + 4.0 * num2) * num2;
		}
	}
	public static class Trig
	{
		private const double DegreeToGradConstant = 1.1111111111111112;

		public static double DegreeToGrad(double degree)
		{
			return degree * 1.1111111111111112;
		}

		public static double DegreeToRadian(double degree)
		{
			return degree * (Math.PI / 180.0);
		}

		public static double GradToDegree(double grad)
		{
			return grad * 0.9;
		}

		public static double GradToRadian(double grad)
		{
			return grad * (Math.PI / 200.0);
		}

		public static double RadianToDegree(double radian)
		{
			return radian / (Math.PI / 180.0);
		}

		public static double RadianToGrad(double radian)
		{
			return radian / (Math.PI / 200.0);
		}

		public static double Sinc(double x)
		{
			double num = Math.PI * x;
			if (!num.AlmostEqual(0.0, 15))
			{
				return Math.Sin(num) / num;
			}
			return 1.0;
		}

		public static double Sin(double radian)
		{
			return Math.Sin(radian);
		}

		public static Complex Sin(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Sin(value.Real), 0.0);
			}
			return new Complex(Sin(value.Real) * Cosh(value.Imaginary), Cos(value.Real) * Sinh(value.Imaginary));
		}

		public static double Cos(double radian)
		{
			return Math.Cos(radian);
		}

		public static Complex Cos(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Cos(value.Real), 0.0);
			}
			return new Complex(Cos(value.Real) * Cosh(value.Imaginary), (0.0 - Sin(value.Real)) * Sinh(value.Imaginary));
		}

		public static double Tan(double radian)
		{
			return Math.Tan(radian);
		}

		public static Complex Tan(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Tan(value.Real), 0.0);
			}
			Complex complex = new Complex(0.0 - value.Imaginary, value.Real).Tanh();
			return new Complex(complex.Imaginary, 0.0 - complex.Real);
		}

		public static double Cot(double radian)
		{
			return 1.0 / Math.Tan(radian);
		}

		public static Complex Cot(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Cot(value.Real), 0.0);
			}
			Complex complex = new Complex(value.Imaginary, 0.0 - value.Real).Coth();
			return new Complex(complex.Imaginary, 0.0 - complex.Real);
		}

		public static double Sec(double radian)
		{
			return 1.0 / Math.Cos(radian);
		}

		public static Complex Sec(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Sec(value.Real), 0.0);
			}
			double num = Cos(value.Real);
			double num2 = Sinh(value.Imaginary);
			double num3 = num * num + num2 * num2;
			return new Complex(num * Cosh(value.Imaginary) / num3, Sin(value.Real) * num2 / num3);
		}

		public static double Csc(double radian)
		{
			return 1.0 / Math.Sin(radian);
		}

		public static Complex Csc(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Csc(value.Real), 0.0);
			}
			double num = Sin(value.Real);
			double num2 = Sinh(value.Imaginary);
			double num3 = num * num + num2 * num2;
			return new Complex(num * Cosh(value.Imaginary) / num3, (0.0 - Cos(value.Real)) * num2 / num3);
		}

		public static double Asin(double opposite)
		{
			return Math.Asin(opposite);
		}

		public static Complex Asin(this Complex value)
		{
			if (value.Imaginary > 0.0 || (value.Imaginary == 0.0 && value.Real < 0.0))
			{
				return -(-value).Asin();
			}
			return -Complex.ImaginaryOne * ((1 - value.Square()).SquareRoot() + Complex.ImaginaryOne * value).Ln();
		}

		public static double Acos(double adjacent)
		{
			return Math.Acos(adjacent);
		}

		public static Complex Acos(this Complex value)
		{
			if (value.Imaginary < 0.0 || (value.Imaginary == 0.0 && value.Real > 0.0))
			{
				return Math.PI - (-value).Acos();
			}
			return -Complex.ImaginaryOne * (value + Complex.ImaginaryOne * (1 - value.Square()).SquareRoot()).Ln();
		}

		public static double Atan(double opposite)
		{
			return Math.Atan(opposite);
		}

		public static Complex Atan(this Complex value)
		{
			Complex complex = new Complex(0.0 - value.Imaginary, value.Real);
			return new Complex(0.0, 0.5) * ((1 - complex).Ln() - (1 + complex).Ln());
		}

		public static double Acot(double adjacent)
		{
			return Math.Atan(1.0 / adjacent);
		}

		public static Complex Acot(this Complex value)
		{
			if (value.IsZero())
			{
				return Math.PI / 2.0;
			}
			Complex complex = Complex.ImaginaryOne / value;
			return Complex.ImaginaryOne * 0.5 * ((1.0 - complex).Ln() - (1.0 + complex).Ln());
		}

		public static double Asec(double hypotenuse)
		{
			return Math.Acos(1.0 / hypotenuse);
		}

		public static Complex Asec(this Complex value)
		{
			Complex complex = 1 / value;
			return -Complex.ImaginaryOne * (complex + Complex.ImaginaryOne * (1 - complex.Square()).SquareRoot()).Ln();
		}

		public static double Acsc(double hypotenuse)
		{
			return Math.Asin(1.0 / hypotenuse);
		}

		public static Complex Acsc(this Complex value)
		{
			Complex complex = 1 / value;
			return -Complex.ImaginaryOne * (Complex.ImaginaryOne * complex + (1 - complex.Square()).SquareRoot()).Ln();
		}

		public static double Sinh(double angle)
		{
			return (Math.Exp(angle) - Math.Exp(0.0 - angle)) / 2.0;
		}

		public static Complex Sinh(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Sinh(value.Real), 0.0);
			}
			if (Math.Abs(value.Real) >= 22.0)
			{
				double num = Math.Exp(Math.Abs(value.Real)) * 0.5;
				return new Complex((double)Math.Sign(value.Real) * num * Cos(value.Imaginary), num * Sin(value.Imaginary));
			}
			return new Complex(Sinh(value.Real) * Cos(value.Imaginary), Cosh(value.Real) * Sin(value.Imaginary));
		}

		public static double Cosh(double angle)
		{
			return (Math.Exp(angle) + Math.Exp(0.0 - angle)) / 2.0;
		}

		public static Complex Cosh(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Cosh(value.Real), 0.0);
			}
			if (Math.Abs(value.Real) >= 22.0)
			{
				double num = Math.Exp(Math.Abs(value.Real)) * 0.5;
				return new Complex(num * Cos(value.Imaginary), (double)Math.Sign(value.Real) * num * Sin(value.Imaginary));
			}
			return new Complex(Cosh(value.Real) * Cos(value.Imaginary), Sinh(value.Real) * Sin(value.Imaginary));
		}

		public static double Tanh(double angle)
		{
			if (angle > 19.1)
			{
				return 1.0;
			}
			if (angle < -19.1)
			{
				return -1.0;
			}
			double num = Math.Exp(angle);
			double num2 = Math.Exp(0.0 - angle);
			return (num - num2) / (num + num2);
		}

		public static Complex Tanh(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Tanh(value.Real), 0.0);
			}
			if (Math.Abs(value.Real) >= 22.0)
			{
				double num = Math.Exp(0.0 - Math.Abs(value.Real));
				if (num != 0.0)
				{
					return new Complex(Math.Sign(value.Real), 4.0 * Math.Cos(value.Imaginary) * Math.Sin(value.Imaginary) * num * num);
				}
				return new Complex(Math.Sign(value.Real), 0.0);
			}
			double num2 = Tan(value.Imaginary);
			double num3 = 1.0 + num2 * num2;
			double num4 = Sinh(value.Real);
			double num5 = Cosh(value.Real);
			if (double.IsInfinity(num2))
			{
				return new Complex(num5 / num4, 0.0);
			}
			double num6 = 1.0 + num3 * num4 * num4;
			return new Complex(num3 * num5 * num4 / num6, num2 / num6);
		}

		public static double Coth(double angle)
		{
			if (angle > 19.115)
			{
				return 1.0;
			}
			if (angle < -19.115)
			{
				return -1.0;
			}
			double num = Math.Exp(angle);
			double num2 = Math.Exp(0.0 - angle);
			return (num + num2) / (num - num2);
		}

		public static Complex Coth(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Coth(value.Real), 0.0);
			}
			return Complex.One / value.Tanh();
		}

		public static double Sech(double angle)
		{
			return 1.0 / Cosh(angle);
		}

		public static Complex Sech(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Sech(value.Real), 0.0);
			}
			double num = Tan(value.Imaginary);
			double num2 = Cos(value.Imaginary);
			double num3 = 1.0 + num * num;
			double num4 = Math.Sinh(value.Real);
			double num5 = Math.Cosh(value.Real);
			if (Math.Abs(value.Real) >= 22.0)
			{
				double num6 = Math.Exp(0.0 - Math.Abs(value.Real));
				if (num6 != 0.0)
				{
					return new Complex(4.0 * num5 * num2 * num6 * num6, -4.0 * num4 * num * num2 * num6 * num6);
				}
				return new Complex(0.0, 0.0);
			}
			if (double.IsInfinity(num))
			{
				return new Complex(0.0, (double)(-Math.Sign(num)) / num4);
			}
			double num7 = 1.0 + num3 * num4 * num4;
			return new Complex(num5 / num2 / num7, (0.0 - num4) * num / num2 / num7);
		}

		public static double Csch(double angle)
		{
			return 1.0 / Sinh(angle);
		}

		public static Complex Csch(this Complex value)
		{
			if (value.IsReal())
			{
				return new Complex(Csch(value.Real), 0.0);
			}
			double num = Cot(value.Imaginary);
			double num2 = Sin(value.Imaginary);
			double num3 = 1.0 + num * num;
			double num4 = Sinh(value.Real);
			double num5 = Cosh(value.Real);
			if (Math.Abs(value.Real) >= 22.0)
			{
				double num6 = Math.Exp(0.0 - Math.Abs(value.Real));
				if (num6 != 0.0)
				{
					return new Complex(4.0 * num4 * num * num2 * num6 * num6, -4.0 * num5 * num2 * num6 * num6);
				}
				return new Complex(0.0, 0.0);
			}
			if (double.IsInfinity(num))
			{
				return new Complex((double)Math.Sign(num) / num4, 0.0);
			}
			double num7 = 1.0 + num3 * num4 * num4;
			return new Complex(num4 * num / num2 / num7, (0.0 - num5) / num2 / num7);
		}

		public static double Asinh(double value)
		{
			if (Math.Abs(value) >= 268435456.0)
			{
				return (double)Math.Sign(value) * (Math.Log(Math.Abs(value)) + Math.Log(2.0));
			}
			return (double)Math.Sign(value) * Math.Log(Math.Abs(value) + Math.Sqrt(value * value + 1.0));
		}

		public static Complex Asinh(this Complex value)
		{
			return (value + (value.Square() + 1).SquareRoot()).Ln();
		}

		public static double Acosh(double value)
		{
			if (Math.Abs(value) >= 268435456.0)
			{
				return Math.Log(value) + Math.Log(2.0);
			}
			return Math.Log(value + Math.Sqrt(value - 1.0) * Math.Sqrt(value + 1.0), Math.E);
		}

		public static Complex Acosh(this Complex value)
		{
			return (value + (value - 1).SquareRoot() * (value + 1).SquareRoot()).Ln();
		}

		public static double Atanh(double value)
		{
			return 0.5 * Math.Log((1.0 + value) / (1.0 - value), Math.E);
		}

		public static Complex Atanh(this Complex value)
		{
			return 0.5 * ((1 + value).Ln() - (1 - value).Ln());
		}

		public static double Acoth(double value)
		{
			return 0.5 * Math.Log((value + 1.0) / (value - 1.0), Math.E);
		}

		public static Complex Acoth(this Complex value)
		{
			Complex complex = 1.0 / value;
			return 0.5 * ((1.0 + complex).Ln() - (1.0 - complex).Ln());
		}

		public static double Asech(double value)
		{
			return Acosh(1.0 / value);
		}

		public static Complex Asech(this Complex value)
		{
			Complex complex = 1 / value;
			return (complex + (complex - 1).SquareRoot() * (complex + 1).SquareRoot()).Ln();
		}

		public static double Acsch(double value)
		{
			return Asinh(1.0 / value);
		}

		public static Complex Acsch(this Complex value)
		{
			Complex complex = 1 / value;
			return (complex + (complex.Square() + 1).SquareRoot()).Ln();
		}
	}
	public static class Window
	{
		public static double[] Hamming(int width)
		{
			double num = Math.PI * 2.0 / ((double)width - 1.0);
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.53836 + -0.46164 * Math.Cos((double)i * num);
			}
			return array;
		}

		public static double[] HammingPeriodic(int width)
		{
			double num = Math.PI * 2.0 / (double)width;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.53836 + -0.46164 * Math.Cos((double)i * num);
			}
			return array;
		}

		public static double[] Hann(int width)
		{
			double num = Math.PI * 2.0 / ((double)width - 1.0);
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.5 - 0.5 * Math.Cos((double)i * num);
			}
			return array;
		}

		public static double[] HannPeriodic(int width)
		{
			double num = Math.PI * 2.0 / (double)width;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.5 - 0.5 * Math.Cos((double)i * num);
			}
			return array;
		}

		public static double[] Cosine(int width)
		{
			double num = Math.PI / ((double)width - 1.0);
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Math.Sin((double)i * num);
			}
			return array;
		}

		public static double[] CosinePeriodic(int width)
		{
			double num = Math.PI / (double)width;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Math.Sin((double)i * num);
			}
			return array;
		}

		public static double[] Lanczos(int width)
		{
			double num = 2.0 / ((double)width - 1.0);
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Trig.Sinc((double)i * num - 1.0);
			}
			return array;
		}

		public static double[] LanczosPeriodic(int width)
		{
			double num = 2.0 / (double)width;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Trig.Sinc((double)i * num - 1.0);
			}
			return array;
		}

		public static double[] Gauss(int width, double sigma)
		{
			double num = (double)(width - 1) / 2.0;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				double num2 = ((double)i - num) / (sigma * num);
				array[i] = Math.Exp(-0.5 * num2 * num2);
			}
			return array;
		}

		public static double[] Blackman(int width)
		{
			int num = width - 1;
			double num2 = Math.PI * 2.0 / (double)num;
			double num3 = 2.0 * num2;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.42 - 0.5 * Math.Cos((double)i * num2) + 0.08 * Math.Cos((double)i * num3);
			}
			return array;
		}

		public static double[] BlackmanHarris(int width)
		{
			int num = width - 1;
			double num2 = Math.PI * 2.0 / (double)num;
			double num3 = 2.0 * num2;
			double num4 = 3.0 * num2;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 287.0 / 800.0 + -0.48829 * Math.Cos(num2 * (double)i) + 0.14128 * Math.Cos(num3 * (double)i) + -0.01168 * Math.Cos(num4 * (double)i);
			}
			return array;
		}

		public static double[] BlackmanNuttall(int width)
		{
			int num = width - 1;
			double num2 = Math.PI * 2.0 / (double)num;
			double num3 = 2.0 * num2;
			double num4 = 3.0 * num2;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.3635819 + -0.4891775 * Math.Cos(num2 * (double)i) + 0.1365995 * Math.Cos(num3 * (double)i) + -0.0106411 * Math.Cos(num4 * (double)i);
			}
			return array;
		}

		public static double[] Bartlett(int width)
		{
			int num = width - 1;
			double num2 = 2.0 / (double)num;
			double num3 = (double)num / 2.0;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = num2 * (num3 - Math.Abs((double)i - num3));
			}
			return array;
		}

		public static double[] BartlettHann(int width)
		{
			int num = width - 1;
			double num2 = 1.0 / (double)num;
			double num3 = Math.PI * 2.0 / (double)num;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.62 + -0.48 * Math.Abs((double)i * num2 - 0.5) + -0.38 * Math.Cos((double)i * num3);
			}
			return array;
		}

		public static double[] Nuttall(int width)
		{
			int num = width - 1;
			double num2 = Math.PI * 2.0 / (double)num;
			double num3 = 2.0 * num2;
			double num4 = 3.0 * num2;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0.355768 + -0.487396 * Math.Cos(num2 * (double)i) + 0.144232 * Math.Cos(num3 * (double)i) + -0.012604 * Math.Cos(num4 * (double)i);
			}
			return array;
		}

		public static double[] FlatTop(int width)
		{
			int num = width - 1;
			double num2 = Math.PI * 2.0 / (double)num;
			double num3 = 2.0 * num2;
			double num4 = 3.0 * num2;
			double num5 = 4.0 * num2;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 1.0 + -1.93 * Math.Cos(num2 * (double)i) + 1.29 * Math.Cos(num3 * (double)i) + -0.388 * Math.Cos(num4 * (double)i) + 0.032 * Math.Cos(num5 * (double)i);
			}
			return array;
		}

		public static double[] Dirichlet(int width)
		{
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 1.0;
			}
			return array;
		}

		public static double[] Triangular(int width)
		{
			double num = 2.0 / (double)width;
			double num2 = (double)width / 2.0;
			double num3 = (double)(width - 1) / 2.0;
			double[] array = new double[width];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = num * (num2 - Math.Abs((double)i - num3));
			}
			return array;
		}

		public static double[] Tukey(int width, double r = 0.5)
		{
			if (r <= 0.0)
			{
				return Generate.Repeat(width, 1.0);
			}
			if (r >= 1.0)
			{
				return Hann(width);
			}
			double[] array = new double[width];
			double num = (double)(width - 1) * r;
			double num2 = Math.PI * 2.0 / num;
			int num3 = (int)Math.Floor((double)(width - 1) * r * 0.5 + 1.0);
			int num4 = width - num3;
			for (int i = 0; i < num3; i++)
			{
				array[i] = (1.0 - Math.Cos((double)i * num2)) * 0.5;
			}
			for (int j = num3; j < num4; j++)
			{
				array[j] = 1.0;
			}
			for (int k = num4; k < width; k++)
			{
				array[k] = array[width - k - 1];
			}
			return array;
		}
	}
}
namespace MathNet.Numerics.Threading
{
	internal static class CommonParallel
	{
		private static ParallelOptions CreateParallelOptions()
		{
			return new ParallelOptions
			{
				MaxDegreeOfParallelism = Control.MaxDegreeOfParallelism,
				TaskScheduler = Control.TaskScheduler
			};
		}

		public static void For(int fromInclusive, int toExclusive, Action<int, int> body)
		{
			For(fromInclusive, toExclusive, Math.Max(1, (toExclusive - fromInclusive) / Control.MaxDegreeOfParallelism), body);
		}

		public static void For(int fromInclusive, int toExclusive, int rangeSize, Action<int, int> body)
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			if (fromInclusive < 0)
			{
				throw new ArgumentOutOfRangeException("fromInclusive");
			}
			if (fromInclusive > toExclusive)
			{
				throw new ArgumentOutOfRangeException("toExclusive");
			}
			if (rangeSize < 1)
			{
				throw new ArgumentOutOfRangeException("rangeSize");
			}
			int num = toExclusive - fromInclusive;
			if (num <= 0)
			{
				return;
			}
			if (Control.MaxDegreeOfParallelism < 2 || rangeSize * 2 > num)
			{
				body(fromInclusive, toExclusive);
				return;
			}
			Parallel.ForEach(Partitioner.Create(fromInclusive, toExclusive, rangeSize), CreateParallelOptions(), delegate(Tuple<int, int> range)
			{
				body(range.Item1, range.Item2);
			});
		}

		public static void Invoke(params Action[] actions)
		{
			if (actions.Length == 0)
			{
				return;
			}
			if (actions.Length == 1)
			{
				actions[0]();
			}
			else if (Control.MaxDegreeOfParallelism < 2)
			{
				for (int i = 0; i < actions.Length; i++)
				{
					actions[i]();
				}
			}
			else
			{
				Parallel.Invoke(CreateParallelOptions(), actions);
			}
		}

		public static T Aggregate<T>(int fromInclusive, int toExclusive, Func<int, T> select, Func<T[], T> reduce)
		{
			if (select == null)
			{
				throw new ArgumentNullException("select");
			}
			if (reduce == null)
			{
				throw new ArgumentNullException("reduce");
			}
			if (fromInclusive >= toExclusive)
			{
				return reduce(new T[0]);
			}
			if (fromInclusive == toExclusive - 1)
			{
				return reduce(new T[1] { select(fromInclusive) });
			}
			if (Control.MaxDegreeOfParallelism < 2)
			{
				T[] array = new T[toExclusive - fromInclusive];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = select(i + fromInclusive);
				}
				return reduce(array);
			}
			List<T> intermediateResults = new List<T>();
			object syncLock = new object();
			Parallel.ForEach(Partitioner.Create(fromInclusive, toExclusive), CreateParallelOptions(), () => new List<T>(), delegate(Tuple<int, int> range, ParallelLoopState loop, List<T> localData)
			{
				T[] array2 = new T[range.Item2 - range.Item1];
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j] = select(j + range.Item1);
				}
				localData.Add(reduce(array2));
				return localData;
			}, delegate(List<T> localResult)
			{
				lock (syncLock)
				{
					intermediateResults.Add(reduce(localResult.ToArray()));
				}
			});
			return reduce(intermediateResults.ToArray());
		}

		public static TOut Aggregate<T, TOut>(T[] array, Func<int, T, TOut> select, Func<TOut[], TOut> reduce)
		{
			if (select == null)
			{
				throw new ArgumentNullException("select");
			}
			if (reduce == null)
			{
				throw new ArgumentNullException("reduce");
			}
			if (array == null || array.Length == 0)
			{
				return reduce(new TOut[0]);
			}
			if (array.Length == 1)
			{
				return reduce(new TOut[1] { select(0, array[0]) });
			}
			if (Control.MaxDegreeOfParallelism < 2)
			{
				TOut[] array2 = new TOut[array.Length];
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = select(i, array[i]);
				}
				return reduce(array2);
			}
			List<TOut> intermediateResults = new List<TOut>();
			object syncLock = new object();
			Parallel.ForEach(Partitioner.Create(0, array.Length), CreateParallelOptions(), () => new List<TOut>(), delegate(Tuple<int, int> range, ParallelLoopState loop, List<TOut> localData)
			{
				TOut[] array3 = new TOut[range.Item2 - range.Item1];
				for (int j = 0; j < array3.Length; j++)
				{
					array3[j] = select(j + range.Item1, array[j + range.Item1]);
				}
				localData.Add(reduce(array3));
				return localData;
			}, delegate(List<TOut> localResult)
			{
				lock (syncLock)
				{
					intermediateResults.Add(reduce(localResult.ToArray()));
				}
			});
			return reduce(intermediateResults.ToArray());
		}

		public static T Aggregate<T>(int fromInclusive, int toExclusive, Func<int, T> select, Func<T, T, T> reducePair, T reduceDefault)
		{
			return Aggregate(fromInclusive, toExclusive, select, delegate(T[] results)
			{
				if (results == null || results.Length == 0)
				{
					return reduceDefault;
				}
				if (results.Length == 1)
				{
					return results[0];
				}
				T val = results[0];
				for (int i = 1; i < results.Length; i++)
				{
					val = reducePair(val, results[i]);
				}
				return val;
			});
		}

		public static TOut Aggregate<T, TOut>(T[] array, Func<int, T, TOut> select, Func<TOut, TOut, TOut> reducePair, TOut reduceDefault)
		{
			return Aggregate(array, select, delegate(TOut[] results)
			{
				if (results == null || results.Length == 0)
				{
					return reduceDefault;
				}
				if (results.Length == 1)
				{
					return results[0];
				}
				TOut val = results[0];
				for (int i = 1; i < results.Length; i++)
				{
					val = reducePair(val, results[i]);
				}
				return val;
			});
		}
	}
}
namespace MathNet.Numerics.Statistics
{
	public static class ArrayStatistics
	{
		public static Complex MinimumMagnitudePhase(Complex[] data)
		{
			if (data.Length == 0)
			{
				return new Complex(double.NaN, double.NaN);
			}
			double num = double.PositiveInfinity;
			Complex result = new Complex(double.PositiveInfinity, double.PositiveInfinity);
			for (int i = 0; i < data.Length; i++)
			{
				double magnitude = data[i].Magnitude;
				if (double.IsNaN(magnitude))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (magnitude < num || (magnitude == num && data[i].Phase < result.Phase))
				{
					num = magnitude;
					result = data[i];
				}
			}
			return result;
		}

		public static Complex32 MinimumMagnitudePhase(Complex32[] data)
		{
			if (data.Length == 0)
			{
				return new Complex32(float.NaN, float.NaN);
			}
			float num = float.PositiveInfinity;
			Complex32 result = new Complex32(float.PositiveInfinity, float.PositiveInfinity);
			for (int i = 0; i < data.Length; i++)
			{
				float magnitude = data[i].Magnitude;
				if (float.IsNaN(magnitude))
				{
					return new Complex32(float.NaN, float.NaN);
				}
				if (magnitude < num || (magnitude == num && data[i].Phase < result.Phase))
				{
					num = magnitude;
					result = data[i];
				}
			}
			return result;
		}

		public static Complex MaximumMagnitudePhase(Complex[] data)
		{
			if (data.Length == 0)
			{
				return new Complex(double.NaN, double.NaN);
			}
			double num = 0.0;
			Complex result = Complex.Zero;
			for (int i = 0; i < data.Length; i++)
			{
				double magnitude = data[i].Magnitude;
				if (double.IsNaN(magnitude))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (magnitude > num || (magnitude == num && data[i].Phase > result.Phase))
				{
					num = magnitude;
					result = data[i];
				}
			}
			return result;
		}

		public static Complex32 MaximumMagnitudePhase(Complex32[] data)
		{
			if (data.Length == 0)
			{
				return new Complex32(float.NaN, float.NaN);
			}
			float num = 0f;
			Complex32 result = Complex32.Zero;
			for (int i = 0; i < data.Length; i++)
			{
				float magnitude = data[i].Magnitude;
				if (float.IsNaN(magnitude))
				{
					return new Complex32(float.NaN, float.NaN);
				}
				if (magnitude > num || (magnitude == num && data[i].Phase > result.Phase))
				{
					num = magnitude;
					result = data[i];
				}
			}
			return result;
		}

		public static double Minimum(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = double.PositiveInfinity;
			for (int i = 0; i < data.Length; i++)
			{
				if (data[i] < num || double.IsNaN(data[i]))
				{
					num = data[i];
				}
			}
			return num;
		}

		public static double Maximum(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = double.NegativeInfinity;
			for (int i = 0; i < data.Length; i++)
			{
				if (data[i] > num || double.IsNaN(data[i]))
				{
					num = data[i];
				}
			}
			return num;
		}

		public static double MinimumAbsolute(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = double.PositiveInfinity;
			for (int i = 0; i < data.Length; i++)
			{
				if (Math.Abs(data[i]) < num || double.IsNaN(data[i]))
				{
					num = Math.Abs(data[i]);
				}
			}
			return num;
		}

		public static double MaximumAbsolute(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				if (Math.Abs(data[i]) > num || double.IsNaN(data[i]))
				{
					num = Math.Abs(data[i]);
				}
			}
			return num;
		}

		public static double Mean(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			ulong num2 = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num += (data[i] - num) / (double)(++num2);
			}
			return num;
		}

		public static double GeometricMean(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				num += Math.Log(data[i]);
			}
			return Math.Exp(num / (double)data.Length);
		}

		public static double HarmonicMean(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				num += 1.0 / data[i];
			}
			return (double)data.Length / num;
		}

		public static double Variance(double[] samples)
		{
			if (samples.Length <= 1)
			{
				return double.NaN;
			}
			double num = 0.0;
			double num2 = samples[0];
			for (int i = 1; i < samples.Length; i++)
			{
				num2 += samples[i];
				double num3 = (double)(i + 1) * samples[i] - num2;
				num += num3 * num3 / (((double)i + 1.0) * (double)i);
			}
			return num / (double)(samples.Length - 1);
		}

		public static double PopulationVariance(double[] population)
		{
			if (population.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			double num2 = population[0];
			for (int i = 1; i < population.Length; i++)
			{
				num2 += population[i];
				double num3 = (double)(i + 1) * population[i] - num2;
				num += num3 * num3 / (((double)i + 1.0) * (double)i);
			}
			return num / (double)population.Length;
		}

		public static double StandardDeviation(double[] samples)
		{
			return Math.Sqrt(Variance(samples));
		}

		public static double PopulationStandardDeviation(double[] population)
		{
			return Math.Sqrt(PopulationVariance(population));
		}

		public static Tuple<double, double> MeanVariance(double[] samples)
		{
			return new Tuple<double, double>(Mean(samples), Variance(samples));
		}

		public static Tuple<double, double> MeanStandardDeviation(double[] samples)
		{
			return new Tuple<double, double>(Mean(samples), StandardDeviation(samples));
		}

		public static double Covariance(double[] samples1, double[] samples2)
		{
			if (samples1.Length != samples2.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (samples1.Length <= 1)
			{
				return double.NaN;
			}
			double num = Mean(samples1);
			double num2 = Mean(samples2);
			double num3 = 0.0;
			for (int i = 0; i < samples1.Length; i++)
			{
				num3 += (samples1[i] - num) * (samples2[i] - num2);
			}
			return num3 / (double)(samples1.Length - 1);
		}

		public static double PopulationCovariance(double[] population1, double[] population2)
		{
			if (population1.Length != population2.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (population1.Length == 0)
			{
				return double.NaN;
			}
			double num = Mean(population1);
			double num2 = Mean(population2);
			double num3 = 0.0;
			for (int i = 0; i < population1.Length; i++)
			{
				num3 += (population1[i] - num) * (population2[i] - num2);
			}
			return num3 / (double)population1.Length;
		}

		public static double RootMeanSquare(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			ulong num2 = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num += (data[i] * data[i] - num) / (double)(++num2);
			}
			return Math.Sqrt(num);
		}

		public static double OrderStatisticInplace(double[] data, int order)
		{
			if (order < 1 || order > data.Length)
			{
				return double.NaN;
			}
			if (order == 1)
			{
				return Minimum(data);
			}
			if (order == data.Length)
			{
				return Maximum(data);
			}
			return SelectInplace(data, order - 1);
		}

		public static double MedianInplace(double[] data)
		{
			int num = data.Length / 2;
			if (!data.Length.IsOdd())
			{
				return (SelectInplace(data, num - 1) + SelectInplace(data, num)) / 2.0;
			}
			return SelectInplace(data, num);
		}

		public static double PercentileInplace(double[] data, int p)
		{
			return QuantileInplace(data, (double)p / 100.0);
		}

		public static double LowerQuartileInplace(double[] data)
		{
			return QuantileInplace(data, 0.25);
		}

		public static double UpperQuartileInplace(double[] data)
		{
			return QuantileInplace(data, 0.75);
		}

		public static double InterquartileRangeInplace(double[] data)
		{
			return QuantileInplace(data, 0.75) - QuantileInplace(data, 0.25);
		}

		public static double[] FiveNumberSummaryInplace(double[] data)
		{
			if (data.Length != 0)
			{
				return new double[5]
				{
					Minimum(data),
					QuantileInplace(data, 0.25),
					MedianInplace(data),
					QuantileInplace(data, 0.75),
					Maximum(data)
				};
			}
			return new double[5]
			{
				double.NaN,
				double.NaN,
				double.NaN,
				double.NaN,
				double.NaN
			};
		}

		public static double QuantileInplace(double[] data, double tau)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return double.NaN;
			}
			double num = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
			int num2 = (int)num;
			if (num2 <= 0 || tau == 0.0)
			{
				return Minimum(data);
			}
			if (num2 >= data.Length || tau == 1.0)
			{
				return Maximum(data);
			}
			double num3 = SelectInplace(data, num2 - 1);
			double num4 = SelectInplace(data, num2);
			return num3 + (num - (double)num2) * (num4 - num3);
		}

		public static double QuantileCustomInplace(double[] data, double tau, double a, double b, double c, double d)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return double.NaN;
			}
			double num = a + ((double)data.Length + b) * tau - 1.0;
			double num2 = Math.Truncate(num);
			double num3 = num - num2;
			if (Math.Abs(num3) < 1E-09)
			{
				return SelectInplace(data, (int)num2);
			}
			double num4 = SelectInplace(data, (int)Math.Floor(num));
			double num5 = SelectInplace(data, (int)Math.Ceiling(num));
			return num4 + (num5 - num4) * (c + d * num3);
		}

		public static double QuantileCustomInplace(double[] data, double tau, QuantileDefinition definition)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return double.NaN;
			}
			if (tau == 0.0 || data.Length == 1)
			{
				return Minimum(data);
			}
			if (tau == 1.0)
			{
				return Maximum(data);
			}
			switch (definition)
			{
			case QuantileDefinition.R1:
			{
				double num26 = (double)data.Length * tau + 0.5;
				return SelectInplace(data, (int)Math.Ceiling(num26 - 0.5) - 1);
			}
			case QuantileDefinition.R2:
			{
				double num25 = (double)data.Length * tau + 0.5;
				return (SelectInplace(data, (int)Math.Ceiling(num25 - 0.5) - 1) + SelectInplace(data, (int)(num25 + 0.5) - 1)) * 0.5;
			}
			case QuantileDefinition.R3:
			{
				double a = (double)data.Length * tau;
				return SelectInplace(data, (int)Math.Round(a) - 1);
			}
			case QuantileDefinition.R4:
			{
				double num21 = (double)data.Length * tau;
				int num22 = (int)num21;
				double num23 = SelectInplace(data, num22 - 1);
				double num24 = SelectInplace(data, num22);
				return num23 + (num21 - (double)num22) * (num24 - num23);
			}
			case QuantileDefinition.R5:
			{
				double num17 = (double)data.Length * tau + 0.5;
				int num18 = (int)num17;
				double num19 = SelectInplace(data, num18 - 1);
				double num20 = SelectInplace(data, num18);
				return num19 + (num17 - (double)num18) * (num20 - num19);
			}
			case QuantileDefinition.R6:
			{
				double num13 = (double)(data.Length + 1) * tau;
				int num14 = (int)num13;
				double num15 = SelectInplace(data, num14 - 1);
				double num16 = SelectInplace(data, num14);
				return num15 + (num13 - (double)num14) * (num16 - num15);
			}
			case QuantileDefinition.R7:
			{
				double num9 = (double)(data.Length - 1) * tau + 1.0;
				int num10 = (int)num9;
				double num11 = SelectInplace(data, num10 - 1);
				double num12 = SelectInplace(data, num10);
				return num11 + (num9 - (double)num10) * (num12 - num11);
			}
			case QuantileDefinition.R8:
			{
				double num5 = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
				int num6 = (int)num5;
				double num7 = SelectInplace(data, num6 - 1);
				double num8 = SelectInplace(data, num6);
				return num7 + (num5 - (double)num6) * (num8 - num7);
			}
			case QuantileDefinition.R9:
			{
				double num = ((double)data.Length + 0.25) * tau + 0.375;
				int num2 = (int)num;
				double num3 = SelectInplace(data, num2 - 1);
				double num4 = SelectInplace(data, num2);
				return num3 + (num - (double)num2) * (num4 - num3);
			}
			default:
				throw new NotSupportedException();
			}
		}

		private static double SelectInplace(double[] workingData, int rank)
		{
			if (rank <= 0)
			{
				return Minimum(workingData);
			}
			if (rank >= workingData.Length - 1)
			{
				return Maximum(workingData);
			}
			int num = 0;
			int num2 = workingData.Length - 1;
			while (num2 > num + 1)
			{
				int num3 = num + num2 >> 1;
				double num4 = workingData[num3];
				workingData[num3] = workingData[num + 1];
				workingData[num + 1] = num4;
				if (workingData[num] > workingData[num2])
				{
					double num5 = workingData[num];
					workingData[num] = workingData[num2];
					workingData[num2] = num5;
				}
				if (workingData[num + 1] > workingData[num2])
				{
					double num6 = workingData[num + 1];
					workingData[num + 1] = workingData[num2];
					workingData[num2] = num6;
				}
				if (workingData[num] > workingData[num + 1])
				{
					double num7 = workingData[num];
					workingData[num] = workingData[num + 1];
					workingData[num + 1] = num7;
				}
				int num8 = num + 1;
				int num9 = num2;
				double num10 = workingData[num8];
				while (true)
				{
					num8++;
					if (!(workingData[num8] < num10))
					{
						do
						{
							num9--;
						}
						while (workingData[num9] > num10);
						if (num9 < num8)
						{
							break;
						}
						double num11 = workingData[num8];
						workingData[num8] = workingData[num9];
						workingData[num9] = num11;
					}
				}
				workingData[num + 1] = workingData[num9];
				workingData[num9] = num10;
				if (num9 >= rank)
				{
					num2 = num9 - 1;
				}
				if (num9 <= rank)
				{
					num = num8;
				}
			}
			if (num2 == num + 1 && workingData[num2] < workingData[num])
			{
				double num12 = workingData[num];
				workingData[num] = workingData[num2];
				workingData[num2] = num12;
			}
			return workingData[rank];
		}

		public static double[] RanksInplace(double[] data, RankDefinition definition = RankDefinition.Average)
		{
			double[] array = new double[data.Length];
			int[] array2 = new int[data.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = i;
			}
			if (definition == RankDefinition.First)
			{
				Sorting.SortAll(data, array2);
				for (int j = 0; j < array.Length; j++)
				{
					array[array2[j]] = j + 1;
				}
				return array;
			}
			Sorting.Sort(data, array2);
			int num = 0;
			for (int k = 1; k < data.Length; k++)
			{
				if (!(Math.Abs(data[k] - data[num]) <= 0.0))
				{
					if (k == num + 1)
					{
						array[array2[num]] = k;
					}
					else
					{
						RanksTies(array, array2, num, k, definition);
					}
					num = k;
				}
			}
			RanksTies(array, array2, num, data.Length, definition);
			return array;
		}

		private static void RanksTies(double[] ranks, int[] index, int a, int b, RankDefinition definition)
		{
			double num = definition switch
			{
				RankDefinition.Average => (double)(b + a - 1) / 2.0 + 1.0, 
				RankDefinition.Min => a + 1, 
				RankDefinition.Max => b, 
				_ => throw new NotSupportedException(), 
			};
			for (int i = a; i < b; i++)
			{
				ranks[index[i]] = num;
			}
		}

		public static double Mean(int[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			ulong num2 = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num += ((double)data[i] - num) / (double)(++num2);
			}
			return num;
		}

		public static double GeometricMean(int[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				num += Math.Log(data[i]);
			}
			return Math.Exp(num / (double)data.Length);
		}

		public static double HarmonicMean(int[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				num += 1.0 / (double)data[i];
			}
			return (double)data.Length / num;
		}

		public static double Variance(int[] samples)
		{
			if (samples.Length <= 1)
			{
				return double.NaN;
			}
			double num = 0.0;
			double num2 = samples[0];
			for (int i = 1; i < samples.Length; i++)
			{
				num2 += (double)samples[i];
				double num3 = (double)((i + 1) * samples[i]) - num2;
				num += num3 * num3 / (((double)i + 1.0) * (double)i);
			}
			return num / (double)(samples.Length - 1);
		}

		public static double PopulationVariance(int[] population)
		{
			if (population.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			double num2 = population[0];
			for (int i = 1; i < population.Length; i++)
			{
				num2 += (double)population[i];
				double num3 = (double)((i + 1) * population[i]) - num2;
				num += num3 * num3 / (((double)i + 1.0) * (double)i);
			}
			return num / (double)population.Length;
		}

		public static double StandardDeviation(int[] samples)
		{
			return Math.Sqrt(Variance(samples));
		}

		public static double PopulationStandardDeviation(int[] population)
		{
			return Math.Sqrt(PopulationVariance(population));
		}

		public static Tuple<double, double> MeanVariance(int[] samples)
		{
			return new Tuple<double, double>(Mean(samples), Variance(samples));
		}

		public static Tuple<double, double> MeanStandardDeviation(int[] samples)
		{
			return new Tuple<double, double>(Mean(samples), StandardDeviation(samples));
		}

		public static double Covariance(int[] samples1, int[] samples2)
		{
			if (samples1.Length != samples2.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (samples1.Length <= 1)
			{
				return double.NaN;
			}
			double num = Mean(samples1);
			double num2 = Mean(samples2);
			double num3 = 0.0;
			for (int i = 0; i < samples1.Length; i++)
			{
				num3 += ((double)samples1[i] - num) * ((double)samples2[i] - num2);
			}
			return num3 / (double)(samples1.Length - 1);
		}

		public static double PopulationCovariance(int[] population1, int[] population2)
		{
			if (population1.Length != population2.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (population1.Length == 0)
			{
				return double.NaN;
			}
			double num = Mean(population1);
			double num2 = Mean(population2);
			double num3 = 0.0;
			for (int i = 0; i < population1.Length; i++)
			{
				num3 += ((double)population1[i] - num) * ((double)population2[i] - num2);
			}
			return num3 / (double)population1.Length;
		}

		public static double RootMeanSquare(int[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			ulong num2 = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num += ((double)(data[i] * data[i]) - num) / (double)(++num2);
			}
			return Math.Sqrt(num);
		}

		public static float Minimum(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			float num = float.PositiveInfinity;
			for (int i = 0; i < data.Length; i++)
			{
				if (data[i] < num || float.IsNaN(data[i]))
				{
					num = data[i];
				}
			}
			return num;
		}

		public static float Maximum(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			float num = float.NegativeInfinity;
			for (int i = 0; i < data.Length; i++)
			{
				if (data[i] > num || float.IsNaN(data[i]))
				{
					num = data[i];
				}
			}
			return num;
		}

		public static float MinimumAbsolute(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			float num = float.PositiveInfinity;
			for (int i = 0; i < data.Length; i++)
			{
				if (Math.Abs(data[i]) < num || float.IsNaN(data[i]))
				{
					num = Math.Abs(data[i]);
				}
			}
			return num;
		}

		public static float MaximumAbsolute(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			float num = 0f;
			for (int i = 0; i < data.Length; i++)
			{
				if (Math.Abs(data[i]) > num || float.IsNaN(data[i]))
				{
					num = Math.Abs(data[i]);
				}
			}
			return num;
		}

		public static double Mean(float[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			ulong num2 = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num += ((double)data[i] - num) / (double)(++num2);
			}
			return num;
		}

		public static double GeometricMean(float[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				num += Math.Log(data[i]);
			}
			return Math.Exp(num / (double)data.Length);
		}

		public static double HarmonicMean(float[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			for (int i = 0; i < data.Length; i++)
			{
				num += 1.0 / (double)data[i];
			}
			return (double)data.Length / num;
		}

		public static double Variance(float[] samples)
		{
			if (samples.Length <= 1)
			{
				return double.NaN;
			}
			double num = 0.0;
			double num2 = samples[0];
			for (int i = 1; i < samples.Length; i++)
			{
				num2 += (double)samples[i];
				double num3 = (double)((float)(i + 1) * samples[i]) - num2;
				num += num3 * num3 / (((double)i + 1.0) * (double)i);
			}
			return num / (double)(samples.Length - 1);
		}

		public static double PopulationVariance(float[] population)
		{
			if (population.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			double num2 = population[0];
			for (int i = 1; i < population.Length; i++)
			{
				num2 += (double)population[i];
				double num3 = (double)((float)(i + 1) * population[i]) - num2;
				num += num3 * num3 / (((double)i + 1.0) * (double)i);
			}
			return num / (double)population.Length;
		}

		public static double StandardDeviation(float[] samples)
		{
			return Math.Sqrt(Variance(samples));
		}

		public static double PopulationStandardDeviation(float[] population)
		{
			return Math.Sqrt(PopulationVariance(population));
		}

		public static Tuple<double, double> MeanVariance(float[] samples)
		{
			return new Tuple<double, double>(Mean(samples), Variance(samples));
		}

		public static Tuple<double, double> MeanStandardDeviation(float[] samples)
		{
			return new Tuple<double, double>(Mean(samples), StandardDeviation(samples));
		}

		public static double Covariance(float[] samples1, float[] samples2)
		{
			if (samples1.Length != samples2.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (samples1.Length <= 1)
			{
				return double.NaN;
			}
			double num = Mean(samples1);
			double num2 = Mean(samples2);
			double num3 = 0.0;
			for (int i = 0; i < samples1.Length; i++)
			{
				num3 += ((double)samples1[i] - num) * ((double)samples2[i] - num2);
			}
			return num3 / (double)(samples1.Length - 1);
		}

		public static double PopulationCovariance(float[] population1, float[] population2)
		{
			if (population1.Length != population2.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (population1.Length == 0)
			{
				return double.NaN;
			}
			double num = Mean(population1);
			double num2 = Mean(population2);
			double num3 = 0.0;
			for (int i = 0; i < population1.Length; i++)
			{
				num3 += ((double)population1[i] - num) * ((double)population2[i] - num2);
			}
			return num3 / (double)population1.Length;
		}

		public static double RootMeanSquare(float[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			double num = 0.0;
			ulong num2 = 0uL;
			for (int i = 0; i < data.Length; i++)
			{
				num += ((double)(data[i] * data[i]) - num) / (double)(++num2);
			}
			return Math.Sqrt(num);
		}

		public static float OrderStatisticInplace(float[] data, int order)
		{
			if (order < 1 || order > data.Length)
			{
				return float.NaN;
			}
			if (order == 1)
			{
				return Minimum(data);
			}
			if (order == data.Length)
			{
				return Maximum(data);
			}
			return SelectInplace(data, order - 1);
		}

		public static float MedianInplace(float[] data)
		{
			int num = data.Length / 2;
			if (!data.Length.IsOdd())
			{
				return (SelectInplace(data, num - 1) + SelectInplace(data, num)) / 2f;
			}
			return SelectInplace(data, num);
		}

		public static float PercentileInplace(float[] data, int p)
		{
			return QuantileInplace(data, (double)p / 100.0);
		}

		public static float LowerQuartileInplace(float[] data)
		{
			return QuantileInplace(data, 0.25);
		}

		public static float UpperQuartileInplace(float[] data)
		{
			return QuantileInplace(data, 0.75);
		}

		public static float InterquartileRangeInplace(float[] data)
		{
			return QuantileInplace(data, 0.75) - QuantileInplace(data, 0.25);
		}

		public static float[] FiveNumberSummaryInplace(float[] data)
		{
			if (data.Length != 0)
			{
				return new float[5]
				{
					Minimum(data),
					QuantileInplace(data, 0.25),
					MedianInplace(data),
					QuantileInplace(data, 0.75),
					Maximum(data)
				};
			}
			return new float[5]
			{
				float.NaN,
				float.NaN,
				float.NaN,
				float.NaN,
				float.NaN
			};
		}

		public static float QuantileInplace(float[] data, double tau)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return float.NaN;
			}
			double num = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
			int num2 = (int)num;
			if (num2 <= 0 || tau == 0.0)
			{
				return Minimum(data);
			}
			if (num2 >= data.Length || tau == 1.0)
			{
				return Maximum(data);
			}
			float num3 = SelectInplace(data, num2 - 1);
			float num4 = SelectInplace(data, num2);
			return (float)((double)num3 + (num - (double)num2) * (double)(num4 - num3));
		}

		public static float QuantileCustomInplace(float[] data, double tau, double a, double b, double c, double d)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return float.NaN;
			}
			double num = a + ((double)data.Length + b) * tau - 1.0;
			double num2 = Math.Truncate(num);
			double num3 = num - num2;
			if (Math.Abs(num3) < 1E-09)
			{
				return SelectInplace(data, (int)num2);
			}
			float num4 = SelectInplace(data, (int)Math.Floor(num));
			float num5 = SelectInplace(data, (int)Math.Ceiling(num));
			return (float)((double)num4 + (double)(num5 - num4) * (c + d * num3));
		}

		public static float QuantileCustomInplace(float[] data, double tau, QuantileDefinition definition)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return float.NaN;
			}
			if (tau == 0.0 || data.Length == 1)
			{
				return Minimum(data);
			}
			if (tau == 1.0)
			{
				return Maximum(data);
			}
			switch (definition)
			{
			case QuantileDefinition.R1:
			{
				double num26 = (double)data.Length * tau + 0.5;
				return SelectInplace(data, (int)Math.Ceiling(num26 - 0.5) - 1);
			}
			case QuantileDefinition.R2:
			{
				double num25 = (double)data.Length * tau + 0.5;
				return (SelectInplace(data, (int)Math.Ceiling(num25 - 0.5) - 1) + SelectInplace(data, (int)(num25 + 0.5) - 1)) * 0.5f;
			}
			case QuantileDefinition.R3:
			{
				double a = (double)data.Length * tau;
				return SelectInplace(data, (int)Math.Round(a) - 1);
			}
			case QuantileDefinition.R4:
			{
				double num21 = (double)data.Length * tau;
				int num22 = (int)num21;
				float num23 = SelectInplace(data, num22 - 1);
				float num24 = SelectInplace(data, num22);
				return (float)((double)num23 + (num21 - (double)num22) * (double)(num24 - num23));
			}
			case QuantileDefinition.R5:
			{
				double num17 = (double)data.Length * tau + 0.5;
				int num18 = (int)num17;
				float num19 = SelectInplace(data, num18 - 1);
				float num20 = SelectInplace(data, num18);
				return (float)((double)num19 + (num17 - (double)num18) * (double)(num20 - num19));
			}
			case QuantileDefinition.R6:
			{
				double num13 = (double)(data.Length + 1) * tau;
				int num14 = (int)num13;
				float num15 = SelectInplace(data, num14 - 1);
				float num16 = SelectInplace(data, num14);
				return (float)((double)num15 + (num13 - (double)num14) * (double)(num16 - num15));
			}
			case QuantileDefinition.R7:
			{
				double num9 = (double)(data.Length - 1) * tau + 1.0;
				int num10 = (int)num9;
				float num11 = SelectInplace(data, num10 - 1);
				float num12 = SelectInplace(data, num10);
				return (float)((double)num11 + (num9 - (double)num10) * (double)(num12 - num11));
			}
			case QuantileDefinition.R8:
			{
				double num5 = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
				int num6 = (int)num5;
				float num7 = SelectInplace(data, num6 - 1);
				float num8 = SelectInplace(data, num6);
				return (float)((double)num7 + (num5 - (double)num6) * (double)(num8 - num7));
			}
			case QuantileDefinition.R9:
			{
				double num = ((double)data.Length + 0.25) * tau + 0.375;
				int num2 = (int)num;
				float num3 = SelectInplace(data, num2 - 1);
				float num4 = SelectInplace(data, num2);
				return (float)((double)num3 + (num - (double)num2) * (double)(num4 - num3));
			}
			default:
				throw new NotSupportedException();
			}
		}

		private static float SelectInplace(float[] workingData, int rank)
		{
			if (rank <= 0)
			{
				return Minimum(workingData);
			}
			if (rank >= workingData.Length - 1)
			{
				return Maximum(workingData);
			}
			int num = 0;
			int num2 = workingData.Length - 1;
			while (num2 > num + 1)
			{
				int num3 = num + num2 >> 1;
				float num4 = workingData[num3];
				workingData[num3] = workingData[num + 1];
				workingData[num + 1] = num4;
				if (workingData[num] > workingData[num2])
				{
					float num5 = workingData[num];
					workingData[num] = workingData[num2];
					workingData[num2] = num5;
				}
				if (workingData[num + 1] > workingData[num2])
				{
					float num6 = workingData[num + 1];
					workingData[num + 1] = workingData[num2];
					workingData[num2] = num6;
				}
				if (workingData[num] > workingData[num + 1])
				{
					float num7 = workingData[num];
					workingData[num] = workingData[num + 1];
					workingData[num + 1] = num7;
				}
				int num8 = num + 1;
				int num9 = num2;
				float num10 = workingData[num8];
				while (true)
				{
					num8++;
					if (!(workingData[num8] < num10))
					{
						do
						{
							num9--;
						}
						while (workingData[num9] > num10);
						if (num9 < num8)
						{
							break;
						}
						float num11 = workingData[num8];
						workingData[num8] = workingData[num9];
						workingData[num9] = num11;
					}
				}
				workingData[num + 1] = workingData[num9];
				workingData[num9] = num10;
				if (num9 >= rank)
				{
					num2 = num9 - 1;
				}
				if (num9 <= rank)
				{
					num = num8;
				}
			}
			if (num2 == num + 1 && workingData[num2] < workingData[num])
			{
				float num12 = workingData[num];
				workingData[num] = workingData[num2];
				workingData[num2] = num12;
			}
			return workingData[rank];
		}

		public static float[] RanksInplace(float[] data, RankDefinition definition = RankDefinition.Average)
		{
			float[] array = new float[data.Length];
			int[] array2 = new int[data.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = i;
			}
			if (definition == RankDefinition.First)
			{
				Sorting.SortAll(data, array2);
				for (int j = 0; j < array.Length; j++)
				{
					array[array2[j]] = j + 1;
				}
				return array;
			}
			Sorting.Sort(data, array2);
			int num = 0;
			for (int k = 1; k < data.Length; k++)
			{
				if (!((double)Math.Abs(data[k] - data[num]) <= 0.0))
				{
					if (k == num + 1)
					{
						array[array2[num]] = k;
					}
					else
					{
						RanksTies(array, array2, num, k, definition);
					}
					num = k;
				}
			}
			RanksTies(array, array2, num, data.Length, definition);
			return array;
		}

		private static void RanksTies(float[] ranks, int[] index, int a, int b, RankDefinition definition)
		{
			float num = definition switch
			{
				RankDefinition.Average => (float)(b + a - 1) / 2f + 1f, 
				RankDefinition.Min => a + 1, 
				RankDefinition.Max => b, 
				_ => throw new NotSupportedException(), 
			};
			for (int i = a; i < b; i++)
			{
				ranks[index[i]] = num;
			}
		}
	}
	public static class Correlation
	{
		public static double[] Auto(double[] x)
		{
			return AutoCorrelationFft(x, 0, x.Length - 1);
		}

		public static double[] Auto(double[] x, int kMax, int kMin = 0)
		{
			int kHigh = Math.Max(kMax, kMin);
			int kLow = Math.Min(kMax, kMin);
			return AutoCorrelationFft(x, kLow, kHigh);
		}

		public static double[] Auto(double[] x, int[] k)
		{
			if (k == null)
			{
				throw new ArgumentNullException("k");
			}
			if (k.Length < 1)
			{
				throw new ArgumentException("k");
			}
			int num = k.Min();
			int kHigh = k.Max();
			double[] array = AutoCorrelationFft(x, num, kHigh);
			double[] array2 = new double[k.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = array[k[i] - num];
			}
			return array2;
		}

		private static double[] AutoCorrelationFft(double[] x, int kLow, int kHigh)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			int num = x.Length;
			if (kLow < 0 || kLow >= num)
			{
				throw new ArgumentOutOfRangeException("kLow", "kMin must be zero or positive and smaller than x.Length");
			}
			if (kHigh < 0 || kHigh >= num)
			{
				throw new ArgumentOutOfRangeException("kHigh", "kMax must be positive and smaller than x.Length");
			}
			if (num < 1)
			{
				return new double[0];
			}
			int num2 = num.CeilingToPowerOfTwo() * 2;
			Complex[] array = new Complex[num2];
			Complex[] array2 = new Complex[num2];
			double num3 = ArrayStatistics.Mean(x);
			for (int i = 0; i < x.Length; i++)
			{
				array[i] = new Complex(x[i] - num3, 0.0);
			}
			Fourier.Forward(array, FourierOptions.AsymmetricScaling);
			for (int j = 0; j < array.Length; j++)
			{
				array2[j] = Complex.Multiply(array[j], Complex.Conjugate(array[j]));
			}
			Fourier.Inverse(array2, FourierOptions.AsymmetricScaling);
			double real = array2[0].Real;
			double[] array3 = new double[kHigh - kLow + 1];
			for (int k = 0; k < kHigh - kLow + 1; k++)
			{
				array3[k] = array2[kLow + k].Real / real;
			}
			return array3;
		}

		public static double Pearson(IEnumerable<double> dataA, IEnumerable<double> dataB)
		{
			int num = 0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = 0.0;
			using (IEnumerator<double> enumerator = dataA.GetEnumerator())
			{
				using IEnumerator<double> enumerator2 = dataB.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (!enumerator2.MoveNext())
					{
						throw new ArgumentOutOfRangeException("dataB", "The array arguments must have the same length.");
					}
					double current = enumerator.Current;
					double current2 = enumerator2.Current;
					double num7 = current - num3;
					double num8 = num7 / (double)(++num);
					double num9 = current2 - num4;
					double num10 = num9 / (double)num;
					num3 += num8;
					num4 += num10;
					num5 += num8 * num7 * (double)(num - 1);
					num6 += num10 * num9 * (double)(num - 1);
					num2 += num7 * num9 * (double)(num - 1) / (double)num;
				}
				if (enumerator2.MoveNext())
				{
					throw new ArgumentOutOfRangeException("dataA", "The array arguments must have the same length.");
				}
			}
			return num2 / Math.Sqrt(num5 * num6);
		}

		public static double WeightedPearson(IEnumerable<double> dataA, IEnumerable<double> dataB, IEnumerable<double> weights)
		{
			int num = 0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = 0.0;
			double num7 = 0.0;
			using (IEnumerator<double> enumerator = dataA.GetEnumerator())
			{
				using IEnumerator<double> enumerator2 = dataB.GetEnumerator();
				using IEnumerator<double> enumerator3 = weights.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (!enumerator2.MoveNext())
					{
						throw new ArgumentOutOfRangeException("dataB", "The array arguments must have the same length.");
					}
					if (!enumerator3.MoveNext())
					{
						throw new ArgumentOutOfRangeException("weights", "The array arguments must have the same length.");
					}
					num++;
					double current = enumerator.Current;
					double current2 = enumerator2.Current;
					double current3 = enumerator3.Current;
					double num8 = num6 + current3;
					double num9 = current - num2;
					double num10 = num9 * current3 / num8;
					num2 += num10;
					num4 += num6 * num9 * num10;
					double num11 = current2 - num3;
					double num12 = num11 * current3 / num8;
					num3 += num12;
					num5 += num6 * num11 * num12;
					num7 += num9 * num11 * current3 * (num6 / num8);
					num6 = num8;
				}
				if (enumerator2.MoveNext())
				{
					throw new ArgumentOutOfRangeException("dataB", "The array arguments must have the same length.");
				}
				if (enumerator3.MoveNext())
				{
					throw new ArgumentOutOfRangeException("weights", "The array arguments must have the same length.");
				}
			}
			return num7 / Math.Sqrt(num4 * num5);
		}

		public static Matrix<double> PearsonMatrix(params double[][] vectors)
		{
			Matrix<double> matrix = Matrix<double>.Build.DenseIdentity(vectors.Length);
			for (int i = 0; i < vectors.Length; i++)
			{
				for (int j = i + 1; j < vectors.Length; j++)
				{
					double value = Pearson(vectors[i], vectors[j]);
					matrix.At(i, j, value);
					matrix.At(j, i, value);
				}
			}
			return matrix;
		}

		public static Matrix<double> PearsonMatrix(IEnumerable<double[]> vectors)
		{
			return PearsonMatrix((vectors as double[][]) ?? vectors.ToArray());
		}

		public static double Spearman(IEnumerable<double> dataA, IEnumerable<double> dataB)
		{
			return Pearson(Rank(dataA), Rank(dataB));
		}

		public static Matrix<double> SpearmanMatrix(params double[][] vectors)
		{
			return PearsonMatrix(vectors.Select(Rank).ToArray());
		}

		public static Matrix<double> SpearmanMatrix(IEnumerable<double[]> vectors)
		{
			return PearsonMatrix(vectors.Select(Rank).ToArray());
		}

		private static double[] Rank(IEnumerable<double> series)
		{
			if (series == null)
			{
				return new double[0];
			}
			return ArrayStatistics.RanksInplace(series.ToArray());
		}
	}
	[DataContract(Namespace = "urn:MathNet/Numerics")]
	public class DescriptiveStatistics
	{
		[DataMember(Order = 1)]
		public long Count { get; private set; }

		[DataMember(Order = 2)]
		public double Mean { get; private set; }

		[DataMember(Order = 3)]
		public double Variance { get; private set; }

		[DataMember(Order = 4)]
		public double StandardDeviation { get; private set; }

		[DataMember(Order = 5)]
		public double Skewness { get; private set; }

		[DataMember(Order = 6)]
		public double Kurtosis { get; private set; }

		[DataMember(Order = 7)]
		public double Maximum { get; private set; }

		[DataMember(Order = 8)]
		public double Minimum { get; private set; }

		public DescriptiveStatistics(IEnumerable<double> data, bool increasedAccuracy = false)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (increasedAccuracy)
			{
				ComputeDecimal(data);
			}
			else
			{
				Compute(data);
			}
		}

		public DescriptiveStatistics(IEnumerable<double?> data, bool increasedAccuracy = false)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (increasedAccuracy)
			{
				ComputeDecimal(data);
			}
			else
			{
				Compute(data);
			}
		}

		private void Compute(IEnumerable<double> data)
		{
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = double.PositiveInfinity;
			double num6 = double.NegativeInfinity;
			long num7 = 0L;
			foreach (double datum in data)
			{
				double num8 = datum - num;
				double num9 = num8 / (double)(++num7);
				double num10 = num9 * num9;
				double num11 = num8 * (double)(num7 - 1);
				num += num9;
				num4 += num11 * num9 * num10 * (double)(num7 * num7 - 3 * num7 + 3) + 6.0 * num10 * num2 - 4.0 * num9 * num3;
				num3 += num11 * num10 * (double)(num7 - 2) - 3.0 * num9 * num2;
				num2 += num11 * num9;
				if (num5 > datum)
				{
					num5 = datum;
				}
				if (num6 < datum)
				{
					num6 = datum;
				}
			}
			SetStatistics(num, num2, num3, num4, num5, num6, num7);
		}

		private void Compute(IEnumerable<double?> data)
		{
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = double.PositiveInfinity;
			double num6 = double.NegativeInfinity;
			long num7 = 0L;
			foreach (double? datum in data)
			{
				if (datum.HasValue)
				{
					double num8 = datum.Value - num;
					double num9 = num8 / (double)(++num7);
					double num10 = num9 * num9;
					double num11 = num8 * (double)(num7 - 1);
					num += num9;
					num4 += num11 * num9 * num10 * (double)(num7 * num7 - 3 * num7 + 3) + 6.0 * num10 * num2 - 4.0 * num9 * num3;
					num3 += num11 * num10 * (double)(num7 - 2) - 3.0 * num9 * num2;
					num2 += num11 * num9;
					if (num5 > datum)
					{
						num5 = datum.Value;
					}
					if (num6 < datum)
					{
						num6 = datum.Value;
					}
				}
			}
			SetStatistics(num, num2, num3, num4, num5, num6, num7);
		}

		private void ComputeDecimal(IEnumerable<double> data)
		{
			decimal num = default(decimal);
			decimal num2 = default(decimal);
			decimal num3 = default(decimal);
			decimal num4 = default(decimal);
			decimal num5 = decimal.MaxValue;
			decimal num6 = decimal.MinValue;
			long num7 = 0L;
			foreach (double datum in data)
			{
				decimal num8 = (decimal)datum;
				decimal num9 = num8 - num;
				decimal num10 = num9 / (decimal)(num7 += 1);
				decimal num11 = num10 * num10;
				decimal num12 = num9 * (decimal)(num7 - 1);
				num += num10;
				num4 += num12 * num10 * num11 * (decimal)(num7 * num7 - 3 * num7 + 3) + 6m * num11 * num2 - 4m * num10 * num3;
				num3 += num12 * num11 * (decimal)(num7 - 2) - 3m * num10 * num2;
				num2 += num12 * num10;
				if (num5 > num8)
				{
					num5 = num8;
				}
				if (num6 < num8)
				{
					num6 = num8;
				}
			}
			SetStatistics((double)num, (double)num2, (double)num3, (double)num4, (double)num5, (double)num6, num7);
		}

		private void ComputeDecimal(IEnumerable<double?> data)
		{
			decimal num = default(decimal);
			decimal num2 = default(decimal);
			decimal num3 = default(decimal);
			decimal num4 = default(decimal);
			decimal num5 = decimal.MaxValue;
			decimal num6 = decimal.MinValue;
			long num7 = 0L;
			foreach (double? datum in data)
			{
				if (datum.HasValue)
				{
					decimal num8 = (decimal)datum.Value;
					decimal num9 = num8 - num;
					decimal num10 = num9 / (decimal)(num7 += 1);
					decimal num11 = num10 * num10;
					decimal num12 = num9 * (decimal)(num7 - 1);
					num += num10;
					num4 += num12 * num10 * num11 * (decimal)(num7 * num7 - 3 * num7 + 3) + 6m * num11 * num2 - 4m * num10 * num3;
					num3 += num12 * num11 * (decimal)(num7 - 2) - 3m * num10 * num2;
					num2 += num12 * num10;
					if (num5 > num8)
					{
						num5 = num8;
					}
					if (num6 < num8)
					{
						num6 = num8;
					}
				}
			}
			SetStatistics((double)num, (double)num2, (double)num3, (double)num4, (double)num5, (double)num6, num7);
		}

		private void SetStatistics(double mean, double variance, double skewness, double kurtosis, double minimum, double maximum, long n)
		{
			Mean = mean;
			Count = n;
			Minimum = double.NaN;
			Maximum = double.NaN;
			Variance = double.NaN;
			StandardDeviation = double.NaN;
			Skewness = double.NaN;
			Kurtosis = double.NaN;
			if (n <= 0)
			{
				return;
			}
			Minimum = minimum;
			Maximum = maximum;
			if (n > 1)
			{
				Variance = variance / (double)(n - 1);
				StandardDeviation = Math.Sqrt(Variance);
			}
			if (Variance != 0.0)
			{
				if (n > 2)
				{
					Skewness = (double)n / (double)((n - 1) * (n - 2)) * (skewness / (Variance * StandardDeviation));
				}
				if (n > 3)
				{
					Kurtosis = ((double)n * (double)n - 1.0) / (double)((n - 2) * (n - 3)) * ((double)n * kurtosis / (variance * variance) - 3.0 + 6.0 / (double)(n + 1));
				}
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics")]
	public class Bucket : IComparable<Bucket>, ICloneable
	{
		private sealed class PointComparer : IComparer<Bucket>
		{
			public int Compare(Bucket bkt1, Bucket bkt2)
			{
				if (!bkt2.IsSinglePoint)
				{
					return -bkt2.Contains(bkt1.UpperBound);
				}
				return -bkt1.Contains(bkt2.UpperBound);
			}
		}

		private static readonly PointComparer Comparer = new PointComparer();

		[DataMember(Order = 1)]
		public double LowerBound { get; set; }

		[DataMember(Order = 2)]
		public double UpperBound { get; set; }

		[DataMember(Order = 3)]
		public double Count { get; set; }

		public double Width => UpperBound - LowerBound;

		private bool IsSinglePoint => double.IsNaN(Count);

		public static IComparer<Bucket> DefaultPointComparer => Comparer;

		public Bucket(double lowerBound, double upperBound, double count = 0.0)
		{
			if (lowerBound > upperBound)
			{
				throw new ArgumentException("The upper bound must be at least as large as the lower bound.");
			}
			if (count < 0.0)
			{
				throw new ArgumentOutOfRangeException("count", "Value must be positive.");
			}
			LowerBound = lowerBound;
			UpperBound = upperBound;
			Count = count;
		}

		public Bucket(double targetValue)
		{
			LowerBound = targetValue;
			UpperBound = targetValue;
			Count = double.NaN;
		}

		public object Clone()
		{
			return new Bucket(LowerBound, UpperBound, Count);
		}

		public int Contains(double x)
		{
			if (LowerBound < x)
			{
				if (UpperBound >= x)
				{
					return 0;
				}
				return 1;
			}
			return -1;
		}

		public int CompareTo(Bucket bucket)
		{
			if (UpperBound > bucket.LowerBound && LowerBound < bucket.LowerBound)
			{
				throw new ArgumentException("The two arguments can't be compared (maybe they are part of a partial ordering?)");
			}
			if (UpperBound.Equals(bucket.UpperBound) && LowerBound.Equals(bucket.LowerBound))
			{
				return 0;
			}
			if (bucket.UpperBound <= LowerBound)
			{
				return 1;
			}
			return -1;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Bucket))
			{
				return false;
			}
			Bucket bucket = (Bucket)obj;
			if (LowerBound.Equals(bucket.LowerBound) && UpperBound.Equals(bucket.UpperBound))
			{
				return Count.AlmostEqual(bucket.Count);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return LowerBound.GetHashCode() ^ UpperBound.GetHashCode() ^ Count.GetHashCode();
		}

		public override string ToString()
		{
			return "(" + LowerBound + ";" + UpperBound + "] = " + Count;
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics")]
	public class Histogram
	{
		[DataMember(Order = 1)]
		private readonly List<Bucket> _buckets;

		[DataMember(Order = 2)]
		private bool _areBucketsSorted;

		public double LowerBound
		{
			get
			{
				LazySort();
				return _buckets[0].LowerBound;
			}
		}

		public double UpperBound
		{
			get
			{
				LazySort();
				return _buckets[_buckets.Count - 1].UpperBound;
			}
		}

		public Bucket this[int n]
		{
			get
			{
				LazySort();
				return (Bucket)_buckets[n].Clone();
			}
		}

		public int BucketCount => _buckets.Count;

		public double DataCount
		{
			get
			{
				double num = 0.0;
				for (int i = 0; i < BucketCount; i++)
				{
					num += this[i].Count;
				}
				return num;
			}
		}

		public Histogram()
		{
			_buckets = new List<Bucket>();
			_areBucketsSorted = true;
		}

		public Histogram(IEnumerable<double> data, int nbuckets)
			: this()
		{
			if (nbuckets < 1)
			{
				throw new ArgumentOutOfRangeException("data", "The number of bins in a histogram should be at least 1.");
			}
			double num = data.Minimum();
			double num2 = (data.Maximum() - num) / (double)nbuckets;
			if (double.IsNaN(num2))
			{
				throw new ArgumentException("Data must contain at least one entry.", "data");
			}
			double num3 = num + num2;
			AddBucket(new Bucket(num.Decrement(), num3));
			for (int i = 1; i < nbuckets; i++)
			{
				AddBucket(new Bucket(num3, num3 = num + (double)(i + 1) * num2));
			}
			AddData(data);
		}

		public Histogram(IEnumerable<double> data, int nbuckets, double lower, double upper)
			: this()
		{
			if (lower > upper)
			{
				throw new ArgumentOutOfRangeException("upper", "The histogram lower bound must be smaller than the upper bound.");
			}
			if (nbuckets < 1)
			{
				throw new ArgumentOutOfRangeException("nbuckets", "The number of bins in a histogram should be at least 1.");
			}
			double num = (upper - lower) / (double)nbuckets;
			for (int i = 0; i < nbuckets; i++)
			{
				AddBucket(new Bucket(lower + (double)i * num, lower + (double)(i + 1) * num));
			}
			AddData(data);
		}

		public void AddData(double d)
		{
			LazySort();
			if (d <= LowerBound)
			{
				_buckets[0].LowerBound = d.Decrement();
				_buckets[0].Count++;
			}
			else if (d > UpperBound)
			{
				_buckets[BucketCount - 1].UpperBound = d;
				_buckets[BucketCount - 1].Count++;
			}
			else
			{
				_buckets[GetBucketIndexOf(d)].Count++;
			}
		}

		public void AddData(IEnumerable<double> data)
		{
			foreach (double datum in data)
			{
				AddData(datum);
			}
		}

		public void AddBucket(Bucket bucket)
		{
			_buckets.Add(bucket);
			_areBucketsSorted = false;
		}

		private void LazySort()
		{
			if (!_areBucketsSorted)
			{
				_buckets.Sort();
				_areBucketsSorted = true;
			}
		}

		public Bucket GetBucketOf(double v)
		{
			return (Bucket)_buckets[GetBucketIndexOf(v)].Clone();
		}

		public int GetBucketIndexOf(double v)
		{
			LazySort();
			int num = _buckets.BinarySearch(new Bucket(v), Bucket.DefaultPointComparer);
			if (num < 0)
			{
				throw new ArgumentException("The histogram does not contain the value.");
			}
			return num;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (Bucket bucket in _buckets)
			{
				stringBuilder.Append(bucket);
			}
			return stringBuilder.ToString();
		}
	}
	public static class KernelDensity
	{
		public static double Estimate(double x, double bandwidth, IList<double> samples, Func<double, double> kernel)
		{
			if (bandwidth <= 0.0)
			{
				throw new ArgumentException("The bandwidth must be a positive number!");
			}
			int count = samples.Count;
			return CommonParallel.Aggregate(0, count, (int i) => kernel((x - samples[i]) / bandwidth), (double a, double b) => a + b, 0.0) / ((double)count * bandwidth);
		}

		public static double EstimateGaussian(double x, double bandwidth, IList<double> samples)
		{
			return Estimate(x, bandwidth, samples, GaussianKernel);
		}

		public static double EstimateEpanechnikov(double x, double bandwidth, IList<double> samples)
		{
			return Estimate(x, bandwidth, samples, EpanechnikovKernel);
		}

		public static double EstimateUniform(double x, double bandwidth, IList<double> samples)
		{
			return Estimate(x, bandwidth, samples, UniformKernel);
		}

		public static double EstimateTriangular(double x, double bandwidth, IList<double> samples)
		{
			return Estimate(x, bandwidth, samples, TriangularKernel);
		}

		public static double GaussianKernel(double x)
		{
			return Normal.PDF(0.0, 1.0, x);
		}

		public static double EpanechnikovKernel(double x)
		{
			if (!(Math.Abs(x) <= 1.0))
			{
				return 0.0;
			}
			return 0.75 * (1.0 - x * x);
		}

		public static double UniformKernel(double x)
		{
			return ContinuousUniform.PDF(-1.0, 1.0, x);
		}

		public static double TriangularKernel(double x)
		{
			return Triangular.PDF(-1.0, 1.0, 0.0, x);
		}
	}
	public class MovingStatistics
	{
		private readonly double[] _oldValues;

		private readonly int _windowSize;

		private long _count;

		private long _totalCountOffset;

		private int _lastIndex;

		private int _lastNaNTimeToLive;

		private int _lastPosInfTimeToLive;

		private int _lastNegInfTimeToLive;

		private double _m1;

		private double _m2;

		private double _max = double.NegativeInfinity;

		private double _min = double.PositiveInfinity;

		public int WindowSize => _windowSize;

		public long Count => _totalCountOffset + _count;

		public double Minimum
		{
			get
			{
				if (_lastNaNTimeToLive > 0)
				{
					return double.NaN;
				}
				if (_lastNegInfTimeToLive > 0)
				{
					return double.NegativeInfinity;
				}
				if (_count <= 0 && _lastPosInfTimeToLive <= 0)
				{
					return double.NaN;
				}
				return _min;
			}
		}

		public double Maximum
		{
			get
			{
				if (_lastNaNTimeToLive > 0)
				{
					return double.NaN;
				}
				if (_lastPosInfTimeToLive > 0)
				{
					return double.PositiveInfinity;
				}
				if (_count <= 0 && _lastNegInfTimeToLive <= 0)
				{
					return double.NaN;
				}
				return _max;
			}
		}

		public double Mean
		{
			get
			{
				if (_lastNaNTimeToLive > 0 || (_lastPosInfTimeToLive > 0 && _lastNegInfTimeToLive > 0))
				{
					return double.NaN;
				}
				if (_lastPosInfTimeToLive > 0)
				{
					return double.PositiveInfinity;
				}
				if (_lastNegInfTimeToLive > 0)
				{
					return double.NegativeInfinity;
				}
				if (_count != 0L)
				{
					return _m1;
				}
				return double.NaN;
			}
		}

		public double Variance
		{
			get
			{
				if (_lastNaNTimeToLive > 0 || _lastNegInfTimeToLive > 0)
				{
					return double.NaN;
				}
				if (_lastPosInfTimeToLive > 0)
				{
					return double.PositiveInfinity;
				}
				if (_count >= 2)
				{
					return _m2 / (double)(_count - 1);
				}
				return double.NaN;
			}
		}

		public double PopulationVariance
		{
			get
			{
				if (_lastNaNTimeToLive > 0 || _lastNegInfTimeToLive > 0)
				{
					return double.NaN;
				}
				if (_lastPosInfTimeToLive > 0)
				{
					return double.PositiveInfinity;
				}
				if (_count >= 2)
				{
					return _m2 / (double)_count;
				}
				return double.NaN;
			}
		}

		public double StandardDeviation
		{
			get
			{
				if (_lastNaNTimeToLive > 0 || _lastNegInfTimeToLive > 0)
				{
					return double.NaN;
				}
				if (_lastPosInfTimeToLive > 0)
				{
					return double.PositiveInfinity;
				}
				if (_count >= 2)
				{
					return Math.Sqrt(_m2 / (double)(_count - 1));
				}
				return double.NaN;
			}
		}

		public double PopulationStandardDeviation
		{
			get
			{
				if (_lastNaNTimeToLive > 0 || _lastNegInfTimeToLive > 0)
				{
					return double.NaN;
				}
				if (_lastPosInfTimeToLive > 0)
				{
					return double.PositiveInfinity;
				}
				if (_count >= 2)
				{
					return Math.Sqrt(_m2 / (double)_count);
				}
				return double.NaN;
			}
		}

		public MovingStatistics(int windowSize)
		{
			if (windowSize < 1)
			{
				throw new ArgumentException($"Value must be positive.", "windowSize");
			}
			_windowSize = windowSize;
			_oldValues = new double[_windowSize];
		}

		public MovingStatistics(int windowSize, IEnumerable<double> values)
			: this(windowSize)
		{
			PushRange(values);
		}

		public void Push(double value)
		{
			DecrementTimeToLive();
			if (double.IsNaN(value))
			{
				_lastNaNTimeToLive = _windowSize;
				Reset(double.PositiveInfinity, double.NegativeInfinity);
				return;
			}
			if (double.IsPositiveInfinity(value))
			{
				_lastPosInfTimeToLive = _windowSize;
				Reset(_min, double.NegativeInfinity);
				return;
			}
			if (double.IsNegativeInfinity(value))
			{
				_lastNegInfTimeToLive = _windowSize;
				Reset(double.PositiveInfinity, _max);
				return;
			}
			if (_count < _windowSize)
			{
				_oldValues[_count] = value;
				_count++;
				double num = value - _m1;
				double num2 = num / (double)_count;
				double num3 = num * num2 * (double)(_count - 1);
				_m1 += num2;
				_m2 += num3;
				if (value < _min)
				{
					_min = value;
				}
				if (value > _max)
				{
					_max = value;
				}
				return;
			}
			double num4 = _oldValues[_lastIndex];
			double num5 = value - num4;
			double num6 = num5 / (double)_count;
			double m = _m1;
			_m1 += num6;
			double num7 = value - _m1 + num4 - m;
			double num8 = num5 * num7;
			_m2 += num8;
			_oldValues[_lastIndex] = value;
			_lastIndex++;
			if (_lastIndex == WindowSize)
			{
				_lastIndex = 0;
			}
			_max = ((value > _max) ? value : _oldValues.Maximum());
			_min = ((value < _min) ? value : _oldValues.Minimum());
		}

		public void PushRange(IEnumerable<double> values)
		{
			foreach (double value in values)
			{
				Push(value);
			}
		}

		private void DecrementTimeToLive()
		{
			if (_lastNaNTimeToLive > 0)
			{
				_lastNaNTimeToLive--;
			}
			if (_lastPosInfTimeToLive > 0)
			{
				_lastPosInfTimeToLive--;
			}
			if (_lastNegInfTimeToLive > 0)
			{
				_lastNegInfTimeToLive--;
			}
		}

		private void Reset(double min, double max)
		{
			_totalCountOffset += _count + 1;
			_count = 0L;
			_m1 = 0.0;
			_max = max;
			_min = min;
		}
	}
	public enum QuantileDefinition
	{
		R1 = 1,
		SAS3 = 1,
		EmpiricalInvCDF = 1,
		R2 = 2,
		SAS5 = 2,
		EmpiricalInvCDFAverage = 2,
		R3 = 3,
		SAS2 = 3,
		Nearest = 3,
		R4 = 4,
		SAS1 = 4,
		California = 4,
		R5 = 5,
		Hydrology = 5,
		Hazen = 5,
		R6 = 6,
		SAS4 = 6,
		Nist = 6,
		Weibull = 6,
		SPSS = 6,
		R7 = 7,
		Excel = 7,
		Mode = 7,
		S = 7,
		R8 = 8,
		Median = 8,
		Default = 8,
		R9 = 9,
		Normal = 9
	}
	public enum RankDefinition
	{
		Average = 1,
		Default = 1,
		Min = 2,
		Sports = 2,
		Max = 3,
		First = 4,
		EmpiricalCDF = 5
	}
	[DataContract(Namespace = "urn:MathNet/Numerics")]
	public class RunningStatistics
	{
		[DataMember(Order = 1)]
		private long _n;

		[DataMember(Order = 2)]
		private double _min = double.PositiveInfinity;

		[DataMember(Order = 3)]
		private double _max = double.NegativeInfinity;

		[DataMember(Order = 4)]
		private double _m1;

		[DataMember(Order = 5)]
		private double _m2;

		[DataMember(Order = 6)]
		private double _m3;

		[DataMember(Order = 7)]
		private double _m4;

		public long Count => _n;

		public double Minimum
		{
			get
			{
				if (_n <= 0)
				{
					return double.NaN;
				}
				return _min;
			}
		}

		public double Maximum
		{
			get
			{
				if (_n <= 0)
				{
					return double.NaN;
				}
				return _max;
			}
		}

		public double Mean
		{
			get
			{
				if (_n <= 0)
				{
					return double.NaN;
				}
				return _m1;
			}
		}

		public double Variance
		{
			get
			{
				if (_n >= 2)
				{
					return _m2 / (double)(_n - 1);
				}
				return double.NaN;
			}
		}

		public double PopulationVariance
		{
			get
			{
				if (_n >= 2)
				{
					return _m2 / (double)_n;
				}
				return double.NaN;
			}
		}

		public double StandardDeviation
		{
			get
			{
				if (_n >= 2)
				{
					return Math.Sqrt(_m2 / (double)(_n - 1));
				}
				return double.NaN;
			}
		}

		public double PopulationStandardDeviation
		{
			get
			{
				if (_n >= 2)
				{
					return Math.Sqrt(_m2 / (double)_n);
				}
				return double.NaN;
			}
		}

		public double Skewness
		{
			get
			{
				if (_n >= 3)
				{
					return (double)_n * _m3 * Math.Sqrt(_m2 / (double)(_n - 1)) / (_m2 * _m2 * (double)(_n - 2)) * (double)(_n - 1);
				}
				return double.NaN;
			}
		}

		public double PopulationSkewness
		{
			get
			{
				if (_n >= 2)
				{
					return Math.Sqrt(_n) * _m3 / Math.Pow(_m2, 1.5);
				}
				return double.NaN;
			}
		}

		public double Kurtosis
		{
			get
			{
				if (_n >= 4)
				{
					return ((double)_n * (double)_n - 1.0) / (double)((_n - 2) * (_n - 3)) * ((double)_n * _m4 / (_m2 * _m2) - 3.0 + 6.0 / (double)(_n + 1));
				}
				return double.NaN;
			}
		}

		public double PopulationKurtosis
		{
			get
			{
				if (_n >= 3)
				{
					return (double)_n * _m4 / (_m2 * _m2) - 3.0;
				}
				return double.NaN;
			}
		}

		public RunningStatistics()
		{
		}

		public RunningStatistics(IEnumerable<double> values)
		{
			PushRange(values);
		}

		public void Push(double value)
		{
			_n++;
			double num = value - _m1;
			double num2 = num / (double)_n;
			double num3 = num2 * num2;
			double num4 = num * num2 * (double)(_n - 1);
			_m1 += num2;
			_m4 += num4 * num3 * (double)(_n * _n - 3 * _n + 3) + 6.0 * num3 * _m2 - 4.0 * num2 * _m3;
			_m3 += num4 * num2 * (double)(_n - 2) - 3.0 * num2 * _m2;
			_m2 += num4;
			if (value < _min || double.IsNaN(value))
			{
				_min = value;
			}
			if (value > _max || double.IsNaN(value))
			{
				_max = value;
			}
		}

		public void PushRange(IEnumerable<double> values)
		{
			foreach (double value in values)
			{
				Push(value);
			}
		}

		public static RunningStatistics Combine(RunningStatistics a, RunningStatistics b)
		{
			if (a._n == 0L)
			{
				return b;
			}
			if (b._n == 0L)
			{
				return a;
			}
			long num = a._n + b._n;
			double num2 = b._m1 - a._m1;
			double num3 = num2 * num2;
			double num4 = num3 * num2;
			double num5 = num3 * num3;
			double m = ((double)a._n * a._m1 + (double)b._n * b._m1) / (double)num;
			double m2 = a._m2 + b._m2 + num3 * (double)a._n * (double)b._n / (double)num;
			double m3 = a._m3 + b._m3 + num4 * (double)a._n * (double)b._n * (double)(a._n - b._n) / (double)(num * num) + 3.0 * num2 * ((double)a._n * b._m2 - (double)b._n * a._m2) / (double)num;
			double m4 = a._m4 + b._m4 + num5 * (double)a._n * (double)b._n * (double)(a._n * a._n - a._n * b._n + b._n * b._n) / (double)(num * num * num) + 6.0 * num3 * ((double)(a._n * a._n) * b._m2 + (double)(b._n * b._n) * a._m2) / (double)(num * num) + 4.0 * num2 * ((double)a._n * b._m3 - (double)b._n * a._m3) / (double)num;
			double min = Math.Min(a._min, b._min);
			double max = Math.Max(a._max, b._max);
			return new RunningStatistics
			{
				_n = num,
				_m1 = m,
				_m2 = m2,
				_m3 = m3,
				_m4 = m4,
				_min = min,
				_max = max
			};
		}

		public static RunningStatistics operator +(RunningStatistics a, RunningStatistics b)
		{
			return Combine(a, b);
		}
	}
	public static class SortedArrayStatistics
	{
		public static double Minimum(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			return data[0];
		}

		public static double Maximum(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			return data[data.Length - 1];
		}

		public static double OrderStatistic(double[] data, int order)
		{
			if (order < 1 || order > data.Length)
			{
				return double.NaN;
			}
			return data[order - 1];
		}

		public static double Median(double[] data)
		{
			if (data.Length == 0)
			{
				return double.NaN;
			}
			int num = data.Length / 2;
			if (!data.Length.IsOdd())
			{
				return (data[num - 1] + data[num]) / 2.0;
			}
			return data[num];
		}

		public static double Percentile(double[] data, int p)
		{
			return Quantile(data, (double)p / 100.0);
		}

		public static double LowerQuartile(double[] data)
		{
			return Quantile(data, 0.25);
		}

		public static double UpperQuartile(double[] data)
		{
			return Quantile(data, 0.75);
		}

		public static double InterquartileRange(double[] data)
		{
			return Quantile(data, 0.75) - Quantile(data, 0.25);
		}

		public static double[] FiveNumberSummary(double[] data)
		{
			if (data.Length != 0)
			{
				return new double[5]
				{
					data[0],
					Quantile(data, 0.25),
					Quantile(data, 0.5),
					Quantile(data, 0.75),
					data[data.Length - 1]
				};
			}
			return new double[5]
			{
				double.NaN,
				double.NaN,
				double.NaN,
				double.NaN,
				double.NaN
			};
		}

		public static double Quantile(double[] data, double tau)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return double.NaN;
			}
			if (tau == 0.0 || data.Length == 1)
			{
				return data[0];
			}
			if (tau == 1.0)
			{
				return data[data.Length - 1];
			}
			double num = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
			int num2 = (int)num;
			if (num2 >= 1)
			{
				if (num2 < data.Length)
				{
					return data[num2 - 1] + (num - (double)num2) * (data[num2] - data[num2 - 1]);
				}
				return data[data.Length - 1];
			}
			return data[0];
		}

		public static double QuantileCustom(double[] data, double tau, double a, double b, double c, double d)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return double.NaN;
			}
			double num = a + ((double)data.Length + b) * tau - 1.0;
			double num2 = Math.Truncate(num);
			double num3 = num - num2;
			if (Math.Abs(num3) < 1E-09)
			{
				return data[Math.Min(Math.Max((int)num2, 0), data.Length - 1)];
			}
			double num4 = data[Math.Max((int)Math.Floor(num), 0)];
			double num5 = data[Math.Min((int)Math.Ceiling(num), data.Length - 1)];
			return num4 + (num5 - num4) * (c + d * num3);
		}

		public static double QuantileCustom(double[] data, double tau, QuantileDefinition definition)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return double.NaN;
			}
			if (tau == 0.0 || data.Length == 1)
			{
				return data[0];
			}
			if (tau == 1.0)
			{
				return data[data.Length - 1];
			}
			switch (definition)
			{
			case QuantileDefinition.R1:
			{
				double num26 = (double)data.Length * tau + 0.5;
				return data[(int)Math.Ceiling(num26 - 0.5) - 1];
			}
			case QuantileDefinition.R2:
			{
				double num25 = (double)data.Length * tau + 0.5;
				return (data[(int)Math.Ceiling(num25 - 0.5) - 1] + data[(int)(num25 + 0.5) - 1]) * 0.5;
			}
			case QuantileDefinition.R3:
			{
				double a = (double)data.Length * tau;
				return data[Math.Max((int)Math.Round(a) - 1, 0)];
			}
			case QuantileDefinition.R4:
			{
				double num21 = (double)data.Length * tau;
				int num22 = (int)num21;
				double num23 = data[Math.Max(num22 - 1, 0)];
				double num24 = data[Math.Min(num22, data.Length - 1)];
				return num23 + (num21 - (double)num22) * (num24 - num23);
			}
			case QuantileDefinition.R5:
			{
				double num17 = (double)data.Length * tau + 0.5;
				int num18 = (int)num17;
				double num19 = data[Math.Max(num18 - 1, 0)];
				double num20 = data[Math.Min(num18, data.Length - 1)];
				return num19 + (num17 - (double)num18) * (num20 - num19);
			}
			case QuantileDefinition.R6:
			{
				double num13 = (double)(data.Length + 1) * tau;
				int num14 = (int)num13;
				double num15 = data[Math.Max(num14 - 1, 0)];
				double num16 = data[Math.Min(num14, data.Length - 1)];
				return num15 + (num13 - (double)num14) * (num16 - num15);
			}
			case QuantileDefinition.R7:
			{
				double num9 = (double)(data.Length - 1) * tau + 1.0;
				int num10 = (int)num9;
				double num11 = data[Math.Max(num10 - 1, 0)];
				double num12 = data[Math.Min(num10, data.Length - 1)];
				return num11 + (num9 - (double)num10) * (num12 - num11);
			}
			case QuantileDefinition.R8:
			{
				double num5 = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
				int num6 = (int)num5;
				double num7 = data[Math.Max(num6 - 1, 0)];
				double num8 = data[Math.Min(num6, data.Length - 1)];
				return num7 + (num5 - (double)num6) * (num8 - num7);
			}
			case QuantileDefinition.R9:
			{
				double num = ((double)data.Length + 0.25) * tau + 0.375;
				int num2 = (int)num;
				double num3 = data[Math.Max(num2 - 1, 0)];
				double num4 = data[Math.Min(num2, data.Length - 1)];
				return num3 + (num - (double)num2) * (num4 - num3);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public static double EmpiricalCDF(double[] data, double x)
		{
			if (x < data[0])
			{
				return 0.0;
			}
			if (x >= data[data.Length - 1])
			{
				return 1.0;
			}
			int i = Array.BinarySearch(data, x);
			if (i >= 0)
			{
				for (; i < data.Length - 1 && data[i + 1] == data[i]; i++)
				{
				}
				return (double)(i + 1) / (double)data.Length;
			}
			return (double)(~i) / (double)data.Length;
		}

		public static double QuantileRank(double[] data, double x, RankDefinition definition = RankDefinition.Average)
		{
			if (x < data[0])
			{
				return 0.0;
			}
			if (x >= data[data.Length - 1])
			{
				return 1.0;
			}
			int i = Array.BinarySearch(data, x);
			if (i >= 0)
			{
				int num = i;
				while (num > 0 && data[num - 1] == data[num])
				{
					num--;
				}
				for (; i < data.Length - 1 && data[i + 1] == data[i]; i++)
				{
				}
				return definition switch
				{
					RankDefinition.EmpiricalCDF => (double)(i + 1) / (double)data.Length, 
					RankDefinition.Max => (double)i / (double)(data.Length - 1), 
					RankDefinition.Min => (double)num / (double)(data.Length - 1), 
					RankDefinition.Average => ((double)num / (double)(data.Length - 1) + (double)i / (double)(data.Length - 1)) / 2.0, 
					_ => throw new NotSupportedException(), 
				};
			}
			i = ~i;
			int num2 = i - 1;
			if (definition == RankDefinition.EmpiricalCDF)
			{
				return (double)(num2 + 1) / (double)data.Length;
			}
			double num3 = (double)num2 / (double)(data.Length - 1);
			double num4 = (double)i / (double)(data.Length - 1);
			return ((data[i] - x) * num3 + (x - data[num2]) * num4) / (data[i] - data[num2]);
		}

		public static double[] Ranks(double[] data, RankDefinition definition = RankDefinition.Average)
		{
			double[] array = new double[data.Length];
			if (definition == RankDefinition.First)
			{
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = i + 1;
				}
				return array;
			}
			int num = 0;
			for (int j = 1; j < data.Length; j++)
			{
				if (!(Math.Abs(data[j] - data[num]) <= 0.0))
				{
					if (j == num + 1)
					{
						array[num] = j;
					}
					else
					{
						RanksTies(array, num, j, definition);
					}
					num = j;
				}
			}
			RanksTies(array, num, data.Length, definition);
			return array;
		}

		private static void RanksTies(double[] ranks, int a, int b, RankDefinition definition)
		{
			double num = definition switch
			{
				RankDefinition.Average => (double)(b + a - 1) / 2.0 + 1.0, 
				RankDefinition.Min => a + 1, 
				RankDefinition.Max => b, 
				_ => throw new NotSupportedException(), 
			};
			for (int i = a; i < b; i++)
			{
				ranks[i] = num;
			}
		}

		public static float Minimum(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			return data[0];
		}

		public static float Maximum(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			return data[data.Length - 1];
		}

		public static float OrderStatistic(float[] data, int order)
		{
			if (order < 1 || order > data.Length)
			{
				return float.NaN;
			}
			return data[order - 1];
		}

		public static float Median(float[] data)
		{
			if (data.Length == 0)
			{
				return float.NaN;
			}
			int num = data.Length / 2;
			if (!data.Length.IsOdd())
			{
				return (data[num - 1] + data[num]) / 2f;
			}
			return data[num];
		}

		public static float Percentile(float[] data, int p)
		{
			return Quantile(data, (double)p / 100.0);
		}

		public static float LowerQuartile(float[] data)
		{
			return Quantile(data, 0.25);
		}

		public static float UpperQuartile(float[] data)
		{
			return Quantile(data, 0.75);
		}

		public static float InterquartileRange(float[] data)
		{
			return Quantile(data, 0.75) - Quantile(data, 0.25);
		}

		public static float[] FiveNumberSummary(float[] data)
		{
			if (data.Length != 0)
			{
				return new float[5]
				{
					data[0],
					Quantile(data, 0.25),
					Median(data),
					Quantile(data, 0.75),
					data[data.Length - 1]
				};
			}
			return new float[5]
			{
				float.NaN,
				float.NaN,
				float.NaN,
				float.NaN,
				float.NaN
			};
		}

		public static float Quantile(float[] data, double tau)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return float.NaN;
			}
			if (tau == 0.0 || data.Length == 1)
			{
				return data[0];
			}
			if (tau == 1.0)
			{
				return data[data.Length - 1];
			}
			double num = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
			int num2 = (int)num;
			if (num2 >= 1)
			{
				if (num2 < data.Length)
				{
					return (float)((double)data[num2 - 1] + (num - (double)num2) * (double)(data[num2] - data[num2 - 1]));
				}
				return data[data.Length - 1];
			}
			return data[0];
		}

		public static float QuantileCustom(float[] data, double tau, double a, double b, double c, double d)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return float.NaN;
			}
			double num = a + ((double)data.Length + b) * tau - 1.0;
			double num2 = Math.Truncate(num);
			double num3 = num - num2;
			if (Math.Abs(num3) < 1E-09)
			{
				return data[Math.Min(Math.Max((int)num2, 0), data.Length - 1)];
			}
			float num4 = data[Math.Max((int)Math.Floor(num), 0)];
			float num5 = data[Math.Min((int)Math.Ceiling(num), data.Length - 1)];
			return (float)((double)num4 + (double)(num5 - num4) * (c + d * num3));
		}

		public static float QuantileCustom(float[] data, double tau, QuantileDefinition definition)
		{
			if (tau < 0.0 || tau > 1.0 || data.Length == 0)
			{
				return float.NaN;
			}
			if (tau == 0.0 || data.Length == 1)
			{
				return data[0];
			}
			if (tau == 1.0)
			{
				return data[data.Length - 1];
			}
			switch (definition)
			{
			case QuantileDefinition.R1:
			{
				double num26 = (double)data.Length * tau + 0.5;
				return data[(int)Math.Ceiling(num26 - 0.5) - 1];
			}
			case QuantileDefinition.R2:
			{
				double num25 = (double)data.Length * tau + 0.5;
				return (data[(int)Math.Ceiling(num25 - 0.5) - 1] + data[(int)(num25 + 0.5) - 1]) * 0.5f;
			}
			case QuantileDefinition.R3:
			{
				double a = (double)data.Length * tau;
				return data[Math.Max((int)Math.Round(a) - 1, 0)];
			}
			case QuantileDefinition.R4:
			{
				double num21 = (double)data.Length * tau;
				int num22 = (int)num21;
				float num23 = data[Math.Max(num22 - 1, 0)];
				float num24 = data[Math.Min(num22, data.Length - 1)];
				return (float)((double)num23 + (num21 - (double)num22) * (double)(num24 - num23));
			}
			case QuantileDefinition.R5:
			{
				double num17 = (double)data.Length * tau + 0.5;
				int num18 = (int)num17;
				float num19 = data[Math.Max(num18 - 1, 0)];
				float num20 = data[Math.Min(num18, data.Length - 1)];
				return (float)((double)num19 + (num17 - (double)num18) * (double)(num20 - num19));
			}
			case QuantileDefinition.R6:
			{
				double num13 = (double)(data.Length + 1) * tau;
				int num14 = (int)num13;
				float num15 = data[Math.Max(num14 - 1, 0)];
				float num16 = data[Math.Min(num14, data.Length - 1)];
				return (float)((double)num15 + (num13 - (double)num14) * (double)(num16 - num15));
			}
			case QuantileDefinition.R7:
			{
				double num9 = (double)(data.Length - 1) * tau + 1.0;
				int num10 = (int)num9;
				float num11 = data[Math.Max(num10 - 1, 0)];
				float num12 = data[Math.Min(num10, data.Length - 1)];
				return (float)((double)num11 + (num9 - (double)num10) * (double)(num12 - num11));
			}
			case QuantileDefinition.R8:
			{
				double num5 = ((double)data.Length + 1.0 / 3.0) * tau + 1.0 / 3.0;
				int num6 = (int)num5;
				float num7 = data[Math.Max(num6 - 1, 0)];
				float num8 = data[Math.Min(num6, data.Length - 1)];
				return (float)((double)num7 + (num5 - (double)num6) * (double)(num8 - num7));
			}
			case QuantileDefinition.R9:
			{
				double num = ((double)data.Length + 0.25) * tau + 0.375;
				int num2 = (int)num;
				float num3 = data[Math.Max(num2 - 1, 0)];
				float num4 = data[Math.Min(num2, data.Length - 1)];
				return (float)((double)num3 + (num - (double)num2) * (double)(num4 - num3));
			}
			default:
				throw new NotSupportedException();
			}
		}

		public static double EmpiricalCDF(float[] data, float x)
		{
			if (x < data[0])
			{
				return 0.0;
			}
			if (x >= data[data.Length - 1])
			{
				return 1.0;
			}
			int i = Array.BinarySearch(data, x);
			if (i >= 0)
			{
				for (; i < data.Length - 1 && data[i + 1] == data[i]; i++)
				{
				}
				return (double)(i + 1) / (double)data.Length;
			}
			return (double)(~i) / (double)data.Length;
		}

		public static double QuantileRank(float[] data, float x, RankDefinition definition = RankDefinition.Average)
		{
			if (x < data[0])
			{
				return 0.0;
			}
			if (x >= data[data.Length - 1])
			{
				return 1.0;
			}
			int i = Array.BinarySearch(data, x);
			if (i >= 0)
			{
				int num = i;
				while (num > 0 && data[num - 1] == data[num])
				{
					num--;
				}
				for (; i < data.Length - 1 && data[i + 1] == data[i]; i++)
				{
				}
				return definition switch
				{
					RankDefinition.EmpiricalCDF => (double)(i + 1) / (double)data.Length, 
					RankDefinition.Max => (double)i / (double)(data.Length - 1), 
					RankDefinition.Min => (double)num / (double)(data.Length - 1), 
					RankDefinition.Average => ((double)num / (double)(data.Length - 1) + (double)i / (double)(data.Length - 1)) / 2.0, 
					_ => throw new NotSupportedException(), 
				};
			}
			i = ~i;
			int num2 = i - 1;
			if (definition == RankDefinition.EmpiricalCDF)
			{
				return (double)(num2 + 1) / (double)data.Length;
			}
			double num3 = (double)num2 / (double)(data.Length - 1);
			double num4 = (double)i / (double)(data.Length - 1);
			return ((double)(data[i] - x) * num3 + (double)(x - data[num2]) * num4) / (double)(data[i] - data[num2]);
		}

		public static double[] Ranks(float[] data, RankDefinition definition = RankDefinition.Average)
		{
			double[] array = new double[data.Length];
			if (definition == RankDefinition.First)
			{
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = i + 1;
				}
				return array;
			}
			int num = 0;
			for (int j = 1; j < data.Length; j++)
			{
				if (!((double)Math.Abs(data[j] - data[num]) <= 0.0))
				{
					if (j == num + 1)
					{
						array[num] = j;
					}
					else
					{
						RanksTies(array, num, j, definition);
					}
					num = j;
				}
			}
			RanksTies(array, num, data.Length, definition);
			return array;
		}
	}
	public static class Statistics
	{
		public static double Minimum(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.Minimum(data);
			}
			return ArrayStatistics.Minimum(data2);
		}

		public static float Minimum(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.Minimum(data);
			}
			return ArrayStatistics.Minimum(data2);
		}

		public static double Minimum(this IEnumerable<double?> data)
		{
			return StreamingStatistics.Minimum(from d in data
				where d.HasValue
				select d.Value);
		}

		public static double Maximum(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.Maximum(data);
			}
			return ArrayStatistics.Maximum(data2);
		}

		public static float Maximum(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.Maximum(data);
			}
			return ArrayStatistics.Maximum(data2);
		}

		public static double Maximum(this IEnumerable<double?> data)
		{
			return StreamingStatistics.Maximum(from d in data
				where d.HasValue
				select d.Value);
		}

		public static double MinimumAbsolute(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.MinimumAbsolute(data);
			}
			return ArrayStatistics.MinimumAbsolute(data2);
		}

		public static float MinimumAbsolute(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.MinimumAbsolute(data);
			}
			return ArrayStatistics.MinimumAbsolute(data2);
		}

		public static double MaximumAbsolute(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.MaximumAbsolute(data);
			}
			return ArrayStatistics.MaximumAbsolute(data2);
		}

		public static float MaximumAbsolute(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.MaximumAbsolute(data);
			}
			return ArrayStatistics.MaximumAbsolute(data2);
		}

		public static Complex MinimumMagnitudePhase(this IEnumerable<Complex> data)
		{
			if (!(data is Complex[] data2))
			{
				return StreamingStatistics.MinimumMagnitudePhase(data);
			}
			return ArrayStatistics.MinimumMagnitudePhase(data2);
		}

		public static Complex32 MinimumMagnitudePhase(this IEnumerable<Complex32> data)
		{
			if (!(data is Complex32[] data2))
			{
				return StreamingStatistics.MinimumMagnitudePhase(data);
			}
			return ArrayStatistics.MinimumMagnitudePhase(data2);
		}

		public static Complex MaximumMagnitudePhase(this IEnumerable<Complex> data)
		{
			if (!(data is Complex[] data2))
			{
				return StreamingStatistics.MaximumMagnitudePhase(data);
			}
			return ArrayStatistics.MaximumMagnitudePhase(data2);
		}

		public static Complex32 MaximumMagnitudePhase(this IEnumerable<Complex32> data)
		{
			if (!(data is Complex32[] data2))
			{
				return StreamingStatistics.MaximumMagnitudePhase(data);
			}
			return ArrayStatistics.MaximumMagnitudePhase(data2);
		}

		public static double Mean(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.Mean(data);
			}
			return ArrayStatistics.Mean(data2);
		}

		public static double Mean(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.Mean(data);
			}
			return ArrayStatistics.Mean(data2);
		}

		public static double Mean(this IEnumerable<double?> data)
		{
			return StreamingStatistics.Mean(from d in data
				where d.HasValue
				select d.Value);
		}

		public static double GeometricMean(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.GeometricMean(data);
			}
			return ArrayStatistics.GeometricMean(data2);
		}

		public static double GeometricMean(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.GeometricMean(data);
			}
			return ArrayStatistics.GeometricMean(data2);
		}

		public static double HarmonicMean(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.HarmonicMean(data);
			}
			return ArrayStatistics.HarmonicMean(data2);
		}

		public static double HarmonicMean(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.HarmonicMean(data);
			}
			return ArrayStatistics.HarmonicMean(data2);
		}

		public static double Variance(this IEnumerable<double> samples)
		{
			if (!(samples is double[] samples2))
			{
				return StreamingStatistics.Variance(samples);
			}
			return ArrayStatistics.Variance(samples2);
		}

		public static double Variance(this IEnumerable<float> samples)
		{
			if (!(samples is float[] samples2))
			{
				return StreamingStatistics.Variance(samples);
			}
			return ArrayStatistics.Variance(samples2);
		}

		public static double Variance(this IEnumerable<double?> samples)
		{
			return StreamingStatistics.Variance(from d in samples
				where d.HasValue
				select d.Value);
		}

		public static double PopulationVariance(this IEnumerable<double> population)
		{
			if (!(population is double[] population2))
			{
				return StreamingStatistics.PopulationVariance(population);
			}
			return ArrayStatistics.PopulationVariance(population2);
		}

		public static double PopulationVariance(this IEnumerable<float> population)
		{
			if (!(population is float[] population2))
			{
				return StreamingStatistics.PopulationVariance(population);
			}
			return ArrayStatistics.PopulationVariance(population2);
		}

		public static double PopulationVariance(this IEnumerable<double?> population)
		{
			return StreamingStatistics.PopulationVariance(from d in population
				where d.HasValue
				select d.Value);
		}

		public static double StandardDeviation(this IEnumerable<double> samples)
		{
			if (!(samples is double[] samples2))
			{
				return StreamingStatistics.StandardDeviation(samples);
			}
			return ArrayStatistics.StandardDeviation(samples2);
		}

		public static double StandardDeviation(this IEnumerable<float> samples)
		{
			if (!(samples is float[] samples2))
			{
				return StreamingStatistics.StandardDeviation(samples);
			}
			return ArrayStatistics.StandardDeviation(samples2);
		}

		public static double StandardDeviation(this IEnumerable<double?> samples)
		{
			return StreamingStatistics.StandardDeviation(from d in samples
				where d.HasValue
				select d.Value);
		}

		public static double PopulationStandardDeviation(this IEnumerable<double> population)
		{
			if (!(population is double[] population2))
			{
				return StreamingStatistics.PopulationStandardDeviation(population);
			}
			return ArrayStatistics.PopulationStandardDeviation(population2);
		}

		public static double PopulationStandardDeviation(this IEnumerable<float> population)
		{
			if (!(population is float[] population2))
			{
				return StreamingStatistics.PopulationStandardDeviation(population);
			}
			return ArrayStatistics.PopulationStandardDeviation(population2);
		}

		public static double PopulationStandardDeviation(this IEnumerable<double?> population)
		{
			return StreamingStatistics.PopulationStandardDeviation(from d in population
				where d.HasValue
				select d.Value);
		}

		public static double Skewness(this IEnumerable<double> samples)
		{
			return new RunningStatistics(samples).Skewness;
		}

		public static double Skewness(this IEnumerable<double?> samples)
		{
			return new RunningStatistics(from d in samples
				where d.HasValue
				select d.Value).Skewness;
		}

		public static double PopulationSkewness(this IEnumerable<double> population)
		{
			return new RunningStatistics(population).PopulationSkewness;
		}

		public static double PopulationSkewness(this IEnumerable<double?> population)
		{
			return new RunningStatistics(from d in population
				where d.HasValue
				select d.Value).PopulationSkewness;
		}

		public static double Kurtosis(this IEnumerable<double> samples)
		{
			return new RunningStatistics(samples).Kurtosis;
		}

		public static double Kurtosis(this IEnumerable<double?> samples)
		{
			return new RunningStatistics(from d in samples
				where d.HasValue
				select d.Value).Kurtosis;
		}

		public static double PopulationKurtosis(this IEnumerable<double> population)
		{
			return new RunningStatistics(population).PopulationKurtosis;
		}

		public static double PopulationKurtosis(this IEnumerable<double?> population)
		{
			return new RunningStatistics(from d in population
				where d.HasValue
				select d.Value).PopulationKurtosis;
		}

		public static Tuple<double, double> MeanVariance(this IEnumerable<double> samples)
		{
			if (!(samples is double[] samples2))
			{
				return StreamingStatistics.MeanVariance(samples);
			}
			return ArrayStatistics.MeanVariance(samples2);
		}

		public static Tuple<double, double> MeanVariance(this IEnumerable<float> samples)
		{
			if (!(samples is float[] samples2))
			{
				return StreamingStatistics.MeanVariance(samples);
			}
			return ArrayStatistics.MeanVariance(samples2);
		}

		public static Tuple<double, double> MeanStandardDeviation(this IEnumerable<double> samples)
		{
			if (!(samples is double[] samples2))
			{
				return StreamingStatistics.MeanStandardDeviation(samples);
			}
			return ArrayStatistics.MeanStandardDeviation(samples2);
		}

		public static Tuple<double, double> MeanStandardDeviation(this IEnumerable<float> samples)
		{
			if (!(samples is float[] samples2))
			{
				return StreamingStatistics.MeanStandardDeviation(samples);
			}
			return ArrayStatistics.MeanStandardDeviation(samples2);
		}

		public static Tuple<double, double> SkewnessKurtosis(this IEnumerable<double> samples)
		{
			RunningStatistics runningStatistics = new RunningStatistics(samples);
			return new Tuple<double, double>(runningStatistics.Skewness, runningStatistics.Kurtosis);
		}

		public static Tuple<double, double> PopulationSkewnessKurtosis(this IEnumerable<double> population)
		{
			RunningStatistics runningStatistics = new RunningStatistics(population);
			return new Tuple<double, double>(runningStatistics.PopulationSkewness, runningStatistics.PopulationKurtosis);
		}

		public static double Covariance(this IEnumerable<double> samples1, IEnumerable<double> samples2)
		{
			if (!(samples1 is double[] samples3) || !(samples2 is double[] samples4))
			{
				return StreamingStatistics.Covariance(samples1, samples2);
			}
			return ArrayStatistics.Covariance(samples3, samples4);
		}

		public static double Covariance(this IEnumerable<float> samples1, IEnumerable<float> samples2)
		{
			if (!(samples1 is float[] samples3) || !(samples2 is float[] samples4))
			{
				return StreamingStatistics.Covariance(samples1, samples2);
			}
			return ArrayStatistics.Covariance(samples3, samples4);
		}

		public static double Covariance(this IEnumerable<double?> samples1, IEnumerable<double?> samples2)
		{
			return StreamingStatistics.Covariance(from d in samples1
				where d.HasValue
				select d.Value, from d in samples2
				where d.HasValue
				select d.Value);
		}

		public static double PopulationCovariance(this IEnumerable<double> population1, IEnumerable<double> population2)
		{
			if (!(population1 is double[] population3) || !(population2 is double[] population4))
			{
				return StreamingStatistics.PopulationCovariance(population1, population2);
			}
			return ArrayStatistics.PopulationCovariance(population3, population4);
		}

		public static double PopulationCovariance(this IEnumerable<float> population1, IEnumerable<float> population2)
		{
			if (!(population1 is float[] population3) || !(population2 is float[] population4))
			{
				return StreamingStatistics.PopulationCovariance(population1, population2);
			}
			return ArrayStatistics.PopulationCovariance(population3, population4);
		}

		public static double PopulationCovariance(this IEnumerable<double?> population1, IEnumerable<double?> population2)
		{
			return StreamingStatistics.PopulationCovariance(from d in population1
				where d.HasValue
				select d.Value, from d in population2
				where d.HasValue
				select d.Value);
		}

		public static double RootMeanSquare(this IEnumerable<double> data)
		{
			if (!(data is double[] data2))
			{
				return StreamingStatistics.RootMeanSquare(data);
			}
			return ArrayStatistics.RootMeanSquare(data2);
		}

		public static double RootMeanSquare(this IEnumerable<float> data)
		{
			if (!(data is float[] data2))
			{
				return StreamingStatistics.RootMeanSquare(data);
			}
			return ArrayStatistics.RootMeanSquare(data2);
		}

		public static double RootMeanSquare(this IEnumerable<double?> data)
		{
			return StreamingStatistics.RootMeanSquare(from d in data
				where d.HasValue
				select d.Value);
		}

		public static double Median(this IEnumerable<double> data)
		{
			return ArrayStatistics.MedianInplace(data.ToArray());
		}

		public static float Median(this IEnumerable<float> data)
		{
			return ArrayStatistics.MedianInplace(data.ToArray());
		}

		public static double Median(this IEnumerable<double?> data)
		{
			return ArrayStatistics.MedianInplace((from d in data
				where d.HasValue
				select d.Value).ToArray());
		}

		public static double Quantile(this IEnumerable<double> data, double tau)
		{
			return ArrayStatistics.QuantileInplace(data.ToArray(), tau);
		}

		public static float Quantile(this IEnumerable<float> data, double tau)
		{
			return ArrayStatistics.QuantileInplace(data.ToArray(), tau);
		}

		public static double Quantile(this IEnumerable<double?> data, double tau)
		{
			return ArrayStatistics.QuantileInplace((from d in data
				where d.HasValue
				select d.Value).ToArray(), tau);
		}

		public static Func<double, double> QuantileFunc(this IEnumerable<double> data)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (double tau) => SortedArrayStatistics.Quantile(array, tau);
		}

		public static Func<float, float> QuantileFunc(this IEnumerable<float> data)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (float tau) => SortedArrayStatistics.Quantile(array, tau);
		}

		public static Func<double, double> QuantileFunc(this IEnumerable<double?> data)
		{
			double[] array = (from d in data
				where d.HasValue
				select d.Value).ToArray();
			Array.Sort(array);
			return (double tau) => SortedArrayStatistics.Quantile(array, tau);
		}

		public static double QuantileCustom(this IEnumerable<double> data, double tau, QuantileDefinition definition)
		{
			return ArrayStatistics.QuantileCustomInplace(data.ToArray(), tau, definition);
		}

		public static float QuantileCustom(this IEnumerable<float> data, double tau, QuantileDefinition definition)
		{
			return ArrayStatistics.QuantileCustomInplace(data.ToArray(), tau, definition);
		}

		public static double QuantileCustom(this IEnumerable<double?> data, double tau, QuantileDefinition definition)
		{
			return ArrayStatistics.QuantileCustomInplace((from d in data
				where d.HasValue
				select d.Value).ToArray(), tau, definition);
		}

		public static Func<double, double> QuantileCustomFunc(this IEnumerable<double> data, QuantileDefinition definition)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (double tau) => SortedArrayStatistics.QuantileCustom(array, tau, definition);
		}

		public static Func<float, float> QuantileCustomFunc(this IEnumerable<float> data, QuantileDefinition definition)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (float tau) => SortedArrayStatistics.QuantileCustom(array, tau, definition);
		}

		public static Func<double, double> QuantileCustomFunc(this IEnumerable<double?> data, QuantileDefinition definition)
		{
			double[] array = (from d in data
				where d.HasValue
				select d.Value).ToArray();
			Array.Sort(array);
			return (double tau) => SortedArrayStatistics.QuantileCustom(array, tau, definition);
		}

		public static double Percentile(this IEnumerable<double> data, int p)
		{
			return ArrayStatistics.PercentileInplace(data.ToArray(), p);
		}

		public static float Percentile(this IEnumerable<float> data, int p)
		{
			return ArrayStatistics.PercentileInplace(data.ToArray(), p);
		}

		public static double Percentile(this IEnumerable<double?> data, int p)
		{
			return ArrayStatistics.PercentileInplace((from d in data
				where d.HasValue
				select d.Value).ToArray(), p);
		}

		public static Func<int, double> PercentileFunc(this IEnumerable<double> data)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (int p) => SortedArrayStatistics.Percentile(array, p);
		}

		public static Func<int, float> PercentileFunc(this IEnumerable<float> data)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (int p) => SortedArrayStatistics.Percentile(array, p);
		}

		public static Func<int, double> PercentileFunc(this IEnumerable<double?> data)
		{
			double[] array = (from d in data
				where d.HasValue
				select d.Value).ToArray();
			Array.Sort(array);
			return (int p) => SortedArrayStatistics.Percentile(array, p);
		}

		public static double LowerQuartile(this IEnumerable<double> data)
		{
			return ArrayStatistics.LowerQuartileInplace(data.ToArray());
		}

		public static float LowerQuartile(this IEnumerable<float> data)
		{
			return ArrayStatistics.LowerQuartileInplace(data.ToArray());
		}

		public static double LowerQuartile(this IEnumerable<double?> data)
		{
			return ArrayStatistics.LowerQuartileInplace((from d in data
				where d.HasValue
				select d.Value).ToArray());
		}

		public static double UpperQuartile(this IEnumerable<double> data)
		{
			return ArrayStatistics.UpperQuartileInplace(data.ToArray());
		}

		public static float UpperQuartile(this IEnumerable<float> data)
		{
			return ArrayStatistics.UpperQuartileInplace(data.ToArray());
		}

		public static double UpperQuartile(this IEnumerable<double?> data)
		{
			return ArrayStatistics.UpperQuartileInplace((from d in data
				where d.HasValue
				select d.Value).ToArray());
		}

		public static double InterquartileRange(this IEnumerable<double> data)
		{
			return ArrayStatistics.InterquartileRangeInplace(data.ToArray());
		}

		public static float InterquartileRange(this IEnumerable<float> data)
		{
			return ArrayStatistics.InterquartileRangeInplace(data.ToArray());
		}

		public static double InterquartileRange(this IEnumerable<double?> data)
		{
			return ArrayStatistics.InterquartileRangeInplace((from d in data
				where d.HasValue
				select d.Value).ToArray());
		}

		public static double[] FiveNumberSummary(this IEnumerable<double> data)
		{
			return ArrayStatistics.FiveNumberSummaryInplace(data.ToArray());
		}

		public static float[] FiveNumberSummary(this IEnumerable<float> data)
		{
			return ArrayStatistics.FiveNumberSummaryInplace(data.ToArray());
		}

		public static double[] FiveNumberSummary(this IEnumerable<double?> data)
		{
			return ArrayStatistics.FiveNumberSummaryInplace((from d in data
				where d.HasValue
				select d.Value).ToArray());
		}

		public static double OrderStatistic(IEnumerable<double> data, int order)
		{
			return ArrayStatistics.OrderStatisticInplace(data.ToArray(), order);
		}

		public static float OrderStatistic(IEnumerable<float> data, int order)
		{
			return ArrayStatistics.OrderStatisticInplace(data.ToArray(), order);
		}

		public static Func<int, double> OrderStatisticFunc(IEnumerable<double> data)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (int order) => SortedArrayStatistics.OrderStatistic(array, order);
		}

		public static Func<int, float> OrderStatisticFunc(IEnumerable<float> data)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (int order) => SortedArrayStatistics.OrderStatistic(array, order);
		}

		public static double[] Ranks(this IEnumerable<double> data, RankDefinition definition = RankDefinition.Average)
		{
			return ArrayStatistics.RanksInplace(data.ToArray(), definition);
		}

		public static float[] Ranks(this IEnumerable<float> data, RankDefinition definition = RankDefinition.Average)
		{
			return ArrayStatistics.RanksInplace(data.ToArray(), definition);
		}

		public static double[] Ranks(this IEnumerable<double?> data, RankDefinition definition = RankDefinition.Average)
		{
			return (from d in data
				where d.HasValue
				select d.Value).Ranks(definition);
		}

		public static double QuantileRank(this IEnumerable<double> data, double x, RankDefinition definition = RankDefinition.Average)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return SortedArrayStatistics.QuantileRank(array, x, definition);
		}

		public static double QuantileRank(this IEnumerable<float> data, float x, RankDefinition definition = RankDefinition.Average)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return SortedArrayStatistics.QuantileRank(array, x, definition);
		}

		public static double QuantileRank(this IEnumerable<double?> data, double x, RankDefinition definition = RankDefinition.Average)
		{
			return (from d in data
				where d.HasValue
				select d.Value).QuantileRank(x, definition);
		}

		public static Func<double, double> QuantileRankFunc(this IEnumerable<double> data, RankDefinition definition = RankDefinition.Average)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (double x) => SortedArrayStatistics.QuantileRank(array, x, definition);
		}

		public static Func<float, double> QuantileRankFunc(this IEnumerable<float> data, RankDefinition definition = RankDefinition.Average)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (float x) => SortedArrayStatistics.QuantileRank(array, x, definition);
		}

		public static Func<double, double> QuantileRankFunc(this IEnumerable<double?> data, RankDefinition definition = RankDefinition.Average)
		{
			return (from d in data
				where d.HasValue
				select d.Value).QuantileRankFunc(definition);
		}

		public static double EmpiricalCDF(this IEnumerable<double> data, double x)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return SortedArrayStatistics.EmpiricalCDF(array, x);
		}

		public static double EmpiricalCDF(this IEnumerable<float> data, float x)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return SortedArrayStatistics.EmpiricalCDF(array, x);
		}

		public static double EmpiricalCDF(this IEnumerable<double?> data, double x)
		{
			return (from d in data
				where d.HasValue
				select d.Value).EmpiricalCDF(x);
		}

		public static Func<double, double> EmpiricalCDFFunc(this IEnumerable<double> data)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (double x) => SortedArrayStatistics.EmpiricalCDF(array, x);
		}

		public static Func<float, double> EmpiricalCDFFunc(this IEnumerable<float> data)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (float x) => SortedArrayStatistics.EmpiricalCDF(array, x);
		}

		public static Func<double, double> EmpiricalCDFFunc(this IEnumerable<double?> data)
		{
			return (from d in data
				where d.HasValue
				select d.Value).EmpiricalCDFFunc();
		}

		public static double EmpiricalInvCDF(this IEnumerable<double> data, double tau)
		{
			return ArrayStatistics.QuantileCustomInplace(data.ToArray(), tau, QuantileDefinition.R1);
		}

		public static float EmpiricalInvCDF(this IEnumerable<float> data, double tau)
		{
			return ArrayStatistics.QuantileCustomInplace(data.ToArray(), tau, QuantileDefinition.R1);
		}

		public static double EmpiricalInvCDF(this IEnumerable<double?> data, double tau)
		{
			return (from d in data
				where d.HasValue
				select d.Value).EmpiricalInvCDF(tau);
		}

		public static Func<double, double> EmpiricalInvCDFFunc(this IEnumerable<double> data)
		{
			double[] array = data.ToArray();
			Array.Sort(array);
			return (double tau) => SortedArrayStatistics.QuantileCustom(array, tau, QuantileDefinition.R1);
		}

		public static Func<double, float> EmpiricalInvCDFFunc(this IEnumerable<float> data)
		{
			float[] array = data.ToArray();
			Array.Sort(array);
			return (double tau) => SortedArrayStatistics.QuantileCustom(array, tau, QuantileDefinition.R1);
		}

		public static Func<double, double> EmpiricalInvCDFFunc(this IEnumerable<double?> data)
		{
			return (from d in data
				where d.HasValue
				select d.Value).EmpiricalInvCDFFunc();
		}

		public static double Entropy(IEnumerable<double> data)
		{
			return StreamingStatistics.Entropy(data);
		}

		public static double Entropy(IEnumerable<double?> data)
		{
			return StreamingStatistics.Entropy(from d in data
				where d.HasValue
				select d.Value);
		}

		public static IEnumerable<double> MovingAverage(this IEnumerable<double> samples, int windowSize)
		{
			MovingStatistics movingStatistics = new MovingStatistics(windowSize);
			return samples.Select(delegate(double sample)
			{
				movingStatistics.Push(sample);
				return movingStatistics.Mean;
			});
		}
	}
	public static class StreamingStatistics
	{
		public static double Minimum(IEnumerable<double> stream)
		{
			double num = double.PositiveInfinity;
			bool flag = false;
			foreach (double item in stream)
			{
				if (item < num || double.IsNaN(item))
				{
					num = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return double.NaN;
			}
			return num;
		}

		public static float Minimum(IEnumerable<float> stream)
		{
			float num = float.PositiveInfinity;
			bool flag = false;
			foreach (float item in stream)
			{
				if (item < num || float.IsNaN(item))
				{
					num = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return float.NaN;
			}
			return num;
		}

		public static double Maximum(IEnumerable<double> stream)
		{
			double num = double.NegativeInfinity;
			bool flag = false;
			foreach (double item in stream)
			{
				if (item > num || double.IsNaN(item))
				{
					num = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return double.NaN;
			}
			return num;
		}

		public static float Maximum(IEnumerable<float> stream)
		{
			float num = float.NegativeInfinity;
			bool flag = false;
			foreach (float item in stream)
			{
				if (item > num || float.IsNaN(item))
				{
					num = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return float.NaN;
			}
			return num;
		}

		public static double MinimumAbsolute(IEnumerable<double> stream)
		{
			double num = double.PositiveInfinity;
			bool flag = false;
			foreach (double item in stream)
			{
				if (Math.Abs(item) < num || double.IsNaN(item))
				{
					num = Math.Abs(item);
				}
				flag = true;
			}
			if (!flag)
			{
				return double.NaN;
			}
			return num;
		}

		public static float MinimumAbsolute(IEnumerable<float> stream)
		{
			float num = float.PositiveInfinity;
			bool flag = false;
			foreach (float item in stream)
			{
				if (Math.Abs(item) < num || float.IsNaN(item))
				{
					num = Math.Abs(item);
				}
				flag = true;
			}
			if (!flag)
			{
				return float.NaN;
			}
			return num;
		}

		public static double MaximumAbsolute(IEnumerable<double> stream)
		{
			double num = 0.0;
			bool flag = false;
			foreach (double item in stream)
			{
				if (Math.Abs(item) > num || double.IsNaN(item))
				{
					num = Math.Abs(item);
				}
				flag = true;
			}
			if (!flag)
			{
				return double.NaN;
			}
			return num;
		}

		public static float MaximumAbsolute(IEnumerable<float> stream)
		{
			float num = 0f;
			bool flag = false;
			foreach (float item in stream)
			{
				if (Math.Abs(item) > num || float.IsNaN(item))
				{
					num = Math.Abs(item);
				}
				flag = true;
			}
			if (!flag)
			{
				return float.NaN;
			}
			return num;
		}

		public static Complex MinimumMagnitudePhase(IEnumerable<Complex> stream)
		{
			double num = double.PositiveInfinity;
			Complex result = new Complex(double.PositiveInfinity, double.PositiveInfinity);
			bool flag = false;
			foreach (Complex item in stream)
			{
				double magnitude = item.Magnitude;
				if (double.IsNaN(magnitude))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (magnitude < num || (magnitude == num && item.Phase < result.Phase))
				{
					num = magnitude;
					result = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return new Complex(double.NaN, double.NaN);
			}
			return result;
		}

		public static Complex32 MinimumMagnitudePhase(IEnumerable<Complex32> stream)
		{
			float num = float.PositiveInfinity;
			Complex32 result = new Complex32(float.PositiveInfinity, float.PositiveInfinity);
			bool flag = false;
			foreach (Complex32 item in stream)
			{
				float magnitude = item.Magnitude;
				if (float.IsNaN(magnitude))
				{
					return new Complex32(float.NaN, float.NaN);
				}
				if (magnitude < num || (magnitude == num && item.Phase < result.Phase))
				{
					num = magnitude;
					result = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return new Complex32(float.NaN, float.NaN);
			}
			return result;
		}

		public static Complex MaximumMagnitudePhase(IEnumerable<Complex> stream)
		{
			double num = 0.0;
			Complex result = Complex.Zero;
			bool flag = false;
			foreach (Complex item in stream)
			{
				double magnitude = item.Magnitude;
				if (double.IsNaN(magnitude))
				{
					return new Complex(double.NaN, double.NaN);
				}
				if (magnitude > num || (magnitude == num && item.Phase > result.Phase))
				{
					num = magnitude;
					result = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return new Complex(double.NaN, double.NaN);
			}
			return result;
		}

		public static Complex32 MaximumMagnitudePhase(IEnumerable<Complex32> stream)
		{
			float num = 0f;
			Complex32 result = Complex32.Zero;
			bool flag = false;
			foreach (Complex32 item in stream)
			{
				float magnitude = item.Magnitude;
				if (float.IsNaN(magnitude))
				{
					return new Complex32(float.NaN, float.NaN);
				}
				if (magnitude > num || (magnitude == num && item.Phase > result.Phase))
				{
					num = magnitude;
					result = item;
				}
				flag = true;
			}
			if (!flag)
			{
				return new Complex32(float.NaN, float.NaN);
			}
			return result;
		}

		public static double Mean(IEnumerable<double> stream)
		{
			double num = 0.0;
			ulong num2 = 0uL;
			bool flag = false;
			foreach (double item in stream)
			{
				num += (item - num) / (double)(++num2);
				flag = true;
			}
			if (!flag)
			{
				return double.NaN;
			}
			return num;
		}

		public static double Mean(IEnumerable<float> stream)
		{
			return Mean(stream.Select((Func<float, double>)((float x) => x)));
		}

		public static double GeometricMean(IEnumerable<double> stream)
		{
			ulong num = 0uL;
			double num2 = 0.0;
			foreach (double item in stream)
			{
				num2 += Math.Log(item);
				num++;
			}
			if (num == 0)
			{
				return double.NaN;
			}
			return Math.Exp(num2 / (double)num);
		}

		public static double GeometricMean(IEnumerable<float> stream)
		{
			return GeometricMean(stream.Select((Func<float, double>)((float x) => x)));
		}

		public static double HarmonicMean(IEnumerable<double> stream)
		{
			ulong num = 0uL;
			double num2 = 0.0;
			foreach (double item in stream)
			{
				num2 += 1.0 / item;
				num++;
			}
			if (num == 0)
			{
				return double.NaN;
			}
			return (double)num / num2;
		}

		public static double HarmonicMean(IEnumerable<float> stream)
		{
			return HarmonicMean(stream.Select((Func<float, double>)((float x) => x)));
		}

		public static double Variance(IEnumerable<double> samples)
		{
			double num = 0.0;
			double num2 = 0.0;
			ulong num3 = 0uL;
			using (IEnumerator<double> enumerator = samples.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					num3++;
					num2 = enumerator.Current;
				}
				while (enumerator.MoveNext())
				{
					num3++;
					double current = enumerator.Current;
					num2 += current;
					double num4 = (double)num3 * current - num2;
					num += num4 * num4 / (double)(num3 * (num3 - 1));
				}
			}
			if (num3 <= 1)
			{
				return double.NaN;
			}
			return num / (double)(num3 - 1);
		}

		public static double Variance(IEnumerable<float> samples)
		{
			return Variance(samples.Select((Func<float, double>)((float x) => x)));
		}

		public static double PopulationVariance(IEnumerable<double> population)
		{
			double num = 0.0;
			double num2 = 0.0;
			ulong num3 = 0uL;
			using (IEnumerator<double> enumerator = population.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					num3++;
					num2 = enumerator.Current;
				}
				while (enumerator.MoveNext())
				{
					num3++;
					double current = enumerator.Current;
					num2 += current;
					double num4 = (double)num3 * current - num2;
					num += num4 * num4 / (double)(num3 * (num3 - 1));
				}
			}
			return num / (double)num3;
		}

		public static double PopulationVariance(IEnumerable<float> population)
		{
			return PopulationVariance(population.Select((Func<float, double>)((float x) => x)));
		}

		public static double StandardDeviation(IEnumerable<double> samples)
		{
			return Math.Sqrt(Variance(samples));
		}

		public static double StandardDeviation(IEnumerable<float> samples)
		{
			return Math.Sqrt(Variance(samples));
		}

		public static double PopulationStandardDeviation(IEnumerable<double> population)
		{
			return Math.Sqrt(PopulationVariance(population));
		}

		public static double PopulationStandardDeviation(IEnumerable<float> population)
		{
			return Math.Sqrt(PopulationVariance(population));
		}

		public static Tuple<double, double> MeanVariance(IEnumerable<double> samples)
		{
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			ulong num4 = 0uL;
			using (IEnumerator<double> enumerator = samples.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					num4++;
					num3 = (num = enumerator.Current);
				}
				while (enumerator.MoveNext())
				{
					num4++;
					double current = enumerator.Current;
					num3 += current;
					double num5 = (double)num4 * current - num3;
					num2 += num5 * num5 / (double)(num4 * (num4 - 1));
					num += (current - num) / (double)num4;
				}
			}
			return new Tuple<double, double>((num4 != 0) ? num : double.NaN, (num4 > 1) ? (num2 / (double)(num4 - 1)) : double.NaN);
		}

		public static Tuple<double, double> MeanVariance(IEnumerable<float> samples)
		{
			return MeanVariance(samples.Select((Func<float, double>)((float x) => x)));
		}

		public static Tuple<double, double> MeanStandardDeviation(IEnumerable<double> samples)
		{
			Tuple<double, double> tuple = MeanVariance(samples);
			return new Tuple<double, double>(tuple.Item1, Math.Sqrt(tuple.Item2));
		}

		public static Tuple<double, double> MeanStandardDeviation(IEnumerable<float> samples)
		{
			return MeanStandardDeviation(samples.Select((Func<float, double>)((float x) => x)));
		}

		public static double Covariance(IEnumerable<double> samples1, IEnumerable<double> samples2)
		{
			int num = 0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			using (IEnumerator<double> enumerator = samples1.GetEnumerator())
			{
				using IEnumerator<double> enumerator2 = samples2.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (!enumerator2.MoveNext())
					{
						throw new ArgumentException("All vectors must have the same dimensionality.");
					}
					double num5 = num3;
					num++;
					num2 += (enumerator.Current - num2) / (double)num;
					num3 += (enumerator2.Current - num3) / (double)num;
					num4 += (enumerator.Current - num2) * (enumerator2.Current - num5);
				}
				if (enumerator2.MoveNext())
				{
					throw new ArgumentException("All vectors must have the same dimensionality.");
				}
			}
			if (num <= 1)
			{
				return double.NaN;
			}
			return num4 / (double)(num - 1);
		}

		public static double Covariance(IEnumerable<float> samples1, IEnumerable<float> samples2)
		{
			return Covariance(samples1.Select((Func<float, double>)((float x) => x)), samples2.Select((Func<float, double>)((float x) => x)));
		}

		public static double PopulationCovariance(IEnumerable<double> population1, IEnumerable<double> population2)
		{
			int num = 0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			using (IEnumerator<double> enumerator = population1.GetEnumerator())
			{
				using IEnumerator<double> enumerator2 = population2.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (!enumerator2.MoveNext())
					{
						throw new ArgumentException("All vectors must have the same dimensionality.");
					}
					double num5 = num3;
					num++;
					num2 += (enumerator.Current - num2) / (double)num;
					num3 += (enumerator2.Current - num3) / (double)num;
					num4 += (enumerator.Current - num2) * (enumerator2.Current - num5);
				}
				if (enumerator2.MoveNext())
				{
					throw new ArgumentException("All vectors must have the same dimensionality.");
				}
			}
			return num4 / (double)num;
		}

		public static double PopulationCovariance(IEnumerable<float> population1, IEnumerable<float> population2)
		{
			return PopulationCovariance(population1.Select((Func<float, double>)((float x) => x)), population2.Select((Func<float, double>)((float x) => x)));
		}

		public static double RootMeanSquare(IEnumerable<double> stream)
		{
			double num = 0.0;
			ulong num2 = 0uL;
			bool flag = false;
			foreach (double item in stream)
			{
				num += (item * item - num) / (double)(++num2);
				flag = true;
			}
			if (!flag)
			{
				return double.NaN;
			}
			return Math.Sqrt(num);
		}

		public static double RootMeanSquare(IEnumerable<float> stream)
		{
			return RootMeanSquare(stream.Select((Func<float, double>)((float x) => x)));
		}

		public static double Entropy(IEnumerable<double> stream)
		{
			Dictionary<double, double> dictionary = new Dictionary<double, double>();
			int num = 0;
			foreach (double item in stream)
			{
				if (double.IsNaN(item))
				{
					return double.NaN;
				}
				if (dictionary.TryGetValue(item, out var value))
				{
					value = (dictionary[item] = value + 1.0);
				}
				else
				{
					dictionary.Add(item, 1.0);
				}
				num++;
			}
			double num3 = 0.0;
			foreach (KeyValuePair<double, double> item2 in dictionary)
			{
				double num4 = item2.Value / (double)num;
				num3 += num4 * Math.Log(num4, 2.0);
			}
			return 0.0 - num3;
		}
	}
}
namespace MathNet.Numerics.Statistics.Mcmc
{
	public class HybridMC : HybridMCGeneric<double[]>
	{
		private readonly int _length;

		private Normal _pDistribution;

		private double[] _mpSdv;

		public double[] MomentumStdDev
		{
			get
			{
				return (double[])_mpSdv.Clone();
			}
			set
			{
				CheckVariance(value);
				_mpSdv = (double[])value.Clone();
			}
		}

		public HybridMC(double[] x0, DensityLn<double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval = 0)
			: this(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, new double[x0.Length], SystemRandomSource.Default, Grad)
		{
			for (int i = 0; i < _length; i++)
			{
				_mpSdv[i] = 1.0;
			}
		}

		public HybridMC(double[] x0, DensityLn<double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double[] pSdv)
			: this(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, pSdv, SystemRandomSource.Default)
		{
		}

		public HybridMC(double[] x0, DensityLn<double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double[] pSdv, System.Random randomSource)
			: this(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, pSdv, randomSource, Grad)
		{
		}

		public HybridMC(double[] x0, DensityLn<double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double[] pSdv, System.Random randomSource, DiffMethod diff)
			: base(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, randomSource, diff)
		{
			_length = x0.Length;
			MomentumStdDev = pSdv;
			Initialize(x0);
			Burn(base.BurnInterval);
		}

		private void Initialize(double[] x0)
		{
			Current = (double[])x0.Clone();
			_pDistribution = new Normal(0.0, 1.0, base.RandomSource);
		}

		private void CheckVariance(double[] pSdv)
		{
			if (pSdv == null)
			{
				throw new ArgumentNullException("pSdv", "Standard deviation cannot be null.");
			}
			if (pSdv.Length != _length)
			{
				throw new ArgumentOutOfRangeException("pSdv", "Standard deviation of momentum must have same length as sample.");
			}
			if (pSdv.Any((double sdv) => sdv < 0.0))
			{
				throw new ArgumentOutOfRangeException("pSdv", "Standard deviation must be positive.");
			}
		}

		protected override double[] Copy(double[] source)
		{
			double[] array = new double[_length];
			Array.Copy(source, 0, array, 0, _length);
			return array;
		}

		protected override double[] Create()
		{
			return new double[_length];
		}

		protected override void DoAdd(ref double[] first, double factor, double[] second)
		{
			for (int i = 0; i < _length; i++)
			{
				first[i] += factor * second[i];
			}
		}

		protected override void DoSubtract(ref double[] first, double factor, double[] second)
		{
			for (int i = 0; i < _length; i++)
			{
				first[i] -= factor * second[i];
			}
		}

		protected override double DoProduct(double[] first, double[] second)
		{
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += first[i] * second[i];
			}
			return num;
		}

		protected override void RandomizeMomentum(ref double[] p)
		{
			for (int i = 0; i < _length; i++)
			{
				p[i] = _mpSdv[i] * _pDistribution.Sample();
			}
		}

		private static double[] Grad(DensityLn<double[]> function, double[] x)
		{
			int num = x.Length;
			double[] array = new double[num];
			double[] array2 = new double[num];
			double[] array3 = new double[num];
			Array.Copy(x, 0, array2, 0, num);
			Array.Copy(x, 0, array3, 0, num);
			for (int i = 0; i < num; i++)
			{
				double num2 = x[i];
				double num3 = Math.Max(0.001, 1E-06 * num2);
				array2[i] += num3;
				array3[i] -= num3;
				array[i] = (function(array2) - function(array3)) / (2.0 * num3);
				array2[i] = num2;
				array3[i] = num2;
			}
			return array;
		}
	}
	public abstract class HybridMCGeneric<T> : McmcSampler<T>
	{
		public delegate T DiffMethod(DensityLn<T> f, T x);

		private readonly DensityLn<T> _energy;

		protected T Current;

		private int _burnInterval;

		private double _stepSize;

		private int _frogLeapSteps;

		private readonly DiffMethod _diff;

		public int BurnInterval
		{
			get
			{
				return _burnInterval;
			}
			set
			{
				_burnInterval = SetNonNegative(value);
			}
		}

		public int FrogLeapSteps
		{
			get
			{
				return _frogLeapSteps;
			}
			set
			{
				_frogLeapSteps = SetPositive(value);
			}
		}

		public double StepSize
		{
			get
			{
				return _stepSize;
			}
			set
			{
				_stepSize = SetPositive(value);
			}
		}

		protected HybridMCGeneric(T x0, DensityLn<T> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, System.Random randomSource, DiffMethod diff)
		{
			_energy = (T x) => 0.0 - pdfLnP(x);
			FrogLeapSteps = frogLeapSteps;
			StepSize = stepSize;
			BurnInterval = burnInterval;
			Current = x0;
			_diff = diff;
			base.RandomSource = randomSource;
		}

		public override T Sample()
		{
			Burn(_burnInterval + 1);
			return Current;
		}

		protected void Burn(int n)
		{
			T p = Create();
			double e = _energy(Current);
			T gradient = _diff(_energy, Current);
			for (int i = 0; i < n; i++)
			{
				RandomizeMomentum(ref p);
				double num = Hamiltonian(p, e);
				T mNew = Copy(Current);
				T gNew = Copy(gradient);
				for (int j = 0; j < _frogLeapSteps; j++)
				{
					HamiltonianEquations(ref gNew, ref mNew, ref p);
				}
				double num2 = _energy(mNew);
				double dh = Hamiltonian(p, num2) - num;
				Update(ref e, ref gradient, mNew, gNew, num2, dh);
				Samples++;
			}
		}

		protected void Update(ref double e, ref T gradient, T mNew, T gNew, double enew, double dh)
		{
			if (dh <= 0.0)
			{
				Current = mNew;
				gradient = gNew;
				e = enew;
				Accepts++;
			}
			else if (Bernoulli.Sample(base.RandomSource, Math.Exp(0.0 - dh)) == 1)
			{
				Current = mNew;
				gradient = gNew;
				e = enew;
				Accepts++;
			}
		}

		protected abstract T Create();

		protected abstract T Copy(T source);

		protected abstract double DoProduct(T first, T second);

		protected abstract void DoAdd(ref T first, double factor, T second);

		protected abstract void DoSubtract(ref T first, double factor, T second);

		protected abstract void RandomizeMomentum(ref T p);

		protected void HamiltonianEquations(ref T gNew, ref T mNew, ref T p)
		{
			DoSubtract(ref p, _stepSize / 2.0, gNew);
			DoAdd(ref mNew, _stepSize, p);
			gNew = _diff(_energy, mNew);
			DoSubtract(ref p, _stepSize / 2.0, gNew);
		}

		protected double Hamiltonian(T momentum, double e)
		{
			return e + DoProduct(momentum, momentum) / 2.0;
		}

		protected int SetNonNegative(int value)
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("value", "Value must not be negative (zero is ok).");
			}
			return value;
		}

		protected int SetPositive(int value)
		{
			if (value <= 0)
			{
				throw new ArgumentOutOfRangeException("value", "Value must not be negative (zero is ok).");
			}
			return value;
		}

		protected double SetPositive(double value)
		{
			if (value <= 0.0)
			{
				throw new ArgumentOutOfRangeException("value", "Value must not be negative (zero is ok).");
			}
			return value;
		}
	}
	public static class MCMCDiagnostics
	{
		public static double ACF<T>(IEnumerable<T> series, int lag, Func<T, double> f)
		{
			if (lag < 0)
			{
				throw new ArgumentOutOfRangeException("lag", "Lag must be positive");
			}
			int num = series.Count();
			if (lag >= num)
			{
				throw new ArgumentOutOfRangeException("lag", "Lag must be smaller than the sample size");
			}
			IEnumerable<double> enumerable = series.Select(f);
			double[] source = (enumerable as double[]) ?? enumerable.ToArray();
			IEnumerable<double> dataA = source.Take(num - lag);
			IEnumerable<double> dataB = source.Skip(lag);
			return Correlation.Pearson(dataA, dataB);
		}

		public static double EffectiveSize<T>(IEnumerable<T> series, Func<T, double> f)
		{
			int num = series.Count();
			double num2 = ACF(series, 1, f);
			return (1.0 - num2) / (1.0 + num2) * (double)num;
		}
	}
	public delegate T GlobalProposalSampler<out T>();
	public delegate T LocalProposalSampler<T>(T init);
	public delegate double Density<in T>(T sample);
	public delegate double DensityLn<in T>(T sample);
	public delegate double TransitionKernelLn<in T>(T to, T from);
	public abstract class McmcSampler<T>
	{
		private System.Random _randomNumberGenerator;

		protected int Accepts;

		protected int Samples;

		public System.Random RandomSource
		{
			get
			{
				return _randomNumberGenerator;
			}
			set
			{
				_randomNumberGenerator = value ?? SystemRandomSource.Default;
			}
		}

		public double AcceptanceRate => (double)Accepts / (double)Samples;

		protected McmcSampler()
		{
			Accepts = 0;
			Samples = 0;
			RandomSource = SystemRandomSource.Default;
		}

		public abstract T Sample();

		public virtual T[] Sample(int n)
		{
			T[] array = new T[n];
			for (int i = 0; i < n; i++)
			{
				array[i] = Sample();
			}
			return array;
		}
	}
	public class MetropolisHastingsSampler<T> : McmcSampler<T>
	{
		private readonly DensityLn<T> _pdfLnP;

		private readonly TransitionKernelLn<T> _krnlQ;

		private readonly LocalProposalSampler<T> _proposal;

		private T _current;

		private double _currentDensityLn;

		private int _burnInterval;

		public int BurnInterval
		{
			get
			{
				return _burnInterval;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Value must not be negative (zero is ok).");
				}
				_burnInterval = value;
			}
		}

		public MetropolisHastingsSampler(T x0, DensityLn<T> pdfLnP, TransitionKernelLn<T> krnlQ, LocalProposalSampler<T> proposal, int burnInterval = 0)
		{
			_current = x0;
			_currentDensityLn = pdfLnP(x0);
			_pdfLnP = pdfLnP;
			_krnlQ = krnlQ;
			_proposal = proposal;
			BurnInterval = burnInterval;
			Burn(BurnInterval);
		}

		private void Burn(int n)
		{
			for (int i = 0; i < n; i++)
			{
				T val = _proposal(_current);
				double num = _pdfLnP(val);
				double num2 = _krnlQ(val, _current);
				double num3 = _krnlQ(_current, val);
				Samples++;
				double num4 = Math.Min(0.0, num + num3 - _currentDensityLn - num2);
				if (num4 == 0.0)
				{
					_current = val;
					_currentDensityLn = num;
					Accepts++;
				}
				else if (Bernoulli.Sample(base.RandomSource, Math.Exp(num4)) == 1)
				{
					_current = val;
					_currentDensityLn = num;
					Accepts++;
				}
			}
		}

		public override T Sample()
		{
			Burn(BurnInterval + 1);
			return _current;
		}
	}
	public class MetropolisSampler<T> : McmcSampler<T>
	{
		private readonly DensityLn<T> _pdfLnP;

		private readonly LocalProposalSampler<T> _proposal;

		private T _current;

		private double _currentDensityLn;

		private int _burnInterval;

		public int BurnInterval
		{
			get
			{
				return _burnInterval;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Value must not be negative (zero is ok).");
				}
				_burnInterval = value;
			}
		}

		public MetropolisSampler(T x0, DensityLn<T> pdfLnP, LocalProposalSampler<T> proposal, int burnInterval = 0)
		{
			_current = x0;
			_currentDensityLn = pdfLnP(x0);
			_pdfLnP = pdfLnP;
			_proposal = proposal;
			BurnInterval = burnInterval;
			Burn(BurnInterval);
		}

		private void Burn(int n)
		{
			for (int i = 0; i < n; i++)
			{
				T val = _proposal(_current);
				double num = _pdfLnP(val);
				Samples++;
				double num2 = Math.Min(0.0, num - _currentDensityLn);
				if (num2 == 0.0)
				{
					_current = val;
					_currentDensityLn = num;
					Accepts++;
				}
				else if (Bernoulli.Sample(base.RandomSource, Math.Exp(num2)) == 1)
				{
					_current = val;
					_currentDensityLn = num;
					Accepts++;
				}
			}
		}

		public override T Sample()
		{
			Burn(BurnInterval + 1);
			return _current;
		}
	}
	public class RejectionSampler<T> : McmcSampler<T>
	{
		private readonly Density<T> _pdfP;

		private readonly Density<T> _pdfQ;

		private readonly GlobalProposalSampler<T> _proposal;

		public RejectionSampler(Density<T> pdfP, Density<T> pdfQ, GlobalProposalSampler<T> proposal)
		{
			_pdfP = pdfP;
			_pdfQ = pdfQ;
			_proposal = proposal;
		}

		public override T Sample()
		{
			T val;
			double num2;
			double num3;
			do
			{
				val = _proposal();
				double num = _pdfQ(val);
				num2 = _pdfP(val);
				num3 = base.RandomSource.NextDouble() * num;
				Samples++;
				if (num < num2)
				{
					throw new ArgumentException("The sampler's proposal distribution is not upper bounding the target density.");
				}
			}
			while (!(num3 < num2));
			Accepts++;
			return val;
		}
	}
	public class UnivariateHybridMC : HybridMCGeneric<double>
	{
		private readonly Normal _distribution;

		private double _sdv;

		public double MomentumStdDev
		{
			get
			{
				return _sdv;
			}
			set
			{
				if (_sdv != value)
				{
					_sdv = SetPositive(value);
				}
			}
		}

		public UnivariateHybridMC(double x0, DensityLn<double> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval = 0, double pSdv = 1.0)
			: this(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, pSdv, SystemRandomSource.Default)
		{
		}

		public UnivariateHybridMC(double x0, DensityLn<double> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double pSdv, System.Random randomSource)
			: this(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, pSdv, randomSource, Grad)
		{
		}

		public UnivariateHybridMC(double x0, DensityLn<double> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double pSdv, System.Random randomSource, DiffMethod diff)
			: base(x0, pdfLnP, frogLeapSteps, stepSize, burnInterval, randomSource, diff)
		{
			MomentumStdDev = pSdv;
			_distribution = new Normal(0.0, MomentumStdDev, base.RandomSource);
			Burn(base.BurnInterval);
		}

		protected override double Copy(double source)
		{
			return source;
		}

		protected override double Create()
		{
			return 0.0;
		}

		protected override void DoAdd(ref double first, double factor, double second)
		{
			first += factor * second;
		}

		protected override double DoProduct(double first, double second)
		{
			return first * second;
		}

		protected override void DoSubtract(ref double first, double factor, double second)
		{
			first -= factor * second;
		}

		protected override void RandomizeMomentum(ref double p)
		{
			p = _distribution.Sample();
		}

		private static double Grad(DensityLn<double> function, double x)
		{
			double num = Math.Max(0.001, 1E-06 * x);
			double sample = x + num;
			double sample2 = x - num;
			return (function(sample) - function(sample2)) / (2.0 * num);
		}
	}
	public class UnivariateSliceSampler : McmcSampler<double>
	{
		private readonly DensityLn<double> _pdfLnP;

		private double _current;

		private double _currentDensityLn;

		private int _burnInterval;

		private double _scale;

		public int BurnInterval
		{
			get
			{
				return _burnInterval;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Value must not be negative (zero is ok).");
				}
				_burnInterval = value;
			}
		}

		public double Scale
		{
			get
			{
				return _scale;
			}
			set
			{
				if (value <= 0.0)
				{
					throw new ArgumentException("Value must be positive (and not zero).");
				}
				_scale = value;
			}
		}

		public UnivariateSliceSampler(double x0, DensityLn<double> pdfLnP, double scale)
			: this(x0, pdfLnP, 0, scale)
		{
		}

		public UnivariateSliceSampler(double x0, DensityLn<double> pdfLnP, int burnInterval, double scale)
		{
			_current = x0;
			_currentDensityLn = pdfLnP(x0);
			_pdfLnP = pdfLnP;
			Scale = scale;
			BurnInterval = burnInterval;
			Burn(BurnInterval);
		}

		private void Burn(int n)
		{
			for (int i = 0; i < n; i++)
			{
				double num = Math.Log(base.RandomSource.NextDouble()) + _currentDensityLn;
				double num2 = base.RandomSource.NextDouble();
				double num3 = _current - num2 * Scale;
				double num4 = _current + (1.0 - num2) * Scale;
				while (_pdfLnP(num3) > num)
				{
					num3 -= Scale;
				}
				for (; _pdfLnP(num4) > num; num4 += Scale)
				{
				}
				double num5;
				while (true)
				{
					num5 = base.RandomSource.NextDouble() * (num4 - num3) + num3;
					_currentDensityLn = _pdfLnP(num5);
					if (_currentDensityLn > num)
					{
						break;
					}
					if (num5 > _current)
					{
						num4 = num5;
					}
					else
					{
						num3 = num5;
					}
				}
				_current = num5;
				Accepts++;
				Samples++;
			}
		}

		public override double Sample()
		{
			Burn(BurnInterval + 1);
			return _current;
		}
	}
}
namespace MathNet.Numerics.RootFinding
{
	public static class Bisection
	{
		public static double FindRootExpand(Func<double, double> f, double guessLowerBound, double guessUpperBound, double accuracy = 1E-08, int maxIterations = 100, double expandFactor = 1.6, int maxExpandIteratons = 100)
		{
			ZeroCrossingBracketing.ExpandReduce(f, ref guessLowerBound, ref guessUpperBound, expandFactor, maxExpandIteratons, maxExpandIteratons * 10);
			return FindRoot(f, guessLowerBound, guessUpperBound, accuracy, maxIterations);
		}

		public static double FindRoot(Func<double, double> f, double lowerBound, double upperBound, double accuracy = 1E-14, int maxIterations = 100)
		{
			if (TryFindRoot(f, lowerBound, upperBound, accuracy, maxIterations, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
		}

		public static bool TryFindRoot(Func<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations, out double root)
		{
			if (accuracy <= 0.0)
			{
				throw new ArgumentOutOfRangeException("accuracy", "Must be greater than zero.");
			}
			if (upperBound < lowerBound)
			{
				double num = upperBound;
				upperBound = lowerBound;
				lowerBound = num;
			}
			double value = f(lowerBound);
			if (Math.Sign(value) == 0)
			{
				root = lowerBound;
				return true;
			}
			double value2 = f(upperBound);
			if (Math.Sign(value2) == 0)
			{
				root = upperBound;
				return true;
			}
			root = 0.5 * (lowerBound + upperBound);
			if (Math.Sign(value) == Math.Sign(value2))
			{
				return false;
			}
			for (int i = 0; i <= maxIterations; i++)
			{
				double num2 = f(root);
				if (upperBound - lowerBound <= 2.0 * accuracy && Math.Abs(num2) <= accuracy)
				{
					return true;
				}
				if (lowerBound == root || upperBound == root)
				{
					return false;
				}
				if (Math.Sign(num2) == Math.Sign(value))
				{
					lowerBound = root;
					value = num2;
				}
				else
				{
					if (Math.Sign(num2) != Math.Sign(value2))
					{
						return true;
					}
					upperBound = root;
					value2 = num2;
				}
				root = 0.5 * (lowerBound + upperBound);
			}
			return false;
		}
	}
	public static class Brent
	{
		public static double FindRootExpand(Func<double, double> f, double guessLowerBound, double guessUpperBound, double accuracy = 1E-08, int maxIterations = 100, double expandFactor = 1.6, int maxExpandIteratons = 100)
		{
			ZeroCrossingBracketing.ExpandReduce(f, ref guessLowerBound, ref guessUpperBound, expandFactor, maxExpandIteratons, maxExpandIteratons * 10);
			return FindRoot(f, guessLowerBound, guessUpperBound, accuracy, maxIterations);
		}

		public static double FindRoot(Func<double, double> f, double lowerBound, double upperBound, double accuracy = 1E-08, int maxIterations = 100)
		{
			if (TryFindRoot(f, lowerBound, upperBound, accuracy, maxIterations, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
		}

		public static bool TryFindRoot(Func<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations, out double root)
		{
			if (accuracy <= 0.0)
			{
				throw new ArgumentOutOfRangeException("accuracy", "Must be greater than zero.");
			}
			double num = f(lowerBound);
			double num2 = f(upperBound);
			double num3 = num2;
			double num4 = 0.0;
			double num5 = 0.0;
			root = upperBound;
			double num6 = double.NaN;
			if (Math.Sign(num) == Math.Sign(num2))
			{
				return false;
			}
			for (int i = 0; i <= maxIterations; i++)
			{
				if (Math.Sign(num3) == Math.Sign(num2))
				{
					upperBound = lowerBound;
					num2 = num;
					num5 = (num4 = root - lowerBound);
				}
				if (Math.Abs(num2) < Math.Abs(num3))
				{
					lowerBound = root;
					root = upperBound;
					upperBound = lowerBound;
					num = num3;
					num3 = num2;
					num2 = num;
				}
				double num7 = Precision.PositiveDoublePrecision * Math.Abs(root) + 0.5 * accuracy;
				double num8 = num6;
				num6 = (upperBound - root) / 2.0;
				if (Math.Abs(num6) <= num7 || num3.AlmostEqualNormRelative(0.0, num3, accuracy))
				{
					return true;
				}
				if (num6 == num8)
				{
					return false;
				}
				if (Math.Abs(num5) >= num7 && Math.Abs(num) > Math.Abs(num3))
				{
					double num9 = num3 / num;
					double num11;
					double num10;
					if (lowerBound.AlmostEqualRelative(upperBound))
					{
						num10 = 2.0 * num6 * num9;
						num11 = 1.0 - num9;
					}
					else
					{
						num11 = num / num2;
						double num12 = num3 / num2;
						num10 = num9 * (2.0 * num6 * num11 * (num11 - num12) - (root - lowerBound) * (num12 - 1.0));
						num11 = (num11 - 1.0) * (num12 - 1.0) * (num9 - 1.0);
					}
					if (num10 > 0.0)
					{
						num11 = 0.0 - num11;
					}
					num10 = Math.Abs(num10);
					if (2.0 * num10 < Math.Min(3.0 * num6 * num11 - Math.Abs(num7 * num11), Math.Abs(num5 * num11)))
					{
						num5 = num4;
						num4 = num10 / num11;
					}
					else
					{
						num4 = num6;
						num5 = num4;
					}
				}
				else
				{
					num4 = num6;
					num5 = num4;
				}
				lowerBound = root;
				num = num3;
				if (Math.Abs(num4) > num7)
				{
					root += num4;
				}
				else
				{
					root += Sign(num7, num6);
				}
				num3 = f(root);
			}
			return false;
		}

		private static double Sign(double a, double b)
		{
			if (!(b >= 0.0))
			{
				if (!(a >= 0.0))
				{
					return a;
				}
				return 0.0 - a;
			}
			if (!(a >= 0.0))
			{
				return 0.0 - a;
			}
			return a;
		}
	}
	public static class Broyden
	{
		public static double[] FindRoot(Func<double[], double[]> f, double[] initialGuess, double accuracy = 1E-08, int maxIterations = 100, double jacobianStepSize = 0.0001)
		{
			if (TryFindRootWithJacobianStep(f, initialGuess, accuracy, maxIterations, jacobianStepSize, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
		}

		public static bool TryFindRootWithJacobianStep(Func<double[], double[]> f, double[] initialGuess, double accuracy, int maxIterations, double jacobianStepSize, out double[] root)
		{
			if (accuracy <= 0.0)
			{
				throw new ArgumentOutOfRangeException("accuracy", "Must be greater than zero.");
			}
			MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(initialGuess);
			double[] array = f(initialGuess);
			MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector2 = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(array);
			double num = denseVector2.L2Norm();
			Matrix<double> matrix = CalculateApproximateJacobian(f, initialGuess, array, jacobianStepSize);
			try
			{
				for (int i = 0; i <= maxIterations; i++)
				{
					MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector3 = (MathNet.Numerics.LinearAlgebra.Double.DenseVector)(-matrix.LU().Solve(denseVector2));
					MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector4 = denseVector + denseVector3;
					MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector5 = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(f(denseVector4.Values));
					double num2 = denseVector5.L2Norm();
					if (num2 > num)
					{
						double num3 = num * num;
						double num4 = num3 / (num3 + num2 * num2);
						if (num4 == 0.0)
						{
							num4 = 0.0001;
						}
						denseVector3 = num4 * denseVector3;
						denseVector4 = denseVector + denseVector3;
						denseVector5 = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(f(denseVector4.Values));
						num2 = denseVector5.L2Norm();
					}
					if (num2 < accuracy)
					{
						root = denseVector4.Values;
						return true;
					}
					Matrix<double> matrix2 = (denseVector5 - denseVector2 - matrix.Multiply(denseVector3)).ToColumnMatrix() * denseVector3.Multiply(1.0 / Math.Pow(denseVector3.L2Norm(), 2.0)).ToRowMatrix();
					matrix += matrix2;
					denseVector = denseVector4;
					denseVector2 = denseVector5;
					num = num2;
				}
			}
			catch (InvalidParameterException)
			{
				root = null;
				return false;
			}
			root = null;
			return false;
		}

		public static bool TryFindRoot(Func<double[], double[]> f, double[] initialGuess, double accuracy, int maxIterations, out double[] root)
		{
			return TryFindRootWithJacobianStep(f, initialGuess, accuracy, maxIterations, 0.0001, out root);
		}

		private static Matrix<double> CalculateApproximateJacobian(Func<double[], double[]> f, double[] x0, double[] y0, double jacobianStepSize)
		{
			int num = x0.Length;
			MathNet.Numerics.LinearAlgebra.Double.DenseMatrix denseMatrix = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix(num);
			double[] array = new double[num];
			Array.Copy(x0, 0, array, 0, num);
			for (int i = 0; i < num; i++)
			{
				double num2 = (1.0 + Math.Abs(x0[i])) * jacobianStepSize;
				double num3 = array[i];
				array[i] = num3 + num2;
				double[] array2 = f(array);
				array[i] = num3;
				for (int j = 0; j < num; j++)
				{
					denseMatrix.At(j, i, (array2[j] - y0[j]) / num2);
				}
			}
			return denseMatrix;
		}
	}
	public static class Cubic
	{
		private static void QR(double a2, double a1, double a0, out double Q, out double R)
		{
			Q = (3.0 * a1 - a2 * a2) / 9.0;
			R = (9.0 * a2 * a1 - 27.0 * a0 - 2.0 * a2 * a2 * a2) / 54.0;
		}

		private static double PowThird(double n)
		{
			return Math.Pow(Math.Abs(n), 1.0 / 3.0) * (double)Math.Sign(n);
		}

		public static Tuple<double, double, double> RealRoots(double a0, double a1, double a2)
		{
			QR(a2, a1, a0, out var Q, out var R);
			double num = Q * Q * Q;
			double num2 = num + R * R;
			double num3 = (0.0 - a2) / 3.0;
			double item = double.NaN;
			double item2 = double.NaN;
			double item3;
			if (num2 >= 0.0)
			{
				double num4 = Math.Pow(num2, 0.5);
				double num5 = PowThird(R + num4);
				double num6 = PowThird(R - num4);
				item3 = num3 + (num5 + num6);
				if (num2 == 0.0)
				{
					item = num3 - num5;
				}
			}
			else
			{
				double num7 = Math.Acos(R / Math.Sqrt(0.0 - num));
				item3 = 2.0 * Math.Sqrt(0.0 - Q) * Math.Cos(num7 / 3.0) + num3;
				item = 2.0 * Math.Sqrt(0.0 - Q) * Math.Cos((num7 + Math.PI * 2.0) / 3.0) + num3;
				item2 = 2.0 * Math.Sqrt(0.0 - Q) * Math.Cos((num7 - Math.PI * 2.0) / 3.0) + num3;
			}
			return new Tuple<double, double, double>(item3, item, item2);
		}

		public static Tuple<Complex, Complex, Complex> Roots(double d, double c, double b, double a)
		{
			double num = b * b - 3.0 * a * c;
			double num2 = 2.0 * b * b * b - 9.0 * a * b * c + 27.0 * a * a * d;
			double num3 = -1.0 / (3.0 * a);
			if ((num2 * num2 - 4.0 * num * num * num) / (-27.0 * a * a) == 0.0)
			{
				if (num == 0.0)
				{
					Complex complex = new Complex(num3 * b, 0.0);
					return new Tuple<Complex, Complex, Complex>(complex, complex, complex);
				}
				Complex complex2 = new Complex((9.0 * a * d - b * c) / (2.0 * num), 0.0);
				Complex item = new Complex((4.0 * a * b * c - 9.0 * a * a * d - b * b * b) / (a * num), 0.0);
				return new Tuple<Complex, Complex, Complex>(complex2, complex2, item);
			}
			Tuple<Complex, Complex, Complex> tuple = ((num == 0.0) ? new Complex(num2, 0.0).CubicRoots() : ((num2 + Complex.Sqrt(num2 * num2 - 4.0 * num * num * num)) / 2).CubicRoots());
			return new Tuple<Complex, Complex, Complex>(num3 * (b + tuple.Item1 + num / tuple.Item1), num3 * (b + tuple.Item2 + num / tuple.Item2), num3 * (b + tuple.Item3 + num / tuple.Item3));
		}
	}
	public static class NewtonRaphson
	{
		public static double FindRoot(Func<double, double> f, Func<double, double> df, double lowerBound, double upperBound, double accuracy = 1E-08, int maxIterations = 100)
		{
			if (TryFindRoot(f, df, 0.5 * (lowerBound + upperBound), lowerBound, upperBound, accuracy, maxIterations, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds. Consider to use RobustNewtonRaphson instead.");
		}

		public static double FindRootNearGuess(Func<double, double> f, Func<double, double> df, double initialGuess, double lowerBound = double.MinValue, double upperBound = double.MaxValue, double accuracy = 1E-08, int maxIterations = 100)
		{
			if (TryFindRoot(f, df, initialGuess, lowerBound, upperBound, accuracy, maxIterations, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds. Consider to use RobustNewtonRaphson instead.");
		}

		public static bool TryFindRoot(Func<double, double> f, Func<double, double> df, double initialGuess, double lowerBound, double upperBound, double accuracy, int maxIterations, out double root)
		{
			if (accuracy <= 0.0)
			{
				throw new ArgumentOutOfRangeException("accuracy", "Must be greater than zero.");
			}
			root = initialGuess;
			for (int i = 0; i < maxIterations; i++)
			{
				if (!(root >= lowerBound))
				{
					break;
				}
				if (!(root <= upperBound))
				{
					break;
				}
				double num = f(root);
				double num2 = df(root);
				double num3 = num / num2;
				root -= num3;
				if (Math.Abs(num3) < accuracy && Math.Abs(num) < accuracy)
				{
					return true;
				}
			}
			return false;
		}
	}
	public static class RobustNewtonRaphson
	{
		public static double FindRoot(Func<double, double> f, Func<double, double> df, double lowerBound, double upperBound, double accuracy = 1E-08, int maxIterations = 100, int subdivision = 20)
		{
			if (TryFindRoot(f, df, lowerBound, upperBound, accuracy, maxIterations, subdivision, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
		}

		public static bool TryFindRoot(Func<double, double> f, Func<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations, int subdivision, out double root)
		{
			if (accuracy <= 0.0)
			{
				throw new ArgumentOutOfRangeException("accuracy", "Must be greater than zero.");
			}
			double num = f(lowerBound);
			double num2 = f(upperBound);
			if (Math.Abs(num) < accuracy)
			{
				root = lowerBound;
				return true;
			}
			if (Math.Abs(num2) < accuracy)
			{
				root = upperBound;
				return true;
			}
			root = 0.5 * (lowerBound + upperBound);
			double num3 = f(root);
			double num4 = Math.Abs(upperBound - lowerBound);
			for (int i = 0; i < maxIterations; i++)
			{
				double num5 = df(root);
				double num6 = num3 / num5;
				root -= num6;
				if (Math.Abs(num6) < accuracy && Math.Abs(num3) < accuracy)
				{
					return true;
				}
				bool flag = root > upperBound;
				bool flag2 = root < lowerBound;
				if (flag || flag2 || Math.Abs(2.0 * num3) > Math.Abs(num4 * num5))
				{
					if (Math.Sign(num) == Math.Sign(num2) && TryScanForCrossingsWithRoots(f, df, lowerBound, upperBound, accuracy, maxIterations - i - 1, subdivision, out root))
					{
						return true;
					}
					root = 0.5 * (upperBound + lowerBound);
					num3 = f(root);
					num4 = 0.5 * Math.Abs(upperBound - lowerBound);
					if (Math.Sign(num3) == Math.Sign(num))
					{
						lowerBound = root;
						num = num3;
						if (flag)
						{
							root = upperBound;
							num3 = num2;
						}
					}
					else
					{
						upperBound = root;
						num2 = num3;
						if (flag2)
						{
							root = lowerBound;
							num3 = num;
						}
					}
				}
				else
				{
					num3 = f(root);
					num4 = num6;
					if (Math.Sign(num3) != Math.Sign(num))
					{
						upperBound = root;
						num2 = num3;
					}
					else if (Math.Sign(num3) != Math.Sign(num2))
					{
						lowerBound = root;
						num = num3;
					}
					else if (Math.Sign(num) != Math.Sign(num2) && Math.Abs(num3) < accuracy)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool TryScanForCrossingsWithRoots(Func<double, double> f, Func<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations, int subdivision, out double root)
		{
			foreach (Tuple<double, double> item in ZeroCrossingBracketing.FindIntervalsWithin(f, lowerBound, upperBound, subdivision))
			{
				if (TryFindRoot(f, df, item.Item1, item.Item2, accuracy, maxIterations, subdivision, out root))
				{
					return true;
				}
			}
			root = double.NaN;
			return false;
		}
	}
	public static class Secant
	{
		public static double FindRoot(Func<double, double> f, double guess, double secondGuess, double lowerBound = double.MinValue, double upperBound = double.MaxValue, double accuracy = 1E-08, int maxIterations = 100)
		{
			if (TryFindRoot(f, guess, secondGuess, lowerBound, upperBound, accuracy, maxIterations, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
		}

		public static bool TryFindRoot(Func<double, double> f, double guess, double secondGuess, double lowerBound, double upperBound, double accuracy, int maxIterations, out double root)
		{
			if (accuracy <= 0.0)
			{
				throw new ArgumentOutOfRangeException("accuracy", "Must be greater than zero.");
			}
			root = secondGuess;
			if (guess <= lowerBound || guess >= upperBound || secondGuess <= lowerBound || secondGuess >= upperBound)
			{
				return false;
			}
			double num = f(guess);
			double num2 = f(root);
			for (int i = 0; i <= maxIterations; i++)
			{
				if (!(root >= lowerBound))
				{
					break;
				}
				if (!(root <= upperBound))
				{
					break;
				}
				double num3 = num2 * (root - guess) / (num2 - num);
				guess = root;
				num = num2;
				root -= num3;
				num2 = f(root);
				if (Math.Abs(num3) < accuracy && Math.Abs(num2) < accuracy)
				{
					return true;
				}
			}
			return false;
		}
	}
	public static class ZeroCrossingBracketing
	{
		public static IEnumerable<Tuple<double, double>> FindIntervalsWithin(Func<double, double> f, double lowerBound, double upperBound, int subdivisions)
		{
			double value = f(lowerBound);
			double value2 = f(upperBound);
			if (Math.Sign(value) != Math.Sign(value2))
			{
				yield return new Tuple<double, double>(lowerBound, upperBound);
				yield break;
			}
			double subdiv = (upperBound - lowerBound) / (double)subdivisions;
			double num = lowerBound;
			int num2 = Math.Sign(value);
			for (int i = 0; i < subdivisions; i++)
			{
				double smax = num + subdiv;
				double sfmax = f(smax);
				if (double.IsInfinity(sfmax))
				{
					num = smax;
					continue;
				}
				if (Math.Sign(sfmax) != num2)
				{
					yield return new Tuple<double, double>(num, smax);
					num2 = Math.Sign(sfmax);
				}
				num = smax;
			}
		}

		public static bool Expand(Func<double, double> f, ref double lowerBound, ref double upperBound, double factor = 1.6, int maxIterations = 50)
		{
			double num = lowerBound;
			double num2 = upperBound;
			if (lowerBound >= upperBound)
			{
				throw new ArgumentOutOfRangeException("upperBound", "xmax must be greater than xmin.");
			}
			double value = f(lowerBound);
			double value2 = f(upperBound);
			for (int i = 0; i < maxIterations; i++)
			{
				if (Math.Sign(value) != Math.Sign(value2))
				{
					return true;
				}
				if (Math.Abs(value) < Math.Abs(value2))
				{
					lowerBound += factor * (lowerBound - upperBound);
					value = f(lowerBound);
				}
				else
				{
					upperBound += factor * (upperBound - lowerBound);
					value2 = f(upperBound);
				}
			}
			lowerBound = num;
			upperBound = num2;
			return false;
		}

		public static bool Reduce(Func<double, double> f, ref double lowerBound, ref double upperBound, int subdivisions = 1000)
		{
			double num = lowerBound;
			double num2 = upperBound;
			if (lowerBound >= upperBound)
			{
				throw new ArgumentOutOfRangeException("upperBound", "xmax must be greater than xmin.");
			}
			double value = f(lowerBound);
			double value2 = f(upperBound);
			if (Math.Sign(value) != Math.Sign(value2))
			{
				return true;
			}
			double num3 = (upperBound - lowerBound) / (double)subdivisions;
			double num4 = lowerBound;
			int num5 = Math.Sign(value);
			for (int i = 0; i < subdivisions; i++)
			{
				double num6 = num4 + num3;
				double num7 = f(num6);
				if (double.IsInfinity(num7))
				{
					num4 = num6;
					continue;
				}
				if (Math.Sign(num7) != num5)
				{
					lowerBound = num4;
					upperBound = num6;
					return true;
				}
				num4 = num6;
			}
			lowerBound = num;
			upperBound = num2;
			return false;
		}

		public static bool ExpandReduce(Func<double, double> f, ref double lowerBound, ref double upperBound, double expansionFactor = 1.6, int expansionMaxIterations = 50, int reduceSubdivisions = 100)
		{
			if (!Expand(f, ref lowerBound, ref upperBound, expansionFactor, expansionMaxIterations))
			{
				return Reduce(f, ref lowerBound, ref upperBound, reduceSubdivisions);
			}
			return true;
		}
	}
}
namespace MathNet.Numerics.Random
{
	public sealed class CryptoRandomSource : RandomSource, IDisposable
	{
		private const double Reciprocal = 2.3283064365386963E-10;

		private readonly RandomNumberGenerator _crypto;

		public CryptoRandomSource()
		{
			_crypto = RandomNumberGenerator.Create();
		}

		public CryptoRandomSource(RandomNumberGenerator rng)
		{
			_crypto = rng;
		}

		public CryptoRandomSource(bool threadSafe)
			: base(threadSafe)
		{
			_crypto = RandomNumberGenerator.Create();
		}

		public CryptoRandomSource(RandomNumberGenerator rng, bool threadSafe)
			: base(threadSafe)
		{
			_crypto = rng;
		}

		protected override void DoSampleBytes(byte[] buffer)
		{
			_crypto.GetBytes(buffer);
		}

		protected sealed override double DoSample()
		{
			byte[] array = new byte[4];
			_crypto.GetBytes(array);
			return (double)BitConverter.ToUInt32(array, 0) * 2.3283064365386963E-10;
		}

		protected sealed override int DoSampleInteger()
		{
			byte[] array = new byte[4];
			_crypto.GetBytes(array);
			int num = (int)(BitConverter.ToUInt32(array, 0) >> 1);
			if (num == int.MaxValue)
			{
				return DoSampleInteger();
			}
			return num;
		}

		public void Dispose()
		{
			_crypto.Dispose();
		}

		public static void Doubles(double[] values)
		{
			byte[] array = new byte[values.Length * 4];
			using (RandomNumberGenerator randomNumberGenerator = RandomNumberGenerator.Create())
			{
				randomNumberGenerator.GetBytes(array);
			}
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = (double)BitConverter.ToUInt32(array, i * 4) * 2.3283064365386963E-10;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length)
		{
			double[] array = new double[length];
			Doubles(array);
			return array;
		}

		public static IEnumerable<double> DoubleSequence()
		{
			RandomNumberGenerator rnd = RandomNumberGenerator.Create();
			byte[] buffer = new byte[4096];
			while (true)
			{
				rnd.GetBytes(buffer);
				for (int i = 0; i < buffer.Length; i += 4)
				{
					yield return (double)BitConverter.ToUInt32(buffer, i) * 2.3283064365386963E-10;
				}
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class Mcg31m1 : RandomSource
	{
		private const ulong Modulus = 2147483647uL;

		private const ulong Multiplier = 1132489760uL;

		private const double Reciprocal = 4.656612875245797E-10;

		[DataMember(Order = 1)]
		private ulong _xn;

		public Mcg31m1()
			: this(RandomSeed.Robust())
		{
		}

		public Mcg31m1(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public Mcg31m1(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (ulong)(uint)seed % 2147483647uL;
		}

		public Mcg31m1(int seed, bool threadSafe)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (ulong)(uint)seed % 2147483647uL;
		}

		protected sealed override double DoSample()
		{
			double result = (double)_xn * 4.656612875245797E-10;
			_xn = _xn * 1132489760 % 2147483647uL;
			return result;
		}

		public static void Doubles(double[] values, int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			ulong num = (ulong)(uint)seed % 2147483647uL;
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = (double)num * 4.656612875245797E-10;
				num = num * 1132489760 % 2147483647uL;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			ulong xn = (ulong)(uint)seed % 2147483647uL;
			while (true)
			{
				yield return (double)xn * 4.656612875245797E-10;
				xn = xn * 1132489760 % 2147483647uL;
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class Mcg59 : RandomSource
	{
		private const ulong Modulus = 576460752303423488uL;

		private const ulong Multiplier = 302875106592253uL;

		private const double Reciprocal = 1.734723475976807E-18;

		[DataMember(Order = 1)]
		private ulong _xn;

		public Mcg59()
			: this(RandomSeed.Robust())
		{
		}

		public Mcg59(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public Mcg59(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (ulong)(uint)seed % 576460752303423488uL;
		}

		public Mcg59(int seed, bool threadSafe)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (ulong)(uint)seed % 576460752303423488uL;
		}

		protected sealed override double DoSample()
		{
			double result = (double)_xn * 1.734723475976807E-18;
			_xn = _xn * 302875106592253L % 576460752303423488uL;
			return result;
		}

		public static void Doubles(double[] values, int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			ulong num = (ulong)(uint)seed % 576460752303423488uL;
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = (double)num * 1.734723475976807E-18;
				num = num * 302875106592253L % 576460752303423488uL;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			ulong xn = (ulong)(uint)seed % 576460752303423488uL;
			while (true)
			{
				yield return (double)xn * 1.734723475976807E-18;
				xn = xn * 302875106592253L % 576460752303423488uL;
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class MersenneTwister : RandomSource
	{
		private const uint LowerMask = 2147483647u;

		private const int M = 397;

		private const uint MatrixA = 2567483615u;

		private const int N = 624;

		private const double Reciprocal = 2.3283064365386963E-10;

		private const uint UpperMask = 2147483648u;

		private static readonly uint[] Mag01 = new uint[2] { 0u, 2567483615u };

		[DataMember(Order = 1)]
		private readonly uint[] _mt = new uint[624];

		[DataMember(Order = 2)]
		private int _mti = 625;

		private static readonly ThreadLocal<MersenneTwister> DefaultInstance = new ThreadLocal<MersenneTwister>(() => new MersenneTwister(RandomSeed.Robust(), threadSafe: true));

		public static MersenneTwister Default => DefaultInstance.Value;

		public MersenneTwister()
			: this(RandomSeed.Robust())
		{
		}

		public MersenneTwister(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public MersenneTwister(int seed)
		{
			init_genrand((uint)seed);
		}

		public MersenneTwister(int seed, bool threadSafe)
			: base(threadSafe)
		{
			init_genrand((uint)seed);
		}

		private void init_genrand(uint s)
		{
			_mt[0] = s & 0xFFFFFFFFu;
			for (_mti = 1; _mti < 624; _mti++)
			{
				_mt[_mti] = 1812433253 * (_mt[_mti - 1] ^ (_mt[_mti - 1] >> 30)) + (uint)_mti;
				_mt[_mti] &= uint.MaxValue;
			}
		}

		private uint genrand_int32()
		{
			uint num;
			if (_mti >= 624)
			{
				if (_mti == 625)
				{
					init_genrand(5489u);
				}
				int i;
				for (i = 0; i < 227; i++)
				{
					num = (_mt[i] & 0x80000000u) | (_mt[i + 1] & 0x7FFFFFFFu);
					_mt[i] = _mt[i + 397] ^ (num >> 1) ^ Mag01[num & 1];
				}
				for (; i < 623; i++)
				{
					num = (_mt[i] & 0x80000000u) | (_mt[i + 1] & 0x7FFFFFFFu);
					_mt[i] = _mt[i + -227] ^ (num >> 1) ^ Mag01[num & 1];
				}
				num = (_mt[623] & 0x80000000u) | (_mt[0] & 0x7FFFFFFFu);
				_mt[623] = _mt[396] ^ (num >> 1) ^ Mag01[num & 1];
				_mti = 0;
			}
			num = _mt[_mti++];
			num ^= num >> 11;
			num ^= (num << 7) & 0x9D2C5680u;
			num ^= (num << 15) & 0xEFC60000u;
			return num ^ (num >> 18);
		}

		protected sealed override double DoSample()
		{
			return (double)genrand_int32() * 2.3283064365386963E-10;
		}

		protected sealed override int DoSampleInteger()
		{
			int num = (int)(genrand_int32() >> 1);
			if (num == int.MaxValue)
			{
				return DoSampleInteger();
			}
			return num;
		}

		protected sealed override void DoSampleBytes(byte[] buffer)
		{
			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i] = (byte)(genrand_int32() % 256u);
			}
		}

		public static void Doubles(double[] values, int seed)
		{
			uint[] array = new uint[624];
			array[0] = (uint)seed & 0xFFFFFFFFu;
			int i;
			for (i = 1; i < 624; i++)
			{
				array[i] = 1812433253 * (array[i - 1] ^ (array[i - 1] >> 30)) + (uint)i;
				array[i] &= uint.MaxValue;
			}
			for (int j = 0; j < values.Length; j++)
			{
				uint num;
				if (i >= 624)
				{
					int k;
					for (k = 0; k < 227; k++)
					{
						num = (array[k] & 0x80000000u) | (array[k + 1] & 0x7FFFFFFFu);
						array[k] = array[k + 397] ^ (num >> 1) ^ Mag01[num & 1];
					}
					for (; k < 623; k++)
					{
						num = (array[k] & 0x80000000u) | (array[k + 1] & 0x7FFFFFFFu);
						array[k] = array[k + -227] ^ (num >> 1) ^ Mag01[num & 1];
					}
					num = (array[623] & 0x80000000u) | (array[0] & 0x7FFFFFFFu);
					array[623] = array[396] ^ (num >> 1) ^ Mag01[num & 1];
					i = 0;
				}
				num = array[i++];
				num ^= num >> 11;
				num ^= (num << 7) & 0x9D2C5680u;
				num ^= (num << 15) & 0xEFC60000u;
				num ^= num >> 18;
				values[j] = (double)num * 2.3283064365386963E-10;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			uint[] t = new uint[624];
			t[0] = (uint)seed & 0xFFFFFFFFu;
			int i;
			for (i = 1; i < 624; i++)
			{
				t[i] = 1812433253 * (t[i - 1] ^ (t[i - 1] >> 30)) + (uint)i;
				t[i] &= uint.MaxValue;
			}
			while (true)
			{
				uint num;
				if (i >= 624)
				{
					int j;
					for (j = 0; j < 227; j++)
					{
						num = (t[j] & 0x80000000u) | (t[j + 1] & 0x7FFFFFFFu);
						t[j] = t[j + 397] ^ (num >> 1) ^ Mag01[num & 1];
					}
					for (; j < 623; j++)
					{
						num = (t[j] & 0x80000000u) | (t[j + 1] & 0x7FFFFFFFu);
						t[j] = t[j + -227] ^ (num >> 1) ^ Mag01[num & 1];
					}
					num = (t[623] & 0x80000000u) | (t[0] & 0x7FFFFFFFu);
					t[623] = t[396] ^ (num >> 1) ^ Mag01[num & 1];
					i = 0;
				}
				num = t[i++];
				num ^= num >> 11;
				num ^= (num << 7) & 0x9D2C5680u;
				num ^= (num << 15) & 0xEFC60000u;
				num ^= num >> 18;
				yield return (double)num * 2.3283064365386963E-10;
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class Mrg32k3a : RandomSource
	{
		private const double A12 = 1403580.0;

		private const double A13 = 810728.0;

		private const double A21 = 527612.0;

		private const double A23 = 1370589.0;

		private const double Modulus1 = 4294967087.0;

		private const double Modulus2 = 4294944443.0;

		private const double Reciprocal = 2.328306549837829E-10;

		[DataMember(Order = 1)]
		private double _xn1 = 1.0;

		[DataMember(Order = 2)]
		private double _xn2 = 1.0;

		[DataMember(Order = 3)]
		private double _xn3;

		[DataMember(Order = 4)]
		private double _yn1 = 1.0;

		[DataMember(Order = 5)]
		private double _yn2 = 1.0;

		[DataMember(Order = 6)]
		private double _yn3 = 1.0;

		public Mrg32k3a()
			: this(RandomSeed.Robust())
		{
		}

		public Mrg32k3a(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public Mrg32k3a(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn3 = (uint)seed;
		}

		public Mrg32k3a(int seed, bool threadSafe)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn3 = (uint)seed;
		}

		protected sealed override double DoSample()
		{
			double num = 1403580.0 * _xn2 - 810728.0 * _xn3;
			double num2 = (long)(num / 4294967087.0);
			num -= num2 * 4294967087.0;
			if (num < 0.0)
			{
				num += 4294967087.0;
			}
			double num3 = 527612.0 * _yn1 - 1370589.0 * _yn3;
			num2 = (long)(num3 / 4294944443.0);
			num3 -= num2 * 4294944443.0;
			if (num3 < 0.0)
			{
				num3 += 4294944443.0;
			}
			_xn3 = _xn2;
			_xn2 = _xn1;
			_xn1 = num;
			_yn3 = _yn2;
			_yn2 = _yn1;
			_yn1 = num3;
			if (num <= num3)
			{
				return (num - num3 + 4294967087.0) * 2.328306549837829E-10;
			}
			return (num - num3) * 2.328306549837829E-10;
		}

		public static void Doubles(double[] values, int seed)
		{
			double num = 1.0;
			double num2 = 1.0;
			double num3 = (uint)seed;
			double num4 = 1.0;
			double num5 = 1.0;
			double num6 = 1.0;
			for (int i = 0; i < values.Length; i++)
			{
				double num7 = 1403580.0 * num2 - 810728.0 * num3;
				double num8 = (long)(num7 / 4294967087.0);
				num7 -= num8 * 4294967087.0;
				if (num7 < 0.0)
				{
					num7 += 4294967087.0;
				}
				double num9 = 527612.0 * num4 - 1370589.0 * num6;
				num8 = (long)(num9 / 4294944443.0);
				num9 -= num8 * 4294944443.0;
				if (num9 < 0.0)
				{
					num9 += 4294944443.0;
				}
				num3 = num2;
				num2 = num;
				num = num7;
				num6 = num5;
				num5 = num4;
				num4 = num9;
				values[i] = ((num7 <= num9) ? ((num7 - num9 + 4294967087.0) * 2.328306549837829E-10) : ((num7 - num9) * 2.328306549837829E-10));
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			double x1 = 1.0;
			double x2 = 1.0;
			double x3 = (uint)seed;
			double y1 = 1.0;
			double y2 = 1.0;
			double y3 = 1.0;
			while (true)
			{
				double num = 1403580.0 * x2 - 810728.0 * x3;
				double num2 = (long)(num / 4294967087.0);
				num -= num2 * 4294967087.0;
				if (num < 0.0)
				{
					num += 4294967087.0;
				}
				double num3 = 527612.0 * y1 - 1370589.0 * y3;
				num2 = (long)(num3 / 4294944443.0);
				num3 -= num2 * 4294944443.0;
				if (num3 < 0.0)
				{
					num3 += 4294944443.0;
				}
				x3 = x2;
				x2 = x1;
				x1 = num;
				y3 = y2;
				y2 = y1;
				y1 = num3;
				yield return (num <= num3) ? ((num - num3 + 4294967087.0) * 2.328306549837829E-10) : ((num - num3) * 2.328306549837829E-10);
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class Palf : RandomSource
	{
		private const int DefaultShortLag = 418;

		private const int DefaultLongLag = 1279;

		private const double Reciprocal = 2.3283064365386963E-10;

		[DataMember(Order = 3)]
		private readonly uint[] _x;

		[DataMember(Order = 4)]
		private readonly int _threads;

		[DataMember(Order = 5)]
		private int _k;

		[DataMember(Order = 1)]
		public int ShortLag { get; private set; }

		[DataMember(Order = 2)]
		public int LongLag { get; private set; }

		public Palf()
			: this(RandomSeed.Robust(), Control.ThreadSafeRandomNumberGenerators, 418, 1279)
		{
		}

		public Palf(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe, 418, 1279)
		{
		}

		public Palf(int seed)
			: this(seed, Control.ThreadSafeRandomNumberGenerators, 418, 1279)
		{
		}

		public Palf(int seed, bool threadSafe)
			: this(seed, threadSafe, 418, 1279)
		{
		}

		public Palf(int seed, bool threadSafe, int shortLag, int longLag)
			: base(threadSafe)
		{
			if (shortLag < 1)
			{
				throw new ArgumentException("Value must be positive.", "shortLag");
			}
			if (longLag <= shortLag)
			{
				throw new ArgumentException("The upper bound must be strictly larger than the lower bound.", "longLag");
			}
			if (seed == 0)
			{
				seed = 1;
			}
			_threads = Control.MaxDegreeOfParallelism;
			ShortLag = shortLag;
			if (longLag % _threads == 0)
			{
				LongLag = longLag;
			}
			else
			{
				LongLag = (longLag / _threads + 1) * _threads;
			}
			_x = Generate.Map(MersenneTwister.Doubles(LongLag, seed), (double uniform) => (uint)(uniform * 4294967295.0));
			_k = LongLag;
		}

		private void Fill()
		{
			for (int i = 0; i < _threads; i++)
			{
				for (int j = i; j < ShortLag; j += _threads)
				{
					_x[j] += _x[j + (LongLag - ShortLag)];
				}
				for (int k = ShortLag + i; k < LongLag; k += _threads)
				{
					_x[k] += _x[k - ShortLag - i];
				}
			}
			_k = 0;
		}

		protected sealed override double DoSample()
		{
			if (_k >= LongLag)
			{
				Fill();
			}
			return (double)_x[_k++] * 2.3283064365386963E-10;
		}

		protected override int DoSampleInteger()
		{
			if (_k >= LongLag)
			{
				Fill();
			}
			int num = (int)(_x[_k++] >> 1);
			if (num == int.MaxValue)
			{
				return DoSampleInteger();
			}
			return num;
		}

		public static void Doubles(double[] values, int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			int maxDegreeOfParallelism = Control.MaxDegreeOfParallelism;
			int num = 1279;
			if (num % maxDegreeOfParallelism != 0)
			{
				num = (num / maxDegreeOfParallelism + 1) * maxDegreeOfParallelism;
			}
			uint[] array = Generate.Map(MersenneTwister.Doubles(num, seed), (double uniform) => (uint)(uniform * 4294967295.0));
			int num2 = num;
			for (int i = 0; i < values.Length; i++)
			{
				if (num2 >= num)
				{
					for (int j = 0; j < maxDegreeOfParallelism; j++)
					{
						for (int k = j; k < 418; k += maxDegreeOfParallelism)
						{
							array[k] += array[k + (num - 418)];
						}
						for (int l = 418 + j; l < num; l += maxDegreeOfParallelism)
						{
							array[l] += array[l - 418 - j];
						}
					}
					num2 = 0;
				}
				values[i] = (double)array[num2++] * 2.3283064365386963E-10;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			int threads = Control.MaxDegreeOfParallelism;
			int longLag = 1279;
			if (longLag % threads != 0)
			{
				longLag = (longLag / threads + 1) * threads;
			}
			uint[] x = Generate.Map(MersenneTwister.Doubles(longLag, seed), (double uniform) => (uint)(uniform * 4294967295.0));
			int i = longLag;
			while (true)
			{
				if (i >= longLag)
				{
					for (int j = 0; j < threads; j++)
					{
						for (int k = j; k < 418; k += threads)
						{
							x[k] += x[k + (longLag - 418)];
						}
						for (int l = 418 + j; l < longLag; l += threads)
						{
							x[l] += x[l - 418 - j];
						}
					}
					i = 0;
				}
				yield return (double)x[i++] * 2.3283064365386963E-10;
			}
		}
	}
	public static class RandomExtensions
	{
		public static void NextDoubles(this System.Random rnd, double[] values)
		{
			if (rnd is RandomSource randomSource)
			{
				randomSource.NextDoubles(values);
				return;
			}
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = rnd.NextDouble();
			}
		}

		public static double[] NextDoubles(this System.Random rnd, int count)
		{
			double[] array = new double[count];
			rnd.NextDoubles(array);
			return array;
		}

		public static IEnumerable<double> NextDoubleSequence(this System.Random rnd)
		{
			if (rnd is RandomSource randomSource)
			{
				return randomSource.NextDoubleSequence();
			}
			return NextDoubleSequenceEnumerable(rnd);
		}

		private static IEnumerable<double> NextDoubleSequenceEnumerable(System.Random rnd)
		{
			while (true)
			{
				yield return rnd.NextDouble();
			}
		}

		public static byte[] NextBytes(this System.Random rnd, int count)
		{
			byte[] array = new byte[count];
			rnd.NextBytes(array);
			return array;
		}

		public static void NextInt32s(this System.Random rnd, int[] values)
		{
			if (rnd is RandomSource randomSource)
			{
				randomSource.NextInt32s(values);
				return;
			}
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = rnd.Next();
			}
		}

		public static void NextInt32s(this System.Random rnd, int[] values, int minInclusive, int maxExclusive)
		{
			if (rnd is RandomSource randomSource)
			{
				randomSource.NextInt32s(values, minInclusive, maxExclusive);
				return;
			}
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = rnd.Next(minInclusive, maxExclusive);
			}
		}

		public static IEnumerable<int> NextInt32Sequence(this System.Random rnd, int minInclusive, int maxExclusive)
		{
			if (rnd is RandomSource randomSource)
			{
				return randomSource.NextInt32Sequence(minInclusive, maxExclusive);
			}
			return NextInt32SequenceEnumerable(rnd, minInclusive, maxExclusive);
		}

		private static IEnumerable<int> NextInt32SequenceEnumerable(System.Random rnd, int minInclusive, int maxExclusive)
		{
			while (true)
			{
				yield return rnd.Next(minInclusive, maxExclusive);
			}
		}

		public static long NextInt64(this System.Random rnd)
		{
			byte[] array = new byte[8];
			rnd.NextBytes(array);
			long num = BitConverter.ToInt64(array, 0);
			num &= 0x7FFFFFFFFFFFFFFFL;
			if (num != long.MaxValue)
			{
				return num;
			}
			return rnd.NextInt64();
		}

		public static int NextFullRangeInt32(this System.Random rnd)
		{
			byte[] array = new byte[4];
			rnd.NextBytes(array);
			return BitConverter.ToInt32(array, 0);
		}

		public static long NextFullRangeInt64(this System.Random rnd)
		{
			byte[] array = new byte[8];
			rnd.NextBytes(array);
			return BitConverter.ToInt64(array, 0);
		}

		public static decimal NextDecimal(this System.Random rnd)
		{
			decimal num;
			do
			{
				num = new decimal(rnd.NextFullRangeInt32(), rnd.NextFullRangeInt32(), rnd.NextFullRangeInt32(), isNegative: false, 28);
			}
			while (num >= 1.0m);
			return num;
		}

		public static bool NextBoolean(this System.Random rnd)
		{
			return rnd.NextDouble() >= 0.5;
		}
	}
	public static class RandomSeed
	{
		private static readonly object Lock = new object();

		private static readonly RandomNumberGenerator MasterRng = RandomNumberGenerator.Create();

		public static int Time()
		{
			return Environment.TickCount;
		}

		public static int Guid()
		{
			return Environment.TickCount ^ System.Guid.NewGuid().GetHashCode();
		}

		public static int Robust()
		{
			lock (Lock)
			{
				byte[] array = new byte[4];
				MasterRng.GetBytes(array);
				return BitConverter.ToInt32(array, 0);
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public abstract class RandomSource : System.Random
	{
		private readonly bool _threadSafe;

		private readonly object _lock = new object();

		protected RandomSource()
			: base(RandomSeed.Robust())
		{
			_threadSafe = Control.ThreadSafeRandomNumberGenerators;
		}

		protected RandomSource(bool threadSafe)
			: base(RandomSeed.Robust())
		{
			_threadSafe = threadSafe;
		}

		public void NextDoubles(double[] values)
		{
			if (_threadSafe)
			{
				lock (_lock)
				{
					for (int i = 0; i < values.Length; i++)
					{
						values[i] = DoSample();
					}
					return;
				}
			}
			for (int j = 0; j < values.Length; j++)
			{
				values[j] = DoSample();
			}
		}

		public double[] NextDoubles(int count)
		{
			double[] array = new double[count];
			NextDoubles(array);
			return array;
		}

		public IEnumerable<double> NextDoubleSequence()
		{
			for (int j = 0; j < 64; j++)
			{
				yield return NextDouble();
			}
			double[] buffer = new double[64];
			while (true)
			{
				NextDoubles(buffer);
				for (int j = 0; j < buffer.Length; j++)
				{
					yield return buffer[j];
				}
			}
		}

		public sealed override int Next()
		{
			if (_threadSafe)
			{
				lock (_lock)
				{
					return DoSampleInteger();
				}
			}
			return DoSampleInteger();
		}

		public sealed override int Next(int maxExclusive)
		{
			if (maxExclusive <= 0)
			{
				throw new ArgumentException("Value must be positive.");
			}
			switch (maxExclusive)
			{
			case 1:
				return 0;
			case int.MaxValue:
				return Next();
			default:
				if (_threadSafe)
				{
					lock (_lock)
					{
						return DoSampleInteger(maxExclusive);
					}
				}
				return DoSampleInteger(maxExclusive);
			}
		}

		public sealed override int Next(int minInclusive, int maxExclusive)
		{
			if (minInclusive >= maxExclusive)
			{
				throw new ArgumentException("In the specified range, the exclusive maximum must be greater than the inclusive minimum.");
			}
			if (maxExclusive == minInclusive + 1)
			{
				return minInclusive;
			}
			if (minInclusive == 0)
			{
				if (maxExclusive == int.MaxValue)
				{
					return Next();
				}
				return Next(maxExclusive);
			}
			if (_threadSafe)
			{
				lock (_lock)
				{
					return DoSampleInteger(minInclusive, maxExclusive);
				}
			}
			return DoSampleInteger(minInclusive, maxExclusive);
		}

		public void NextInt32s(int[] values)
		{
			if (_threadSafe)
			{
				lock (_lock)
				{
					for (int i = 0; i < values.Length; i++)
					{
						values[i] = DoSampleInteger();
					}
					return;
				}
			}
			for (int j = 0; j < values.Length; j++)
			{
				values[j] = DoSampleInteger();
			}
		}

		public int[] NextInt32s(int count)
		{
			int[] array = new int[count];
			NextInt32s(array);
			return array;
		}

		public void NextInt32s(int[] values, int maxExclusive)
		{
			if (maxExclusive <= 0)
			{
				throw new ArgumentException("Value must be positive.");
			}
			switch (maxExclusive)
			{
			case 1:
				Array.Clear(values, 0, values.Length);
				return;
			case int.MaxValue:
				NextInt32s(values);
				return;
			}
			if (_threadSafe)
			{
				lock (_lock)
				{
					for (int i = 0; i < values.Length; i++)
					{
						values[i] = DoSampleInteger(maxExclusive);
					}
					return;
				}
			}
			for (int j = 0; j < values.Length; j++)
			{
				values[j] = DoSampleInteger(maxExclusive);
			}
		}

		public int[] NextInt32s(int count, int maxExclusive)
		{
			int[] array = new int[count];
			NextInt32s(array, maxExclusive);
			return array;
		}

		public void NextInt32s(int[] values, int minInclusive, int maxExclusive)
		{
			if (minInclusive >= maxExclusive)
			{
				throw new ArgumentException("In the specified range, the exclusive maximum must be greater than the inclusive minimum.");
			}
			if (maxExclusive == minInclusive + 1)
			{
				for (int i = 0; i < values.Length; i++)
				{
					values[i] = minInclusive;
				}
				return;
			}
			if (minInclusive == 0)
			{
				if (maxExclusive == int.MaxValue)
				{
					NextInt32s(values);
				}
				else
				{
					NextInt32s(values, maxExclusive);
				}
				return;
			}
			if (_threadSafe)
			{
				lock (_lock)
				{
					for (int j = 0; j < values.Length; j++)
					{
						values[j] = DoSampleInteger(minInclusive, maxExclusive);
					}
					return;
				}
			}
			for (int k = 0; k < values.Length; k++)
			{
				values[k] = DoSampleInteger(minInclusive, maxExclusive);
			}
		}

		public int[] NextInt32s(int count, int minInclusive, int maxExclusive)
		{
			int[] array = new int[count];
			NextInt32s(array, minInclusive, maxExclusive);
			return array;
		}

		public IEnumerable<int> NextInt32Sequence()
		{
			for (int j = 0; j < 64; j++)
			{
				yield return Next();
			}
			int[] buffer = new int[64];
			while (true)
			{
				NextInt32s(buffer);
				for (int j = 0; j < buffer.Length; j++)
				{
					yield return buffer[j];
				}
			}
		}

		public IEnumerable<int> NextInt32Sequence(int minInclusive, int maxExclusive)
		{
			if (minInclusive > maxExclusive)
			{
				throw new ArgumentException("In the specified range, the minimum is greater than maximum.");
			}
			for (int j = 0; j < 64; j++)
			{
				yield return Next(minInclusive, maxExclusive);
			}
			int[] buffer = new int[64];
			while (true)
			{
				NextInt32s(buffer, minInclusive, maxExclusive);
				for (int j = 0; j < buffer.Length; j++)
				{
					yield return buffer[j];
				}
			}
		}

		public sealed override void NextBytes(byte[] buffer)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (_threadSafe)
			{
				lock (_lock)
				{
					DoSampleBytes(buffer);
					return;
				}
			}
			DoSampleBytes(buffer);
		}

		protected sealed override double Sample()
		{
			if (_threadSafe)
			{
				lock (_lock)
				{
					return DoSample();
				}
			}
			return DoSample();
		}

		protected abstract double DoSample();

		protected virtual int DoSampleInteger()
		{
			return (int)(DoSample() * 2147483647.0);
		}

		protected virtual void DoSampleBytes(byte[] buffer)
		{
			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i] = (byte)(DoSampleInteger() % 256);
			}
		}

		protected virtual int DoSampleInt32WithNBits(int bitCount)
		{
			if (bitCount == 0)
			{
				return 0;
			}
			byte[] array = new byte[4];
			DoSampleBytes(array);
			return (int)(BitConverter.ToUInt32(array, 0) >> 32 - bitCount);
		}

		protected virtual long DoSampleInt64WithNBits(int bitCount)
		{
			if (bitCount == 0)
			{
				return 0L;
			}
			byte[] array = new byte[8];
			DoSampleBytes(array);
			return (long)(BitConverter.ToUInt64(array, 0) >> 64 - bitCount);
		}

		protected virtual int DoSampleInteger(int maxExclusive)
		{
			int num = maxExclusive.Log2();
			if (num.PowerOfTwo() == maxExclusive)
			{
				return DoSampleInt32WithNBits(num);
			}
			num++;
			int num2;
			do
			{
				num2 = DoSampleInt32WithNBits(num);
			}
			while (num2 >= maxExclusive);
			return num2;
		}

		protected virtual int DoSampleInteger(int minInclusive, int maxExclusive)
		{
			return DoSampleInteger(maxExclusive - minInclusive) + minInclusive;
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class SystemRandomSource : RandomSource
	{
		[DataMember(Order = 1)]
		private readonly System.Random _random;

		private static readonly ThreadLocal<SystemRandomSource> DefaultInstance = new ThreadLocal<SystemRandomSource>(() => new SystemRandomSource(RandomSeed.Robust(), threadSafe: true));

		public static SystemRandomSource Default => DefaultInstance.Value;

		public SystemRandomSource()
			: this(RandomSeed.Robust())
		{
		}

		public SystemRandomSource(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public SystemRandomSource(int seed)
		{
			_random = new System.Random(seed);
		}

		public SystemRandomSource(int seed, bool threadSafe)
			: base(threadSafe)
		{
			_random = new System.Random(seed);
		}

		protected sealed override double DoSample()
		{
			return _random.NextDouble();
		}

		protected override int DoSampleInteger()
		{
			return _random.Next();
		}

		protected override int DoSampleInteger(int maxExclusive)
		{
			return _random.Next(maxExclusive);
		}

		protected override int DoSampleInteger(int minInclusive, int maxExclusive)
		{
			return _random.Next(minInclusive, maxExclusive);
		}

		protected override void DoSampleBytes(byte[] buffer)
		{
			_random.NextBytes(buffer);
		}

		public static void FastDoubles(double[] values)
		{
			if (values.Length < 2048)
			{
				Default.NextDoubles(values);
				return;
			}
			CommonParallel.For(0, values.Length, (values.Length >= 65536) ? 8192 : ((values.Length >= 16384) ? 2048 : 1024), delegate(int a, int b)
			{
				System.Random random = new System.Random(RandomSeed.Robust());
				for (int i = a; i < b; i++)
				{
					values[i] = random.NextDouble();
				}
			});
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] FastDoubles(int length)
		{
			double[] array = new double[length];
			FastDoubles(array);
			return array;
		}

		public static IEnumerable<double> DoubleSequence()
		{
			SystemRandomSource rnd1 = Default;
			for (int i = 0; i < 128; i++)
			{
				yield return rnd1.NextDouble();
			}
			System.Random rnd2 = new System.Random(RandomSeed.Robust());
			while (true)
			{
				yield return rnd2.NextDouble();
			}
		}

		public static void Doubles(double[] values, int seed)
		{
			System.Random random = new System.Random(seed);
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = random.NextDouble();
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			System.Random rnd = new System.Random(seed);
			while (true)
			{
				yield return rnd.NextDouble();
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class WH1982 : RandomSource
	{
		private const uint Modx = 30269u;

		private const double ModxRecip = 3.3037100664045725E-05;

		private const uint Mody = 30307u;

		private const double ModyRecip = 3.2995677566238825E-05;

		private const uint Modz = 30323u;

		private const double ModzRecip = 3.297826732183491E-05;

		[DataMember(Order = 1)]
		private uint _xn;

		[DataMember(Order = 2)]
		private uint _yn = 1u;

		[DataMember(Order = 3)]
		private uint _zn = 1u;

		public WH1982()
			: this(RandomSeed.Robust())
		{
		}

		public WH1982(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public WH1982(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (uint)seed % 30269u;
		}

		public WH1982(int seed, bool threadSafe)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (uint)seed % 30269u;
		}

		protected sealed override double DoSample()
		{
			_xn = 171 * _xn % 30269u;
			_yn = 172 * _yn % 30307u;
			_zn = 170 * _zn % 30323u;
			double num = (double)_xn * 3.3037100664045725E-05 + (double)_yn * 3.2995677566238825E-05 + (double)_zn * 3.297826732183491E-05;
			return num - (double)(int)num;
		}

		public static void Doubles(double[] values, int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			uint num = (uint)seed % 30269u;
			uint num2 = 1u;
			uint num3 = 1u;
			for (int i = 0; i < values.Length; i++)
			{
				num = 171 * num % 30269u;
				num2 = 172 * num2 % 30307u;
				num3 = 170 * num3 % 30323u;
				double num4 = (double)num * 3.3037100664045725E-05 + (double)num2 * 3.2995677566238825E-05 + (double)num3 * 3.297826732183491E-05;
				values[i] = num4 - (double)(int)num4;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			uint xn = (uint)seed % 30269u;
			uint yn = 1u;
			uint zn = 1u;
			while (true)
			{
				xn = 171 * xn % 30269u;
				yn = 172 * yn % 30307u;
				zn = 170 * zn % 30323u;
				double num = (double)xn * 3.3037100664045725E-05 + (double)yn * 3.2995677566238825E-05 + (double)zn * 3.297826732183491E-05;
				yield return num - (double)(int)num;
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class WH2006 : RandomSource
	{
		private const uint Modw = 2147483123u;

		private const double ModwRecip = 4.656614011489952E-10;

		private const uint Modx = 2147483579u;

		private const double ModxRecip = 4.656613022697298E-10;

		private const uint Mody = 2147483543u;

		private const double ModyRecip = 4.65661310075986E-10;

		private const uint Modz = 2147483423u;

		private const double ModzRecip = 4.656613360968421E-10;

		[DataMember(Order = 1)]
		private ulong _wn = 1uL;

		[DataMember(Order = 2)]
		private ulong _xn;

		[DataMember(Order = 3)]
		private ulong _yn = 1uL;

		[DataMember(Order = 4)]
		private ulong _zn = 1uL;

		public WH2006()
			: this(RandomSeed.Robust())
		{
		}

		public WH2006(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public WH2006(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (uint)seed % 2147483579u;
		}

		public WH2006(int seed, bool threadSafe)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_xn = (uint)seed % 2147483579u;
		}

		protected sealed override double DoSample()
		{
			_xn = 11600 * _xn % 2147483579uL;
			_yn = 47003 * _yn % 2147483543uL;
			_zn = 23000 * _zn % 2147483423uL;
			_wn = 33000 * _wn % 2147483123uL;
			double num = (double)_xn * 4.656613022697298E-10 + (double)_yn * 4.65661310075986E-10 + (double)_zn * 4.656613360968421E-10 + (double)_wn * 4.656614011489952E-10;
			return num - (double)(int)num;
		}

		public static void Doubles(double[] values, int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			ulong num = 1uL;
			ulong num2 = (uint)seed % 2147483579u;
			ulong num3 = 1uL;
			ulong num4 = 1uL;
			for (int i = 0; i < values.Length; i++)
			{
				num2 = 11600 * num2 % 2147483579uL;
				num3 = 47003 * num3 % 2147483543uL;
				num4 = 23000 * num4 % 2147483423uL;
				num = 33000 * num % 2147483123uL;
				double num5 = (double)num2 * 4.656613022697298E-10 + (double)num3 * 4.65661310075986E-10 + (double)num4 * 4.656613360968421E-10 + (double)num * 4.656614011489952E-10;
				values[i] = num5 - (double)(int)num5;
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			ulong wn = 1uL;
			ulong xn = (uint)seed % 2147483579u;
			ulong yn = 1uL;
			ulong zn = 1uL;
			while (true)
			{
				xn = 11600 * xn % 2147483579uL;
				yn = 47003 * yn % 2147483543uL;
				zn = 23000 * zn % 2147483423uL;
				wn = 33000 * wn % 2147483123uL;
				double num = (double)xn * 4.656613022697298E-10 + (double)yn * 4.65661310075986E-10 + (double)zn * 4.656613360968421E-10 + (double)wn * 4.656614011489952E-10;
				yield return num - (double)(int)num;
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class Xorshift : RandomSource
	{
		private const uint YSeed = 362436069u;

		private const uint ZSeed = 77465321u;

		private const uint ASeed = 916905990u;

		private const uint CSeed = 13579u;

		private const double UlongToDoubleMultiplier = 2.3283064365386963E-10;

		[DataMember(Order = 1)]
		private ulong _x;

		[DataMember(Order = 2)]
		private ulong _y;

		[DataMember(Order = 3)]
		private ulong _z;

		[DataMember(Order = 4)]
		private ulong _c;

		[DataMember(Order = 5)]
		private readonly ulong _a;

		public Xorshift()
			: this(RandomSeed.Robust())
		{
		}

		public Xorshift(long a, long c, long x1, long x2)
			: this(RandomSeed.Robust(), a, c, x1, x2)
		{
		}

		public Xorshift(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public Xorshift(bool threadSafe, long a, long c, long x1, long x2)
			: this(RandomSeed.Robust(), threadSafe, a, c, x1, x2)
		{
		}

		public Xorshift(int seed)
			: this(seed, Control.ThreadSafeRandomNumberGenerators)
		{
		}

		public Xorshift(int seed, long a, long c, long x1, long x2)
			: this(seed, Control.ThreadSafeRandomNumberGenerators, a, c, x1, x2)
		{
		}

		public Xorshift(int seed, bool threadSafe)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			_x = (uint)seed;
			_y = 362436069uL;
			_z = 77465321uL;
			_c = 13579uL;
			_a = 916905990uL;
		}

		public Xorshift(int seed, bool threadSafe, long a, long c, long x1, long x2)
			: base(threadSafe)
		{
			if (seed == 0)
			{
				seed = 1;
			}
			if (a <= c)
			{
				throw new ArgumentException("a must be greater than c.", "a");
			}
			_x = (uint)seed;
			_y = (ulong)x1;
			_z = (ulong)x2;
			_a = (ulong)a;
			_c = (ulong)c;
		}

		protected sealed override double DoSample()
		{
			ulong num = _a * _x + _c;
			_x = _y;
			_y = _z;
			_c = num >> 32;
			_z = num & 0xFFFFFFFFu;
			return (double)_z * 2.3283064365386963E-10;
		}

		protected sealed override int DoSampleInteger()
		{
			ulong num = _a * _x + _c;
			_x = _y;
			_y = _z;
			_c = num >> 32;
			_z = num & 0xFFFFFFFFu;
			int num2 = (int)((uint)_z >> 1);
			if (num2 == int.MaxValue)
			{
				return DoSampleInteger();
			}
			return num2;
		}

		protected sealed override void DoSampleBytes(byte[] buffer)
		{
			for (int i = 0; i < buffer.Length; i++)
			{
				ulong num = _a * _x + _c;
				_x = _y;
				_y = _z;
				_c = num >> 32;
				_z = num & 0xFFFFFFFFu;
				buffer[i] = (byte)(_z % 256uL);
			}
		}

		[CLSCompliant(false)]
		public static void Doubles(double[] values, int seed, ulong a = 916905990uL, ulong c = 13579uL, ulong x1 = 362436069uL, ulong x2 = 77465321uL)
		{
			if (a <= c)
			{
				throw new ArgumentException("a must be greater than c.", "a");
			}
			if (seed == 0)
			{
				seed = 1;
			}
			ulong num = (uint)seed;
			for (int i = 0; i < values.Length; i++)
			{
				ulong num2 = a * num + c;
				num = x1;
				x1 = x2;
				c = num2 >> 32;
				x2 = num2 & 0xFFFFFFFFu;
				values[i] = (double)x2 * 2.3283064365386963E-10;
			}
		}

		[CLSCompliant(false)]
		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed, ulong a = 916905990uL, ulong c = 13579uL, ulong x1 = 362436069uL, ulong x2 = 77465321uL)
		{
			double[] array = new double[length];
			Doubles(array, seed, a, c, x1, x2);
			return array;
		}

		[CLSCompliant(false)]
		public static IEnumerable<double> DoubleSequence(int seed, ulong a = 916905990uL, ulong c = 13579uL, ulong x1 = 362436069uL, ulong x2 = 77465321uL)
		{
			if (a <= c)
			{
				throw new ArgumentException("a must be greater than c.", "a");
			}
			if (seed == 0)
			{
				seed = 1;
			}
			ulong x3 = (uint)seed;
			while (true)
			{
				ulong num = a * x3 + c;
				x3 = x1;
				x1 = x2;
				c = num >> 32;
				x2 = num & 0xFFFFFFFFu;
				yield return (double)x2 * 2.3283064365386963E-10;
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/Random")]
	public class Xoshiro256StarStar : RandomSource
	{
		private const double REAL_UNIT_UINT = 1.1102230246251565E-16;

		[DataMember(Order = 1)]
		private ulong _s0;

		[DataMember(Order = 2)]
		private ulong _s1;

		[DataMember(Order = 3)]
		private ulong _s2;

		[DataMember(Order = 4)]
		private ulong _s3;

		public Xoshiro256StarStar()
			: this(RandomSeed.Robust())
		{
		}

		public Xoshiro256StarStar(bool threadSafe)
			: this(RandomSeed.Robust(), threadSafe)
		{
		}

		public Xoshiro256StarStar(int seed)
		{
			Initialise(seed);
		}

		public Xoshiro256StarStar(int seed, bool threadSafe)
			: base(threadSafe)
		{
			Initialise(seed);
		}

		protected sealed override double DoSample()
		{
			return (double)(NextInnerULong() >> 11) * 1.1102230246251565E-16;
		}

		protected override int DoSampleInteger()
		{
			ulong num;
			do
			{
				num = NextInnerULong() & 0x7FFFFFFF;
			}
			while (num == int.MaxValue);
			return (int)num;
		}

		protected override void DoSampleBytes(byte[] buffer)
		{
			ulong num = _s0;
			ulong num2 = _s1;
			ulong num3 = _s2;
			ulong num4 = _s3;
			int num5 = 0;
			int num6 = buffer.Length - 3;
			while (num5 < num6)
			{
				ulong num7 = RotateLeft(num2 * 5, 7) * 9;
				ulong num8 = num2 << 17;
				num3 ^= num;
				num4 ^= num2;
				num2 ^= num3;
				num ^= num4;
				num3 ^= num8;
				num4 = RotateLeft(num4, 45);
				buffer[num5++] = (byte)num7;
				buffer[num5++] = (byte)(num7 >> 8);
				buffer[num5++] = (byte)(num7 >> 16);
				buffer[num5++] = (byte)(num7 >> 24);
				buffer[num5++] = (byte)(num7 >> 32);
				buffer[num5++] = (byte)(num7 >> 40);
				buffer[num5++] = (byte)(num7 >> 48);
				buffer[num5++] = (byte)(num7 >> 56);
			}
			if (num5 < buffer.Length)
			{
				ulong num9 = RotateLeft(num2 * 5, 7) * 9;
				ulong num10 = num2 << 17;
				num3 ^= num;
				num4 ^= num2;
				num2 ^= num3;
				num ^= num4;
				num3 ^= num10;
				num4 = RotateLeft(num4, 45);
				while (num5 < buffer.Length)
				{
					buffer[num5++] = (byte)num9;
					num9 >>= 8;
				}
			}
			_s0 = num;
			_s1 = num2;
			_s2 = num3;
			_s3 = num4;
		}

		protected override int DoSampleInt32WithNBits(int bitCount)
		{
			return (int)(NextInnerULong() >> 64 - bitCount);
		}

		protected override long DoSampleInt64WithNBits(int bitCount)
		{
			return (long)(NextInnerULong() >> 64 - bitCount);
		}

		private void Initialise(int seed)
		{
			ulong x = (ulong)seed;
			_s0 = Splitmix64(ref x);
			_s1 = Splitmix64(ref x);
			_s2 = Splitmix64(ref x);
			_s3 = Splitmix64(ref x);
		}

		private ulong NextInnerULong()
		{
			ulong s = _s0;
			ulong s2 = _s1;
			ulong s3 = _s2;
			ulong s4 = _s3;
			ulong result = RotateLeft(s2 * 5, 7) * 9;
			ulong num = s2 << 17;
			s3 ^= s;
			s4 ^= s2;
			s2 ^= s3;
			s ^= s4;
			s3 ^= num;
			s4 = RotateLeft(s4, 45);
			_s0 = s;
			_s1 = s2;
			_s2 = s3;
			_s3 = s4;
			return result;
		}

		public static void Doubles(double[] values, int seed)
		{
			ulong x = (ulong)seed;
			ulong num = Splitmix64(ref x);
			ulong num2 = Splitmix64(ref x);
			ulong num3 = Splitmix64(ref x);
			ulong num4 = Splitmix64(ref x);
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = (double)(RotateLeft(num2 * 5, 7) * 9 >> 11) * 1.1102230246251565E-16;
				ulong num5 = num2 << 17;
				num3 ^= num;
				num4 ^= num2;
				num2 ^= num3;
				num ^= num4;
				num3 ^= num5;
				num4 = RotateLeft(num4, 45);
			}
		}

		[TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		public static double[] Doubles(int length, int seed)
		{
			double[] array = new double[length];
			Doubles(array, seed);
			return array;
		}

		public static IEnumerable<double> DoubleSequence(int seed)
		{
			ulong x = (ulong)seed;
			ulong s0 = Splitmix64(ref x);
			ulong s1 = Splitmix64(ref x);
			ulong s3 = Splitmix64(ref x);
			ulong s5 = Splitmix64(ref x);
			while (true)
			{
				double num = (double)(RotateLeft(s1 * 5, 7) * 9 >> 11) * 1.1102230246251565E-16;
				ulong num2 = s1 << 17;
				s3 ^= s0;
				s5 ^= s1;
				s1 ^= s3;
				s0 ^= s5;
				s3 ^= num2;
				s5 = RotateLeft(s5, 45);
				yield return num;
			}
		}

		private static ulong Splitmix64(ref ulong x)
		{
			ulong num = (x += 11400714819323198485uL);
			long num2 = (long)(num ^ (num >> 30)) * -4658895280553007687L;
			long num3 = (long)((ulong)num2 ^ ((ulong)num2 >> 27)) * -7723592293110705685L;
			return (ulong)num3 ^ ((ulong)num3 >> 31);
		}

		private static ulong RotateLeft(ulong x, int k)
		{
			return (x << k) | (x >> 64 - k);
		}
	}
}
namespace MathNet.Numerics.Providers.SparseSolver
{
	public enum DssMatrixStructure
	{
		Symmetric = 536870976,
		SymmetricStructure = 536871040,
		Nonsymmetric = 536871104,
		SymmetricComplex = 536871168,
		SymmetricStructureComplex = 536871232,
		NonsymmetricComplex = 536871296
	}
	public enum DssMatrixType
	{
		PositiveDefinite = 134217792,
		Indefinite = 134217856,
		HermitianPositiveDefinite = 134217920,
		HermitianIndefinite = 134217984
	}
	public enum DssSystemType
	{
		DontTranspose = 0,
		Transpose = 0x40000,
		ConjugateTranspose = 0x80000
	}
	public enum DssStatus
	{
		MKL_DSS_SUCCESS = 0,
		MKL_DSS_ZERO_PIVOT = -1,
		MKL_DSS_OUT_OF_MEMORY = -2,
		MKL_DSS_FAILURE = -3,
		MKL_DSS_ROW_ERR = -4,
		MKL_DSS_COL_ERR = -5,
		MKL_DSS_TOO_FEW_VALUES = -6,
		MKL_DSS_TOO_MANY_VALUES = -7,
		MKL_DSS_NOT_SQUARE = -8,
		MKL_DSS_STATE_ERR = -9,
		MKL_DSS_INVALID_OPTION = -10,
		MKL_DSS_OPTION_CONFLICT = -11,
		MKL_DSS_MSG_LVL_ERR = -12,
		MKL_DSS_TERM_LVL_ERR = -13,
		MKL_DSS_STRUCTURE_ERR = -14,
		MKL_DSS_REORDER_ERR = -15,
		MKL_DSS_VALUES_ERR = -16,
		MKL_DSS_STATISTICS_INVALID_MATRIX = -17,
		MKL_DSS_STATISTICS_INVALID_STATE = -18,
		MKL_DSS_STATISTICS_INVALID_STRING = -19,
		MKL_DSS_REORDER1_ERR = -20,
		MKL_DSS_PREORDER_ERR = -21,
		MKL_DSS_DIAG_ERR = -22,
		MKL_DSS_I32BIT_ERR = -23,
		MKL_DSS_OOC_MEM_ERR = -24,
		MKL_DSS_OOC_OC_ERR = -25,
		MKL_DSS_OOC_RW_ERR = -26
	}
	public interface ISparseSolverProvider : ISparseSolverProvider<double>, ISparseSolverProvider<float>, ISparseSolverProvider<Complex>, ISparseSolverProvider<Complex32>
	{
		bool IsAvailable();

		void InitializeVerify();

		void FreeResources();
	}
	public interface ISparseSolverProvider<T> where T : struct
	{
		DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rows, int cols, int nnz, int[] rowIdx, int[] colPtr, T[] values, int nRhs, T[] rhs, T[] solution);
	}
	public static class SparseSolverControl
	{
		private const string EnvVarSSProvider = "MathNetNumericsSSProvider";

		private const string EnvVarSSProviderPath = "MathNetNumericsSSProviderPath";

		private static ISparseSolverProvider _sparseSolverProvider;

		private static readonly object StaticLock = new object();

		public static ISparseSolverProvider Provider
		{
			get
			{
				if (_sparseSolverProvider == null)
				{
					lock (StaticLock)
					{
						if (_sparseSolverProvider == null)
						{
							UseDefault();
						}
					}
				}
				return _sparseSolverProvider;
			}
			set
			{
				value.InitializeVerify();
				_sparseSolverProvider = value;
			}
		}

		public static string HintPath { get; set; }

		public static ISparseSolverProvider CreateManaged()
		{
			return new ManagedSparseSolverProvider();
		}

		public static void UseManaged()
		{
			Provider = CreateManaged();
		}

		public static ISparseSolverProvider CreateNativeMKL()
		{
			return new MklSparseSolverProvider(GetCombinedHintPath());
		}

		public static void UseNativeMKL()
		{
			Provider = CreateNativeMKL();
		}

		public static bool TryUseNativeMKL()
		{
			return TryUse(CreateNativeMKL());
		}

		public static bool TryUseNative()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				return false;
			}
			return TryUseNativeMKL();
		}

		private static bool TryUse(ISparseSolverProvider provider)
		{
			try
			{
				if (!provider.IsAvailable())
				{
					return false;
				}
				Provider = provider;
				return true;
			}
			catch
			{
				return false;
			}
		}

		public static void UseBest()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				UseManaged();
			}
			else if (!TryUseNative())
			{
				UseManaged();
			}
		}

		public static void UseDefault()
		{
			if (AppSwitches.DisableNativeProviders)
			{
				UseManaged();
				return;
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MathNetNumericsSSProvider");
			string text = ((environmentVariable != null) ? environmentVariable.ToUpperInvariant() : string.Empty);
			if (text != null && text == "MKL")
			{
				UseNativeMKL();
			}
			else
			{
				UseBest();
			}
		}

		public static void FreeResources()
		{
			Provider.FreeResources();
		}

		private static string GetCombinedHintPath()
		{
			if (!string.IsNullOrEmpty(HintPath))
			{
				return HintPath;
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MathNetNumericsSSProviderPath");
			if (!string.IsNullOrEmpty(environmentVariable))
			{
				return environmentVariable;
			}
			return null;
		}
	}
}
namespace MathNet.Numerics.Providers.SparseSolver.Mkl
{
	internal class MklSparseSolverProvider : ManagedSparseSolverProvider, IDisposable
	{
		private const int MinimumCompatibleRevision = 14;

		private readonly string _hintPath;

		private int sparseSolverMajor;

		private int sparseSolverMinor;

		[SecuritySafeCritical]
		public override DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, Complex[] values, int nRhs, Complex[] rhs, Complex[] solution)
		{
			if (rowCount != columnCount)
			{
				throw new ArgumentException("Matrix must be symmetric.");
			}
			if (rowPointers == null)
			{
				throw new ArgumentNullException("rowPointers");
			}
			if (columnIndices == null)
			{
				throw new ArgumentNullException("columnIndices");
			}
			if (values == null)
			{
				throw new ArgumentNullException("values");
			}
			if (rhs == null)
			{
				throw new ArgumentNullException("rhs");
			}
			if (solution == null)
			{
				throw new ArgumentNullException("solution");
			}
			if (rowCount * nRhs != rhs.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "rhs");
			}
			if (columnCount * nRhs != solution.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "solution");
			}
			return (DssStatus)MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_dss_solve((int)matrixStructure, (int)matrixType, (int)systemType, rowCount, columnCount, nonZerosCount, rowPointers, columnIndices, values, nRhs, rhs, solution);
		}

		[SecuritySafeCritical]
		public override DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, Complex32[] values, int nRhs, Complex32[] rhs, Complex32[] solution)
		{
			if (rowCount != columnCount)
			{
				throw new ArgumentException("Matrix must be symmetric.");
			}
			if (rowPointers == null)
			{
				throw new ArgumentNullException("rowPointers");
			}
			if (columnIndices == null)
			{
				throw new ArgumentNullException("columnIndices");
			}
			if (values == null)
			{
				throw new ArgumentNullException("values");
			}
			if (rhs == null)
			{
				throw new ArgumentNullException("rhs");
			}
			if (solution == null)
			{
				throw new ArgumentNullException("solution");
			}
			if (rowCount * nRhs != rhs.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "rhs");
			}
			if (columnCount * nRhs != solution.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "solution");
			}
			return (DssStatus)MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_dss_solve((int)matrixStructure, (int)matrixType, (int)systemType, rowCount, columnCount, nonZerosCount, rowPointers, columnIndices, values, nRhs, rhs, solution);
		}

		internal MklSparseSolverProvider(string hintPath)
		{
			_hintPath = hintPath;
		}

		public override bool IsAvailable()
		{
			return MklProvider.IsAvailable(_hintPath);
		}

		public override void InitializeVerify()
		{
			int num = MklProvider.Load(_hintPath);
			if (num < 14)
			{
				throw new NotSupportedException($"MKL Native Provider revision r{num} is too old. Consider upgrading to a newer version. Revision r{14} and newer are supported.");
			}
			sparseSolverMajor = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(512);
			sparseSolverMinor = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(513);
			if (sparseSolverMajor != 1 || sparseSolverMinor < 0)
			{
				throw new NotSupportedException($"MKL Native Provider not compatible. Expecting sparse solver v1 but provider implements v{sparseSolverMajor}.");
			}
		}

		public override void FreeResources()
		{
			MklProvider.FreeResources();
		}

		public override string ToString()
		{
			return MklProvider.Describe();
		}

		public void Dispose()
		{
			FreeResources();
		}

		[SecuritySafeCritical]
		public override DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, double[] values, int nRhs, double[] rhs, double[] solution)
		{
			if (rowCount != columnCount)
			{
				throw new ArgumentException("Matrix must be symmetric.");
			}
			if (rowPointers == null)
			{
				throw new ArgumentNullException("rowPointers");
			}
			if (columnIndices == null)
			{
				throw new ArgumentNullException("columnIndices");
			}
			if (values == null)
			{
				throw new ArgumentNullException("values");
			}
			if (rhs == null)
			{
				throw new ArgumentNullException("rhs");
			}
			if (solution == null)
			{
				throw new ArgumentNullException("solution");
			}
			if (rowCount * nRhs != rhs.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "rhs");
			}
			if (columnCount * nRhs != solution.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "solution");
			}
			return (DssStatus)MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_dss_solve((int)matrixStructure, (int)matrixType, (int)systemType, rowCount, columnCount, nonZerosCount, rowPointers, columnIndices, values, nRhs, rhs, solution);
		}

		[SecuritySafeCritical]
		public override DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, float[] values, int nRhs, float[] rhs, float[] solution)
		{
			if (rowCount != columnCount)
			{
				throw new ArgumentException("Matrix must be symmetric.");
			}
			if (rowPointers == null)
			{
				throw new ArgumentNullException("rowPointers");
			}
			if (columnIndices == null)
			{
				throw new ArgumentNullException("columnIndices");
			}
			if (values == null)
			{
				throw new ArgumentNullException("values");
			}
			if (rhs == null)
			{
				throw new ArgumentNullException("rhs");
			}
			if (solution == null)
			{
				throw new ArgumentNullException("solution");
			}
			if (rowCount * nRhs != rhs.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "rhs");
			}
			if (columnCount * nRhs != solution.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "solution");
			}
			return (DssStatus)MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_dss_solve((int)matrixStructure, (int)matrixType, (int)systemType, rowCount, columnCount, nonZerosCount, rowPointers, columnIndices, values, nRhs, rhs, solution);
		}
	}
}
namespace MathNet.Numerics.Providers.SparseSolver.Managed
{
	internal class ManagedSparseSolverProvider : ISparseSolverProvider, ISparseSolverProvider<double>, ISparseSolverProvider<float>, ISparseSolverProvider<Complex>, ISparseSolverProvider<Complex32>
	{
		public virtual bool IsAvailable()
		{
			return true;
		}

		public virtual void InitializeVerify()
		{
		}

		public virtual void FreeResources()
		{
		}

		public override string ToString()
		{
			return "Managed";
		}

		public virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] ColumnIndices, float[] values, int nRhs, float[] rhs, float[] solution)
		{
			throw new NotImplementedException();
		}

		public virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] ColumnIndices, double[] values, int nRhs, double[] rhs, double[] solution)
		{
			throw new NotImplementedException();
		}

		public virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] ColumnIndices, Complex32[] values, int nRhs, Complex32[] rhs, Complex32[] solution)
		{
			throw new NotImplementedException();
		}

		public virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] ColumnIndices, Complex[] values, int nRhs, Complex[] rhs, Complex[] solution)
		{
			throw new NotImplementedException();
		}
	}
}
namespace MathNet.Numerics.Providers.LinearAlgebra
{
	public enum Transpose
	{
		DontTranspose = 111,
		Transpose,
		ConjugateTranspose
	}
	public enum Norm : byte
	{
		OneNorm = 49,
		FrobeniusNorm = 102,
		InfinityNorm = 105,
		LargestAbsoluteValue = 109
	}
	public interface ILinearAlgebraProvider : ILinearAlgebraProvider<double>, ILinearAlgebraProvider<float>, ILinearAlgebraProvider<Complex>, ILinearAlgebraProvider<Complex32>
	{
		bool IsAvailable();

		void InitializeVerify();

		void FreeResources();
	}
	public interface ILinearAlgebraProvider<T> where T : struct
	{
		void AddVectorToScaledVector(T[] y, T alpha, T[] x, T[] result);

		void ScaleArray(T alpha, T[] x, T[] result);

		void ConjugateArray(T[] x, T[] result);

		T DotProduct(T[] x, T[] y);

		void AddArrays(T[] x, T[] y, T[] result);

		void SubtractArrays(T[] x, T[] y, T[] result);

		void PointWiseMultiplyArrays(T[] x, T[] y, T[] result);

		void PointWiseDivideArrays(T[] x, T[] y, T[] result);

		void PointWisePowerArrays(T[] x, T[] y, T[] result);

		double MatrixNorm(Norm norm, int rows, int columns, T[] matrix);

		void MatrixMultiply(T[] x, int rowsX, int columnsX, T[] y, int rowsY, int columnsY, T[] result);

		void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, T alpha, T[] a, int rowsA, int columnsA, T[] b, int rowsB, int columnsB, T beta, T[] c);

		void LUFactor(T[] data, int order, int[] ipiv);

		void LUInverse(T[] a, int order);

		void LUInverseFactored(T[] a, int order, int[] ipiv);

		void LUSolve(int columnsOfB, T[] a, int order, T[] b);

		void LUSolveFactored(int columnsOfB, T[] a, int order, int[] ipiv, T[] b);

		void CholeskyFactor(T[] a, int order);

		void CholeskySolve(T[] a, int orderA, T[] b, int columnsB);

		void CholeskySolveFactored(T[] a, int orderA, T[] b, int columnsB);

		void QRFactor(T[] a, int rowsA, int columnsA, T[] q, T[] tau);

		void ThinQRFactor(T[] a, int rowsA, int columnsA, T[] r, T[] tau);

		void QRSolve(T[] a, int rows, int columns, T[] b, int columnsB, T[] x, QRMethod method = QRMethod.Full);

		void QRSolveFactored(T[] q, T[] r, int rowsA, int columnsA, T[] tau, T[] b, int columnsB, T[] x, QRMethod method = QRMethod.Full);

		void SingularValueDecomposition(bool computeVectors, T[] a, int rowsA, int columnsA, T[] s, T[] u, T[] vt);

		void SvdSolve(T[] a, int rowsA, int columnsA, T[] b, int columnsB, T[] x);

		void SvdSolveFactored(int rowsA, int columnsA, T[] s, T[] u, T[] vt, T[] b, int columnsB, T[] x);

		void EigenDecomp(bool isSymmetric, int order, T[] matrix, T[] matrixEv, Complex[] vectorEv, T[] matrixD);
	}
	public static class LinearAlgebraControl
	{
		private const string EnvVarLAProvider = "MathNetNumericsLAProvider";

		private const string EnvVarLAProviderPath = "MathNetNumericsLAProviderPath";

		private static ILinearAlgebraProvider _linearAlgebraProvider;

		private static readonly object StaticLock = new object();

		public static ILinearAlgebraProvider Provider
		{
			get
			{
				if (_linearAlgebraProvider == null)
				{
					lock (StaticLock)
					{
						if (_linearAlgebraProvider == null)
						{
							UseDefault();
						}
					}
				}
				return _linearAlgebraProvider;
			}
			set
			{
				value.InitializeVerify();
				_linearAlgebraProvider = value;
			}
		}

		public static string HintPath { get; set; }

		public static ILinearAlgebraProvider CreateManaged()
		{
			return new ManagedLinearAlgebraProvider();
		}

		public static void UseManaged()
		{
			Provider = CreateManaged();
		}

		internal static ILinearAlgebraProvider CreateManagedReference()
		{
			return new ManagedReferenceLinearAlgebraProvider();
		}

		internal static void UseManagedReference()
		{
			Provider = CreateManagedReference();
		}

		[CLSCompliant(false)]
		public static ILinearAlgebraProvider CreateNativeMKL(MklConsistency consistency = MklConsistency.Auto, MklPrecision precision = MklPrecision.Double, MklAccuracy accuracy = MklAccuracy.High)
		{
			return new MklLinearAlgebraProvider(GetCombinedHintPath(), consistency, precision, accuracy);
		}

		[CLSCompliant(false)]
		public static void UseNativeMKL(MklConsistency consistency = MklConsistency.Auto, MklPrecision precision = MklPrecision.Double, MklAccuracy accuracy = MklAccuracy.High)
		{
			Provider = CreateNativeMKL(consistency, precision, accuracy);
		}

		[CLSCompliant(false)]
		public static bool TryUseNativeMKL(MklConsistency consistency = MklConsistency.Auto, MklPrecision precision = MklPrecision.Double, MklAccuracy accuracy = MklAccuracy.High)
		{
			return TryUse(CreateNativeMKL(consistency, precision, accuracy));
		}

		public static ILinearAlgebraProvider CreateNativeCUDA()
		{
			return new CudaLinearAlgebraProvider(GetCombinedHintPath());
		}

		public static void UseNativeCUDA()
		{
			Provider = CreateNativeCUDA();
		}

		public static bool TryUseNativeCUDA()
		{
			return TryUse(CreateNativeCUDA());
		}

		public static ILinearAlgebraProvider CreateNativeOpenBLAS()
		{
			return new OpenBlasLinearAlgebraProvider(GetCombinedHintPath());
		}

		public static void UseNativeOpenBLAS()
		{
			Provider = CreateNativeOpenBLAS();
		}

		public static bool TryUseNativeOpenBLAS()
		{
			return TryUse(CreateNativeOpenBLAS());
		}

		public static bool TryUseNative()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				return false;
			}
			if (!TryUseNativeMKL() && !TryUseNativeOpenBLAS())
			{
				return TryUseNativeCUDA();
			}
			return true;
		}

		private static bool TryUse(ILinearAlgebraProvider provider)
		{
			try
			{
				if (!provider.IsAvailable())
				{
					return false;
				}
				Provider = provider;
				return true;
			}
			catch
			{
				return false;
			}
		}

		public static void UseBest()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				UseManaged();
			}
			else if (!TryUseNative())
			{
				UseManaged();
			}
		}

		public static void UseDefault()
		{
			if (AppSwitches.DisableNativeProviders)
			{
				UseManaged();
				return;
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MathNetNumericsLAProvider");
			switch ((environmentVariable != null) ? environmentVariable.ToUpperInvariant() : string.Empty)
			{
			case "MKL":
				UseNativeMKL();
				break;
			case "CUDA":
				UseNativeCUDA();
				break;
			case "OPENBLAS":
				UseNativeOpenBLAS();
				break;
			default:
				UseBest();
				break;
			}
		}

		public static void FreeResources()
		{
			Provider.FreeResources();
		}

		private static string GetCombinedHintPath()
		{
			if (!string.IsNullOrEmpty(HintPath))
			{
				return HintPath;
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MathNetNumericsLAProviderPath");
			if (!string.IsNullOrEmpty(environmentVariable))
			{
				return environmentVariable;
			}
			return null;
		}
	}
}
namespace MathNet.Numerics.Providers.LinearAlgebra.OpenBlas
{
	internal class OpenBlasLinearAlgebraProvider : ManagedLinearAlgebraProvider, IDisposable
	{
		private const int MinimumCompatibleRevision = 1;

		private readonly string _hintPath;

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, Complex[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override Complex DotProduct(Complex[] x, Complex[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(Complex[] y, Complex alpha, Complex[] x, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (!(alpha == Complex.Zero))
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(Complex alpha, Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (!(alpha == Complex.One))
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(Complex[] x, int rowsX, int columnsX, Complex[] y, int rowsY, int columnsY, Complex[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, Complex.One, x, rowsX, columnsX, y, rowsY, columnsY, Complex.Zero, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] a, int rowsA, int columnsA, Complex[] b, int rowsB, int columnsB, Complex beta, Complex[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(Complex[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(Complex[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, Complex[] a, int order, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, Complex[] a, int order, int[] ipiv, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_cholesky_factor(order, a);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(Complex[] r, int rowsR, int columnsR, Complex[] q, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(Complex[] q, int rowsA, int columnsA, Complex[] r, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(Complex[] a, int rows, int columns, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(Complex[] q, Complex[] r, int rowsA, int columnsA, Complex[] tau, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(Complex[] a, int rowsA, int columnsA, Complex[] b, int columnsB, Complex[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex[] s = new Complex[Math.Min(rowsA, columnsA)];
			Complex[] u = new Complex[rowsA * rowsA];
			Complex[] vt = new Complex[columnsA * columnsA];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, Complex[] a, int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void EigenDecomp(bool isSymmetric, int order, Complex[] matrix, Complex[] matrixEv, Complex[] vectorEv, Complex[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.z_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, Complex32[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override Complex32 DotProduct(Complex32[] x, Complex32[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(Complex32[] y, Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (!(alpha == Complex32.Zero))
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (!(alpha == Complex32.One))
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(Complex32[] x, int rowsX, int columnsX, Complex32[] y, int rowsY, int columnsY, Complex32[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, Complex32.One, x, rowsX, columnsX, y, rowsY, columnsY, Complex32.Zero, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] a, int rowsA, int columnsA, Complex32[] b, int rowsB, int columnsB, Complex32 beta, Complex32[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(Complex32[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(Complex32[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, Complex32[] a, int order, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, Complex32[] a, int order, int[] ipiv, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_cholesky_factor(order, a);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(Complex32[] r, int rowsR, int columnsR, Complex32[] q, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(Complex32[] q, int rowsA, int columnsA, Complex32[] r, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(Complex32[] a, int rows, int columns, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(Complex32[] q, Complex32[] r, int rowsA, int columnsA, Complex32[] tau, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(Complex32[] a, int rowsA, int columnsA, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex32[] s = new Complex32[Math.Min(rowsA, columnsA)];
			Complex32[] u = new Complex32[rowsA * rowsA];
			Complex32[] vt = new Complex32[columnsA * columnsA];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, Complex32[] a, int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void EigenDecomp(bool isSymmetric, int order, Complex32[] matrix, Complex32[] matrixEv, Complex[] vectorEv, Complex32[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.c_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		internal OpenBlasLinearAlgebraProvider(string hintPath)
		{
			_hintPath = hintPath;
		}

		public override bool IsAvailable()
		{
			return OpenBlasProvider.IsAvailable(_hintPath);
		}

		public override void InitializeVerify()
		{
			int num = OpenBlasProvider.Load(_hintPath);
			if (num < 1)
			{
				throw new NotSupportedException(FormattableString.Invariant($"OpenBLAS Native Provider revision r{num} is too old. Consider upgrading to a newer version. Revision r{1} and newer are supported."));
			}
			int num2 = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.query_capability(128);
			if (num2 != 1)
			{
				throw new NotSupportedException(FormattableString.Invariant($"OpenBLAS Native Provider not compatible. Expecting linear algebra v1 but provider implements v{num2}."));
			}
		}

		public override void FreeResources()
		{
			OpenBlasProvider.FreeResources();
		}

		public override string ToString()
		{
			return OpenBlasProvider.Describe();
		}

		public void Dispose()
		{
			FreeResources();
		}

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, double[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override double DotProduct(double[] x, double[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(double[] y, double alpha, double[] x, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (alpha != 0.0)
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(double alpha, double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (alpha != 1.0)
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(double[] x, int rowsX, int columnsX, double[] y, int rowsY, int columnsY, double[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, 1.0, x, rowsX, columnsX, y, rowsY, columnsY, 0.0, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, double alpha, double[] a, int rowsA, int columnsA, double[] b, int rowsB, int columnsB, double beta, double[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(double[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(double[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, double[] a, int order, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, double[] a, int order, int[] ipiv, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_cholesky_factor(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(double[] r, int rowsR, int columnsR, double[] q, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(double[] q, int rowsA, int columnsA, double[] r, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(double[] a, int rows, int columns, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(double[] q, double[] r, int rowsA, int columnsA, double[] tau, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(double[] a, int rowsA, int columnsA, double[] b, int columnsB, double[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			double[] s = new double[Math.Min(rowsA, columnsA)];
			double[] u = new double[rowsA * rowsA];
			double[] vt = new double[columnsA * columnsA];
			double[] array = new double[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, double[] a, int rowsA, int columnsA, double[] s, double[] u, double[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void EigenDecomp(bool isSymmetric, int order, double[] matrix, double[] matrixEv, Complex[] vectorEv, double[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.d_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, float[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override float DotProduct(float[] x, float[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(float[] y, float alpha, float[] x, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (alpha != 0f)
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(float alpha, float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (alpha != 1f)
			{
				MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(float[] x, int rowsX, int columnsX, float[] y, int rowsY, int columnsY, float[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, 1f, x, rowsX, columnsX, y, rowsY, columnsY, 0f, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, float alpha, float[] a, int rowsA, int columnsA, float[] b, int rowsB, int columnsB, float beta, float[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(float[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(float[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, float[] a, int order, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, float[] a, int order, int[] ipiv, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_cholesky_factor(order, a);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(float[] r, int rowsR, int columnsR, float[] q, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(float[] q, int rowsA, int columnsA, float[] r, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(float[] a, int rows, int columns, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(float[] q, float[] r, int rowsA, int columnsA, float[] tau, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(float[] a, int rowsA, int columnsA, float[] b, int columnsB, float[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			float[] s = new float[Math.Min(rowsA, columnsA)];
			float[] u = new float[rowsA * rowsA];
			float[] vt = new float[columnsA * columnsA];
			float[] array = new float[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, float[] a, int rowsA, int columnsA, float[] s, float[] u, float[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void EigenDecomp(bool isSymmetric, int order, float[] matrix, float[] matrixEv, Complex[] vectorEv, float[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.OpenBlas.SafeNativeMethods.s_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}
	}
	public enum NativeError
	{
		MemoryAllocation = -999999
	}
	internal enum ParallelType
	{
		Sequential,
		Thread,
		OpenMP
	}
}
namespace MathNet.Numerics.Providers.LinearAlgebra.Mkl
{
	internal class MklLinearAlgebraProvider : ManagedLinearAlgebraProvider, IDisposable
	{
		private const int MinimumCompatibleRevision = 4;

		private readonly string _hintPath;

		private readonly MklConsistency _consistency;

		private readonly MklPrecision _precision;

		private readonly MklAccuracy _accuracy;

		private int _linearAlgebraMajor;

		private int _linearAlgebraMinor;

		private int _vectorFunctionsMajor;

		private int _vectorFunctionsMinor;

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, Complex[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override Complex DotProduct(Complex[] x, Complex[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(Complex[] y, Complex alpha, Complex[] x, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (!(alpha == Complex.Zero))
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(Complex alpha, Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (!(alpha == Complex.One))
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(Complex[] x, int rowsX, int columnsX, Complex[] y, int rowsY, int columnsY, Complex[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, Complex.One, x, rowsX, columnsX, y, rowsY, columnsY, Complex.Zero, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] a, int rowsA, int columnsA, Complex[] b, int rowsB, int columnsB, Complex beta, Complex[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(Complex[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(Complex[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, Complex[] a, int order, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, Complex[] a, int order, int[] ipiv, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_cholesky_factor(order, a);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(Complex[] r, int rowsR, int columnsR, Complex[] q, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(Complex[] q, int rowsA, int columnsA, Complex[] r, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(Complex[] a, int rows, int columns, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(Complex[] q, Complex[] r, int rowsA, int columnsA, Complex[] tau, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(Complex[] a, int rowsA, int columnsA, Complex[] b, int columnsB, Complex[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex[] s = new Complex[Math.Min(rowsA, columnsA)];
			Complex[] u = new Complex[rowsA * rowsA];
			Complex[] vt = new Complex[columnsA * columnsA];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, Complex[] a, int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void AddArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_vector_add(x.Length, x, y, result);
		}

		public override void SubtractArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_vector_subtract(x.Length, x, y, result);
		}

		public override void PointWiseMultiplyArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_vector_multiply(x.Length, x, y, result);
		}

		public override void PointWisePowerArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (_vectorFunctionsMajor != 0 || _vectorFunctionsMinor < 1)
			{
				base.PointWisePowerArrays(x, y, result);
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_vector_power(x.Length, x, y, result);
		}

		public override void PointWiseDivideArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_vector_divide(x.Length, x, y, result);
		}

		public override void EigenDecomp(bool isSymmetric, int order, Complex[] matrix, Complex[] matrixEv, Complex[] vectorEv, Complex[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, Complex32[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override Complex32 DotProduct(Complex32[] x, Complex32[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(Complex32[] y, Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (!(alpha == Complex32.Zero))
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (!(alpha == Complex32.One))
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(Complex32[] x, int rowsX, int columnsX, Complex32[] y, int rowsY, int columnsY, Complex32[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, Complex32.One, x, rowsX, columnsX, y, rowsY, columnsY, Complex32.Zero, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] a, int rowsA, int columnsA, Complex32[] b, int rowsB, int columnsB, Complex32 beta, Complex32[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(Complex32[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(Complex32[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, Complex32[] a, int order, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, Complex32[] a, int order, int[] ipiv, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_cholesky_factor(order, a);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(Complex32[] r, int rowsR, int columnsR, Complex32[] q, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(Complex32[] q, int rowsA, int columnsA, Complex32[] r, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(Complex32[] a, int rows, int columns, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(Complex32[] q, Complex32[] r, int rowsA, int columnsA, Complex32[] tau, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(Complex32[] a, int rowsA, int columnsA, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex32[] s = new Complex32[Math.Min(rowsA, columnsA)];
			Complex32[] u = new Complex32[rowsA * rowsA];
			Complex32[] vt = new Complex32[columnsA * columnsA];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, Complex32[] a, int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void AddArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_vector_add(x.Length, x, y, result);
		}

		public override void SubtractArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_vector_subtract(x.Length, x, y, result);
		}

		public override void PointWiseMultiplyArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_vector_multiply(x.Length, x, y, result);
		}

		public override void PointWiseDivideArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_vector_divide(x.Length, x, y, result);
		}

		public override void PointWisePowerArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (_vectorFunctionsMajor != 0 || _vectorFunctionsMinor < 1)
			{
				base.PointWisePowerArrays(x, y, result);
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_vector_power(x.Length, x, y, result);
		}

		public override void EigenDecomp(bool isSymmetric, int order, Complex32[] matrix, Complex32[] matrixEv, Complex[] vectorEv, Complex32[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		internal MklLinearAlgebraProvider(string hintPath, MklConsistency consistency, MklPrecision precision, MklAccuracy accuracy)
		{
			_hintPath = hintPath;
			_consistency = consistency;
			_precision = precision;
			_accuracy = accuracy;
		}

		public override bool IsAvailable()
		{
			return MklProvider.IsAvailable(_hintPath);
		}

		public override void InitializeVerify()
		{
			int num = MklProvider.Load(_hintPath, _consistency, _precision, _accuracy);
			if (num < 4)
			{
				throw new NotSupportedException(FormattableString.Invariant($"MKL Native Provider revision r{num} is too old. Consider upgrading to a newer version. Revision r{4} and newer are supported."));
			}
			_linearAlgebraMajor = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(128);
			_linearAlgebraMinor = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(129);
			_vectorFunctionsMajor = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(130);
			_vectorFunctionsMinor = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(131);
			if (_linearAlgebraMajor != 2)
			{
				throw new NotSupportedException(FormattableString.Invariant($"MKL Native Provider not compatible. Expecting linear algebra v2 but provider implements v{_linearAlgebraMajor}."));
			}
		}

		public override void FreeResources()
		{
			MklProvider.FreeResources();
		}

		public override string ToString()
		{
			return MklProvider.Describe();
		}

		public void Dispose()
		{
			FreeResources();
		}

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, double[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override double DotProduct(double[] x, double[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(double[] y, double alpha, double[] x, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (alpha != 0.0)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(double alpha, double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (alpha != 1.0)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(double[] x, int rowsX, int columnsX, double[] y, int rowsY, int columnsY, double[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, 1.0, x, rowsX, columnsX, y, rowsY, columnsY, 0.0, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, double alpha, double[] a, int rowsA, int columnsA, double[] b, int rowsB, int columnsB, double beta, double[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(double[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(double[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, double[] a, int order, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, double[] a, int order, int[] ipiv, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_cholesky_factor(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(double[] r, int rowsR, int columnsR, double[] q, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(double[] q, int rowsA, int columnsA, double[] r, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(double[] a, int rows, int columns, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(double[] q, double[] r, int rowsA, int columnsA, double[] tau, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(double[] a, int rowsA, int columnsA, double[] b, int columnsB, double[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			double[] s = new double[Math.Min(rowsA, columnsA)];
			double[] u = new double[rowsA * rowsA];
			double[] vt = new double[columnsA * columnsA];
			double[] array = new double[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, double[] a, int rowsA, int columnsA, double[] s, double[] u, double[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void AddArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_vector_add(x.Length, x, y, result);
		}

		public override void SubtractArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_vector_subtract(x.Length, x, y, result);
		}

		public override void PointWiseMultiplyArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_vector_multiply(x.Length, x, y, result);
		}

		public override void PointWiseDivideArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_vector_divide(x.Length, x, y, result);
		}

		public override void PointWisePowerArrays(double[] x, double[] y, double[] result)
		{
			if (_vectorFunctionsMajor != 0 || _vectorFunctionsMinor < 1)
			{
				base.PointWisePowerArrays(x, y, result);
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_vector_power(x.Length, x, y, result);
		}

		public override void EigenDecomp(bool isSymmetric, int order, double[] matrix, double[] matrixEv, Complex[] vectorEv, double[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		[SecuritySafeCritical]
		public override double MatrixNorm(Norm norm, int rows, int columns, float[] matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (rows <= 0)
			{
				throw new ArgumentException("Value must be positive.", "rows");
			}
			if (columns <= 0)
			{
				throw new ArgumentException("Value must be positive.", "columns");
			}
			if (matrix.Length < rows * columns)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {rows * columns} long.", "matrix");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_matrix_norm((byte)norm, rows, columns, matrix);
		}

		[SecuritySafeCritical]
		public override float DotProduct(float[] x, float[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_dot_product(x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(float[] y, float alpha, float[] x, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (alpha != 0f)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_axpy(y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(float alpha, float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (alpha != 1f)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_scale(x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(float[] x, int rowsX, int columnsX, float[] y, int rowsY, int columnsY, float[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, 1f, x, rowsX, columnsX, y, rowsY, columnsY, 0f, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, float alpha, float[] a, int rowsA, int columnsA, float[] b, int rowsB, int columnsB, float beta, float[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_matrix_multiply(transposeA, transposeB, num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(float[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_lu_factor(order, data, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUInverse(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_lu_inverse(order, a);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(float[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_lu_inverse_factored(order, a, ipiv);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new SingularUMatrixException(num);
			}
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, float[] a, int order, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_lu_solve(order, columnsOfB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, float[] a, int order, int[] ipiv, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_lu_solve_factored(order, columnsOfB, a, ipiv, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_cholesky_factor(order, a);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_cholesky_solve(orderA, columnsB, a, b);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_cholesky_solve_factored(orderA, columnsB, a, b);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRFactor(float[] r, int rowsR, int columnsR, float[] q, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_qr_factor(rowsR, columnsR, r, tau, q);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void ThinQRFactor(float[] q, int rowsA, int columnsA, float[] r, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (q.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "q");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_qr_thin_factor(rowsA, columnsA, q, tau, r);
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
		}

		[SecuritySafeCritical]
		public override void QRSolve(float[] a, int rows, int columns, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_qr_solve(rows, columns, columnsB, a, b, x);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new ArgumentException("Matrix must not be rank deficient.", "a");
			}
		}

		[SecuritySafeCritical]
		public override void QRSolveFactored(float[] q, float[] r, int rowsA, int columnsA, float[] tau, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			if (method == QRMethod.Full)
			{
				int num5 = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_qr_solve_factored(rowsA, columnsA, columnsB, r, b, tau, x);
				if (num5 == -999999)
				{
					throw new MemoryAllocationException();
				}
				if (num5 < 0)
				{
					throw new InvalidParameterException(Math.Abs(num5));
				}
			}
			else
			{
				base.QRSolveFactored(q, r, rowsA, columnsA, tau, b, columnsB, x, QRMethod.Thin);
			}
		}

		public override void SvdSolve(float[] a, int rowsA, int columnsA, float[] b, int columnsB, float[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			float[] s = new float[Math.Min(rowsA, columnsA)];
			float[] u = new float[rowsA * rowsA];
			float[] vt = new float[columnsA * columnsA];
			float[] array = new float[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, float[] a, int rowsA, int columnsA, float[] s, float[] u, float[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_svd_factor(computeVectors, rowsA, columnsA, a, s, u, vt);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}

		public override void AddArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_vector_add(x.Length, x, y, result);
		}

		public override void SubtractArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_vector_subtract(x.Length, x, y, result);
		}

		public override void PointWiseMultiplyArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_vector_multiply(x.Length, x, y, result);
		}

		public override void PointWiseDivideArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_vector_divide(x.Length, x, y, result);
		}

		public override void PointWisePowerArrays(float[] x, float[] y, float[] result)
		{
			if (_vectorFunctionsMajor != 0 || _vectorFunctionsMinor < 1)
			{
				base.PointWisePowerArrays(x, y, result);
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (x.Length != result.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_vector_power(x.Length, x, y, result);
		}

		public override void EigenDecomp(bool isSymmetric, int order, float[] matrix, float[] matrixEv, Complex[] vectorEv, float[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			int num = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_eigen(isSymmetric, order, matrix, matrixEv, vectorEv, matrixD);
			if (num == -999999)
			{
				throw new MemoryAllocationException();
			}
			if (num < 0)
			{
				throw new InvalidParameterException(Math.Abs(num));
			}
			if (num > 0)
			{
				throw new NonConvergenceException();
			}
		}
	}
	internal enum MklError
	{
		MemoryAllocation = -999999
	}
}
namespace MathNet.Numerics.Providers.LinearAlgebra.Managed
{
	internal class ManagedLinearAlgebraProvider : ILinearAlgebraProvider, ILinearAlgebraProvider<double>, ILinearAlgebraProvider<float>, ILinearAlgebraProvider<Complex>, ILinearAlgebraProvider<Complex32>
	{
		public virtual void AddVectorToScaledVector(Complex[] y, Complex alpha, Complex[] x, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (alpha.IsZero())
			{
				y.Copy(result);
			}
			else if (alpha.IsOne())
			{
				for (int i = 0; i < result.Length; i++)
				{
					result[i] = y[i] + x[i];
				}
			}
			else
			{
				for (int j = 0; j < result.Length; j++)
				{
					result[j] = y[j] + alpha * x[j];
				}
			}
		}

		public virtual void ScaleArray(Complex alpha, Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (alpha.IsZero())
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if (alpha.IsOne())
			{
				x.Copy(result);
				return;
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = alpha * x[i];
			}
		}

		public virtual void ConjugateArray(Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i].Conjugate();
			}
		}

		public virtual Complex DotProduct(Complex[] x, Complex[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Complex zero = Complex.Zero;
			for (int i = 0; i < y.Length; i++)
			{
				zero += y[i] * x[i];
			}
			return zero;
		}

		public virtual void AddArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] + y[i];
			}
		}

		public virtual void SubtractArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] - y[i];
			}
		}

		public virtual void PointWiseMultiplyArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] * y[i];
			}
		}

		public virtual void PointWiseDivideArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = Complex.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, Complex[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += matrix[l * rows + m].Magnitude;
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(matrix[j * rows + k].Magnitude, num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += matrix[n * rows + num5].Magnitude;
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				Complex[] array = new Complex[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.ConjugateTranspose, 1.0, matrix, rows, columns, matrix, rows, columns, 0.0, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += array[i * rows + i].Magnitude;
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(Complex[] x, int rowsX, int columnsX, Complex[] y, int rowsY, int columnsY, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsX}) != rowsB ({rowsY})"));
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsA ({columnsX}) != a.Length ({x.Length})"));
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsY}) * columnsB ({columnsY}) != b.Length ({y.Length})"));
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsB ({columnsY}) != c.Length ({result.Length})"));
			}
			Array.Clear(result, 0, result.Length);
			Complex[][] columnDataB = new Complex[columnsY][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				Complex[] array = new Complex[rowsY];
				GetColumn(Transpose.DontTranspose, i, rowsY, columnsY, y, array);
				columnDataB[i] = array;
			}
			if (rowsX + columnsY + columnsX < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				Complex[] array2 = new Complex[columnsX];
				for (int j = 0; j < rowsX; j++)
				{
					GetRow(Transpose.DontTranspose, j, rowsX, columnsX, x, array2);
					for (int k = 0; k < columnsY; k++)
					{
						Complex[] array3 = columnDataB[k];
						Complex zero = Complex.Zero;
						for (int l = 0; l < array2.Length; l++)
						{
							zero += array2[l] * array3[l];
						}
						result[k * rowsX + j] += Complex.One * zero;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsX, 1, delegate(int u, int v)
			{
				Complex[] array4 = new Complex[columnsX];
				for (int m = u; m < v; m++)
				{
					GetRow(Transpose.DontTranspose, m, rowsX, columnsX, x, array4);
					for (int n = 0; n < columnsY; n++)
					{
						Complex[] array5 = columnDataB[n];
						Complex zero2 = Complex.Zero;
						for (int num = 0; num < array4.Length; num++)
						{
							zero2 += array4[num] * array5[num];
						}
						result[n * rowsX + m] += Complex.One * zero2;
					}
				}
			});
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] a, int rowsA, int columnsA, Complex[] b, int rowsB, int columnsB, Complex beta, Complex[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			if (transposeA != Transpose.DontTranspose)
			{
				int num = rowsA;
				rowsA = columnsA;
				columnsA = num;
			}
			if (transposeB != Transpose.DontTranspose)
			{
				int num2 = rowsB;
				rowsB = columnsB;
				columnsB = num2;
			}
			if (columnsA != rowsB)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsA}) != rowsB ({rowsB})"));
			}
			if (rowsA * columnsA != a.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsA ({columnsA}) != a.Length ({a.Length})"));
			}
			if (rowsB * columnsB != b.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsB}) * columnsB ({columnsB}) != b.Length ({b.Length})"));
			}
			if (rowsA * columnsB != c.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsB ({columnsB}) != c.Length ({c.Length})"));
			}
			if (beta == Complex.Zero)
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (beta != Complex.One)
			{
				ScaleArray(beta, c, c);
			}
			if (alpha == Complex.Zero)
			{
				return;
			}
			Complex[][] columnDataB = new Complex[columnsB][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				Complex[] array = new Complex[rowsB];
				GetColumn(transposeB, i, rowsB, columnsB, b, array);
				columnDataB[i] = array;
			}
			if (rowsA + columnsB + columnsA < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				Complex[] array2 = new Complex[columnsA];
				for (int j = 0; j < rowsA; j++)
				{
					GetRow(transposeA, j, rowsA, columnsA, a, array2);
					for (int k = 0; k < columnsB; k++)
					{
						Complex[] array3 = columnDataB[k];
						Complex zero = Complex.Zero;
						for (int l = 0; l < array2.Length; l++)
						{
							zero += array2[l] * array3[l];
						}
						c[k * rowsA + j] += alpha * zero;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsA, 1, delegate(int u, int v)
			{
				Complex[] array4 = new Complex[columnsA];
				for (int m = u; m < v; m++)
				{
					GetRow(transposeA, m, rowsA, columnsA, a, array4);
					for (int n = 0; n < columnsB; n++)
					{
						Complex[] array5 = columnDataB[n];
						Complex zero2 = Complex.Zero;
						for (int num3 = 0; num3 < array4.Length; num3++)
						{
							zero2 += array4[num3] * array5[num3];
						}
						c[n * rowsA + m] += alpha * zero2;
					}
				}
			});
		}

		public virtual void LUFactor(Complex[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			Complex[] array = new Complex[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					Complex zero = Complex.Zero;
					for (int m = 0; m < num3; m++)
					{
						zero += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= zero);
				}
				int num4 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (array[n].Magnitude > array[num4].Magnitude)
					{
						num4 = n;
					}
				}
				if (num4 != j)
				{
					for (int num5 = 0; num5 < order; num5++)
					{
						int num6 = num5 * order;
						int num7 = num6 + num4;
						int num8 = num6 + j;
						Complex complex = data[num7];
						data[num7] = data[num8];
						data[num8] = complex;
					}
					ipiv[j] = num4;
				}
				if ((j < order) & (data[num2] != 0.0))
				{
					for (int num9 = j + 1; num9 < order; num9++)
					{
						data[num + num9] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(Complex[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Complex[] array = new Complex[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = Complex.One;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, Complex[] a, int order, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, Complex[] a, int order, int[] ipiv, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						Complex complex = b[num3];
						b[num3] = b[num4];
						b[num4] = complex;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num5 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num6 = m * order;
						b[l + num6] -= b[k + num6] * a[l + num5];
					}
				}
			}
			for (int num7 = order - 1; num7 >= 0; num7--)
			{
				int num8 = num7 + num7 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num7 + n * order] /= a[num8];
				}
				num8 = num7 * order;
				for (int num9 = 0; num9 < num7; num9++)
				{
					for (int num10 = 0; num10 < columnsOfB; num10++)
					{
						int num11 = num10 * order;
						b[num9 + num11] -= b[num7 + num11] * a[num9 + num8];
					}
				}
			}
		}

		public virtual void CholeskyFactor(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			Complex[] array = new Complex[order];
			for (int i = 0; i < order; i++)
			{
				Complex complex = a[i * order + i];
				if (!(complex.Real > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				complex = (array[i] = (a[i * order + i] = complex.SquareRoot()));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= complex;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0.0;
				}
			}
		}

		private static void DoCholeskyStep(Complex[] data, int rowDim, int firstCol, int colLimit, Complex[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				Complex complex = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * complex.Conjugate();
				}
			}
		}

		public virtual void CholeskySolve(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(Complex[] a, int orderA, Complex[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				Complex complex = b[num + i];
				for (int num2 = i - 1; num2 >= 0; num2--)
				{
					complex -= a[num2 * orderA + i] * b[num + num2];
				}
				b[num + i] = complex / a[i * orderA + i];
			}
			for (int num3 = orderA - 1; num3 >= 0; num3--)
			{
				Complex complex = b[num + num3];
				int num4 = num3 * orderA;
				for (int j = num3 + 1; j < orderA; j++)
				{
					complex -= a[num4 + j].Conjugate() * b[num + j];
				}
				b[num + num3] = complex / a[num4 + num3];
			}
		}

		public virtual void QRFactor(Complex[] r, int rowsR, int columnsR, Complex[] q, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			Complex[] work = ((columnsR > rowsR) ? new Complex[rowsR * rowsR] : new Complex[rowsR * columnsR]);
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = Complex.One;
				}
			});
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(Complex[] a, int rowsA, int columnsA, Complex[] r, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			Complex[] work = new Complex[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = Complex.One;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(Complex[] work, int workIndex, Complex[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				Complex zero = Complex.Zero;
				for (int j = rowStart; j < rowCount; j++)
				{
					zero += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart].Conjugate() * zero;
				}
			}
		}

		private static void GenerateColumn(Complex[] work, Complex[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num3 = tmp + l;
					work[num3 - row] = a[num3];
					a[num3] = Complex.Zero;
				}
			});
			Complex norm = Complex.Zero;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num2 = tmp + i;
				norm += (Complex)(work[num2].Magnitude * work[num2].Magnitude);
			}
			norm = norm.SquareRoot();
			if (row == rowCount - 1 || norm.Magnitude == 0.0)
			{
				a[num] = -work[tmp];
				work[tmp] = new Complex(2.0, 0.0).SquareRoot();
				return;
			}
			if (work[tmp].Magnitude != 0.0)
			{
				norm = norm.Magnitude * (work[tmp] / work[tmp].Magnitude);
			}
			a[num] = -norm;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] /= norm;
				}
			});
			work[tmp] += (Complex)1.0;
			Complex s = (1.0 / work[tmp]).SquareRoot();
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] = work[tmp + j].Conjugate() * s;
				}
			});
		}

		public virtual void QRSolve(Complex[] a, int rows, int columns, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			Complex[] tau = new Complex[rows * columns];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				Complex[] q = new Complex[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				Complex[] r = new Complex[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(Complex[] q, Complex[] r, int rowsA, int columnsA, Complex[] tau, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			Complex[] sol = new Complex[b.Length];
			Array.Copy(b, 0, sol, 0, b.Length);
			Complex[] column = new Complex[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						Complex zero = Complex.Zero;
						for (int num9 = 0; num9 < rowsA; num9++)
						{
							zero += q[num8 + num9].Conjugate() * column[num9];
						}
						sol[jm + n] = zero;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, Complex[] a, int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			Complex[] array = new Complex[rowsA];
			Complex[] array2 = new Complex[columnsA];
			Complex[] array3 = new Complex[vt.Length];
			Complex[] array4 = new Complex[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					double num5 = 0.0;
					for (int j = i; j < rowsA; j++)
					{
						num5 += a[i * rowsA + j].Magnitude * a[i * rowsA + j].Magnitude;
					}
					array4[i] = Math.Sqrt(num5);
					if (array4[i] != 0.0)
					{
						if (a[i * rowsA + i] != 0.0)
						{
							array4[i] = array4[i].Magnitude * (a[i * rowsA + i] / a[i * rowsA + i].Magnitude);
						}
						for (int j = i; j < rowsA; j++)
						{
							a[i * rowsA + j] *= 1.0 / array4[i];
						}
						a[i * rowsA + i] = 1.0 + a[i * rowsA + i];
					}
					array4[i] = -array4[i];
				}
				for (int k = num4; k < columnsA; k++)
				{
					if (i < num && array4[i] != 0.0)
					{
						Complex complex = 0.0;
						for (int j = i; j < rowsA; j++)
						{
							complex += a[i * rowsA + j].Conjugate() * a[k * rowsA + j];
						}
						complex = -complex / a[i * rowsA + i];
						for (int l = i; l < rowsA; l++)
						{
							a[k * rowsA + l] += complex * a[i * rowsA + l];
						}
					}
					array2[k] = a[k * rowsA + i].Conjugate();
				}
				if (computeVectors && i < num)
				{
					for (int j = i; j < rowsA; j++)
					{
						u[i * rowsA + j] = a[i * rowsA + j];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				double num6 = 0.0;
				for (int j = num4; j < array2.Length; j++)
				{
					num6 += array2[j].Magnitude * array2[j].Magnitude;
				}
				array2[i] = Math.Sqrt(num6);
				if (array2[i] != 0.0)
				{
					if (array2[num4] != 0.0)
					{
						array2[i] = array2[i].Magnitude * (array2[num4] / array2[num4].Magnitude);
					}
					for (int j = num4; j < array2.Length; j++)
					{
						array2[j] *= 1.0 / array2[i];
					}
					array2[num4] = 1.0 + array2[num4];
				}
				array2[i] = -array2[i].Conjugate();
				if (num4 < rowsA && array2[i] != 0.0)
				{
					for (int j = num4; j < rowsA; j++)
					{
						array[j] = 0.0;
					}
					for (int k = num4; k < columnsA; k++)
					{
						for (int m = num4; m < rowsA; m++)
						{
							array[m] += array2[k] * a[k * rowsA + m];
						}
					}
					for (int k = num4; k < columnsA; k++)
					{
						Complex complex2 = (-array2[k] / array2[num4]).Conjugate();
						for (int n = num4; n < rowsA; n++)
						{
							a[k * rowsA + n] += complex2 * array[n];
						}
					}
				}
				if (computeVectors)
				{
					for (int j = num4; j < columnsA; j++)
					{
						array3[i * columnsA + j] = array2[j];
					}
				}
			}
			int num7 = Math.Min(columnsA, rowsA + 1);
			int num8 = num + 1;
			int num9 = num2 + 1;
			if (num < columnsA)
			{
				array4[num8 - 1] = a[(num8 - 1) * rowsA + (num8 - 1)];
			}
			if (rowsA < num7)
			{
				array4[num7 - 1] = 0.0;
			}
			if (num9 < num7)
			{
				array2[num9 - 1] = a[(num7 - 1) * rowsA + (num9 - 1)];
			}
			array2[num7 - 1] = 0.0;
			if (computeVectors)
			{
				for (int k = num8 - 1; k < rowsA; k++)
				{
					for (int j = 0; j < rowsA; j++)
					{
						u[k * rowsA + j] = 0.0;
					}
					u[k * rowsA + k] = 1.0;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if (array4[i] != 0.0)
					{
						for (int k = i + 1; k < rowsA; k++)
						{
							Complex complex = 0.0;
							for (int j = i; j < rowsA; j++)
							{
								complex += u[i * rowsA + j].Conjugate() * u[k * rowsA + j];
							}
							complex = -complex / u[i * rowsA + i];
							for (int num10 = i; num10 < rowsA; num10++)
							{
								u[k * rowsA + num10] += complex * u[i * rowsA + num10];
							}
						}
						for (int j = i; j < rowsA; j++)
						{
							u[i * rowsA + j] *= (Complex)(-1.0);
						}
						u[i * rowsA + i] = 1.0 + u[i * rowsA + i];
						for (int j = 0; j < i; j++)
						{
							u[i * rowsA + j] = 0.0;
						}
					}
					else
					{
						for (int j = 0; j < rowsA; j++)
						{
							u[i * rowsA + j] = 0.0;
						}
						u[i * rowsA + i] = 1.0;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && array2[i] != 0.0)
					{
						for (int k = num4; k < columnsA; k++)
						{
							Complex complex = 0.0;
							for (int j = num4; j < columnsA; j++)
							{
								complex += array3[i * columnsA + j].Conjugate() * array3[k * columnsA + j];
							}
							complex = -complex / array3[i * columnsA + num4];
							for (int num11 = i; num11 < columnsA; num11++)
							{
								array3[k * columnsA + num11] += complex * array3[i * columnsA + num11];
							}
						}
					}
					for (int j = 0; j < columnsA; j++)
					{
						array3[i * columnsA + j] = 0.0;
					}
					array3[i * columnsA + i] = 1.0;
				}
			}
			for (int j = 0; j < num7; j++)
			{
				Complex complex;
				Complex complex3;
				if (array4[j] != 0.0)
				{
					complex = array4[j].Magnitude;
					complex3 = array4[j] / complex;
					array4[j] = complex;
					if (j < num7 - 1)
					{
						array2[j] /= complex3;
					}
					if (computeVectors)
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[j * rowsA + k] *= complex3;
						}
					}
				}
				if (j == num7 - 1)
				{
					break;
				}
				if (array2[j] == 0.0)
				{
					continue;
				}
				complex = array2[j].Magnitude;
				complex3 = complex / array2[j];
				array2[j] = complex;
				array4[j + 1] *= complex3;
				if (computeVectors)
				{
					for (int k = 0; k < columnsA; k++)
					{
						array3[(j + 1) * columnsA + k] *= complex3;
					}
				}
			}
			int num12 = num7;
			int num13 = 0;
			while (num7 > 0)
			{
				if (num13 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num7 - 2; i >= 0; i--)
				{
					double num14 = array4[i].Magnitude + array4[i + 1].Magnitude;
					if ((num14 + array2[i].Magnitude).AlmostEqualRelative(num14, 15))
					{
						array2[i] = 0.0;
						break;
					}
				}
				int num15;
				if (i == num7 - 2)
				{
					num15 = 4;
				}
				else
				{
					int num16;
					for (num16 = num7 - 1; num16 > i; num16--)
					{
						double num14 = 0.0;
						if (num16 != num7 - 1)
						{
							num14 += array2[num16].Magnitude;
						}
						if (num16 != i + 1)
						{
							num14 += array2[num16 - 1].Magnitude;
						}
						if ((num14 + array4[num16].Magnitude).AlmostEqualRelative(num14, 15))
						{
							array4[num16] = 0.0;
							break;
						}
					}
					if (num16 == i)
					{
						num15 = 3;
					}
					else if (num16 == num7 - 1)
					{
						num15 = 1;
					}
					else
					{
						num15 = 2;
						i = num16;
					}
				}
				i++;
				double c;
				double s2;
				switch (num15)
				{
				case 1:
				{
					double db = array2[num7 - 2].Real;
					array2[num7 - 2] = 0.0;
					for (int num26 = i; num26 < num7 - 1; num26++)
					{
						int num17 = num7 - 2 - num26 + i;
						double da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						if (num17 != i)
						{
							db = (0.0 - s2) * array2[num17 - 1].Real;
							array2[num17 - 1] = c * array2[num17 - 1];
						}
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex complex9 = c * array3[num17 * columnsA + j] + s2 * array3[(num7 - 1) * columnsA + j];
								array3[(num7 - 1) * columnsA + j] = c * array3[(num7 - 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex9;
							}
						}
					}
					break;
				}
				case 2:
				{
					double db = array2[i - 1].Real;
					array2[i - 1] = 0.0;
					for (int num17 = i; num17 < num7; num17++)
					{
						double da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						db = (0.0 - s2) * array2[num17].Real;
						array2[num17] = c * array2[num17];
						if (computeVectors)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex complex6 = c * u[num17 * rowsA + j] + s2 * u[(i - 1) * rowsA + j];
								u[(i - 1) * rowsA + j] = c * u[(i - 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex6;
							}
						}
					}
					break;
				}
				case 3:
				{
					double val = 0.0;
					val = Math.Max(val, array4[num7 - 1].Magnitude);
					val = Math.Max(val, array4[num7 - 2].Magnitude);
					val = Math.Max(val, array2[num7 - 2].Magnitude);
					val = Math.Max(val, array4[i].Magnitude);
					val = Math.Max(val, array2[i].Magnitude);
					double num18 = array4[num7 - 1].Real / val;
					double num19 = array4[num7 - 2].Real / val;
					double num20 = array2[num7 - 2].Real / val;
					double num21 = array4[i].Real / val;
					double num22 = array2[i].Real / val;
					double num23 = ((num19 + num18) * (num19 - num18) + num20 * num20) / 2.0;
					double num24 = num18 * num20 * (num18 * num20);
					double num25 = 0.0;
					if (num23 != 0.0 || num24 != 0.0)
					{
						num25 = Math.Sqrt(num23 * num23 + num24);
						if (num23 < 0.0)
						{
							num25 = 0.0 - num25;
						}
						num25 = num24 / (num23 + num25);
					}
					double db = (num21 + num18) * (num21 - num18) + num25;
					double db2 = num21 * num22;
					for (int num17 = i; num17 < num7 - 1; num17++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num17 != i)
						{
							array2[num17 - 1] = db;
						}
						db = c * array4[num17].Real + s2 * array2[num17].Real;
						array2[num17] = c * array2[num17] - s2 * array4[num17];
						db2 = s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = c * array4[num17 + 1];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex complex7 = c * array3[num17 * columnsA + j] + s2 * array3[(num17 + 1) * columnsA + j];
								array3[(num17 + 1) * columnsA + j] = c * array3[(num17 + 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex7;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num17] = db;
						db = c * array2[num17].Real + s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = -(s2 * array2[num17]) + c * array4[num17 + 1];
						db2 = s2 * array2[num17 + 1].Real;
						array2[num17 + 1] = c * array2[num17 + 1];
						if (computeVectors && num17 < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex complex8 = c * u[num17 * rowsA + j] + s2 * u[(num17 + 1) * rowsA + j];
								u[(num17 + 1) * rowsA + j] = c * u[(num17 + 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex8;
							}
						}
					}
					array2[num7 - 2] = db;
					num13++;
					break;
				}
				case 4:
					if (array4[i].Real < 0.0)
					{
						array4[i] = -array4[i];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								array3[i * columnsA + j] *= (Complex)(-1.0);
							}
						}
					}
					for (; i != num12 - 1 && !(array4[i].Real >= array4[i + 1].Real); i++)
					{
						Complex complex = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = complex;
						if (computeVectors && i < columnsA)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex complex4 = array3[i * columnsA + j];
								array3[i * columnsA + j] = array3[(i + 1) * columnsA + j];
								array3[(i + 1) * columnsA + j] = complex4;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex complex5 = u[i * rowsA + j];
								u[i * rowsA + j] = u[(i + 1) * rowsA + j];
								u[(i + 1) * rowsA + j] = complex5;
							}
						}
					}
					num13 = 0;
					num7--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int j = 0; j < columnsA; j++)
				{
					for (int k = 0; k < columnsA; k++)
					{
						vt[k * columnsA + j] = array3[j * columnsA + k].Conjugate();
					}
				}
			}
			Array.Copy(array4, 0, s, 0, Math.Min(rowsA, columnsA));
		}

		public virtual void SvdSolve(Complex[] a, int rowsA, int columnsA, Complex[] b, int columnsB, Complex[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex[] s = new Complex[Math.Min(rowsA, columnsA)];
			Complex[] u = new Complex[rowsA * rowsA];
			Complex[] vt = new Complex[columnsA * columnsA];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt, Complex[] b, int columnsB, Complex[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			Complex[] array = new Complex[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					Complex zero = Complex.Zero;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							zero += u[j * rowsA + k].Conjugate() * b[i * rowsA + k];
						}
						zero /= s[j];
					}
					array[j] = zero;
				}
				for (int l = 0; l < columnsA; l++)
				{
					Complex zero2 = Complex.Zero;
					for (int m = 0; m < columnsA; m++)
					{
						zero2 += vt[l * columnsA + m].Conjugate() * array[m];
					}
					x[i * columnsA + l] = zero2;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, Complex[] matrix, Complex[] matrixEv, Complex[] vectorEv, Complex[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			Complex[] array = new Complex[matrix.Length];
			Array.Copy(matrix, 0, array, 0, matrix.Length);
			if (isSymmetric)
			{
				Complex[] tau = new Complex[order];
				double[] array2 = new double[order];
				double[] array3 = new double[order];
				SymmetricTridiagonalize(array, array2, array3, tau, order);
				SymmetricDiagonalize(matrixEv, array2, array3, order);
				SymmetricUntridiagonalize(matrixEv, array, tau, order);
				for (int i = 0; i < order; i++)
				{
					vectorEv[i] = new Complex(array2[i], array3[i]);
				}
			}
			else
			{
				NonsymmetricReduceToHessenberg(matrixEv, array, order);
				NonsymmetricReduceHessenberToRealSchur(vectorEv, matrixEv, array, order);
			}
			for (int j = 0; j < order; j++)
			{
				matrixD[j * order + j] = vectorEv[j];
			}
		}

		internal static void SymmetricTridiagonalize(Complex[] matrixA, double[] d, double[] e, Complex[] tau, int order)
		{
			tau[order - 1] = Complex.One;
			for (int i = 0; i < order; i++)
			{
				d[i] = matrixA[i * order + i].Real;
			}
			double num6;
			for (int num = order - 1; num > 0; num--)
			{
				double num2 = 0.0;
				double num3 = 0.0;
				for (int j = 0; j < num; j++)
				{
					num2 = num2 + Math.Abs(matrixA[j * order + num].Real) + Math.Abs(matrixA[j * order + num].Imaginary);
				}
				if (num2 == 0.0)
				{
					tau[num - 1] = Complex.One;
					e[num] = 0.0;
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						matrixA[k * order + num] /= (Complex)num2;
						num3 += matrixA[k * order + num].MagnitudeSquared();
					}
					Complex complex = Math.Sqrt(num3);
					e[num] = num2 * complex.Real;
					int num4 = (num - 1) * order + num;
					Complex complex2 = matrixA[num4];
					Complex complex3;
					if (complex2.Magnitude != 0.0)
					{
						complex3 = -(matrixA[num4].Conjugate() * tau[num].Conjugate()) / complex2.Magnitude;
						num3 += complex2.Magnitude * complex.Real;
						complex = 1.0 + complex / complex2.Magnitude;
						matrixA[num4] *= complex;
					}
					else
					{
						complex3 = -tau[num].Conjugate();
						matrixA[num4] = complex;
					}
					if (complex2.Magnitude == 0.0 || num != 1)
					{
						complex2 = Complex.Zero;
						for (int l = 0; l < num; l++)
						{
							Complex zero = Complex.Zero;
							int num5 = l * order;
							for (int m = 0; m <= l; m++)
							{
								zero += matrixA[m * order + l] * matrixA[m * order + num].Conjugate();
							}
							for (int n = l + 1; n <= num - 1; n++)
							{
								zero += matrixA[num5 + n].Conjugate() * matrixA[n * order + num].Conjugate();
							}
							tau[l] = zero / num3;
							complex2 += zero / num3 * matrixA[num5 + num];
						}
						num6 = complex2.Real / (num3 + num3);
						for (int num7 = 0; num7 < num; num7++)
						{
							complex2 = matrixA[num7 * order + num].Conjugate();
							complex = tau[num7] - num6 * complex2;
							tau[num7] = complex.Conjugate();
							for (int num8 = 0; num8 <= num7; num8++)
							{
								matrixA[num8 * order + num7] -= complex2 * tau[num8] + complex * matrixA[num8 * order + num];
							}
						}
					}
					for (int num9 = 0; num9 < num; num9++)
					{
						matrixA[num9 * order + num] *= (Complex)num2;
					}
					tau[num - 1] = complex3.Conjugate();
				}
				num6 = d[num];
				d[num] = matrixA[num * order + num].Real;
				matrixA[num * order + num] = new Complex(num6, num2 * Math.Sqrt(num3));
			}
			num6 = d[0];
			d[0] = matrixA[0].Real;
			matrixA[0] = num6;
			e[0] = 0.0;
		}

		internal static void SymmetricDiagonalize(Complex[] dataEv, double[] d, double[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0.0;
			double num = 0.0;
			double num2 = 0.0;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !(Math.Abs(e[k]) <= doublePrecision * num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						double num4 = d[j];
						double num5 = (d[j + 1] - num4) / (2.0 * e[j]);
						double num6 = SpecialFunctions.Hypotenuse(num5, 1.0);
						if (num5 < 0.0)
						{
							num6 = 0.0 - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						double num7 = d[j + 1];
						double num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						double num9 = 1.0;
						double num10 = num9;
						double num11 = num9;
						double num12 = e[j + 1];
						double num13 = 0.0;
						double num14 = 0.0;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = dataEv[(num15 + 1) * order + m].Real;
								dataEv[(num15 + 1) * order + m] = num13 * dataEv[num15 * order + m].Real + num9 * num8;
								dataEv[num15 * order + m] = num9 * dataEv[num15 * order + m].Real - num13 * num8;
							}
						}
						num5 = (0.0 - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while (Math.Abs(e[j]) > doublePrecision * num2);
				}
				d[j] += num;
				e[j] = 0.0;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				double num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = dataEv[n * order + num19].Real;
						dataEv[n * order + num19] = dataEv[num16 * order + num19];
						dataEv[num16 * order + num19] = num17;
					}
				}
			}
		}

		internal static void SymmetricUntridiagonalize(Complex[] dataEv, Complex[] matrixA, Complex[] tau, int order)
		{
			for (int i = 0; i < order; i++)
			{
				for (int j = 0; j < order; j++)
				{
					dataEv[j * order + i] = dataEv[j * order + i].Real * tau[i].Conjugate();
				}
			}
			for (int k = 1; k < order; k++)
			{
				double imaginary = matrixA[k * order + k].Imaginary;
				if (imaginary == 0.0)
				{
					continue;
				}
				for (int l = 0; l < order; l++)
				{
					Complex zero = Complex.Zero;
					for (int m = 0; m < k; m++)
					{
						zero += dataEv[l * order + m] * matrixA[m * order + k];
					}
					zero = zero / imaginary / imaginary;
					for (int n = 0; n < k; n++)
					{
						dataEv[l * order + n] -= zero * matrixA[n * order + k].Conjugate();
					}
				}
			}
		}

		internal static void NonsymmetricReduceToHessenberg(Complex[] dataEv, Complex[] matrixH, int order)
		{
			Complex[] array = new Complex[order];
			for (int i = 1; i < order - 1; i++)
			{
				double num = 0.0;
				int num2 = (i - 1) * order;
				for (int j = i; j < order; j++)
				{
					num += Math.Abs(matrixH[num2 + j].Real) + Math.Abs(matrixH[num2 + j].Imaginary);
				}
				if (num == 0.0)
				{
					continue;
				}
				double num3 = 0.0;
				for (int num4 = order - 1; num4 >= i; num4--)
				{
					array[num4] = matrixH[num2 + num4] / num;
					num3 += array[num4].MagnitudeSquared();
				}
				double num5 = Math.Sqrt(num3);
				if (array[i].Magnitude != 0.0)
				{
					num3 += array[i].Magnitude * num5;
					num5 /= array[i].Magnitude;
					array[i] = (1.0 + num5) * array[i];
				}
				else
				{
					array[i] = num5;
					matrixH[num2 + i] = num;
				}
				for (int k = i; k < order; k++)
				{
					Complex zero = Complex.Zero;
					int num6 = k * order;
					for (int num7 = order - 1; num7 >= i; num7--)
					{
						zero += array[num7].Conjugate() * matrixH[num6 + num7];
					}
					zero /= (Complex)num3;
					for (int l = i; l < order; l++)
					{
						matrixH[num6 + l] -= zero * array[l];
					}
				}
				for (int m = 0; m < order; m++)
				{
					Complex zero2 = Complex.Zero;
					for (int num8 = order - 1; num8 >= i; num8--)
					{
						zero2 += array[num8] * matrixH[num8 * order + m];
					}
					zero2 /= (Complex)num3;
					for (int n = i; n < order; n++)
					{
						matrixH[n * order + m] -= zero2 * array[n].Conjugate();
					}
				}
				array[i] = num * array[i];
				matrixH[num2 + i] *= (Complex)(0.0 - num5);
			}
			for (int num9 = 0; num9 < order; num9++)
			{
				for (int num10 = 0; num10 < order; num10++)
				{
					dataEv[num10 * order + num9] = ((num9 == num10) ? Complex.One : Complex.Zero);
				}
			}
			for (int num11 = order - 2; num11 >= 1; num11--)
			{
				int num12 = (num11 - 1) * order;
				int num13 = num12 + num11;
				if (matrixH[num13] != Complex.Zero && array[num11] != Complex.Zero)
				{
					double num14 = matrixH[num13].Real * array[num11].Real + matrixH[num13].Imaginary * array[num11].Imaginary;
					for (int num15 = num11 + 1; num15 < order; num15++)
					{
						array[num15] = matrixH[num12 + num15];
					}
					for (int num16 = num11; num16 < order; num16++)
					{
						Complex zero3 = Complex.Zero;
						for (int num17 = num11; num17 < order; num17++)
						{
							zero3 += array[num17].Conjugate() * dataEv[num16 * order + num17];
						}
						zero3 /= (Complex)num14;
						for (int num18 = num11; num18 < order; num18++)
						{
							dataEv[num16 * order + num18] += zero3 * array[num18];
						}
					}
				}
			}
			for (int num19 = 1; num19 < order; num19++)
			{
				int num20 = (num19 - 1) * order + num19;
				int num21 = num19 * order;
				if (matrixH[num20].Imaginary != 0.0)
				{
					Complex complex = matrixH[num20] / matrixH[num20].Magnitude;
					matrixH[num20] = matrixH[num20].Magnitude;
					for (int num22 = num19; num22 < order; num22++)
					{
						matrixH[num22 * order + num19] *= complex.Conjugate();
					}
					for (int num23 = 0; num23 <= Math.Min(num19 + 1, order - 1); num23++)
					{
						matrixH[num21 + num23] *= complex;
					}
					for (int num24 = 0; num24 < order; num24++)
					{
						dataEv[num19 * order + num24] *= complex;
					}
				}
			}
		}

		internal static void NonsymmetricReduceHessenberToRealSchur(Complex[] vectorV, Complex[] dataEv, Complex[] matrixH, int order)
		{
			int num = order - 1;
			double doublePrecision = Precision.DoublePrecision;
			Complex zero = Complex.Zero;
			int num2 = 0;
			double num15;
			while (num >= 0)
			{
				int num3;
				for (num3 = num; num3 > 0; num3--)
				{
					int num4 = num3 - 1;
					int num5 = num4 * order;
					int num6 = num3 * order;
					double num7 = Math.Abs(matrixH[num5 + num4].Real) + Math.Abs(matrixH[num5 + num4].Imaginary) + Math.Abs(matrixH[num6 + num3].Real) + Math.Abs(matrixH[num6 + num3].Imaginary);
					if (Math.Abs(matrixH[num5 + num3].Real) < doublePrecision * num7)
					{
						break;
					}
				}
				int num8 = num - 1;
				int num9 = num8 * order;
				int num10 = num * order;
				int num11 = num10 + num;
				if (num3 == num)
				{
					matrixH[num11] += zero;
					vectorV[num] = matrixH[num11];
					num--;
					num2 = 0;
					continue;
				}
				Complex complex;
				if (num2 != 10 && num2 != 20)
				{
					complex = matrixH[num11];
					Complex complex2 = matrixH[num10 + num8] * matrixH[num9 + num].Real;
					if (complex2.Real != 0.0 || complex2.Imaginary != 0.0)
					{
						Complex complex3 = (matrixH[num9 + num8] - complex) / 2.0;
						Complex complex4 = (complex3 * complex3 + complex2).SquareRoot();
						if (complex3.Real * complex4.Real + complex3.Imaginary * complex4.Imaginary < 0.0)
						{
							complex4 *= (Complex)(-1.0);
						}
						complex2 /= complex3 + complex4;
						complex -= complex2;
					}
				}
				else
				{
					complex = Math.Abs(matrixH[num9 + num].Real) + Math.Abs(matrixH[(num - 2) * order + num8].Real);
				}
				for (int i = 0; i <= num; i++)
				{
					matrixH[i * order + i] -= complex;
				}
				zero += complex;
				num2++;
				for (int j = num3 + 1; j <= num; j++)
				{
					int num12 = j - 1;
					int num13 = num12 * order;
					int num14 = num13 + num12;
					complex = matrixH[num13 + j].Real;
					num15 = SpecialFunctions.Hypotenuse(matrixH[num14].Magnitude, complex.Real);
					Complex complex2 = (vectorV[j - 1] = matrixH[num14] / num15);
					matrixH[num14] = num15;
					matrixH[num13 + j] = new Complex(0.0, complex.Real / num15);
					for (int k = j; k < order; k++)
					{
						int num16 = k * order;
						Complex complex3 = matrixH[num16 + num12];
						Complex complex4 = matrixH[num16 + j];
						matrixH[num16 + num12] = complex2.Conjugate() * complex3 + matrixH[num13 + j].Imaginary * complex4;
						matrixH[num16 + j] = complex2 * complex4 - matrixH[num13 + j].Imaginary * complex3;
					}
				}
				complex = matrixH[num11];
				if (complex.Imaginary != 0.0)
				{
					complex /= (Complex)matrixH[num11].Magnitude;
					matrixH[num11] = matrixH[num11].Magnitude;
					for (int l = num + 1; l < order; l++)
					{
						matrixH[l * order + num] *= complex.Conjugate();
					}
				}
				for (int m = num3 + 1; m <= num; m++)
				{
					Complex complex2 = vectorV[m - 1];
					int num17 = m * order;
					int num18 = (m - 1) * order;
					int num19 = num18 + m;
					for (int n = 0; n <= m; n++)
					{
						int num20 = num18 + n;
						Complex complex4 = matrixH[num17 + n];
						Complex complex3;
						if (n != m)
						{
							complex3 = matrixH[num20];
							matrixH[num20] = complex2 * complex3 + matrixH[num18 + m].Imaginary * complex4;
						}
						else
						{
							complex3 = matrixH[num20].Real;
							matrixH[num20] = new Complex(complex2.Real * complex3.Real - complex2.Imaginary * complex3.Imaginary + matrixH[num18 + m].Imaginary * complex4.Real, matrixH[num20].Imaginary);
						}
						matrixH[num17 + n] = complex2.Conjugate() * complex4 - matrixH[num18 + m].Imaginary * complex3;
					}
					for (int num21 = 0; num21 < order; num21++)
					{
						Complex complex3 = dataEv[(m - 1) * order + num21];
						Complex complex4 = dataEv[m * order + num21];
						dataEv[num18 + num21] = complex2 * complex3 + matrixH[num19].Imaginary * complex4;
						dataEv[num17 + num21] = complex2.Conjugate() * complex4 - matrixH[num19].Imaginary * complex3;
					}
				}
				if (complex.Imaginary != 0.0)
				{
					for (int num22 = 0; num22 <= num; num22++)
					{
						matrixH[num10 + num22] *= complex;
					}
					for (int num23 = 0; num23 < order; num23++)
					{
						dataEv[num10 + num23] *= complex;
					}
				}
			}
			num15 = 0.0;
			for (int num24 = 0; num24 < order; num24++)
			{
				for (int num25 = num24; num25 < order; num25++)
				{
					num15 = Math.Max(num15, Math.Abs(matrixH[num25 * order + num24].Real) + Math.Abs(matrixH[num25 * order + num24].Imaginary));
				}
			}
			if (order == 1 || num15 == 0.0)
			{
				return;
			}
			for (num = order - 1; num > 0; num--)
			{
				int num26 = num * order;
				int num27 = num26 + num;
				Complex complex2 = vectorV[num];
				matrixH[num27] = 1.0;
				for (int num28 = num - 1; num28 >= 0; num28--)
				{
					Complex complex4 = 0.0;
					for (int num29 = num28 + 1; num29 <= num; num29++)
					{
						complex4 += matrixH[num29 * order + num28] * matrixH[num26 + num29];
					}
					Complex complex3 = complex2 - vectorV[num28];
					if (complex3.Real == 0.0 && complex3.Imaginary == 0.0)
					{
						complex3 = doublePrecision * num15;
					}
					matrixH[num26 + num28] = complex4 / complex3;
					double num30 = Math.Abs(matrixH[num26 + num28].Real) + Math.Abs(matrixH[num26 + num28].Imaginary);
					if (doublePrecision * num30 * num30 > 1.0)
					{
						for (int num31 = num28; num31 <= num; num31++)
						{
							matrixH[num26 + num31] /= (Complex)num30;
						}
					}
				}
			}
			for (int num32 = order - 1; num32 > 0; num32--)
			{
				int num33 = num32 * order;
				for (int num34 = 0; num34 < order; num34++)
				{
					Complex complex4 = Complex.Zero;
					for (int num35 = 0; num35 <= num32; num35++)
					{
						complex4 += dataEv[num35 * order + num34] * matrixH[num33 + num35];
					}
					dataEv[num33 + num34] = complex4;
				}
			}
		}

		protected static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, Complex[] matrix, Complex[] row)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
			{
				for (int j = 0; j < numCols; j++)
				{
					row[j] = matrix[j * numRows + rowindx];
				}
				break;
			}
			case Transpose.ConjugateTranspose:
			{
				int num = rowindx * numCols;
				for (int i = 0; i < row.Length; i++)
				{
					row[i] = matrix[i + num].Conjugate();
				}
				break;
			}
			default:
				Array.Copy(matrix, rowindx * numCols, row, 0, numCols);
				break;
			}
		}

		protected static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, Complex[] matrix, Complex[] column)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
				Array.Copy(matrix, colindx * numRows, column, 0, numRows);
				break;
			case Transpose.ConjugateTranspose:
			{
				for (int j = 0; j < numRows; j++)
				{
					column[j] = matrix[j * numCols + colindx].Conjugate();
				}
				break;
			}
			default:
			{
				for (int i = 0; i < numRows; i++)
				{
					column[i] = matrix[i * numCols + colindx];
				}
				break;
			}
			}
		}

		public virtual void AddVectorToScaledVector(Complex32[] y, Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (alpha.IsZero())
			{
				y.Copy(result);
			}
			else if (alpha.IsOne())
			{
				for (int i = 0; i < result.Length; i++)
				{
					result[i] = y[i] + x[i];
				}
			}
			else
			{
				for (int j = 0; j < result.Length; j++)
				{
					result[j] = y[j] + alpha * x[j];
				}
			}
		}

		public virtual void ScaleArray(Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (alpha.IsZero())
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if (alpha.IsOne())
			{
				x.Copy(result);
				return;
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = alpha * x[i];
			}
		}

		public virtual void ConjugateArray(Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i].Conjugate();
			}
		}

		public virtual Complex32 DotProduct(Complex32[] x, Complex32[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Complex32 result = new Complex32(0f, 0f);
			for (int i = 0; i < y.Length; i++)
			{
				result += y[i] * x[i];
			}
			return result;
		}

		public virtual void AddArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] + y[i];
			}
		}

		public virtual void SubtractArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] - y[i];
			}
		}

		public virtual void PointWiseMultiplyArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] * y[i];
			}
		}

		public virtual void PointWiseDivideArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = Complex32.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, Complex32[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += (double)matrix[l * rows + m].Magnitude;
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(matrix[j * rows + k].Magnitude, num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += matrix[n * rows + num5].Magnitude;
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				Complex32[] array = new Complex32[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.ConjugateTranspose, 1f, matrix, rows, columns, matrix, rows, columns, 0f, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += (double)array[i * rows + i].Magnitude;
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(Complex32[] x, int rowsX, int columnsX, Complex32[] y, int rowsY, int columnsY, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsX}) != rowsB ({rowsY})"));
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsA ({columnsX}) != a.Length ({x.Length})"));
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsY}) * columnsB ({columnsY}) != b.Length ({y.Length})"));
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsB ({columnsY}) != c.Length ({result.Length})"));
			}
			Array.Clear(result, 0, result.Length);
			Complex32[][] columnDataB = new Complex32[columnsY][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				Complex32[] array = new Complex32[rowsY];
				GetColumn(Transpose.DontTranspose, i, rowsY, columnsY, y, array);
				columnDataB[i] = array;
			}
			if (rowsX + columnsY + columnsX < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				Complex32[] array2 = new Complex32[columnsX];
				for (int j = 0; j < rowsX; j++)
				{
					GetRow(Transpose.DontTranspose, j, rowsX, columnsX, x, array2);
					for (int k = 0; k < columnsY; k++)
					{
						Complex32[] array3 = columnDataB[k];
						Complex32 zero = Complex32.Zero;
						for (int l = 0; l < array2.Length; l++)
						{
							zero += array2[l] * array3[l];
						}
						result[k * rowsX + j] += Complex32.One * zero;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsX, 1, delegate(int u, int v)
			{
				Complex32[] array4 = new Complex32[columnsX];
				for (int m = u; m < v; m++)
				{
					GetRow(Transpose.DontTranspose, m, rowsX, columnsX, x, array4);
					for (int n = 0; n < columnsY; n++)
					{
						Complex32[] array5 = columnDataB[n];
						Complex32 zero2 = Complex32.Zero;
						for (int num = 0; num < array4.Length; num++)
						{
							zero2 += array4[num] * array5[num];
						}
						result[n * rowsX + m] += Complex32.One * zero2;
					}
				}
			});
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] a, int rowsA, int columnsA, Complex32[] b, int rowsB, int columnsB, Complex32 beta, Complex32[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			if (transposeA != Transpose.DontTranspose)
			{
				int num = rowsA;
				rowsA = columnsA;
				columnsA = num;
			}
			if (transposeB != Transpose.DontTranspose)
			{
				int num2 = rowsB;
				rowsB = columnsB;
				columnsB = num2;
			}
			if (columnsA != rowsB)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsA}) != rowsB ({rowsB})"));
			}
			if (rowsA * columnsA != a.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsA ({columnsA}) != a.Length ({a.Length})"));
			}
			if (rowsB * columnsB != b.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsB}) * columnsB ({columnsB}) != b.Length ({b.Length})"));
			}
			if (rowsA * columnsB != c.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsB ({columnsB}) != c.Length ({c.Length})"));
			}
			if (beta == Complex32.Zero)
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (beta != Complex32.One)
			{
				ScaleArray(beta, c, c);
			}
			if (alpha == Complex32.Zero)
			{
				return;
			}
			Complex32[][] columnDataB = new Complex32[columnsB][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				Complex32[] array = new Complex32[rowsB];
				GetColumn(transposeB, i, rowsB, columnsB, b, array);
				columnDataB[i] = array;
			}
			if (rowsA + columnsB + columnsA < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				Complex32[] array2 = new Complex32[columnsA];
				for (int j = 0; j < rowsA; j++)
				{
					GetRow(transposeA, j, rowsA, columnsA, a, array2);
					for (int k = 0; k < columnsB; k++)
					{
						Complex32[] array3 = columnDataB[k];
						Complex32 zero = Complex32.Zero;
						for (int l = 0; l < array2.Length; l++)
						{
							zero += array2[l] * array3[l];
						}
						c[k * rowsA + j] += alpha * zero;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsA, 1, delegate(int u, int v)
			{
				Complex32[] array4 = new Complex32[columnsA];
				for (int m = u; m < v; m++)
				{
					GetRow(transposeA, m, rowsA, columnsA, a, array4);
					for (int n = 0; n < columnsB; n++)
					{
						Complex32[] array5 = columnDataB[n];
						Complex32 zero2 = Complex32.Zero;
						for (int num3 = 0; num3 < array4.Length; num3++)
						{
							zero2 += array4[num3] * array5[num3];
						}
						c[n * rowsA + m] += alpha * zero2;
					}
				}
			});
		}

		public virtual void LUFactor(Complex32[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			Complex32[] array = new Complex32[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					Complex32 zero = Complex32.Zero;
					for (int m = 0; m < num3; m++)
					{
						zero += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= zero);
				}
				int num4 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (array[n].Magnitude > array[num4].Magnitude)
					{
						num4 = n;
					}
				}
				if (num4 != j)
				{
					for (int num5 = 0; num5 < order; num5++)
					{
						int num6 = num5 * order;
						int num7 = num6 + num4;
						int num8 = num6 + j;
						Complex32 complex = data[num7];
						data[num7] = data[num8];
						data[num8] = complex;
					}
					ipiv[j] = num4;
				}
				if ((j < order) & (data[num2] != 0f))
				{
					for (int num9 = j + 1; num9 < order; num9++)
					{
						data[num + num9] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(Complex32[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Complex32[] array = new Complex32[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = Complex32.One;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, Complex32[] a, int order, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, Complex32[] a, int order, int[] ipiv, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						Complex32 complex = b[num3];
						b[num3] = b[num4];
						b[num4] = complex;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num5 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num6 = m * order;
						b[l + num6] -= b[k + num6] * a[l + num5];
					}
				}
			}
			for (int num7 = order - 1; num7 >= 0; num7--)
			{
				int num8 = num7 + num7 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num7 + n * order] /= a[num8];
				}
				num8 = num7 * order;
				for (int num9 = 0; num9 < num7; num9++)
				{
					for (int num10 = 0; num10 < columnsOfB; num10++)
					{
						int num11 = num10 * order;
						b[num9 + num11] -= b[num7 + num11] * a[num9 + num8];
					}
				}
			}
		}

		public virtual void CholeskyFactor(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			Complex32[] array = new Complex32[order];
			for (int i = 0; i < order; i++)
			{
				Complex32 complex = a[i * order + i];
				if (!((double)complex.Real > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				complex = (array[i] = (a[i * order + i] = complex.SquareRoot()));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= complex;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0f;
				}
			}
		}

		private static void DoCholeskyStep(Complex32[] data, int rowDim, int firstCol, int colLimit, Complex32[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				Complex32 complex = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * complex.Conjugate();
				}
			}
		}

		public virtual void CholeskySolve(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(Complex32[] a, int orderA, Complex32[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				Complex32 complex = b[num + i];
				for (int num2 = i - 1; num2 >= 0; num2--)
				{
					complex -= a[num2 * orderA + i] * b[num + num2];
				}
				b[num + i] = complex / a[i * orderA + i];
			}
			for (int num3 = orderA - 1; num3 >= 0; num3--)
			{
				Complex32 complex = b[num + num3];
				int num4 = num3 * orderA;
				for (int j = num3 + 1; j < orderA; j++)
				{
					complex -= a[num4 + j].Conjugate() * b[num + j];
				}
				b[num + num3] = complex / a[num4 + num3];
			}
		}

		public virtual void QRFactor(Complex32[] r, int rowsR, int columnsR, Complex32[] q, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			Complex32[] work = ((columnsR > rowsR) ? new Complex32[rowsR * rowsR] : new Complex32[rowsR * columnsR]);
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = Complex32.One;
				}
			});
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(Complex32[] a, int rowsA, int columnsA, Complex32[] r, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			Complex32[] work = new Complex32[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = Complex32.One;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(Complex32[] work, int workIndex, Complex32[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				Complex32 zero = Complex32.Zero;
				for (int j = rowStart; j < rowCount; j++)
				{
					zero += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart].Conjugate() * zero;
				}
			}
		}

		private static void GenerateColumn(Complex32[] work, Complex32[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num3 = tmp + l;
					work[num3 - row] = a[num3];
					a[num3] = Complex32.Zero;
				}
			});
			Complex32 norm = Complex32.Zero;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num2 = tmp + i;
				norm += work[num2].Magnitude * work[num2].Magnitude;
			}
			norm = norm.SquareRoot();
			if (row == rowCount - 1 || norm.Magnitude == 0f)
			{
				a[num] = -work[tmp];
				work[tmp] = new Complex32(2f, 0f).SquareRoot();
				return;
			}
			if (work[tmp].Magnitude != 0f)
			{
				norm = norm.Magnitude * (work[tmp] / work[tmp].Magnitude);
			}
			a[num] = -norm;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] /= norm;
				}
			});
			work[tmp] += 1f;
			Complex32 s = (1f / work[tmp]).SquareRoot();
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] = work[tmp + j].Conjugate() * s;
				}
			});
		}

		public virtual void QRSolve(Complex32[] a, int rows, int columns, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			Complex32[] tau = new Complex32[rows * columns];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				Complex32[] q = new Complex32[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				Complex32[] r = new Complex32[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(Complex32[] q, Complex32[] r, int rowsA, int columnsA, Complex32[] tau, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			Complex32[] sol = new Complex32[b.Length];
			Array.Copy(b, 0, sol, 0, b.Length);
			Complex32[] column = new Complex32[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						Complex32 zero = Complex32.Zero;
						for (int num9 = 0; num9 < rowsA; num9++)
						{
							zero += q[num8 + num9].Conjugate() * column[num9];
						}
						sol[jm + n] = zero;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, Complex32[] a, int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			Complex32[] array = new Complex32[rowsA];
			Complex32[] array2 = new Complex32[columnsA];
			Complex32[] array3 = new Complex32[vt.Length];
			Complex32[] array4 = new Complex32[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					float num5 = 0f;
					for (int j = i; j < rowsA; j++)
					{
						num5 += a[i * rowsA + j].Magnitude * a[i * rowsA + j].Magnitude;
					}
					array4[i] = (float)Math.Sqrt(num5);
					if (array4[i] != 0f)
					{
						if (a[i * rowsA + i] != 0f)
						{
							array4[i] = array4[i].Magnitude * (a[i * rowsA + i] / a[i * rowsA + i].Magnitude);
						}
						for (int j = i; j < rowsA; j++)
						{
							a[i * rowsA + j] *= 1f / array4[i];
						}
						a[i * rowsA + i] = 1f + a[i * rowsA + i];
					}
					array4[i] = -array4[i];
				}
				for (int k = num4; k < columnsA; k++)
				{
					if (i < num && array4[i] != 0f)
					{
						Complex32 complex = 0f;
						for (int j = i; j < rowsA; j++)
						{
							complex += a[i * rowsA + j].Conjugate() * a[k * rowsA + j];
						}
						complex = -complex / a[i * rowsA + i];
						for (int l = i; l < rowsA; l++)
						{
							a[k * rowsA + l] += complex * a[i * rowsA + l];
						}
					}
					array2[k] = a[k * rowsA + i].Conjugate();
				}
				if (computeVectors && i < num)
				{
					for (int j = i; j < rowsA; j++)
					{
						u[i * rowsA + j] = a[i * rowsA + j];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				float num6 = 0f;
				for (int j = num4; j < array2.Length; j++)
				{
					num6 += array2[j].Magnitude * array2[j].Magnitude;
				}
				array2[i] = (float)Math.Sqrt(num6);
				if (array2[i] != 0f)
				{
					if (array2[num4] != 0f)
					{
						array2[i] = array2[i].Magnitude * (array2[num4] / array2[num4].Magnitude);
					}
					for (int j = num4; j < array2.Length; j++)
					{
						array2[j] *= 1f / array2[i];
					}
					array2[num4] = 1f + array2[num4];
				}
				array2[i] = -array2[i].Conjugate();
				if (num4 < rowsA && array2[i] != 0f)
				{
					for (int j = num4; j < rowsA; j++)
					{
						array[j] = 0f;
					}
					for (int k = num4; k < columnsA; k++)
					{
						for (int m = num4; m < rowsA; m++)
						{
							array[m] += array2[k] * a[k * rowsA + m];
						}
					}
					for (int k = num4; k < columnsA; k++)
					{
						Complex32 complex2 = (-array2[k] / array2[num4]).Conjugate();
						for (int n = num4; n < rowsA; n++)
						{
							a[k * rowsA + n] += complex2 * array[n];
						}
					}
				}
				if (computeVectors)
				{
					for (int j = num4; j < columnsA; j++)
					{
						array3[i * columnsA + j] = array2[j];
					}
				}
			}
			int num7 = Math.Min(columnsA, rowsA + 1);
			int num8 = num + 1;
			int num9 = num2 + 1;
			if (num < columnsA)
			{
				array4[num8 - 1] = a[(num8 - 1) * rowsA + (num8 - 1)];
			}
			if (rowsA < num7)
			{
				array4[num7 - 1] = 0f;
			}
			if (num9 < num7)
			{
				array2[num9 - 1] = a[(num7 - 1) * rowsA + (num9 - 1)];
			}
			array2[num7 - 1] = 0f;
			if (computeVectors)
			{
				for (int k = num8 - 1; k < rowsA; k++)
				{
					for (int j = 0; j < rowsA; j++)
					{
						u[k * rowsA + j] = 0f;
					}
					u[k * rowsA + k] = 1f;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if (array4[i] != 0f)
					{
						for (int k = i + 1; k < rowsA; k++)
						{
							Complex32 complex = 0f;
							for (int j = i; j < rowsA; j++)
							{
								complex += u[i * rowsA + j].Conjugate() * u[k * rowsA + j];
							}
							complex = -complex / u[i * rowsA + i];
							for (int num10 = i; num10 < rowsA; num10++)
							{
								u[k * rowsA + num10] += complex * u[i * rowsA + num10];
							}
						}
						for (int j = i; j < rowsA; j++)
						{
							u[i * rowsA + j] *= -1f;
						}
						u[i * rowsA + i] = 1f + u[i * rowsA + i];
						for (int j = 0; j < i; j++)
						{
							u[i * rowsA + j] = 0f;
						}
					}
					else
					{
						for (int j = 0; j < rowsA; j++)
						{
							u[i * rowsA + j] = 0f;
						}
						u[i * rowsA + i] = 1f;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && array2[i] != 0f)
					{
						for (int k = num4; k < columnsA; k++)
						{
							Complex32 complex = 0f;
							for (int j = num4; j < columnsA; j++)
							{
								complex += array3[i * columnsA + j].Conjugate() * array3[k * columnsA + j];
							}
							complex = -complex / array3[i * columnsA + num4];
							for (int num11 = i; num11 < columnsA; num11++)
							{
								array3[k * columnsA + num11] += complex * array3[i * columnsA + num11];
							}
						}
					}
					for (int j = 0; j < columnsA; j++)
					{
						array3[i * columnsA + j] = 0f;
					}
					array3[i * columnsA + i] = 1f;
				}
			}
			for (int j = 0; j < num7; j++)
			{
				Complex32 complex;
				Complex32 complex3;
				if (array4[j] != 0f)
				{
					complex = array4[j].Magnitude;
					complex3 = array4[j] / complex;
					array4[j] = complex;
					if (j < num7 - 1)
					{
						array2[j] /= complex3;
					}
					if (computeVectors)
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[j * rowsA + k] *= complex3;
						}
					}
				}
				if (j == num7 - 1)
				{
					break;
				}
				if (array2[j] == 0f)
				{
					continue;
				}
				complex = array2[j].Magnitude;
				complex3 = complex / array2[j];
				array2[j] = complex;
				array4[j + 1] *= complex3;
				if (computeVectors)
				{
					for (int k = 0; k < columnsA; k++)
					{
						array3[(j + 1) * columnsA + k] *= complex3;
					}
				}
			}
			int num12 = num7;
			int num13 = 0;
			while (num7 > 0)
			{
				if (num13 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num7 - 2; i >= 0; i--)
				{
					float num14 = array4[i].Magnitude + array4[i + 1].Magnitude;
					if ((num14 + array2[i].Magnitude).AlmostEqualRelative(num14, 7))
					{
						array2[i] = 0f;
						break;
					}
				}
				int num15;
				if (i == num7 - 2)
				{
					num15 = 4;
				}
				else
				{
					int num16;
					for (num16 = num7 - 1; num16 > i; num16--)
					{
						float num14 = 0f;
						if (num16 != num7 - 1)
						{
							num14 += array2[num16].Magnitude;
						}
						if (num16 != i + 1)
						{
							num14 += array2[num16 - 1].Magnitude;
						}
						if ((num14 + array4[num16].Magnitude).AlmostEqualRelative(num14, 7))
						{
							array4[num16] = 0f;
							break;
						}
					}
					if (num16 == i)
					{
						num15 = 3;
					}
					else if (num16 == num7 - 1)
					{
						num15 = 1;
					}
					else
					{
						num15 = 2;
						i = num16;
					}
				}
				i++;
				float c;
				float s2;
				switch (num15)
				{
				case 1:
				{
					float db = array2[num7 - 2].Real;
					array2[num7 - 2] = 0f;
					for (int num26 = i; num26 < num7 - 1; num26++)
					{
						int num17 = num7 - 2 - num26 + i;
						float da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						if (num17 != i)
						{
							db = (0f - s2) * array2[num17 - 1].Real;
							array2[num17 - 1] = c * array2[num17 - 1];
						}
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex32 complex9 = c * array3[num17 * columnsA + j] + s2 * array3[(num7 - 1) * columnsA + j];
								array3[(num7 - 1) * columnsA + j] = c * array3[(num7 - 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex9;
							}
						}
					}
					break;
				}
				case 2:
				{
					float db = array2[i - 1].Real;
					array2[i - 1] = 0f;
					for (int num17 = i; num17 < num7; num17++)
					{
						float da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						db = (0f - s2) * array2[num17].Real;
						array2[num17] = c * array2[num17];
						if (computeVectors)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex32 complex6 = c * u[num17 * rowsA + j] + s2 * u[(i - 1) * rowsA + j];
								u[(i - 1) * rowsA + j] = c * u[(i - 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex6;
							}
						}
					}
					break;
				}
				case 3:
				{
					float val = 0f;
					val = Math.Max(val, array4[num7 - 1].Magnitude);
					val = Math.Max(val, array4[num7 - 2].Magnitude);
					val = Math.Max(val, array2[num7 - 2].Magnitude);
					val = Math.Max(val, array4[i].Magnitude);
					val = Math.Max(val, array2[i].Magnitude);
					float num18 = array4[num7 - 1].Real / val;
					float num19 = array4[num7 - 2].Real / val;
					float num20 = array2[num7 - 2].Real / val;
					float num21 = array4[i].Real / val;
					float num22 = array2[i].Real / val;
					float num23 = ((num19 + num18) * (num19 - num18) + num20 * num20) / 2f;
					float num24 = num18 * num20 * (num18 * num20);
					float num25 = 0f;
					if (num23 != 0f || num24 != 0f)
					{
						num25 = (float)Math.Sqrt(num23 * num23 + num24);
						if (num23 < 0f)
						{
							num25 = 0f - num25;
						}
						num25 = num24 / (num23 + num25);
					}
					float db = (num21 + num18) * (num21 - num18) + num25;
					float db2 = num21 * num22;
					for (int num17 = i; num17 < num7 - 1; num17++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num17 != i)
						{
							array2[num17 - 1] = db;
						}
						db = c * array4[num17].Real + s2 * array2[num17].Real;
						array2[num17] = c * array2[num17] - s2 * array4[num17];
						db2 = s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = c * array4[num17 + 1];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex32 complex7 = c * array3[num17 * columnsA + j] + s2 * array3[(num17 + 1) * columnsA + j];
								array3[(num17 + 1) * columnsA + j] = c * array3[(num17 + 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex7;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num17] = db;
						db = c * array2[num17].Real + s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = -(s2 * array2[num17]) + c * array4[num17 + 1];
						db2 = s2 * array2[num17 + 1].Real;
						array2[num17 + 1] = c * array2[num17 + 1];
						if (computeVectors && num17 < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex32 complex8 = c * u[num17 * rowsA + j] + s2 * u[(num17 + 1) * rowsA + j];
								u[(num17 + 1) * rowsA + j] = c * u[(num17 + 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex8;
							}
						}
					}
					array2[num7 - 2] = db;
					num13++;
					break;
				}
				case 4:
					if (array4[i].Real < 0f)
					{
						array4[i] = -array4[i];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								array3[i * columnsA + j] *= -1f;
							}
						}
					}
					for (; i != num12 - 1 && !(array4[i].Real >= array4[i + 1].Real); i++)
					{
						Complex32 complex = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = complex;
						if (computeVectors && i < columnsA)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex32 complex4 = array3[i * columnsA + j];
								array3[i * columnsA + j] = array3[(i + 1) * columnsA + j];
								array3[(i + 1) * columnsA + j] = complex4;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex32 complex5 = u[i * rowsA + j];
								u[i * rowsA + j] = u[(i + 1) * rowsA + j];
								u[(i + 1) * rowsA + j] = complex5;
							}
						}
					}
					num13 = 0;
					num7--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int j = 0; j < columnsA; j++)
				{
					for (int k = 0; k < columnsA; k++)
					{
						vt[k * columnsA + j] = array3[j * columnsA + k].Conjugate();
					}
				}
			}
			Array.Copy(array4, 0, s, 0, Math.Min(rowsA, columnsA));
		}

		public virtual void SvdSolve(Complex32[] a, int rowsA, int columnsA, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex32[] s = new Complex32[Math.Min(rowsA, columnsA)];
			Complex32[] u = new Complex32[rowsA * rowsA];
			Complex32[] vt = new Complex32[columnsA * columnsA];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			Complex32[] array = new Complex32[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					Complex32 zero = Complex32.Zero;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							zero += u[j * rowsA + k].Conjugate() * b[i * rowsA + k];
						}
						zero /= s[j];
					}
					array[j] = zero;
				}
				for (int l = 0; l < columnsA; l++)
				{
					Complex32 zero2 = Complex32.Zero;
					for (int m = 0; m < columnsA; m++)
					{
						zero2 += vt[l * columnsA + m].Conjugate() * array[m];
					}
					x[i * columnsA + l] = zero2;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, Complex32[] matrix, Complex32[] matrixEv, Complex[] vectorEv, Complex32[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			Complex32[] array = new Complex32[matrix.Length];
			Array.Copy(matrix, 0, array, 0, matrix.Length);
			if (isSymmetric)
			{
				Complex32[] tau = new Complex32[order];
				float[] array2 = new float[order];
				float[] array3 = new float[order];
				SymmetricTridiagonalize(array, array2, array3, tau, order);
				SymmetricDiagonalize(matrixEv, array2, array3, order);
				SymmetricUntridiagonalize(matrixEv, array, tau, order);
				for (int i = 0; i < order; i++)
				{
					vectorEv[i] = new Complex(array2[i], array3[i]);
					matrixD[i * order + i] = new Complex32(array2[i], array3[i]);
				}
			}
			else
			{
				Complex32[] array4 = new Complex32[order];
				NonsymmetricReduceToHessenberg(matrixEv, array, order);
				NonsymmetricReduceHessenberToRealSchur(array4, matrixEv, array, order);
				for (int j = 0; j < order; j++)
				{
					vectorEv[j] = new Complex(array4[j].Real, array4[j].Imaginary);
					matrixD[j * order + j] = array4[j];
				}
			}
		}

		internal static void SymmetricTridiagonalize(Complex32[] matrixA, float[] d, float[] e, Complex32[] tau, int order)
		{
			tau[order - 1] = Complex32.One;
			for (int i = 0; i < order; i++)
			{
				d[i] = matrixA[i * order + i].Real;
			}
			float num6;
			for (int num = order - 1; num > 0; num--)
			{
				float num2 = 0f;
				float num3 = 0f;
				for (int j = 0; j < num; j++)
				{
					num2 = num2 + Math.Abs(matrixA[j * order + num].Real) + Math.Abs(matrixA[j * order + num].Imaginary);
				}
				if (num2 == 0f)
				{
					tau[num - 1] = Complex32.One;
					e[num] = 0f;
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						matrixA[k * order + num] /= num2;
						num3 += matrixA[k * order + num].MagnitudeSquared;
					}
					Complex32 complex = (float)Math.Sqrt(num3);
					e[num] = num2 * complex.Real;
					int num4 = (num - 1) * order + num;
					Complex32 complex2 = matrixA[num4];
					Complex32 complex3;
					if (complex2.Magnitude != 0f)
					{
						complex3 = -(matrixA[num4].Conjugate() * tau[num].Conjugate()) / complex2.Magnitude;
						num3 += complex2.Magnitude * complex.Real;
						complex = 1f + complex / complex2.Magnitude;
						matrixA[num4] *= complex;
					}
					else
					{
						complex3 = -tau[num].Conjugate();
						matrixA[num4] = complex;
					}
					if (complex2.Magnitude == 0f || num != 1)
					{
						complex2 = Complex32.Zero;
						for (int l = 0; l < num; l++)
						{
							Complex32 zero = Complex32.Zero;
							int num5 = l * order;
							for (int m = 0; m <= l; m++)
							{
								zero += matrixA[m * order + l] * matrixA[m * order + num].Conjugate();
							}
							for (int n = l + 1; n <= num - 1; n++)
							{
								zero += matrixA[num5 + n].Conjugate() * matrixA[n * order + num].Conjugate();
							}
							tau[l] = zero / num3;
							complex2 += zero / num3 * matrixA[num5 + num];
						}
						num6 = complex2.Real / (num3 + num3);
						for (int num7 = 0; num7 < num; num7++)
						{
							complex2 = matrixA[num7 * order + num].Conjugate();
							complex = tau[num7] - num6 * complex2;
							tau[num7] = complex.Conjugate();
							for (int num8 = 0; num8 <= num7; num8++)
							{
								matrixA[num8 * order + num7] -= complex2 * tau[num8] + complex * matrixA[num8 * order + num];
							}
						}
					}
					for (int num9 = 0; num9 < num; num9++)
					{
						matrixA[num9 * order + num] *= num2;
					}
					tau[num - 1] = complex3.Conjugate();
				}
				num6 = d[num];
				d[num] = matrixA[num * order + num].Real;
				matrixA[num * order + num] = new Complex32(num6, num2 * (float)Math.Sqrt(num3));
			}
			num6 = d[0];
			d[0] = matrixA[0].Real;
			matrixA[0] = num6;
			e[0] = 0f;
		}

		internal static void SymmetricDiagonalize(Complex32[] dataEv, float[] d, float[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0f;
			float num = 0f;
			float num2 = 0f;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !((double)Math.Abs(e[k]) <= doublePrecision * (double)num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						float num4 = d[j];
						float num5 = (d[j + 1] - num4) / (2f * e[j]);
						float num6 = SpecialFunctions.Hypotenuse(num5, 1f);
						if (num5 < 0f)
						{
							num6 = 0f - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						float num7 = d[j + 1];
						float num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						float num9 = 1f;
						float num10 = num9;
						float num11 = num9;
						float num12 = e[j + 1];
						float num13 = 0f;
						float num14 = 0f;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = dataEv[(num15 + 1) * order + m].Real;
								dataEv[(num15 + 1) * order + m] = num13 * dataEv[num15 * order + m].Real + num9 * num8;
								dataEv[num15 * order + m] = num9 * dataEv[num15 * order + m].Real - num13 * num8;
							}
						}
						num5 = (0f - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while ((double)Math.Abs(e[j]) > doublePrecision * (double)num2);
				}
				d[j] += num;
				e[j] = 0f;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				float num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = dataEv[n * order + num19].Real;
						dataEv[n * order + num19] = dataEv[num16 * order + num19];
						dataEv[num16 * order + num19] = num17;
					}
				}
			}
		}

		internal static void SymmetricUntridiagonalize(Complex32[] dataEv, Complex32[] matrixA, Complex32[] tau, int order)
		{
			for (int i = 0; i < order; i++)
			{
				for (int j = 0; j < order; j++)
				{
					dataEv[j * order + i] = dataEv[j * order + i].Real * tau[i].Conjugate();
				}
			}
			for (int k = 1; k < order; k++)
			{
				float imaginary = matrixA[k * order + k].Imaginary;
				if (imaginary == 0f)
				{
					continue;
				}
				for (int l = 0; l < order; l++)
				{
					Complex32 zero = Complex32.Zero;
					for (int m = 0; m < k; m++)
					{
						zero += dataEv[l * order + m] * matrixA[m * order + k];
					}
					zero = zero / imaginary / imaginary;
					for (int n = 0; n < k; n++)
					{
						dataEv[l * order + n] -= zero * matrixA[n * order + k].Conjugate();
					}
				}
			}
		}

		internal static void NonsymmetricReduceToHessenberg(Complex32[] dataEv, Complex32[] matrixH, int order)
		{
			Complex32[] array = new Complex32[order];
			for (int i = 1; i < order - 1; i++)
			{
				float num = 0f;
				int num2 = (i - 1) * order;
				for (int j = i; j < order; j++)
				{
					num += Math.Abs(matrixH[num2 + j].Real) + Math.Abs(matrixH[num2 + j].Imaginary);
				}
				if (num == 0f)
				{
					continue;
				}
				float num3 = 0f;
				for (int num4 = order - 1; num4 >= i; num4--)
				{
					array[num4] = matrixH[num2 + num4] / num;
					num3 += array[num4].MagnitudeSquared;
				}
				float num5 = (float)Math.Sqrt(num3);
				if (array[i].Magnitude != 0f)
				{
					num3 += array[i].Magnitude * num5;
					num5 /= array[i].Magnitude;
					array[i] = (1f + num5) * array[i];
				}
				else
				{
					array[i] = num5;
					matrixH[num2 + i] = num;
				}
				for (int k = i; k < order; k++)
				{
					Complex32 zero = Complex32.Zero;
					int num6 = k * order;
					for (int num7 = order - 1; num7 >= i; num7--)
					{
						zero += array[num7].Conjugate() * matrixH[num6 + num7];
					}
					zero /= num3;
					for (int l = i; l < order; l++)
					{
						matrixH[num6 + l] -= zero * array[l];
					}
				}
				for (int m = 0; m < order; m++)
				{
					Complex32 zero2 = Complex32.Zero;
					for (int num8 = order - 1; num8 >= i; num8--)
					{
						zero2 += array[num8] * matrixH[num8 * order + m];
					}
					zero2 /= num3;
					for (int n = i; n < order; n++)
					{
						matrixH[n * order + m] -= zero2 * array[n].Conjugate();
					}
				}
				array[i] = num * array[i];
				matrixH[num2 + i] *= 0f - num5;
			}
			for (int num9 = 0; num9 < order; num9++)
			{
				for (int num10 = 0; num10 < order; num10++)
				{
					dataEv[num10 * order + num9] = ((num9 == num10) ? Complex32.One : Complex32.Zero);
				}
			}
			for (int num11 = order - 2; num11 >= 1; num11--)
			{
				int num12 = (num11 - 1) * order;
				int num13 = num12 + num11;
				if (matrixH[num13] != Complex32.Zero && array[num11] != Complex32.Zero)
				{
					float num14 = matrixH[num13].Real * array[num11].Real + matrixH[num13].Imaginary * array[num11].Imaginary;
					for (int num15 = num11 + 1; num15 < order; num15++)
					{
						array[num15] = matrixH[num12 + num15];
					}
					for (int num16 = num11; num16 < order; num16++)
					{
						Complex32 zero3 = Complex32.Zero;
						for (int num17 = num11; num17 < order; num17++)
						{
							zero3 += array[num17].Conjugate() * dataEv[num16 * order + num17];
						}
						zero3 /= num14;
						for (int num18 = num11; num18 < order; num18++)
						{
							dataEv[num16 * order + num18] += zero3 * array[num18];
						}
					}
				}
			}
			for (int num19 = 1; num19 < order; num19++)
			{
				int num20 = (num19 - 1) * order + num19;
				int num21 = num19 * order;
				if (matrixH[num20].Imaginary != 0f)
				{
					Complex32 complex = matrixH[num20] / matrixH[num20].Magnitude;
					matrixH[num20] = matrixH[num20].Magnitude;
					for (int num22 = num19; num22 < order; num22++)
					{
						matrixH[num22 * order + num19] *= complex.Conjugate();
					}
					for (int num23 = 0; num23 <= Math.Min(num19 + 1, order - 1); num23++)
					{
						matrixH[num21 + num23] *= complex;
					}
					for (int num24 = 0; num24 < order; num24++)
					{
						dataEv[num19 * order + num24] *= complex;
					}
				}
			}
		}

		internal static void NonsymmetricReduceHessenberToRealSchur(Complex32[] vectorV, Complex32[] dataEv, Complex32[] matrixH, int order)
		{
			int num = order - 1;
			float num2 = (float)Precision.SinglePrecision;
			Complex32 zero = Complex32.Zero;
			int num3 = 0;
			float num16;
			while (num >= 0)
			{
				int num4;
				for (num4 = num; num4 > 0; num4--)
				{
					int num5 = num4 - 1;
					int num6 = num5 * order;
					int num7 = num4 * order;
					float num8 = Math.Abs(matrixH[num6 + num5].Real) + Math.Abs(matrixH[num6 + num5].Imaginary) + Math.Abs(matrixH[num7 + num4].Real) + Math.Abs(matrixH[num7 + num4].Imaginary);
					if (Math.Abs(matrixH[num6 + num4].Real) < num2 * num8)
					{
						break;
					}
				}
				int num9 = num - 1;
				int num10 = num9 * order;
				int num11 = num * order;
				int num12 = num11 + num;
				if (num4 == num)
				{
					matrixH[num12] += zero;
					vectorV[num] = matrixH[num12];
					num--;
					num3 = 0;
					continue;
				}
				Complex32 complex;
				if (num3 != 10 && num3 != 20)
				{
					complex = matrixH[num12];
					Complex32 complex2 = matrixH[num11 + num9] * matrixH[num10 + num].Real;
					if (complex2.Real != 0f || complex2.Imaginary != 0f)
					{
						Complex32 complex3 = (matrixH[num10 + num9] - complex) / 2f;
						Complex32 complex4 = (complex3 * complex3 + complex2).SquareRoot();
						if ((double)(complex3.Real * complex4.Real + complex3.Imaginary * complex4.Imaginary) < 0.0)
						{
							complex4 *= -1f;
						}
						complex2 /= complex3 + complex4;
						complex -= complex2;
					}
				}
				else
				{
					complex = Math.Abs(matrixH[num10 + num].Real) + Math.Abs(matrixH[(num - 2) * order + num9].Real);
				}
				for (int i = 0; i <= num; i++)
				{
					matrixH[i * order + i] -= complex;
				}
				zero += complex;
				num3++;
				for (int j = num4 + 1; j <= num; j++)
				{
					int num13 = j - 1;
					int num14 = num13 * order;
					int num15 = num14 + num13;
					complex = matrixH[num14 + j].Real;
					num16 = SpecialFunctions.Hypotenuse(matrixH[num15].Magnitude, complex.Real);
					Complex32 complex2 = (vectorV[j - 1] = matrixH[num15] / num16);
					matrixH[num15] = num16;
					matrixH[num14 + j] = new Complex32(0f, complex.Real / num16);
					for (int k = j; k < order; k++)
					{
						int num17 = k * order;
						Complex32 complex3 = matrixH[num17 + num13];
						Complex32 complex4 = matrixH[num17 + j];
						matrixH[num17 + num13] = complex2.Conjugate() * complex3 + matrixH[num14 + j].Imaginary * complex4;
						matrixH[num17 + j] = complex2 * complex4 - matrixH[num14 + j].Imaginary * complex3;
					}
				}
				complex = matrixH[num12];
				if (complex.Imaginary != 0f)
				{
					complex /= matrixH[num12].Magnitude;
					matrixH[num12] = matrixH[num12].Magnitude;
					for (int l = num + 1; l < order; l++)
					{
						matrixH[l * order + num] *= complex.Conjugate();
					}
				}
				for (int m = num4 + 1; m <= num; m++)
				{
					Complex32 complex2 = vectorV[m - 1];
					int num18 = m * order;
					int num19 = (m - 1) * order;
					int num20 = num19 + m;
					for (int n = 0; n <= m; n++)
					{
						int num21 = num19 + n;
						Complex32 complex4 = matrixH[num18 + n];
						Complex32 complex3;
						if (n != m)
						{
							complex3 = matrixH[num21];
							matrixH[num21] = complex2 * complex3 + matrixH[num19 + m].Imaginary * complex4;
						}
						else
						{
							complex3 = matrixH[num21].Real;
							matrixH[num21] = new Complex32(complex2.Real * complex3.Real - complex2.Imaginary * complex3.Imaginary + matrixH[num19 + m].Imaginary * complex4.Real, matrixH[num21].Imaginary);
						}
						matrixH[num18 + n] = complex2.Conjugate() * complex4 - matrixH[num19 + m].Imaginary * complex3;
					}
					for (int num22 = 0; num22 < order; num22++)
					{
						Complex32 complex3 = dataEv[(m - 1) * order + num22];
						Complex32 complex4 = dataEv[m * order + num22];
						dataEv[num19 + num22] = complex2 * complex3 + matrixH[num20].Imaginary * complex4;
						dataEv[num18 + num22] = complex2.Conjugate() * complex4 - matrixH[num20].Imaginary * complex3;
					}
				}
				if (complex.Imaginary != 0f)
				{
					for (int num23 = 0; num23 <= num; num23++)
					{
						matrixH[num11 + num23] *= complex;
					}
					for (int num24 = 0; num24 < order; num24++)
					{
						dataEv[num11 + num24] *= complex;
					}
				}
			}
			num16 = 0f;
			for (int num25 = 0; num25 < order; num25++)
			{
				for (int num26 = num25; num26 < order; num26++)
				{
					num16 = Math.Max(num16, Math.Abs(matrixH[num26 * order + num25].Real) + Math.Abs(matrixH[num26 * order + num25].Imaginary));
				}
			}
			if (order == 1 || (double)num16 == 0.0)
			{
				return;
			}
			for (num = order - 1; num > 0; num--)
			{
				int num27 = num * order;
				int num28 = num27 + num;
				Complex32 complex2 = vectorV[num];
				matrixH[num28] = 1f;
				for (int num29 = num - 1; num29 >= 0; num29--)
				{
					Complex32 complex4 = 0f;
					for (int num30 = num29 + 1; num30 <= num; num30++)
					{
						complex4 += matrixH[num30 * order + num29] * matrixH[num27 + num30];
					}
					Complex32 complex3 = complex2 - vectorV[num29];
					if (complex3.Real == 0f && complex3.Imaginary == 0f)
					{
						complex3 = num2 * num16;
					}
					matrixH[num27 + num29] = complex4 / complex3;
					float num31 = Math.Abs(matrixH[num27 + num29].Real) + Math.Abs(matrixH[num27 + num29].Imaginary);
					if (num2 * num31 * num31 > 1f)
					{
						for (int num32 = num29; num32 <= num; num32++)
						{
							matrixH[num27 + num32] /= num31;
						}
					}
				}
			}
			for (int num33 = order - 1; num33 > 0; num33--)
			{
				int num34 = num33 * order;
				for (int num35 = 0; num35 < order; num35++)
				{
					Complex32 complex4 = Complex32.Zero;
					for (int num36 = 0; num36 <= num33; num36++)
					{
						complex4 += dataEv[num36 * order + num35] * matrixH[num34 + num36];
					}
					dataEv[num34 + num35] = complex4;
				}
			}
		}

		protected static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, Complex32[] matrix, Complex32[] row)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
			{
				for (int j = 0; j < numCols; j++)
				{
					row[j] = matrix[j * numRows + rowindx];
				}
				break;
			}
			case Transpose.ConjugateTranspose:
			{
				int num = rowindx * numCols;
				for (int i = 0; i < row.Length; i++)
				{
					row[i] = matrix[i + num].Conjugate();
				}
				break;
			}
			default:
				Array.Copy(matrix, rowindx * numCols, row, 0, numCols);
				break;
			}
		}

		protected static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, Complex32[] matrix, Complex32[] column)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
				Array.Copy(matrix, colindx * numRows, column, 0, numRows);
				break;
			case Transpose.ConjugateTranspose:
			{
				for (int j = 0; j < numRows; j++)
				{
					column[j] = matrix[j * numCols + colindx].Conjugate();
				}
				break;
			}
			default:
			{
				for (int i = 0; i < numRows; i++)
				{
					column[i] = matrix[i * numCols + colindx];
				}
				break;
			}
			}
		}

		public virtual bool IsAvailable()
		{
			return true;
		}

		public virtual void InitializeVerify()
		{
		}

		public virtual void FreeResources()
		{
		}

		public override string ToString()
		{
			return "Managed";
		}

		private static void GetRow<T>(Transpose transpose, int rowindx, int numRows, int numCols, T[] matrix, T[] row)
		{
			if (transpose == Transpose.DontTranspose)
			{
				for (int i = 0; i < numCols; i++)
				{
					row[i] = matrix[i * numRows + rowindx];
				}
			}
			else
			{
				Array.Copy(matrix, rowindx * numCols, row, 0, numCols);
			}
		}

		private static void GetColumn<T>(Transpose transpose, int colindx, int numRows, int numCols, T[] matrix, T[] column)
		{
			if (transpose == Transpose.DontTranspose)
			{
				Array.Copy(matrix, colindx * numRows, column, 0, numRows);
				return;
			}
			for (int i = 0; i < numRows; i++)
			{
				column[i] = matrix[i * numCols + colindx];
			}
		}

		public virtual void AddVectorToScaledVector(double[] y, double alpha, double[] x, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (alpha == 0.0)
			{
				y.Copy(result);
			}
			else if (alpha == 1.0)
			{
				for (int i = 0; i < result.Length; i++)
				{
					result[i] = y[i] + x[i];
				}
			}
			else
			{
				for (int j = 0; j < result.Length; j++)
				{
					result[j] = y[j] + alpha * x[j];
				}
			}
		}

		public virtual void ScaleArray(double alpha, double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (alpha == 0.0)
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if (alpha == 1.0)
			{
				x.Copy(result);
				return;
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = alpha * x[i];
			}
		}

		public virtual void ConjugateArray(double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				x.CopyTo(result, 0);
			}
		}

		public virtual double DotProduct(double[] x, double[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double num = 0.0;
			for (int i = 0; i < y.Length; i++)
			{
				num += y[i] * x[i];
			}
			return num;
		}

		public virtual void AddArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] + y[i];
			}
		}

		public virtual void SubtractArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] - y[i];
			}
		}

		public virtual void PointWiseMultiplyArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] * y[i];
			}
		}

		public virtual void PointWiseDivideArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = Math.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, double[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += Math.Abs(matrix[l * rows + m]);
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(Math.Abs(matrix[j * rows + k]), num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += Math.Abs(matrix[n * rows + num5]);
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				double[] array = new double[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.Transpose, 1.0, matrix, rows, columns, matrix, rows, columns, 0.0, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += Math.Abs(array[i * rows + i]);
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(double[] x, int rowsX, int columnsX, double[] y, int rowsY, int columnsY, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsX}) != rowsB ({rowsY})"));
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsA ({columnsX}) != a.Length ({x.Length})"));
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsY}) * columnsB ({columnsY}) != b.Length ({y.Length})"));
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsB ({columnsY}) != c.Length ({result.Length})"));
			}
			Array.Clear(result, 0, result.Length);
			double[][] columnDataB = new double[columnsY][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				double[] array = new double[rowsY];
				GetColumn(Transpose.DontTranspose, i, rowsY, columnsY, y, array);
				columnDataB[i] = array;
			}
			if (rowsX + columnsY + columnsX < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				double[] array2 = new double[columnsX];
				for (int j = 0; j < rowsX; j++)
				{
					GetRow(Transpose.DontTranspose, j, rowsX, columnsX, x, array2);
					for (int k = 0; k < columnsY; k++)
					{
						double[] array3 = columnDataB[k];
						double num = 0.0;
						for (int l = 0; l < array2.Length; l++)
						{
							num += array2[l] * array3[l];
						}
						result[k * rowsX + j] += 1.0 * num;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsX, 1, delegate(int u, int v)
			{
				double[] array4 = new double[columnsX];
				for (int m = u; m < v; m++)
				{
					GetRow(Transpose.DontTranspose, m, rowsX, columnsX, x, array4);
					for (int n = 0; n < columnsY; n++)
					{
						double[] array5 = columnDataB[n];
						double num2 = 0.0;
						for (int num3 = 0; num3 < array4.Length; num3++)
						{
							num2 += array4[num3] * array5[num3];
						}
						result[n * rowsX + m] += 1.0 * num2;
					}
				}
			});
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, double alpha, double[] a, int rowsA, int columnsA, double[] b, int rowsB, int columnsB, double beta, double[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			if (transposeA != Transpose.DontTranspose)
			{
				int num = rowsA;
				rowsA = columnsA;
				columnsA = num;
			}
			if (transposeB != Transpose.DontTranspose)
			{
				int num2 = rowsB;
				rowsB = columnsB;
				columnsB = num2;
			}
			if (columnsA != rowsB)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsA}) != rowsB ({rowsB})"));
			}
			if (rowsA * columnsA != a.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsA ({columnsA}) != a.Length ({a.Length})"));
			}
			if (rowsB * columnsB != b.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsB}) * columnsB ({columnsB}) != b.Length ({b.Length})"));
			}
			if (rowsA * columnsB != c.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsB ({columnsB}) != c.Length ({c.Length})"));
			}
			if (beta == 0.0)
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (beta != 1.0)
			{
				ScaleArray(beta, c, c);
			}
			if (alpha == 0.0)
			{
				return;
			}
			double[][] columnDataB = new double[columnsB][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				double[] array = new double[rowsB];
				GetColumn(transposeB, i, rowsB, columnsB, b, array);
				columnDataB[i] = array;
			}
			if (rowsA + columnsB + columnsA < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				double[] array2 = new double[columnsA];
				for (int j = 0; j < rowsA; j++)
				{
					GetRow(transposeA, j, rowsA, columnsA, a, array2);
					for (int k = 0; k < columnsB; k++)
					{
						double[] array3 = columnDataB[k];
						double num3 = 0.0;
						for (int l = 0; l < array2.Length; l++)
						{
							num3 += array2[l] * array3[l];
						}
						c[k * rowsA + j] += alpha * num3;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsA, 1, delegate(int u, int v)
			{
				double[] array4 = new double[columnsA];
				for (int m = u; m < v; m++)
				{
					GetRow(transposeA, m, rowsA, columnsA, a, array4);
					for (int n = 0; n < columnsB; n++)
					{
						double[] array5 = columnDataB[n];
						double num4 = 0.0;
						for (int num5 = 0; num5 < array4.Length; num5++)
						{
							num4 += array4[num5] * array5[num5];
						}
						c[n * rowsA + m] += alpha * num4;
					}
				}
			});
		}

		public virtual void LUFactor(double[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			double[] array = new double[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					double num4 = 0.0;
					for (int m = 0; m < num3; m++)
					{
						num4 += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= num4);
				}
				int num5 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (Math.Abs(array[n]) > Math.Abs(array[num5]))
					{
						num5 = n;
					}
				}
				if (num5 != j)
				{
					for (int num6 = 0; num6 < order; num6++)
					{
						int num7 = num6 * order;
						int num8 = num7 + num5;
						int num9 = num7 + j;
						double num10 = data[num8];
						data[num8] = data[num9];
						data[num9] = num10;
					}
					ipiv[j] = num5;
				}
				if ((j < order) & (data[num2] != 0.0))
				{
					for (int num11 = j + 1; num11 < order; num11++)
					{
						data[num + num11] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(double[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			double[] array = new double[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = 1.0;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, double[] a, int order, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			double[] array = new double[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, double[] a, int order, int[] ipiv, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						double num5 = b[num3];
						b[num3] = b[num4];
						b[num4] = num5;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num6 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num7 = m * order;
						b[l + num7] -= b[k + num7] * a[l + num6];
					}
				}
			}
			for (int num8 = order - 1; num8 >= 0; num8--)
			{
				int num9 = num8 + num8 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num8 + n * order] /= a[num9];
				}
				num9 = num8 * order;
				for (int num10 = 0; num10 < num8; num10++)
				{
					for (int num11 = 0; num11 < columnsOfB; num11++)
					{
						int num12 = num11 * order;
						b[num10 + num12] -= b[num8 + num12] * a[num10 + num9];
					}
				}
			}
		}

		public virtual void CholeskyFactor(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			double[] array = new double[order];
			for (int i = 0; i < order; i++)
			{
				double num = a[i * order + i];
				if (!(num > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				num = (array[i] = (a[i * order + i] = Math.Sqrt(num)));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= num;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0.0;
				}
			}
		}

		private static void DoCholeskyStep(double[] data, int rowDim, int firstCol, int colLimit, double[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				double num2 = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * num2;
				}
			}
		}

		public virtual void CholeskySolve(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			double[] array = new double[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(double[] a, int orderA, double[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				double num2 = b[num + i];
				for (int num3 = i - 1; num3 >= 0; num3--)
				{
					num2 -= a[num3 * orderA + i] * b[num + num3];
				}
				b[num + i] = num2 / a[i * orderA + i];
			}
			for (int num4 = orderA - 1; num4 >= 0; num4--)
			{
				double num2 = b[num + num4];
				int num5 = num4 * orderA;
				for (int j = num4 + 1; j < orderA; j++)
				{
					num2 -= a[num5 + j] * b[num + j];
				}
				b[num + num4] = num2 / a[num5 + num4];
			}
		}

		public virtual void QRFactor(double[] r, int rowsR, int columnsR, double[] q, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = 1.0;
				}
			});
			double[] work = ((columnsR > rowsR) ? new double[rowsR * rowsR] : new double[rowsR * columnsR]);
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(double[] a, int rowsA, int columnsA, double[] r, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			double[] work = new double[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = 1.0;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(double[] work, int workIndex, double[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				double num2 = 0.0;
				for (int j = rowStart; j < rowCount; j++)
				{
					num2 += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart] * num2;
				}
			}
		}

		private static void GenerateColumn(double[] work, double[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num4 = tmp + l;
					work[num4 - row] = a[num4];
					a[num4] = 0.0;
				}
			});
			double num2 = 0.0;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num3 = tmp + i;
				num2 += work[num3] * work[num3];
			}
			num2 = Math.Sqrt(num2);
			if (row == rowCount - 1 || num2 == 0.0)
			{
				a[num] = 0.0 - work[tmp];
				work[tmp] = 1.4142135623730951;
				return;
			}
			double scale = 1.0 / num2;
			if (work[tmp] < 0.0)
			{
				scale *= -1.0;
			}
			a[num] = -1.0 / scale;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] *= scale;
				}
			});
			work[tmp] += 1.0;
			double s = Math.Sqrt(1.0 / work[tmp]);
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] *= s;
				}
			});
		}

		public virtual void QRSolve(double[] a, int rows, int columns, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			double[] tau = new double[rows * columns];
			double[] array = new double[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				double[] q = new double[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				double[] r = new double[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(double[] q, double[] r, int rowsA, int columnsA, double[] tau, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			double[] sol = new double[b.Length];
			Buffer.BlockCopy(b, 0, sol, 0, b.Length * 8);
			double[] column = new double[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						double num9 = 0.0;
						for (int num10 = 0; num10 < rowsA; num10++)
						{
							num9 += q[num8 + num10] * column[num10];
						}
						sol[jm + n] = num9;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, double[] a, int rowsA, int columnsA, double[] s, double[] u, double[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			double[] array = new double[rowsA];
			double[] array2 = new double[columnsA];
			double[] array3 = new double[vt.Length];
			double[] array4 = new double[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					double num5 = 0.0;
					for (int j = i; j < rowsA; j++)
					{
						num5 += a[i * rowsA + j] * a[i * rowsA + j];
					}
					array4[i] = Math.Sqrt(num5);
					if (array4[i] != 0.0)
					{
						if (a[i * rowsA + i] != 0.0)
						{
							array4[i] = Math.Abs(array4[i]) * (a[i * rowsA + i] / Math.Abs(a[i * rowsA + i]));
						}
						for (int k = i; k < rowsA; k++)
						{
							a[i * rowsA + k] *= 1.0 / array4[i];
						}
						a[i * rowsA + i] = 1.0 + a[i * rowsA + i];
					}
					array4[i] = 0.0 - array4[i];
				}
				for (int l = num4; l < columnsA; l++)
				{
					if (i < num && array4[i] != 0.0)
					{
						double num6 = 0.0;
						for (int k = i; k < rowsA; k++)
						{
							num6 += a[l * rowsA + k] * a[i * rowsA + k];
						}
						num6 = (0.0 - num6) / a[i * rowsA + i];
						for (int m = i; m < rowsA; m++)
						{
							a[l * rowsA + m] += num6 * a[i * rowsA + m];
						}
					}
					array2[l] = a[l * rowsA + i];
				}
				if (computeVectors && i < num)
				{
					for (int k = i; k < rowsA; k++)
					{
						u[i * rowsA + k] = a[i * rowsA + k];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				double num7 = 0.0;
				for (int k = num4; k < array2.Length; k++)
				{
					num7 += array2[k] * array2[k];
				}
				array2[i] = Math.Sqrt(num7);
				if (array2[i] != 0.0)
				{
					if (array2[num4] != 0.0)
					{
						array2[i] = Math.Abs(array2[i]) * (array2[num4] / Math.Abs(array2[num4]));
					}
					for (int k = num4; k < array2.Length; k++)
					{
						array2[k] *= 1.0 / array2[i];
					}
					array2[num4] = 1.0 + array2[num4];
				}
				array2[i] = 0.0 - array2[i];
				if (num4 < rowsA && array2[i] != 0.0)
				{
					for (int k = num4; k < rowsA; k++)
					{
						array[k] = 0.0;
					}
					for (int l = num4; l < columnsA; l++)
					{
						for (int n = num4; n < rowsA; n++)
						{
							array[n] += array2[l] * a[l * rowsA + n];
						}
					}
					for (int l = num4; l < columnsA; l++)
					{
						double num8 = (0.0 - array2[l]) / array2[num4];
						for (int num9 = num4; num9 < rowsA; num9++)
						{
							a[l * rowsA + num9] += num8 * array[num9];
						}
					}
				}
				if (computeVectors)
				{
					for (int k = num4; k < columnsA; k++)
					{
						array3[i * columnsA + k] = array2[k];
					}
				}
			}
			int num10 = Math.Min(columnsA, rowsA + 1);
			int num11 = num + 1;
			int num12 = num2 + 1;
			if (num < columnsA)
			{
				array4[num11 - 1] = a[(num11 - 1) * rowsA + (num11 - 1)];
			}
			if (rowsA < num10)
			{
				array4[num10 - 1] = 0.0;
			}
			if (num12 < num10)
			{
				array2[num12 - 1] = a[(num10 - 1) * rowsA + (num12 - 1)];
			}
			array2[num10 - 1] = 0.0;
			if (computeVectors)
			{
				for (int l = num11 - 1; l < rowsA; l++)
				{
					for (int k = 0; k < rowsA; k++)
					{
						u[l * rowsA + k] = 0.0;
					}
					u[l * rowsA + l] = 1.0;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if (array4[i] != 0.0)
					{
						for (int l = i + 1; l < rowsA; l++)
						{
							double num6 = 0.0;
							for (int k = i; k < rowsA; k++)
							{
								num6 += u[l * rowsA + k] * u[i * rowsA + k];
							}
							num6 = (0.0 - num6) / u[i * rowsA + i];
							for (int num13 = i; num13 < rowsA; num13++)
							{
								u[l * rowsA + num13] += num6 * u[i * rowsA + num13];
							}
						}
						for (int k = i; k < rowsA; k++)
						{
							u[i * rowsA + k] *= -1.0;
						}
						u[i * rowsA + i] = 1.0 + u[i * rowsA + i];
						for (int k = 0; k < i; k++)
						{
							u[i * rowsA + k] = 0.0;
						}
					}
					else
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[i * rowsA + k] = 0.0;
						}
						u[i * rowsA + i] = 1.0;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && array2[i] != 0.0)
					{
						for (int l = num4; l < columnsA; l++)
						{
							double num6 = 0.0;
							for (int k = num4; k < columnsA; k++)
							{
								num6 += array3[l * columnsA + k] * array3[i * columnsA + k];
							}
							num6 = (0.0 - num6) / array3[i * columnsA + num4];
							for (int num14 = i; num14 < columnsA; num14++)
							{
								array3[l * columnsA + num14] += num6 * array3[i * columnsA + num14];
							}
						}
					}
					for (int k = 0; k < columnsA; k++)
					{
						array3[i * columnsA + k] = 0.0;
					}
					array3[i * columnsA + i] = 1.0;
				}
			}
			for (int k = 0; k < num10; k++)
			{
				double num6;
				double num15;
				if (array4[k] != 0.0)
				{
					num6 = array4[k];
					num15 = array4[k] / num6;
					array4[k] = num6;
					if (k < num10 - 1)
					{
						array2[k] /= num15;
					}
					if (computeVectors)
					{
						for (int l = 0; l < rowsA; l++)
						{
							u[k * rowsA + l] *= num15;
						}
					}
				}
				if (k == num10 - 1)
				{
					break;
				}
				if (array2[k] == 0.0)
				{
					continue;
				}
				num6 = array2[k];
				num15 = num6 / array2[k];
				array2[k] = num6;
				array4[k + 1] *= num15;
				if (computeVectors)
				{
					for (int l = 0; l < columnsA; l++)
					{
						array3[(k + 1) * columnsA + l] *= num15;
					}
				}
			}
			int num16 = num10;
			int num17 = 0;
			while (num10 > 0)
			{
				if (num17 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num10 - 2; i >= 0; i--)
				{
					double num18 = Math.Abs(array4[i]) + Math.Abs(array4[i + 1]);
					if ((num18 + Math.Abs(array2[i])).AlmostEqualRelative(num18, 15))
					{
						array2[i] = 0.0;
						break;
					}
				}
				int num19;
				if (i == num10 - 2)
				{
					num19 = 4;
				}
				else
				{
					int num20;
					for (num20 = num10 - 1; num20 > i; num20--)
					{
						double num18 = 0.0;
						if (num20 != num10 - 1)
						{
							num18 += Math.Abs(array2[num20]);
						}
						if (num20 != i + 1)
						{
							num18 += Math.Abs(array2[num20 - 1]);
						}
						if ((num18 + Math.Abs(array4[num20])).AlmostEqualRelative(num18, 15))
						{
							array4[num20] = 0.0;
							break;
						}
					}
					if (num20 == i)
					{
						num19 = 3;
					}
					else if (num20 == num10 - 1)
					{
						num19 = 1;
					}
					else
					{
						num19 = 2;
						i = num20;
					}
				}
				i++;
				double c;
				double s2;
				switch (num19)
				{
				case 1:
				{
					double db = array2[num10 - 2];
					array2[num10 - 2] = 0.0;
					for (int num35 = i; num35 < num10 - 1; num35++)
					{
						int num23 = num10 - 2 - num35 + i;
						double da = array4[num23];
						Drotg(ref da, ref db, out c, out s2);
						array4[num23] = da;
						if (num23 != i)
						{
							db = (0.0 - s2) * array2[num23 - 1];
							array2[num23 - 1] = c * array2[num23 - 1];
						}
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								double num36 = c * array3[num23 * columnsA + k] + s2 * array3[(num10 - 1) * columnsA + k];
								array3[(num10 - 1) * columnsA + k] = c * array3[(num10 - 1) * columnsA + k] - s2 * array3[num23 * columnsA + k];
								array3[num23 * columnsA + k] = num36;
							}
						}
					}
					break;
				}
				case 2:
				{
					double db = array2[i - 1];
					array2[i - 1] = 0.0;
					for (int num23 = i; num23 < num10; num23++)
					{
						double da = array4[num23];
						Drotg(ref da, ref db, out c, out s2);
						array4[num23] = da;
						db = (0.0 - s2) * array2[num23];
						array2[num23] = c * array2[num23];
						if (computeVectors)
						{
							for (int k = 0; k < rowsA; k++)
							{
								double num24 = c * u[num23 * rowsA + k] + s2 * u[(i - 1) * rowsA + k];
								u[(i - 1) * rowsA + k] = c * u[(i - 1) * rowsA + k] - s2 * u[num23 * rowsA + k];
								u[num23 * rowsA + k] = num24;
							}
						}
					}
					break;
				}
				case 3:
				{
					double val = 0.0;
					val = Math.Max(val, Math.Abs(array4[num10 - 1]));
					val = Math.Max(val, Math.Abs(array4[num10 - 2]));
					val = Math.Max(val, Math.Abs(array2[num10 - 2]));
					val = Math.Max(val, Math.Abs(array4[i]));
					val = Math.Max(val, Math.Abs(array2[i]));
					double num25 = array4[num10 - 1] / val;
					double num26 = array4[num10 - 2] / val;
					double num27 = array2[num10 - 2] / val;
					double num28 = array4[i] / val;
					double num29 = array2[i] / val;
					double num30 = ((num26 + num25) * (num26 - num25) + num27 * num27) / 2.0;
					double num31 = num25 * num27 * (num25 * num27);
					double num32 = 0.0;
					if (num30 != 0.0 || num31 != 0.0)
					{
						num32 = Math.Sqrt(num30 * num30 + num31);
						if (num30 < 0.0)
						{
							num32 = 0.0 - num32;
						}
						num32 = num31 / (num30 + num32);
					}
					double db = (num28 + num25) * (num28 - num25) + num32;
					double db2 = num28 * num29;
					for (int num23 = i; num23 < num10 - 1; num23++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num23 != i)
						{
							array2[num23 - 1] = db;
						}
						db = c * array4[num23] + s2 * array2[num23];
						array2[num23] = c * array2[num23] - s2 * array4[num23];
						db2 = s2 * array4[num23 + 1];
						array4[num23 + 1] = c * array4[num23 + 1];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								double num33 = c * array3[num23 * columnsA + k] + s2 * array3[(num23 + 1) * columnsA + k];
								array3[(num23 + 1) * columnsA + k] = c * array3[(num23 + 1) * columnsA + k] - s2 * array3[num23 * columnsA + k];
								array3[num23 * columnsA + k] = num33;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num23] = db;
						db = c * array2[num23] + s2 * array4[num23 + 1];
						array4[num23 + 1] = 0.0 - s2 * array2[num23] + c * array4[num23 + 1];
						db2 = s2 * array2[num23 + 1];
						array2[num23 + 1] = c * array2[num23 + 1];
						if (computeVectors && num23 < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								double num34 = c * u[num23 * rowsA + k] + s2 * u[(num23 + 1) * rowsA + k];
								u[(num23 + 1) * rowsA + k] = c * u[(num23 + 1) * rowsA + k] - s2 * u[num23 * rowsA + k];
								u[num23 * rowsA + k] = num34;
							}
						}
					}
					array2[num10 - 2] = db;
					num17++;
					break;
				}
				case 4:
					if (array4[i] < 0.0)
					{
						array4[i] = 0.0 - array4[i];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								array3[i * columnsA + k] *= -1.0;
							}
						}
					}
					for (; i != num16 - 1 && !(array4[i] >= array4[i + 1]); i++)
					{
						double num6 = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = num6;
						if (computeVectors && i < columnsA)
						{
							for (int k = 0; k < columnsA; k++)
							{
								double num21 = array3[i * columnsA + k];
								array3[i * columnsA + k] = array3[(i + 1) * columnsA + k];
								array3[(i + 1) * columnsA + k] = num21;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								double num22 = u[i * rowsA + k];
								u[i * rowsA + k] = u[(i + 1) * rowsA + k];
								u[(i + 1) * rowsA + k] = num22;
							}
						}
					}
					num17 = 0;
					num10--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int k = 0; k < columnsA; k++)
				{
					for (int l = 0; l < columnsA; l++)
					{
						vt[l * columnsA + k] = array3[k * columnsA + l];
					}
				}
			}
			Buffer.BlockCopy(array4, 0, s, 0, Math.Min(rowsA, columnsA) * 8);
		}

		private static void Drotg(ref double da, ref double db, out double c, out double s)
		{
			double num = db;
			double num2 = Math.Abs(da);
			double num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			double num4 = num2 + num3;
			double num5;
			double num6;
			if (num4 == 0.0)
			{
				c = 1.0;
				s = 0.0;
				num5 = 0.0;
				num6 = 0.0;
			}
			else
			{
				double num7 = da / num4;
				double num8 = db / num4;
				num5 = num4 * Math.Sqrt(num7 * num7 + num8 * num8);
				if (num < 0.0)
				{
					num5 = 0.0 - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1.0;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && c != 0.0)
				{
					num6 = 1.0 / c;
				}
			}
			da = num5;
			db = num6;
		}

		public virtual void SvdSolve(double[] a, int rowsA, int columnsA, double[] b, int columnsB, double[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			double[] s = new double[Math.Min(rowsA, columnsA)];
			double[] u = new double[rowsA * rowsA];
			double[] vt = new double[columnsA * columnsA];
			double[] array = new double[a.Length];
			Buffer.BlockCopy(a, 0, array, 0, a.Length * 8);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, double[] s, double[] u, double[] vt, double[] b, int columnsB, double[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			double[] array = new double[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					double num2 = 0.0;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							num2 += u[j * rowsA + k] * b[i * rowsA + k];
						}
						num2 /= s[j];
					}
					array[j] = num2;
				}
				for (int l = 0; l < columnsA; l++)
				{
					double num3 = 0.0;
					for (int m = 0; m < columnsA; m++)
					{
						num3 += vt[l * columnsA + m] * array[m];
					}
					x[i * columnsA + l] = num3;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, double[] matrix, double[] matrixEv, Complex[] vectorEv, double[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			double[] array = new double[order];
			double[] array2 = new double[order];
			if (isSymmetric)
			{
				Buffer.BlockCopy(matrix, 0, matrixEv, 0, matrix.Length * 8);
				int num = order - 1;
				for (int i = 0; i < order; i++)
				{
					array[i] = matrixEv[i * order + num];
				}
				SymmetricTridiagonalize(matrixEv, array, array2, order);
				SymmetricDiagonalize(matrixEv, array, array2, order);
			}
			else
			{
				double[] array3 = new double[matrix.Length];
				Buffer.BlockCopy(matrix, 0, array3, 0, matrix.Length * 8);
				NonsymmetricReduceToHessenberg(matrixEv, array3, order);
				NonsymmetricReduceHessenberToRealSchur(matrixEv, array3, array, array2, order);
			}
			for (int j = 0; j < order; j++)
			{
				vectorEv[j] = new Complex(array[j], array2[j]);
				int num2 = j * order;
				matrixD[num2 + j] = array[j];
				if (array2[j] > 0.0)
				{
					matrixD[num2 + order + j] = array2[j];
					matrixD[(j + 1) * order + j] = array2[j];
				}
				else if (array2[j] < 0.0)
				{
					matrixD[num2 - order + j] = array2[j];
				}
			}
		}

		internal static void SymmetricTridiagonalize(double[] a, double[] d, double[] e, int order)
		{
			for (int num = order - 1; num > 0; num--)
			{
				double num2 = 0.0;
				double num3 = 0.0;
				for (int i = 0; i < num; i++)
				{
					num2 += Math.Abs(d[i]);
				}
				if (num2 == 0.0)
				{
					e[num] = d[num - 1];
					for (int j = 0; j < num; j++)
					{
						d[j] = a[j * order + num - 1];
						a[j * order + num] = 0.0;
						a[num * order + j] = 0.0;
					}
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						d[k] /= num2;
						num3 += d[k] * d[k];
					}
					double num4 = d[num - 1];
					double num5 = Math.Sqrt(num3);
					if (num4 > 0.0)
					{
						num5 = 0.0 - num5;
					}
					e[num] = num2 * num5;
					num3 -= num4 * num5;
					d[num - 1] = num4 - num5;
					for (int l = 0; l < num; l++)
					{
						e[l] = 0.0;
					}
					for (int m = 0; m < num; m++)
					{
						num4 = (a[num * order + m] = d[m]);
						num5 = e[m] + a[m * order + m] * num4;
						for (int n = m + 1; n <= num - 1; n++)
						{
							num5 += a[m * order + n] * d[n];
							e[n] += a[m * order + n] * num4;
						}
						e[m] = num5;
					}
					num4 = 0.0;
					for (int num6 = 0; num6 < num; num6++)
					{
						e[num6] /= num3;
						num4 += e[num6] * d[num6];
					}
					double num7 = num4 / (num3 + num3);
					for (int num8 = 0; num8 < num; num8++)
					{
						e[num8] -= num7 * d[num8];
					}
					for (int num9 = 0; num9 < num; num9++)
					{
						num4 = d[num9];
						num5 = e[num9];
						for (int num10 = num9; num10 <= num - 1; num10++)
						{
							a[num9 * order + num10] -= num4 * e[num10] + num5 * d[num10];
						}
						d[num9] = a[num9 * order + num - 1];
						a[num9 * order + num] = 0.0;
					}
				}
				d[num] = num3;
			}
			for (int num11 = 0; num11 < order - 1; num11++)
			{
				a[num11 * order + order - 1] = a[num11 * order + num11];
				a[num11 * order + num11] = 1.0;
				double num12 = d[num11 + 1];
				if (num12 != 0.0)
				{
					for (int num13 = 0; num13 <= num11; num13++)
					{
						d[num13] = a[(num11 + 1) * order + num13] / num12;
					}
					for (int num14 = 0; num14 <= num11; num14++)
					{
						double num15 = 0.0;
						for (int num16 = 0; num16 <= num11; num16++)
						{
							num15 += a[(num11 + 1) * order + num16] * a[num14 * order + num16];
						}
						for (int num17 = 0; num17 <= num11; num17++)
						{
							a[num14 * order + num17] -= num15 * d[num17];
						}
					}
				}
				for (int num18 = 0; num18 <= num11; num18++)
				{
					a[(num11 + 1) * order + num18] = 0.0;
				}
			}
			for (int num19 = 0; num19 < order; num19++)
			{
				d[num19] = a[num19 * order + order - 1];
				a[num19 * order + order - 1] = 0.0;
			}
			a[order * order - 1] = 1.0;
			e[0] = 0.0;
		}

		internal static void SymmetricDiagonalize(double[] a, double[] d, double[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0.0;
			double num = 0.0;
			double num2 = 0.0;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !(Math.Abs(e[k]) <= doublePrecision * num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						double num4 = d[j];
						double num5 = (d[j + 1] - num4) / (2.0 * e[j]);
						double num6 = SpecialFunctions.Hypotenuse(num5, 1.0);
						if (num5 < 0.0)
						{
							num6 = 0.0 - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						double num7 = d[j + 1];
						double num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						double num9 = 1.0;
						double num10 = num9;
						double num11 = num9;
						double num12 = e[j + 1];
						double num13 = 0.0;
						double num14 = 0.0;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = a[(num15 + 1) * order + m];
								a[(num15 + 1) * order + m] = num13 * a[num15 * order + m] + num9 * num8;
								a[num15 * order + m] = num9 * a[num15 * order + m] - num13 * num8;
							}
						}
						num5 = (0.0 - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while (Math.Abs(e[j]) > doublePrecision * num2);
				}
				d[j] += num;
				e[j] = 0.0;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				double num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = a[n * order + num19];
						a[n * order + num19] = a[num16 * order + num19];
						a[num16 * order + num19] = num17;
					}
				}
			}
		}

		internal static void NonsymmetricReduceToHessenberg(double[] a, double[] matrixH, int order)
		{
			double[] array = new double[order];
			int num = order - 1;
			for (int i = 1; i <= num - 1; i++)
			{
				int num2 = (i - 1) * order;
				double num3 = 0.0;
				for (int j = i; j <= num; j++)
				{
					num3 += Math.Abs(matrixH[num2 + j]);
				}
				if (num3 == 0.0)
				{
					continue;
				}
				double num4 = 0.0;
				for (int num5 = num; num5 >= i; num5--)
				{
					array[num5] = matrixH[num2 + num5] / num3;
					num4 += array[num5] * array[num5];
				}
				double num6 = Math.Sqrt(num4);
				if (array[i] > 0.0)
				{
					num6 = 0.0 - num6;
				}
				num4 -= array[i] * num6;
				array[i] -= num6;
				for (int k = i; k < order; k++)
				{
					int num7 = k * order;
					double num8 = 0.0;
					for (int num9 = order - 1; num9 >= i; num9--)
					{
						num8 += array[num9] * matrixH[num7 + num9];
					}
					num8 /= num4;
					for (int l = i; l <= num; l++)
					{
						matrixH[num7 + l] -= num8 * array[l];
					}
				}
				for (int m = 0; m <= num; m++)
				{
					double num10 = 0.0;
					for (int num11 = num; num11 >= i; num11--)
					{
						num10 += array[num11] * matrixH[num11 * order + m];
					}
					num10 /= num4;
					for (int n = i; n <= num; n++)
					{
						matrixH[n * order + m] -= num10 * array[n];
					}
				}
				array[i] = num3 * array[i];
				matrixH[num2 + i] = num3 * num6;
			}
			for (int num12 = 0; num12 < order; num12++)
			{
				for (int num13 = 0; num13 < order; num13++)
				{
					a[num13 * order + num12] = ((num12 == num13) ? 1.0 : 0.0);
				}
			}
			for (int num14 = num - 1; num14 >= 1; num14--)
			{
				int num15 = (num14 - 1) * order;
				int num16 = num15 + num14;
				if (matrixH[num16] != 0.0)
				{
					for (int num17 = num14 + 1; num17 <= num; num17++)
					{
						array[num17] = matrixH[num15 + num17];
					}
					for (int num18 = num14; num18 <= num; num18++)
					{
						double num19 = 0.0;
						int num20 = num18 * order;
						for (int num21 = num14; num21 <= num; num21++)
						{
							num19 += array[num21] * a[num20 + num21];
						}
						num19 = num19 / array[num14] / matrixH[num16];
						for (int num22 = num14; num22 <= num; num22++)
						{
							a[num20 + num22] += num19 * array[num22];
						}
					}
				}
			}
		}

		internal static void NonsymmetricReduceHessenberToRealSchur(double[] a, double[] matrixH, double[] d, double[] e, int order)
		{
			int num = order - 1;
			double num2 = Math.Pow(2.0, -52.0);
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = 0.0;
			double num7 = 0.0;
			double num8 = 0.0;
			double num9 = 0.0;
			for (int i = 0; i < order; i++)
			{
				for (int j = Math.Max(i - 1, 0); j < order; j++)
				{
					num9 += Math.Abs(matrixH[j * order + i]);
				}
			}
			int num10 = 0;
			while (num >= 0)
			{
				int num11;
				for (num11 = num; num11 > 0; num11--)
				{
					int num12 = num11 - 1;
					int num13 = num12 * order;
					num7 = Math.Abs(matrixH[num13 + num12]) + Math.Abs(matrixH[num11 * order + num11]);
					if (num7 == 0.0)
					{
						num7 = num9;
					}
					if (Math.Abs(matrixH[num13 + num11]) < num2 * num7)
					{
						break;
					}
				}
				if (num11 == num)
				{
					int num14 = num * order + num;
					matrixH[num14] += num3;
					d[num] = matrixH[num14];
					e[num] = 0.0;
					num--;
					num10 = 0;
					continue;
				}
				double num20;
				double num19;
				if (num11 == num - 1)
				{
					int num15 = num * order;
					int num16 = num - 1;
					int num17 = num16 * order;
					int num18 = num15 + num;
					num19 = matrixH[num17 + num] * matrixH[num15 + num16];
					num4 = (matrixH[num17 + num16] - matrixH[num18]) / 2.0;
					num5 = num4 * num4 + num19;
					num8 = Math.Sqrt(Math.Abs(num5));
					matrixH[num18] += num3;
					matrixH[num17 + num16] += num3;
					num20 = matrixH[num18];
					if (num5 >= 0.0)
					{
						num8 = ((!(num4 >= 0.0)) ? (num4 - num8) : (num4 + num8));
						d[num16] = num20 + num8;
						d[num] = d[num16];
						if (num8 != 0.0)
						{
							d[num] = num20 - num19 / num8;
						}
						e[num - 1] = 0.0;
						e[num] = 0.0;
						num20 = matrixH[num17 + num];
						num7 = Math.Abs(num20) + Math.Abs(num8);
						num4 = num20 / num7;
						num5 = num8 / num7;
						num6 = Math.Sqrt(num4 * num4 + num5 * num5);
						num4 /= num6;
						num5 /= num6;
						for (int k = num - 1; k < order; k++)
						{
							int num21 = k * order;
							int num22 = num21 + num;
							num8 = matrixH[num21 + num16];
							matrixH[num21 + num16] = num5 * num8 + num4 * matrixH[num22];
							matrixH[num22] = num5 * matrixH[num22] - num4 * num8;
						}
						for (int l = 0; l <= num; l++)
						{
							int num23 = num15 + l;
							num8 = matrixH[num17 + l];
							matrixH[num17 + l] = num5 * num8 + num4 * matrixH[num23];
							matrixH[num23] = num5 * matrixH[num23] - num4 * num8;
						}
						for (int m = 0; m < order; m++)
						{
							int num24 = num15 + m;
							num8 = a[num17 + m];
							a[num17 + m] = num5 * num8 + num4 * a[num24];
							a[num24] = num5 * a[num24] - num4 * num8;
						}
					}
					else
					{
						d[num - 1] = num20 + num4;
						d[num] = num20 + num4;
						e[num - 1] = num8;
						e[num] = 0.0 - num8;
					}
					num -= 2;
					num10 = 0;
					continue;
				}
				int num25 = num * order;
				int num26 = num - 1;
				int num27 = num26 * order;
				int num28 = num25 + num;
				num20 = matrixH[num28];
				double num29 = 0.0;
				num19 = 0.0;
				if (num11 < num)
				{
					num29 = matrixH[num27 + num26];
					num19 = matrixH[num27 + num] * matrixH[num25 + num26];
				}
				if (num10 == 10)
				{
					num3 += num20;
					for (int n = 0; n <= num; n++)
					{
						matrixH[n * order + n] -= num20;
					}
					num7 = Math.Abs(matrixH[num27 + num]) + Math.Abs(matrixH[(num - 2) * order + num26]);
					num20 = (num29 = 0.75 * num7);
					num19 = -0.4375 * num7 * num7;
				}
				if (num10 == 30)
				{
					num7 = (num29 - num20) / 2.0;
					num7 = num7 * num7 + num19;
					if (num7 > 0.0)
					{
						num7 = Math.Sqrt(num7);
						if (num29 < num20)
						{
							num7 = 0.0 - num7;
						}
						num7 = num20 - num19 / ((num29 - num20) / 2.0 + num7);
						for (int num30 = 0; num30 <= num; num30++)
						{
							matrixH[num30 * order + num30] -= num7;
						}
						num3 += num7;
						num20 = (num29 = (num19 = 0.964));
					}
				}
				num10++;
				if (num10 >= 30 * order)
				{
					throw new NonConvergenceException();
				}
				int num31;
				for (num31 = num - 2; num31 >= num11; num31--)
				{
					int num32 = num31 + 1;
					int num33 = num31 - 1;
					int num34 = num31 * order;
					int num35 = num32 * order;
					int num36 = num33 * order;
					num8 = matrixH[num34 + num31];
					num6 = num20 - num8;
					num7 = num29 - num8;
					num4 = (num6 * num7 - num19) / matrixH[num34 + num32] + matrixH[num35 + num31];
					num5 = matrixH[num35 + num32] - num8 - num6 - num7;
					num6 = matrixH[num35 + (num31 + 2)];
					num7 = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6);
					num4 /= num7;
					num5 /= num7;
					num6 /= num7;
					if (num31 == num11 || Math.Abs(matrixH[num36 + num31]) * (Math.Abs(num5) + Math.Abs(num6)) < num2 * (Math.Abs(num4) * (Math.Abs(matrixH[num36 + num33]) + Math.Abs(num8) + Math.Abs(matrixH[num35 + num32]))))
					{
						break;
					}
				}
				int num37 = num31 + 2;
				for (int num38 = num37; num38 <= num; num38++)
				{
					matrixH[(num38 - 2) * order + num38] = 0.0;
					if (num38 > num37)
					{
						matrixH[(num38 - 3) * order + num38] = 0.0;
					}
				}
				for (int num39 = num31; num39 <= num - 1; num39++)
				{
					bool flag = num39 != num - 1;
					int num40 = num39 * order;
					int num41 = num39 - 1;
					int num42 = num39 + 1;
					int num43 = num39 + 2;
					int num44 = num42 * order;
					int num45 = num43 * order;
					int num46 = num41 * order;
					if (num39 != num31)
					{
						num4 = matrixH[num46 + num39];
						num5 = matrixH[num46 + num42];
						num6 = (flag ? matrixH[num46 + num43] : 0.0);
						num20 = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6);
						if (num20 == 0.0)
						{
							continue;
						}
						num4 /= num20;
						num5 /= num20;
						num6 /= num20;
					}
					num7 = Math.Sqrt(num4 * num4 + num5 * num5 + num6 * num6);
					if (num4 < 0.0)
					{
						num7 = 0.0 - num7;
					}
					if (num7 == 0.0)
					{
						continue;
					}
					if (num39 != num31)
					{
						matrixH[num46 + num39] = (0.0 - num7) * num20;
					}
					else if (num11 != num31)
					{
						matrixH[num46 + num39] = 0.0 - matrixH[num46 + num39];
					}
					num4 += num7;
					num20 = num4 / num7;
					num29 = num5 / num7;
					num8 = num6 / num7;
					num5 /= num4;
					num6 /= num4;
					for (int num47 = num39; num47 < order; num47++)
					{
						int num48 = num47 * order;
						int num49 = num48 + num39;
						int num50 = num48 + num42;
						int num51 = num48 + num43;
						num4 = matrixH[num49] + num5 * matrixH[num50];
						if (flag)
						{
							num4 += num6 * matrixH[num51];
							matrixH[num51] -= num4 * num8;
						}
						matrixH[num49] -= num4 * num20;
						matrixH[num50] -= num4 * num29;
					}
					for (int num52 = 0; num52 <= Math.Min(num, num39 + 3); num52++)
					{
						num4 = num20 * matrixH[num40 + num52] + num29 * matrixH[num44 + num52];
						if (flag)
						{
							num4 += num8 * matrixH[num45 + num52];
							matrixH[num45 + num52] -= num4 * num6;
						}
						matrixH[num40 + num52] -= num4;
						matrixH[num44 + num52] -= num4 * num5;
					}
					for (int num53 = 0; num53 < order; num53++)
					{
						num4 = num20 * a[num40 + num53] + num29 * a[num44 + num53];
						if (flag)
						{
							num4 += num8 * a[num45 + num53];
							a[num45 + num53] -= num4 * num6;
						}
						a[num40 + num53] -= num4;
						a[num44 + num53] -= num4 * num5;
					}
				}
			}
			if (num9 == 0.0)
			{
				return;
			}
			for (num = order - 1; num >= 0; num--)
			{
				int num54 = num * order;
				int num55 = num - 1;
				int num56 = num55 * order;
				num4 = d[num];
				num5 = e[num];
				if (num5 == 0.0)
				{
					int num57 = num;
					matrixH[num54 + num] = 1.0;
					for (int num58 = num - 1; num58 >= 0; num58--)
					{
						int num59 = num58 + 1;
						int num60 = num58 * order;
						int num61 = num59 * order;
						double num19 = matrixH[num60 + num58] - num4;
						num6 = 0.0;
						for (int num62 = num57; num62 <= num; num62++)
						{
							num6 += matrixH[num62 * order + num58] * matrixH[num54 + num62];
						}
						if (e[num58] < 0.0)
						{
							num8 = num19;
							num7 = num6;
						}
						else
						{
							num57 = num58;
							double num63;
							if (e[num58] == 0.0)
							{
								if (num19 != 0.0)
								{
									matrixH[num54 + num58] = (0.0 - num6) / num19;
								}
								else
								{
									matrixH[num54 + num58] = (0.0 - num6) / (num2 * num9);
								}
							}
							else
							{
								double num20 = matrixH[num61 + num58];
								double num29 = matrixH[num60 + num59];
								num5 = (d[num58] - num4) * (d[num58] - num4) + e[num58] * e[num58];
								num63 = (matrixH[num54 + num58] = (num20 * num7 - num8 * num6) / num5);
								if (Math.Abs(num20) > Math.Abs(num8))
								{
									matrixH[num54 + num59] = (0.0 - num6 - num19 * num63) / num20;
								}
								else
								{
									matrixH[num54 + num59] = (0.0 - num7 - num29 * num63) / num8;
								}
							}
							num63 = Math.Abs(matrixH[num54 + num58]);
							if (num2 * num63 * num63 > 1.0)
							{
								for (int num64 = num58; num64 <= num; num64++)
								{
									matrixH[num54 + num64] /= num63;
								}
							}
						}
					}
				}
				else if (num5 < 0.0)
				{
					int num65 = num - 1;
					if (Math.Abs(matrixH[num56 + num]) > Math.Abs(matrixH[num54 + num55]))
					{
						matrixH[num56 + num55] = num5 / matrixH[num56 + num];
						matrixH[num54 + num55] = (0.0 - (matrixH[num54 + num] - num4)) / matrixH[num56 + num];
					}
					else
					{
						Complex complex = Cdiv(0.0, 0.0 - matrixH[num54 + num55], matrixH[num56 + num55] - num4, num5);
						matrixH[num56 + num55] = complex.Real;
						matrixH[num54 + num55] = complex.Imaginary;
					}
					matrixH[num56 + num] = 0.0;
					matrixH[num54 + num] = 1.0;
					for (int num66 = num - 2; num66 >= 0; num66--)
					{
						int num67 = num66 + 1;
						int num68 = num66 * order;
						int num69 = num67 * order;
						double num70 = 0.0;
						double num71 = 0.0;
						for (int num72 = num65; num72 <= num; num72++)
						{
							int num73 = num72 * order + num66;
							num70 += matrixH[num73] * matrixH[num56 + num72];
							num71 += matrixH[num73] * matrixH[num54 + num72];
						}
						double num19 = matrixH[num68 + num66] - num4;
						if (e[num66] < 0.0)
						{
							num8 = num19;
							num6 = num70;
							num7 = num71;
						}
						else
						{
							num65 = num66;
							if (e[num66] == 0.0)
							{
								Complex complex2 = Cdiv(0.0 - num70, 0.0 - num71, num19, num5);
								matrixH[num56 + num66] = complex2.Real;
								matrixH[num54 + num66] = complex2.Imaginary;
							}
							else
							{
								double num20 = matrixH[num69 + num66];
								double num29 = matrixH[num68 + num67];
								double num74 = (d[num66] - num4) * (d[num66] - num4) + e[num66] * e[num66] - num5 * num5;
								double num75 = (d[num66] - num4) * 2.0 * num5;
								if (num74 == 0.0 && num75 == 0.0)
								{
									num74 = num2 * num9 * (Math.Abs(num19) + Math.Abs(num5) + Math.Abs(num20) + Math.Abs(num29) + Math.Abs(num8));
								}
								Complex complex3 = Cdiv(num20 * num6 - num8 * num70 + num5 * num71, num20 * num7 - num8 * num71 - num5 * num70, num74, num75);
								matrixH[num56 + num66] = complex3.Real;
								matrixH[num54 + num66] = complex3.Imaginary;
								if (Math.Abs(num20) > Math.Abs(num8) + Math.Abs(num5))
								{
									matrixH[num56 + num67] = (0.0 - num70 - num19 * matrixH[num56 + num66] + num5 * matrixH[num54 + num66]) / num20;
									matrixH[num54 + num67] = (0.0 - num71 - num19 * matrixH[num54 + num66] - num5 * matrixH[num56 + num66]) / num20;
								}
								else
								{
									complex3 = Cdiv(0.0 - num6 - num29 * matrixH[num56 + num66], 0.0 - num7 - num29 * matrixH[num54 + num66], num8, num5);
									matrixH[num56 + num67] = complex3.Real;
									matrixH[num54 + num67] = complex3.Imaginary;
								}
							}
							double num63 = Math.Max(Math.Abs(matrixH[num56 + num66]), Math.Abs(matrixH[num54 + num66]));
							if (num2 * num63 * num63 > 1.0)
							{
								for (int num76 = num66; num76 <= num; num76++)
								{
									matrixH[num56 + num76] /= num63;
									matrixH[num54 + num76] /= num63;
								}
							}
						}
					}
				}
			}
			for (int num77 = order - 1; num77 >= 0; num77--)
			{
				int num78 = num77 * order;
				for (int num79 = 0; num79 < order; num79++)
				{
					num8 = 0.0;
					for (int num80 = 0; num80 <= num77; num80++)
					{
						num8 += a[num80 * order + num79] * matrixH[num78 + num80];
					}
					a[num78 + num79] = num8;
				}
			}
		}

		private static Complex Cdiv(double xreal, double ximag, double yreal, double yimag)
		{
			if (Math.Abs(yimag) < Math.Abs(yreal))
			{
				return new Complex((xreal + ximag * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)), (ximag - xreal * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)));
			}
			return new Complex((ximag + xreal * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)), (0.0 - xreal + ximag * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)));
		}

		public virtual void AddVectorToScaledVector(float[] y, float alpha, float[] x, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if ((double)alpha == 0.0)
			{
				y.Copy(result);
			}
			else if ((double)alpha == 1.0)
			{
				for (int i = 0; i < result.Length; i++)
				{
					result[i] = y[i] + x[i];
				}
			}
			else
			{
				for (int j = 0; j < result.Length; j++)
				{
					result[j] = y[j] + alpha * x[j];
				}
			}
		}

		public virtual void ScaleArray(float alpha, float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if ((double)alpha == 0.0)
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if ((double)alpha == 1.0)
			{
				x.Copy(result);
				return;
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = alpha * x[i];
			}
		}

		public virtual void ConjugateArray(float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				x.CopyTo(result, 0);
			}
		}

		public virtual float DotProduct(float[] x, float[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float num = 0f;
			for (int i = 0; i < y.Length; i++)
			{
				num += y[i] * x[i];
			}
			return num;
		}

		public virtual void AddArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] + y[i];
			}
		}

		public virtual void SubtractArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] - y[i];
			}
		}

		public virtual void PointWiseMultiplyArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = x[i] * y[i];
			}
		}

		public virtual void PointWiseDivideArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = (float)Math.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, float[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += (double)Math.Abs(matrix[l * rows + m]);
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(Math.Abs(matrix[j * rows + k]), num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += Math.Abs(matrix[n * rows + num5]);
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				float[] array = new float[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.Transpose, 1f, matrix, rows, columns, matrix, rows, columns, 0f, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += (double)Math.Abs(array[i * rows + i]);
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(float[] x, int rowsX, int columnsX, float[] y, int rowsY, int columnsY, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsX}) != rowsB ({rowsY})"));
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsA ({columnsX}) != a.Length ({x.Length})"));
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsY}) * columnsB ({columnsY}) != b.Length ({y.Length})"));
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsX}) * columnsB ({columnsY}) != c.Length ({result.Length})"));
			}
			Array.Clear(result, 0, result.Length);
			float[][] columnDataB = new float[columnsY][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				float[] array = new float[rowsY];
				GetColumn(Transpose.DontTranspose, i, rowsY, columnsY, y, array);
				columnDataB[i] = array;
			}
			if (rowsX + columnsY + columnsX < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				float[] array2 = new float[columnsX];
				for (int j = 0; j < rowsX; j++)
				{
					GetRow(Transpose.DontTranspose, j, rowsX, columnsX, x, array2);
					for (int k = 0; k < columnsY; k++)
					{
						float[] array3 = columnDataB[k];
						float num = 0f;
						for (int l = 0; l < array2.Length; l++)
						{
							num += array2[l] * array3[l];
						}
						result[k * rowsX + j] += 1f * num;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsX, 1, delegate(int u, int v)
			{
				float[] array4 = new float[columnsX];
				for (int m = u; m < v; m++)
				{
					GetRow(Transpose.DontTranspose, m, rowsX, columnsX, x, array4);
					for (int n = 0; n < columnsY; n++)
					{
						float[] array5 = columnDataB[n];
						float num2 = 0f;
						for (int num3 = 0; num3 < array4.Length; num3++)
						{
							num2 += array4[num3] * array5[num3];
						}
						result[n * rowsX + m] += 1f * num2;
					}
				}
			});
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, float alpha, float[] a, int rowsA, int columnsA, float[] b, int rowsB, int columnsB, float beta, float[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			if (transposeA != Transpose.DontTranspose)
			{
				int num = rowsA;
				rowsA = columnsA;
				columnsA = num;
			}
			if (transposeB != Transpose.DontTranspose)
			{
				int num2 = rowsB;
				rowsB = columnsB;
				columnsB = num2;
			}
			if (columnsA != rowsB)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"columnsA ({columnsA}) != rowsB ({rowsB})"));
			}
			if (rowsA * columnsA != a.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsA ({columnsA}) != a.Length ({a.Length})"));
			}
			if (rowsB * columnsB != b.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsB ({rowsB}) * columnsB ({columnsB}) != b.Length ({b.Length})"));
			}
			if (rowsA * columnsB != c.Length)
			{
				throw new ArgumentOutOfRangeException(FormattableString.Invariant($"rowsA ({rowsA}) * columnsB ({columnsB}) != c.Length ({c.Length})"));
			}
			if ((double)beta == 0.0)
			{
				Array.Clear(c, 0, c.Length);
			}
			else if ((double)beta != 1.0)
			{
				ScaleArray(beta, c, c);
			}
			if ((double)alpha == 0.0)
			{
				return;
			}
			float[][] columnDataB = new float[columnsB][];
			for (int i = 0; i < columnDataB.Length; i++)
			{
				float[] array = new float[rowsB];
				GetColumn(transposeB, i, rowsB, columnsB, b, array);
				columnDataB[i] = array;
			}
			if (rowsA + columnsB + columnsA < Control.ParallelizeOrder || Control.MaxDegreeOfParallelism < 2)
			{
				float[] array2 = new float[columnsA];
				for (int j = 0; j < rowsA; j++)
				{
					GetRow(transposeA, j, rowsA, columnsA, a, array2);
					for (int k = 0; k < columnsB; k++)
					{
						float[] array3 = columnDataB[k];
						float num3 = 0f;
						for (int l = 0; l < array2.Length; l++)
						{
							num3 += array2[l] * array3[l];
						}
						c[k * rowsA + j] += alpha * num3;
					}
				}
				return;
			}
			CommonParallel.For(0, rowsA, 1, delegate(int u, int v)
			{
				float[] array4 = new float[columnsA];
				for (int m = u; m < v; m++)
				{
					GetRow(transposeA, m, rowsA, columnsA, a, array4);
					for (int n = 0; n < columnsB; n++)
					{
						float[] array5 = columnDataB[n];
						float num4 = 0f;
						for (int num5 = 0; num5 < array4.Length; num5++)
						{
							num4 += array4[num5] * array5[num5];
						}
						c[n * rowsA + m] += alpha * num4;
					}
				}
			});
		}

		public virtual void LUFactor(float[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			float[] array = new float[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					float num4 = 0f;
					for (int m = 0; m < num3; m++)
					{
						num4 += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= num4);
				}
				int num5 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (Math.Abs(array[n]) > Math.Abs(array[num5]))
					{
						num5 = n;
					}
				}
				if (num5 != j)
				{
					for (int num6 = 0; num6 < order; num6++)
					{
						int num7 = num6 * order;
						int num8 = num7 + num5;
						int num9 = num7 + j;
						float num10 = data[num8];
						data[num8] = data[num9];
						data[num9] = num10;
					}
					ipiv[j] = num5;
				}
				if ((j < order) & ((double)data[num2] != 0.0))
				{
					for (int num11 = j + 1; num11 < order; num11++)
					{
						data[num + num11] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(float[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			float[] array = new float[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = 1f;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, float[] a, int order, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			float[] array = new float[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, float[] a, int order, int[] ipiv, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						float num5 = b[num3];
						b[num3] = b[num4];
						b[num4] = num5;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num6 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num7 = m * order;
						b[l + num7] -= b[k + num7] * a[l + num6];
					}
				}
			}
			for (int num8 = order - 1; num8 >= 0; num8--)
			{
				int num9 = num8 + num8 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num8 + n * order] /= a[num9];
				}
				num9 = num8 * order;
				for (int num10 = 0; num10 < num8; num10++)
				{
					for (int num11 = 0; num11 < columnsOfB; num11++)
					{
						int num12 = num11 * order;
						b[num10 + num12] -= b[num8 + num12] * a[num10 + num9];
					}
				}
			}
		}

		public virtual void CholeskyFactor(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			float[] array = new float[order];
			for (int i = 0; i < order; i++)
			{
				float num = a[i * order + i];
				if (!((double)num > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				num = (array[i] = (a[i * order + i] = (float)Math.Sqrt(num)));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= num;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0f;
				}
			}
		}

		private static void DoCholeskyStep(float[] data, int rowDim, int firstCol, int colLimit, float[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				float num2 = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * num2;
				}
			}
		}

		public virtual void CholeskySolve(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			float[] array = new float[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(float[] a, int orderA, float[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				float num2 = b[num + i];
				for (int num3 = i - 1; num3 >= 0; num3--)
				{
					num2 -= a[num3 * orderA + i] * b[num + num3];
				}
				b[num + i] = num2 / a[i * orderA + i];
			}
			for (int num4 = orderA - 1; num4 >= 0; num4--)
			{
				float num2 = b[num + num4];
				int num5 = num4 * orderA;
				for (int j = num4 + 1; j < orderA; j++)
				{
					num2 -= a[num5 + j] * b[num + j];
				}
				b[num + num4] = num2 / a[num5 + num4];
			}
		}

		public virtual void QRFactor(float[] r, int rowsR, int columnsR, float[] q, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			float[] work = ((columnsR > rowsR) ? new float[rowsR * rowsR] : new float[rowsR * columnsR]);
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = 1f;
				}
			});
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(float[] a, int rowsA, int columnsA, float[] r, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			float[] work = new float[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = 1f;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(float[] work, int workIndex, float[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				float num2 = 0f;
				for (int j = rowStart; j < rowCount; j++)
				{
					num2 += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart] * num2;
				}
			}
		}

		private static void GenerateColumn(float[] work, float[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num4 = tmp + l;
					work[num4 - row] = a[num4];
					a[num4] = 0f;
				}
			});
			double num2 = 0.0;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num3 = tmp + i;
				num2 += (double)(work[num3] * work[num3]);
			}
			num2 = Math.Sqrt(num2);
			if (row == rowCount - 1 || num2 == 0.0)
			{
				a[num] = 0f - work[tmp];
				work[tmp] = 1.4142135f;
				return;
			}
			float scale = 1f / (float)num2;
			if ((double)work[tmp] < 0.0)
			{
				scale *= -1f;
			}
			a[num] = -1f / scale;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] *= scale;
				}
			});
			work[tmp] += 1f;
			float s = (float)Math.Sqrt(1.0 / (double)work[tmp]);
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] *= s;
				}
			});
		}

		public virtual void QRSolve(float[] a, int rows, int columns, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			float[] tau = new float[rows * columns];
			float[] array = new float[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				float[] q = new float[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				float[] r = new float[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(float[] q, float[] r, int rowsA, int columnsA, float[] tau, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			float[] sol = new float[b.Length];
			Buffer.BlockCopy(b, 0, sol, 0, b.Length * 4);
			float[] column = new float[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						float num9 = 0f;
						for (int num10 = 0; num10 < rowsA; num10++)
						{
							num9 += q[num8 + num10] * column[num10];
						}
						sol[jm + n] = num9;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, float[] a, int rowsA, int columnsA, float[] s, float[] u, float[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			float[] array = new float[rowsA];
			float[] array2 = new float[columnsA];
			float[] array3 = new float[vt.Length];
			float[] array4 = new float[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					int num5 = i;
					float num6 = 0f;
					for (int j = i; j < rowsA; j++)
					{
						num6 += a[num5 * rowsA + j] * a[num5 * rowsA + j];
					}
					array4[i] = (float)Math.Sqrt(num6);
					if ((double)array4[i] != 0.0)
					{
						if ((double)a[i * rowsA + i] != 0.0)
						{
							array4[i] = Math.Abs(array4[i]) * (a[i * rowsA + i] / Math.Abs(a[i * rowsA + i]));
						}
						for (int k = i; k < rowsA; k++)
						{
							a[i * rowsA + k] *= 1f / array4[i];
						}
						a[i * rowsA + i] = 1f + a[i * rowsA + i];
					}
					array4[i] = 0f - array4[i];
				}
				for (int l = num4; l < columnsA; l++)
				{
					if (i < num && (double)array4[i] != 0.0)
					{
						float num7 = 0f;
						for (int k = i; k < rowsA; k++)
						{
							num7 += a[l * rowsA + k] * a[i * rowsA + k];
						}
						num7 = (0f - num7) / a[i * rowsA + i];
						for (int m = i; m < rowsA; m++)
						{
							a[l * rowsA + m] += num7 * a[i * rowsA + m];
						}
					}
					array2[l] = a[l * rowsA + i];
				}
				if (computeVectors && i < num)
				{
					for (int k = i; k < rowsA; k++)
					{
						u[i * rowsA + k] = a[i * rowsA + k];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				double num8 = 0.0;
				for (int k = num4; k < array2.Length; k++)
				{
					num8 += (double)(array2[k] * array2[k]);
				}
				array2[i] = (float)Math.Sqrt(num8);
				if ((double)array2[i] != 0.0)
				{
					if ((double)array2[num4] != 0.0)
					{
						array2[i] = Math.Abs(array2[i]) * (array2[num4] / Math.Abs(array2[num4]));
					}
					for (int k = num4; k < array2.Length; k++)
					{
						array2[k] *= 1f / array2[i];
					}
					array2[num4] = 1f + array2[num4];
				}
				array2[i] = 0f - array2[i];
				if (num4 < rowsA && (double)array2[i] != 0.0)
				{
					for (int k = num4; k < rowsA; k++)
					{
						array[k] = 0f;
					}
					for (int l = num4; l < columnsA; l++)
					{
						for (int n = num4; n < rowsA; n++)
						{
							array[n] += array2[l] * a[l * rowsA + n];
						}
					}
					for (int l = num4; l < columnsA; l++)
					{
						float num9 = (0f - array2[l]) / array2[num4];
						for (int num10 = num4; num10 < rowsA; num10++)
						{
							a[l * rowsA + num10] += num9 * array[num10];
						}
					}
				}
				if (computeVectors)
				{
					for (int k = num4; k < columnsA; k++)
					{
						array3[i * columnsA + k] = array2[k];
					}
				}
			}
			int num11 = Math.Min(columnsA, rowsA + 1);
			int num12 = num + 1;
			int num13 = num2 + 1;
			if (num < columnsA)
			{
				array4[num12 - 1] = a[(num12 - 1) * rowsA + (num12 - 1)];
			}
			if (rowsA < num11)
			{
				array4[num11 - 1] = 0f;
			}
			if (num13 < num11)
			{
				array2[num13 - 1] = a[(num11 - 1) * rowsA + (num13 - 1)];
			}
			array2[num11 - 1] = 0f;
			if (computeVectors)
			{
				for (int l = num12 - 1; l < rowsA; l++)
				{
					for (int k = 0; k < rowsA; k++)
					{
						u[l * rowsA + k] = 0f;
					}
					u[l * rowsA + l] = 1f;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if ((double)array4[i] != 0.0)
					{
						for (int l = i + 1; l < rowsA; l++)
						{
							float num7 = 0f;
							for (int k = i; k < rowsA; k++)
							{
								num7 += u[l * rowsA + k] * u[i * rowsA + k];
							}
							num7 = (0f - num7) / u[i * rowsA + i];
							for (int num14 = i; num14 < rowsA; num14++)
							{
								u[l * rowsA + num14] += num7 * u[i * rowsA + num14];
							}
						}
						for (int k = i; k < rowsA; k++)
						{
							u[i * rowsA + k] *= -1f;
						}
						u[i * rowsA + i] = 1f + u[i * rowsA + i];
						for (int k = 0; k < i; k++)
						{
							u[i * rowsA + k] = 0f;
						}
					}
					else
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[i * rowsA + k] = 0f;
						}
						u[i * rowsA + i] = 1f;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && (double)array2[i] != 0.0)
					{
						for (int l = num4; l < columnsA; l++)
						{
							float num7 = 0f;
							for (int k = num4; k < columnsA; k++)
							{
								num7 += array3[l * columnsA + k] * array3[i * columnsA + k];
							}
							num7 = (0f - num7) / array3[i * columnsA + num4];
							for (int num15 = i; num15 < columnsA; num15++)
							{
								array3[l * columnsA + num15] += num7 * array3[i * columnsA + num15];
							}
						}
					}
					for (int k = 0; k < columnsA; k++)
					{
						array3[i * columnsA + k] = 0f;
					}
					array3[i * columnsA + i] = 1f;
				}
			}
			for (int k = 0; k < num11; k++)
			{
				float num7;
				float num16;
				if ((double)array4[k] != 0.0)
				{
					num7 = array4[k];
					num16 = array4[k] / num7;
					array4[k] = num7;
					if (k < num11 - 1)
					{
						array2[k] /= num16;
					}
					if (computeVectors)
					{
						for (int l = 0; l < rowsA; l++)
						{
							u[k * rowsA + l] *= num16;
						}
					}
				}
				if (k == num11 - 1)
				{
					break;
				}
				if ((double)array2[k] == 0.0)
				{
					continue;
				}
				num7 = array2[k];
				num16 = num7 / array2[k];
				array2[k] = num7;
				array4[k + 1] *= num16;
				if (computeVectors)
				{
					for (int l = 0; l < columnsA; l++)
					{
						array3[(k + 1) * columnsA + l] *= num16;
					}
				}
			}
			int num17 = num11;
			int num18 = 0;
			while (num11 > 0)
			{
				if (num18 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num11 - 2; i >= 0; i--)
				{
					double num19 = Math.Abs(array4[i]) + Math.Abs(array4[i + 1]);
					if ((num19 + (double)Math.Abs(array2[i])).AlmostEqualRelative(num19, 7))
					{
						array2[i] = 0f;
						break;
					}
				}
				int num20;
				if (i == num11 - 2)
				{
					num20 = 4;
				}
				else
				{
					int num21;
					for (num21 = num11 - 1; num21 > i; num21--)
					{
						double num19 = 0.0;
						if (num21 != num11 - 1)
						{
							num19 += (double)Math.Abs(array2[num21]);
						}
						if (num21 != i + 1)
						{
							num19 += (double)Math.Abs(array2[num21 - 1]);
						}
						if ((num19 + (double)Math.Abs(array4[num21])).AlmostEqualRelative(num19, 7))
						{
							array4[num21] = 0f;
							break;
						}
					}
					if (num21 == i)
					{
						num20 = 3;
					}
					else if (num21 == num11 - 1)
					{
						num20 = 1;
					}
					else
					{
						num20 = 2;
						i = num21;
					}
				}
				i++;
				float c;
				float s2;
				switch (num20)
				{
				case 1:
				{
					float db = array2[num11 - 2];
					array2[num11 - 2] = 0f;
					for (int num36 = i; num36 < num11 - 1; num36++)
					{
						int num24 = num11 - 2 - num36 + i;
						float da = array4[num24];
						Drotg(ref da, ref db, out c, out s2);
						array4[num24] = da;
						if (num24 != i)
						{
							db = (0f - s2) * array2[num24 - 1];
							array2[num24 - 1] = c * array2[num24 - 1];
						}
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								float num37 = c * array3[num24 * columnsA + k] + s2 * array3[(num11 - 1) * columnsA + k];
								array3[(num11 - 1) * columnsA + k] = c * array3[(num11 - 1) * columnsA + k] - s2 * array3[num24 * columnsA + k];
								array3[num24 * columnsA + k] = num37;
							}
						}
					}
					break;
				}
				case 2:
				{
					float db = array2[i - 1];
					array2[i - 1] = 0f;
					for (int num24 = i; num24 < num11; num24++)
					{
						float da = array4[num24];
						Drotg(ref da, ref db, out c, out s2);
						array4[num24] = da;
						db = (0f - s2) * array2[num24];
						array2[num24] = c * array2[num24];
						if (computeVectors)
						{
							for (int k = 0; k < rowsA; k++)
							{
								float num25 = c * u[num24 * rowsA + k] + s2 * u[(i - 1) * rowsA + k];
								u[(i - 1) * rowsA + k] = c * u[(i - 1) * rowsA + k] - s2 * u[num24 * rowsA + k];
								u[num24 * rowsA + k] = num25;
							}
						}
					}
					break;
				}
				case 3:
				{
					float val = 0f;
					val = Math.Max(val, Math.Abs(array4[num11 - 1]));
					val = Math.Max(val, Math.Abs(array4[num11 - 2]));
					val = Math.Max(val, Math.Abs(array2[num11 - 2]));
					val = Math.Max(val, Math.Abs(array4[i]));
					val = Math.Max(val, Math.Abs(array2[i]));
					float num26 = array4[num11 - 1] / val;
					float num27 = array4[num11 - 2] / val;
					float num28 = array2[num11 - 2] / val;
					float num29 = array4[i] / val;
					float num30 = array2[i] / val;
					float num31 = ((num27 + num26) * (num27 - num26) + num28 * num28) / 2f;
					float num32 = num26 * num28 * (num26 * num28);
					float num33 = 0f;
					if ((double)num31 != 0.0 || (double)num32 != 0.0)
					{
						num33 = (float)Math.Sqrt(num31 * num31 + num32);
						if ((double)num31 < 0.0)
						{
							num33 = 0f - num33;
						}
						num33 = num32 / (num31 + num33);
					}
					float db = (num29 + num26) * (num29 - num26) + num33;
					float db2 = num29 * num30;
					for (int num24 = i; num24 < num11 - 1; num24++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num24 != i)
						{
							array2[num24 - 1] = db;
						}
						db = c * array4[num24] + s2 * array2[num24];
						array2[num24] = c * array2[num24] - s2 * array4[num24];
						db2 = s2 * array4[num24 + 1];
						array4[num24 + 1] = c * array4[num24 + 1];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								float num34 = c * array3[num24 * columnsA + k] + s2 * array3[(num24 + 1) * columnsA + k];
								array3[(num24 + 1) * columnsA + k] = c * array3[(num24 + 1) * columnsA + k] - s2 * array3[num24 * columnsA + k];
								array3[num24 * columnsA + k] = num34;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num24] = db;
						db = c * array2[num24] + s2 * array4[num24 + 1];
						array4[num24 + 1] = 0f - s2 * array2[num24] + c * array4[num24 + 1];
						db2 = s2 * array2[num24 + 1];
						array2[num24 + 1] = c * array2[num24 + 1];
						if (computeVectors && num24 < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								float num35 = c * u[num24 * rowsA + k] + s2 * u[(num24 + 1) * rowsA + k];
								u[(num24 + 1) * rowsA + k] = c * u[(num24 + 1) * rowsA + k] - s2 * u[num24 * rowsA + k];
								u[num24 * rowsA + k] = num35;
							}
						}
					}
					array2[num11 - 2] = db;
					num18++;
					break;
				}
				case 4:
					if ((double)array4[i] < 0.0)
					{
						array4[i] = 0f - array4[i];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								array3[i * columnsA + k] *= -1f;
							}
						}
					}
					for (; i != num17 - 1 && !(array4[i] >= array4[i + 1]); i++)
					{
						float num7 = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = num7;
						if (computeVectors && i < columnsA)
						{
							for (int k = 0; k < columnsA; k++)
							{
								float num22 = array3[i * columnsA + k];
								array3[i * columnsA + k] = array3[(i + 1) * columnsA + k];
								array3[(i + 1) * columnsA + k] = num22;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								float num23 = u[i * rowsA + k];
								u[i * rowsA + k] = u[(i + 1) * rowsA + k];
								u[(i + 1) * rowsA + k] = num23;
							}
						}
					}
					num18 = 0;
					num11--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int k = 0; k < columnsA; k++)
				{
					for (int l = 0; l < columnsA; l++)
					{
						vt[l * columnsA + k] = array3[k * columnsA + l];
					}
				}
			}
			Buffer.BlockCopy(array4, 0, s, 0, Math.Min(rowsA, columnsA) * 4);
		}

		private static void Drotg(ref float da, ref float db, out float c, out float s)
		{
			float num = db;
			float num2 = Math.Abs(da);
			float num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			float num4 = num2 + num3;
			float num5;
			float num6;
			if ((double)num4 == 0.0)
			{
				c = 1f;
				s = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				float num7 = da / num4;
				float num8 = db / num4;
				num5 = num4 * (float)Math.Sqrt(num7 * num7 + num8 * num8);
				if ((double)num < 0.0)
				{
					num5 = 0f - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1f;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && (double)c != 0.0)
				{
					num6 = 1f / c;
				}
			}
			da = num5;
			db = num6;
		}

		public virtual void SvdSolve(float[] a, int rowsA, int columnsA, float[] b, int columnsB, float[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			float[] s = new float[Math.Min(rowsA, columnsA)];
			float[] u = new float[rowsA * rowsA];
			float[] vt = new float[columnsA * columnsA];
			float[] array = new float[a.Length];
			Buffer.BlockCopy(a, 0, array, 0, a.Length * 4);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, float[] s, float[] u, float[] vt, float[] b, int columnsB, float[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			float[] array = new float[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					float num2 = 0f;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							num2 += u[j * rowsA + k] * b[i * rowsA + k];
						}
						num2 /= s[j];
					}
					array[j] = num2;
				}
				for (int l = 0; l < columnsA; l++)
				{
					float num3 = 0f;
					for (int m = 0; m < columnsA; m++)
					{
						num3 += vt[l * columnsA + m] * array[m];
					}
					x[i * columnsA + l] = num3;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, float[] matrix, float[] matrixEv, Complex[] vectorEv, float[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			float[] array = new float[order];
			float[] array2 = new float[order];
			if (isSymmetric)
			{
				Buffer.BlockCopy(matrix, 0, matrixEv, 0, matrix.Length * 4);
				int num = order - 1;
				for (int i = 0; i < order; i++)
				{
					array[i] = matrixEv[i * order + num];
				}
				SymmetricTridiagonalize(matrixEv, array, array2, order);
				SymmetricDiagonalize(matrixEv, array, array2, order);
			}
			else
			{
				float[] array3 = new float[matrix.Length];
				Buffer.BlockCopy(matrix, 0, array3, 0, matrix.Length * 4);
				NonsymmetricReduceToHessenberg(matrixEv, array3, order);
				NonsymmetricReduceHessenberToRealSchur(matrixEv, array3, array, array2, order);
			}
			for (int j = 0; j < order; j++)
			{
				vectorEv[j] = new Complex(array[j], array2[j]);
				int num2 = j * order;
				matrixD[num2 + j] = array[j];
				if (array2[j] > 0f)
				{
					matrixD[num2 + order + j] = array2[j];
				}
				else if (array2[j] < 0f)
				{
					matrixD[num2 - order + j] = array2[j];
				}
			}
		}

		internal static void SymmetricTridiagonalize(float[] a, float[] d, float[] e, int order)
		{
			for (int num = order - 1; num > 0; num--)
			{
				float num2 = 0f;
				float num3 = 0f;
				for (int i = 0; i < num; i++)
				{
					num2 += Math.Abs(d[i]);
				}
				if (num2 == 0f)
				{
					e[num] = d[num - 1];
					for (int j = 0; j < num; j++)
					{
						d[j] = a[j * order + num - 1];
						a[j * order + num] = 0f;
						a[num * order + j] = 0f;
					}
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						d[k] /= num2;
						num3 += d[k] * d[k];
					}
					float num4 = d[num - 1];
					float num5 = (float)Math.Sqrt(num3);
					if (num4 > 0f)
					{
						num5 = 0f - num5;
					}
					e[num] = num2 * num5;
					num3 -= num4 * num5;
					d[num - 1] = num4 - num5;
					for (int l = 0; l < num; l++)
					{
						e[l] = 0f;
					}
					for (int m = 0; m < num; m++)
					{
						num4 = (a[num * order + m] = d[m]);
						num5 = e[m] + a[m * order + m] * num4;
						for (int n = m + 1; n <= num - 1; n++)
						{
							num5 += a[m * order + n] * d[n];
							e[n] += a[m * order + n] * num4;
						}
						e[m] = num5;
					}
					num4 = 0f;
					for (int num6 = 0; num6 < num; num6++)
					{
						e[num6] /= num3;
						num4 += e[num6] * d[num6];
					}
					float num7 = num4 / (num3 + num3);
					for (int num8 = 0; num8 < num; num8++)
					{
						e[num8] -= num7 * d[num8];
					}
					for (int num9 = 0; num9 < num; num9++)
					{
						num4 = d[num9];
						num5 = e[num9];
						for (int num10 = num9; num10 <= num - 1; num10++)
						{
							a[num9 * order + num10] -= num4 * e[num10] + num5 * d[num10];
						}
						d[num9] = a[num9 * order + num - 1];
						a[num9 * order + num] = 0f;
					}
				}
				d[num] = num3;
			}
			for (int num11 = 0; num11 < order - 1; num11++)
			{
				a[num11 * order + order - 1] = a[num11 * order + num11];
				a[num11 * order + num11] = 1f;
				float num12 = d[num11 + 1];
				if (num12 != 0f)
				{
					for (int num13 = 0; num13 <= num11; num13++)
					{
						d[num13] = a[(num11 + 1) * order + num13] / num12;
					}
					for (int num14 = 0; num14 <= num11; num14++)
					{
						float num15 = 0f;
						for (int num16 = 0; num16 <= num11; num16++)
						{
							num15 += a[(num11 + 1) * order + num16] * a[num14 * order + num16];
						}
						for (int num17 = 0; num17 <= num11; num17++)
						{
							a[num14 * order + num17] -= num15 * d[num17];
						}
					}
				}
				for (int num18 = 0; num18 <= num11; num18++)
				{
					a[(num11 + 1) * order + num18] = 0f;
				}
			}
			for (int num19 = 0; num19 < order; num19++)
			{
				d[num19] = a[num19 * order + order - 1];
				a[num19 * order + order - 1] = 0f;
			}
			a[order * order - 1] = 1f;
			e[0] = 0f;
		}

		internal static void SymmetricDiagonalize(float[] a, float[] d, float[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0f;
			float num = 0f;
			float num2 = 0f;
			double singlePrecision = Precision.SinglePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !((double)Math.Abs(e[k]) <= singlePrecision * (double)num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						float num4 = d[j];
						float num5 = (d[j + 1] - num4) / (2f * e[j]);
						float num6 = SpecialFunctions.Hypotenuse(num5, 1f);
						if (num5 < 0f)
						{
							num6 = 0f - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						float num7 = d[j + 1];
						float num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						float num9 = 1f;
						float num10 = num9;
						float num11 = num9;
						float num12 = e[j + 1];
						float num13 = 0f;
						float num14 = 0f;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = a[(num15 + 1) * order + m];
								a[(num15 + 1) * order + m] = num13 * a[num15 * order + m] + num9 * num8;
								a[num15 * order + m] = num9 * a[num15 * order + m] - num13 * num8;
							}
						}
						num5 = (0f - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while ((double)Math.Abs(e[j]) > singlePrecision * (double)num2);
				}
				d[j] += num;
				e[j] = 0f;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				float num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = a[n * order + num19];
						a[n * order + num19] = a[num16 * order + num19];
						a[num16 * order + num19] = num17;
					}
				}
			}
		}

		internal static void NonsymmetricReduceToHessenberg(float[] a, float[] matrixH, int order)
		{
			float[] array = new float[order];
			int num = order - 1;
			for (int i = 1; i <= num - 1; i++)
			{
				int num2 = (i - 1) * order;
				float num3 = 0f;
				for (int j = i; j <= num; j++)
				{
					num3 += Math.Abs(matrixH[num2 + j]);
				}
				if (num3 == 0f)
				{
					continue;
				}
				float num4 = 0f;
				for (int num5 = num; num5 >= i; num5--)
				{
					array[num5] = matrixH[num2 + num5] / num3;
					num4 += array[num5] * array[num5];
				}
				float num6 = (float)Math.Sqrt(num4);
				if (array[i] > 0f)
				{
					num6 = 0f - num6;
				}
				num4 -= array[i] * num6;
				array[i] -= num6;
				for (int k = i; k < order; k++)
				{
					int num7 = k * order;
					float num8 = 0f;
					for (int num9 = order - 1; num9 >= i; num9--)
					{
						num8 += array[num9] * matrixH[num7 + num9];
					}
					num8 /= num4;
					for (int l = i; l <= num; l++)
					{
						matrixH[num7 + l] -= num8 * array[l];
					}
				}
				for (int m = 0; m <= num; m++)
				{
					float num10 = 0f;
					for (int num11 = num; num11 >= i; num11--)
					{
						num10 += array[num11] * matrixH[num11 * order + m];
					}
					num10 /= num4;
					for (int n = i; n <= num; n++)
					{
						matrixH[n * order + m] -= num10 * array[n];
					}
				}
				array[i] = num3 * array[i];
				matrixH[num2 + i] = num3 * num6;
			}
			for (int num12 = 0; num12 < order; num12++)
			{
				for (int num13 = 0; num13 < order; num13++)
				{
					a[num13 * order + num12] = ((num12 == num13) ? 1f : 0f);
				}
			}
			for (int num14 = num - 1; num14 >= 1; num14--)
			{
				int num15 = (num14 - 1) * order;
				int num16 = num15 + num14;
				if ((double)matrixH[num16] != 0.0)
				{
					for (int num17 = num14 + 1; num17 <= num; num17++)
					{
						array[num17] = matrixH[num15 + num17];
					}
					for (int num18 = num14; num18 <= num; num18++)
					{
						float num19 = 0f;
						int num20 = num18 * order;
						for (int num21 = num14; num21 <= num; num21++)
						{
							num19 += array[num21] * a[num20 + num21];
						}
						num19 = num19 / array[num14] / matrixH[num16];
						for (int num22 = num14; num22 <= num; num22++)
						{
							a[num20 + num22] += num19 * array[num22];
						}
					}
				}
			}
		}

		internal static void NonsymmetricReduceHessenberToRealSchur(float[] a, float[] matrixH, float[] d, float[] e, int order)
		{
			int num = order - 1;
			float num2 = (float)Precision.SinglePrecision;
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			float num6 = 0f;
			float num7 = 0f;
			float num8 = 0f;
			float num9 = 0f;
			for (int i = 0; i < order; i++)
			{
				for (int j = Math.Max(i - 1, 0); j < order; j++)
				{
					num9 += Math.Abs(matrixH[j * order + i]);
				}
			}
			int num10 = 0;
			while (num >= 0)
			{
				int num11;
				for (num11 = num; num11 > 0; num11--)
				{
					int num12 = num11 - 1;
					int num13 = num12 * order;
					num7 = Math.Abs(matrixH[num13 + num12]) + Math.Abs(matrixH[num11 * order + num11]);
					if ((double)num7 == 0.0)
					{
						num7 = num9;
					}
					if (Math.Abs(matrixH[num13 + num11]) < num2 * num7)
					{
						break;
					}
				}
				if (num11 == num)
				{
					int num14 = num * order + num;
					matrixH[num14] += num3;
					d[num] = matrixH[num14];
					e[num] = 0f;
					num--;
					num10 = 0;
					continue;
				}
				float num20;
				float num19;
				if (num11 == num - 1)
				{
					int num15 = num * order;
					int num16 = num - 1;
					int num17 = num16 * order;
					int num18 = num15 + num;
					num19 = matrixH[num17 + num] * matrixH[num15 + num16];
					num4 = (matrixH[num17 + num16] - matrixH[num18]) / 2f;
					num5 = num4 * num4 + num19;
					num8 = (float)Math.Sqrt(Math.Abs(num5));
					matrixH[num18] += num3;
					matrixH[num17 + num16] += num3;
					num20 = matrixH[num18];
					if (num5 >= 0f)
					{
						num8 = ((!(num4 >= 0f)) ? (num4 - num8) : (num4 + num8));
						d[num16] = num20 + num8;
						d[num] = d[num16];
						if ((double)num8 != 0.0)
						{
							d[num] = num20 - num19 / num8;
						}
						e[num - 1] = 0f;
						e[num] = 0f;
						num20 = matrixH[num17 + num];
						num7 = Math.Abs(num20) + Math.Abs(num8);
						num4 = num20 / num7;
						num5 = num8 / num7;
						num6 = (float)Math.Sqrt(num4 * num4 + num5 * num5);
						num4 /= num6;
						num5 /= num6;
						for (int k = num - 1; k < order; k++)
						{
							int num21 = k * order;
							int num22 = num21 + num;
							num8 = matrixH[num21 + num16];
							matrixH[num21 + num16] = num5 * num8 + num4 * matrixH[num22];
							matrixH[num22] = num5 * matrixH[num22] - num4 * num8;
						}
						for (int l = 0; l <= num; l++)
						{
							int num23 = num15 + l;
							num8 = matrixH[num17 + l];
							matrixH[num17 + l] = num5 * num8 + num4 * matrixH[num23];
							matrixH[num23] = num5 * matrixH[num23] - num4 * num8;
						}
						for (int m = 0; m < order; m++)
						{
							int num24 = num15 + m;
							num8 = a[num17 + m];
							a[num17 + m] = num5 * num8 + num4 * a[num24];
							a[num24] = num5 * a[num24] - num4 * num8;
						}
					}
					else
					{
						d[num - 1] = num20 + num4;
						d[num] = num20 + num4;
						e[num - 1] = num8;
						e[num] = 0f - num8;
					}
					num -= 2;
					num10 = 0;
					continue;
				}
				int num25 = num * order;
				int num26 = num - 1;
				int num27 = num26 * order;
				int num28 = num25 + num;
				num20 = matrixH[num28];
				float num29 = 0f;
				num19 = 0f;
				if (num11 < num)
				{
					num29 = matrixH[num27 + num26];
					num19 = matrixH[num27 + num] * matrixH[num25 + num26];
				}
				if (num10 == 10)
				{
					num3 += num20;
					for (int n = 0; n <= num; n++)
					{
						matrixH[n * order + n] -= num20;
					}
					num7 = Math.Abs(matrixH[num27 + num]) + Math.Abs(matrixH[(num - 2) * order + num26]);
					num20 = (num29 = 0.75f * num7);
					num19 = -0.4375f * num7 * num7;
				}
				if (num10 == 30)
				{
					num7 = (num29 - num20) / 2f;
					num7 = num7 * num7 + num19;
					if (num7 > 0f)
					{
						num7 = (float)Math.Sqrt(num7);
						if (num29 < num20)
						{
							num7 = 0f - num7;
						}
						num7 = num20 - num19 / ((num29 - num20) / 2f + num7);
						for (int num30 = 0; num30 <= num; num30++)
						{
							matrixH[num30 * order + num30] -= num7;
						}
						num3 += num7;
						num20 = (num29 = (num19 = 0.964f));
					}
				}
				num10++;
				if (num10 >= 30 * order)
				{
					throw new NonConvergenceException();
				}
				int num31;
				for (num31 = num - 2; num31 >= num11; num31--)
				{
					int num32 = num31 + 1;
					int num33 = num31 - 1;
					int num34 = num31 * order;
					int num35 = num32 * order;
					int num36 = num33 * order;
					num8 = matrixH[num34 + num31];
					num6 = num20 - num8;
					num7 = num29 - num8;
					num4 = (num6 * num7 - num19) / matrixH[num34 + num32] + matrixH[num35 + num31];
					num5 = matrixH[num35 + num32] - num8 - num6 - num7;
					num6 = matrixH[num35 + (num31 + 2)];
					num7 = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6);
					num4 /= num7;
					num5 /= num7;
					num6 /= num7;
					if (num31 == num11 || Math.Abs(matrixH[num36 + num31]) * (Math.Abs(num5) + Math.Abs(num6)) < num2 * (Math.Abs(num4) * (Math.Abs(matrixH[num36 + num33]) + Math.Abs(num8) + Math.Abs(matrixH[num35 + num32]))))
					{
						break;
					}
				}
				int num37 = num31 + 2;
				for (int num38 = num37; num38 <= num; num38++)
				{
					matrixH[(num38 - 2) * order + num38] = 0f;
					if (num38 > num37)
					{
						matrixH[(num38 - 3) * order + num38] = 0f;
					}
				}
				for (int num39 = num31; num39 <= num - 1; num39++)
				{
					bool flag = num39 != num - 1;
					int num40 = num39 * order;
					int num41 = num39 - 1;
					int num42 = num39 + 1;
					int num43 = num39 + 2;
					int num44 = num42 * order;
					int num45 = num43 * order;
					int num46 = num41 * order;
					if (num39 != num31)
					{
						num4 = matrixH[num46 + num39];
						num5 = matrixH[num46 + num42];
						num6 = (flag ? matrixH[num46 + num43] : 0f);
						num20 = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6);
						if (num20 == 0f)
						{
							continue;
						}
						num4 /= num20;
						num5 /= num20;
						num6 /= num20;
					}
					num7 = (float)Math.Sqrt(num4 * num4 + num5 * num5 + num6 * num6);
					if (num4 < 0f)
					{
						num7 = 0f - num7;
					}
					if (num7 == 0f)
					{
						continue;
					}
					if (num39 != num31)
					{
						matrixH[num46 + num39] = (0f - num7) * num20;
					}
					else if (num11 != num31)
					{
						matrixH[num46 + num39] = 0f - matrixH[num46 + num39];
					}
					num4 += num7;
					num20 = num4 / num7;
					num29 = num5 / num7;
					num8 = num6 / num7;
					num5 /= num4;
					num6 /= num4;
					for (int num47 = num39; num47 < order; num47++)
					{
						int num48 = num47 * order;
						int num49 = num48 + num39;
						int num50 = num48 + num42;
						int num51 = num48 + num43;
						num4 = matrixH[num49] + num5 * matrixH[num50];
						if (flag)
						{
							num4 += num6 * matrixH[num51];
							matrixH[num51] -= num4 * num8;
						}
						matrixH[num49] -= num4 * num20;
						matrixH[num50] -= num4 * num29;
					}
					for (int num52 = 0; num52 <= Math.Min(num, num39 + 3); num52++)
					{
						num4 = num20 * matrixH[num40 + num52] + num29 * matrixH[num44 + num52];
						if (flag)
						{
							num4 += num8 * matrixH[num45 + num52];
							matrixH[num45 + num52] -= num4 * num6;
						}
						matrixH[num40 + num52] -= num4;
						matrixH[num44 + num52] -= num4 * num5;
					}
					for (int num53 = 0; num53 < order; num53++)
					{
						num4 = num20 * a[num40 + num53] + num29 * a[num44 + num53];
						if (flag)
						{
							num4 += num8 * a[num45 + num53];
							a[num45 + num53] -= num4 * num6;
						}
						a[num40 + num53] -= num4;
						a[num44 + num53] -= num4 * num5;
					}
				}
			}
			if (num9 == 0f)
			{
				return;
			}
			for (num = order - 1; num >= 0; num--)
			{
				int num54 = num * order;
				int num55 = num - 1;
				int num56 = num55 * order;
				num4 = d[num];
				num5 = e[num];
				if (num5 == 0f)
				{
					int num57 = num;
					matrixH[num54 + num] = 1f;
					for (int num58 = num - 1; num58 >= 0; num58--)
					{
						int num59 = num58 + 1;
						int num60 = num58 * order;
						int num61 = num59 * order;
						float num19 = matrixH[num60 + num58] - num4;
						num6 = 0f;
						for (int num62 = num57; num62 <= num; num62++)
						{
							num6 += matrixH[num62 * order + num58] * matrixH[num54 + num62];
						}
						if ((double)e[num58] < 0.0)
						{
							num8 = num19;
							num7 = num6;
						}
						else
						{
							num57 = num58;
							float num63;
							if (e[num58] == 0f)
							{
								if (num19 != 0f)
								{
									matrixH[num54 + num58] = (0f - num6) / num19;
								}
								else
								{
									matrixH[num54 + num58] = (0f - num6) / (num2 * num9);
								}
							}
							else
							{
								float num20 = matrixH[num61 + num58];
								float num29 = matrixH[num60 + num59];
								num5 = (d[num58] - num4) * (d[num58] - num4) + e[num58] * e[num58];
								num63 = (matrixH[num54 + num58] = (num20 * num7 - num8 * num6) / num5);
								if (Math.Abs(num20) > Math.Abs(num8))
								{
									matrixH[num54 + num59] = (0f - num6 - num19 * num63) / num20;
								}
								else
								{
									matrixH[num54 + num59] = (0f - num7 - num29 * num63) / num8;
								}
							}
							num63 = Math.Abs(matrixH[num54 + num58]);
							if (num2 * num63 * num63 > 1f)
							{
								for (int num64 = num58; num64 <= num; num64++)
								{
									matrixH[num54 + num64] /= num63;
								}
							}
						}
					}
				}
				else if (num5 < 0f)
				{
					int num65 = num - 1;
					if (Math.Abs(matrixH[num56 + num]) > Math.Abs(matrixH[num54 + num55]))
					{
						matrixH[num56 + num55] = num5 / matrixH[num56 + num];
						matrixH[num54 + num55] = (0f - (matrixH[num54 + num] - num4)) / matrixH[num56 + num];
					}
					else
					{
						Complex32 complex = Cdiv(0f, 0f - matrixH[num54 + num55], matrixH[num56 + num55] - num4, num5);
						matrixH[num56 + num55] = complex.Real;
						matrixH[num54 + num55] = complex.Imaginary;
					}
					matrixH[num56 + num] = 0f;
					matrixH[num54 + num] = 1f;
					for (int num66 = num - 2; num66 >= 0; num66--)
					{
						int num67 = num66 + 1;
						int num68 = num66 * order;
						int num69 = num67 * order;
						float num70 = 0f;
						float num71 = 0f;
						for (int num72 = num65; num72 <= num; num72++)
						{
							int num73 = num72 * order + num66;
							num70 += matrixH[num73] * matrixH[num56 + num72];
							num71 += matrixH[num73] * matrixH[num54 + num72];
						}
						float num19 = matrixH[num68 + num66] - num4;
						if ((double)e[num66] < 0.0)
						{
							num8 = num19;
							num6 = num70;
							num7 = num71;
						}
						else
						{
							num65 = num66;
							if ((double)e[num66] == 0.0)
							{
								Complex32 complex2 = Cdiv(0f - num70, 0f - num71, num19, num5);
								matrixH[num56 + num66] = complex2.Real;
								matrixH[num54 + num66] = complex2.Imaginary;
							}
							else
							{
								float num20 = matrixH[num69 + num66];
								float num29 = matrixH[num68 + num67];
								float num74 = (d[num66] - num4) * (d[num66] - num4) + e[num66] * e[num66] - num5 * num5;
								float num75 = (d[num66] - num4) * 2f * num5;
								if (num74 == 0f && num75 == 0f)
								{
									num74 = num2 * num9 * (Math.Abs(num19) + Math.Abs(num5) + Math.Abs(num20) + Math.Abs(num29) + Math.Abs(num8));
								}
								Complex32 complex3 = Cdiv(num20 * num6 - num8 * num70 + num5 * num71, num20 * num7 - num8 * num71 - num5 * num70, num74, num75);
								matrixH[num56 + num66] = complex3.Real;
								matrixH[num54 + num66] = complex3.Imaginary;
								if (Math.Abs(num20) > Math.Abs(num8) + Math.Abs(num5))
								{
									matrixH[num56 + num67] = (0f - num70 - num19 * matrixH[num56 + num66] + num5 * matrixH[num54 + num66]) / num20;
									matrixH[num54 + num67] = (0f - num71 - num19 * matrixH[num54 + num66] - num5 * matrixH[num56 + num66]) / num20;
								}
								else
								{
									complex3 = Cdiv(0f - num6 - num29 * matrixH[num56 + num66], 0f - num7 - num29 * matrixH[num54 + num66], num8, num5);
									matrixH[num56 + num67] = complex3.Real;
									matrixH[num54 + num67] = complex3.Imaginary;
								}
							}
							float num63 = Math.Max(Math.Abs(matrixH[num56 + num66]), Math.Abs(matrixH[num54 + num66]));
							if (num2 * num63 * num63 > 1f)
							{
								for (int num76 = num66; num76 <= num; num76++)
								{
									matrixH[num56 + num76] /= num63;
									matrixH[num54 + num76] /= num63;
								}
							}
						}
					}
				}
			}
			for (int num77 = order - 1; num77 >= 0; num77--)
			{
				int num78 = num77 * order;
				for (int num79 = 0; num79 < order; num79++)
				{
					num8 = 0f;
					for (int num80 = 0; num80 <= num77; num80++)
					{
						num8 += a[num80 * order + num79] * matrixH[num78 + num80];
					}
					a[num78 + num79] = num8;
				}
			}
		}

		private static Complex32 Cdiv(float xreal, float ximag, float yreal, float yimag)
		{
			if (Math.Abs(yimag) < Math.Abs(yreal))
			{
				return new Complex32((xreal + ximag * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)), (ximag - xreal * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)));
			}
			return new Complex32((ximag + xreal * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)), (0f - xreal + ximag * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)));
		}
	}
}
namespace MathNet.Numerics.Providers.LinearAlgebra.ManagedReference
{
	internal class ManagedReferenceLinearAlgebraProvider : ILinearAlgebraProvider, ILinearAlgebraProvider<double>, ILinearAlgebraProvider<float>, ILinearAlgebraProvider<Complex>, ILinearAlgebraProvider<Complex32>
	{
		public virtual void AddVectorToScaledVector(Complex[] y, Complex alpha, Complex[] x, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (alpha.IsZero())
			{
				y.Copy(result);
				return;
			}
			if (alpha.IsOne())
			{
				CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						result[j] = y[j] + x[j];
					}
				});
				return;
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = y[i] + alpha * x[i];
				}
			});
		}

		public virtual void ScaleArray(Complex alpha, Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (alpha.IsZero())
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if (alpha.IsOne())
			{
				x.Copy(result);
				return;
			}
			CommonParallel.For(0, x.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = alpha * x[i];
				}
			});
		}

		public virtual void ConjugateArray(Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			CommonParallel.For(0, x.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i].Conjugate();
				}
			});
		}

		public virtual Complex DotProduct(Complex[] x, Complex[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Complex zero = Complex.Zero;
			for (int i = 0; i < y.Length; i++)
			{
				zero += y[i] * x[i];
			}
			return zero;
		}

		public virtual void AddArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] + y[i];
				}
			});
		}

		public virtual void SubtractArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] - y[i];
				}
			});
		}

		public virtual void PointWiseMultiplyArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] * y[i];
				}
			});
		}

		public virtual void PointWiseDivideArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(Complex[] x, Complex[] y, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = Complex.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, Complex[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += matrix[l * rows + m].Magnitude;
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(matrix[j * rows + k].Magnitude, num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += matrix[n * rows + num5].Magnitude;
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				Complex[] array = new Complex[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.ConjugateTranspose, 1.0, matrix, rows, columns, matrix, rows, columns, 0.0, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += array[i * rows + i].Magnitude;
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(Complex[] x, int rowsX, int columnsX, Complex[] y, int rowsY, int columnsY, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentException("x.Length != xRows * xColumns");
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentException("y.Length != yRows * yColumns");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentException("xColumns != yRows");
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentException("xRows * yColumns != result.Length");
			}
			Complex[] matrixA = ((x != result) ? x : ((Complex[])x.Clone()));
			Complex[] matrixB = ((y != result) ? y : ((Complex[])y.Clone()));
			Array.Clear(result, 0, result.Length);
			CacheObliviousMatrixMultiply(Transpose.DontTranspose, Transpose.DontTranspose, Complex.One, matrixA, 0, 0, matrixB, 0, 0, result, 0, 0, rowsX, columnsY, columnsX, rowsX, columnsY, columnsX, first: true);
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] a, int rowsA, int columnsA, Complex[] b, int rowsB, int columnsB, Complex beta, Complex[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			int num;
			int num2;
			int num3;
			if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
			{
				if (rowsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = rowsB;
				num3 = rowsA;
			}
			else if (transposeA > Transpose.DontTranspose)
			{
				if (rowsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = columnsB;
				num3 = rowsA;
			}
			else if (transposeB > Transpose.DontTranspose)
			{
				if (columnsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = rowsB;
				num3 = columnsA;
			}
			else
			{
				if (columnsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = columnsB;
				num3 = columnsA;
			}
			if (alpha.IsZero() && beta.IsZero())
			{
				Array.Clear(c, 0, c.Length);
				return;
			}
			Complex[] matrixA = ((a != c) ? a : ((Complex[])a.Clone()));
			Complex[] matrixB = ((b != c) ? b : ((Complex[])b.Clone()));
			if (beta.IsZero())
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (!beta.IsOne())
			{
				ScaleArray(beta, c, c);
			}
			if (!alpha.IsZero())
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, 0, 0, matrixB, 0, 0, c, 0, 0, num, num2, num3, num, num2, num3, first: true);
			}
		}

		private static void CacheObliviousMatrixMultiply(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] matrixA, int shiftArow, int shiftAcol, Complex[] matrixB, int shiftBrow, int shiftBcol, Complex[] result, int shiftCrow, int shiftCcol, int m, int n, int k, int constM, int constN, int constK, bool first)
		{
			if (m + n <= Control.ParallelizeOrder || m == 1 || n == 1 || k == 1)
			{
				if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
				{
					if (transposeA > Transpose.Transpose && transposeB > Transpose.Transpose)
					{
						for (int i = 0; i < m; i++)
						{
							int num = i + shiftArow;
							int num2 = i + shiftCrow;
							for (int j = 0; j < n; j++)
							{
								int num3 = j + shiftBcol;
								Complex zero = Complex.Zero;
								for (int l = 0; l < k; l++)
								{
									zero += matrixA[num * constK + l + shiftAcol].Conjugate() * matrixB[(l + shiftBrow) * constN + num3].Conjugate();
								}
								result[(j + shiftCcol) * constM + num2] += alpha * zero;
							}
						}
						return;
					}
					if (transposeA > Transpose.Transpose)
					{
						for (int num4 = 0; num4 < m; num4++)
						{
							int num5 = num4 + shiftArow;
							int num6 = num4 + shiftCrow;
							for (int num7 = 0; num7 < n; num7++)
							{
								int num8 = num7 + shiftBcol;
								Complex zero2 = Complex.Zero;
								for (int num9 = 0; num9 < k; num9++)
								{
									zero2 += matrixA[num5 * constK + num9 + shiftAcol].Conjugate() * matrixB[(num9 + shiftBrow) * constN + num8];
								}
								result[(num7 + shiftCcol) * constM + num6] += alpha * zero2;
							}
						}
						return;
					}
					if (transposeB > Transpose.Transpose)
					{
						for (int num10 = 0; num10 < m; num10++)
						{
							int num11 = num10 + shiftArow;
							int num12 = num10 + shiftCrow;
							for (int num13 = 0; num13 < n; num13++)
							{
								int num14 = num13 + shiftBcol;
								Complex zero3 = Complex.Zero;
								for (int num15 = 0; num15 < k; num15++)
								{
									zero3 += matrixA[num11 * constK + num15 + shiftAcol] * matrixB[(num15 + shiftBrow) * constN + num14].Conjugate();
								}
								result[(num13 + shiftCcol) * constM + num12] += alpha * zero3;
							}
						}
						return;
					}
					for (int num16 = 0; num16 < m; num16++)
					{
						int num17 = num16 + shiftArow;
						int num18 = num16 + shiftCrow;
						for (int num19 = 0; num19 < n; num19++)
						{
							int num20 = num19 + shiftBcol;
							Complex zero4 = Complex.Zero;
							for (int num21 = 0; num21 < k; num21++)
							{
								zero4 += matrixA[num17 * constK + num21 + shiftAcol] * matrixB[(num21 + shiftBrow) * constN + num20];
							}
							result[(num19 + shiftCcol) * constM + num18] += alpha * zero4;
						}
					}
					return;
				}
				if (transposeA > Transpose.DontTranspose)
				{
					if (transposeA > Transpose.Transpose)
					{
						for (int num22 = 0; num22 < m; num22++)
						{
							int num23 = num22 + shiftArow;
							int num24 = num22 + shiftCrow;
							for (int num25 = 0; num25 < n; num25++)
							{
								int num26 = num25 + shiftBcol;
								Complex zero5 = Complex.Zero;
								for (int num27 = 0; num27 < k; num27++)
								{
									zero5 += matrixA[num23 * constK + num27 + shiftAcol].Conjugate() * matrixB[num26 * constK + num27 + shiftBrow];
								}
								result[(num25 + shiftCcol) * constM + num24] += alpha * zero5;
							}
						}
						return;
					}
					for (int num28 = 0; num28 < m; num28++)
					{
						int num29 = num28 + shiftArow;
						int num30 = num28 + shiftCrow;
						for (int num31 = 0; num31 < n; num31++)
						{
							int num32 = num31 + shiftBcol;
							Complex zero6 = Complex.Zero;
							for (int num33 = 0; num33 < k; num33++)
							{
								zero6 += matrixA[num29 * constK + num33 + shiftAcol] * matrixB[num32 * constK + num33 + shiftBrow];
							}
							result[(num31 + shiftCcol) * constM + num30] += alpha * zero6;
						}
					}
					return;
				}
				if (transposeB > Transpose.DontTranspose)
				{
					if (transposeB > Transpose.Transpose)
					{
						for (int num34 = 0; num34 < m; num34++)
						{
							int num35 = num34 + shiftArow;
							int num36 = num34 + shiftCrow;
							for (int num37 = 0; num37 < n; num37++)
							{
								int num38 = num37 + shiftBcol;
								Complex zero7 = Complex.Zero;
								for (int num39 = 0; num39 < k; num39++)
								{
									zero7 += matrixA[(num39 + shiftAcol) * constM + num35] * matrixB[(num39 + shiftBrow) * constN + num38].Conjugate();
								}
								result[(num37 + shiftCcol) * constM + num36] += alpha * zero7;
							}
						}
						return;
					}
					for (int num40 = 0; num40 < m; num40++)
					{
						int num41 = num40 + shiftArow;
						int num42 = num40 + shiftCrow;
						for (int num43 = 0; num43 < n; num43++)
						{
							int num44 = num43 + shiftBcol;
							Complex zero8 = Complex.Zero;
							for (int num45 = 0; num45 < k; num45++)
							{
								zero8 += matrixA[(num45 + shiftAcol) * constM + num41] * matrixB[(num45 + shiftBrow) * constN + num44];
							}
							result[(num43 + shiftCcol) * constM + num42] += alpha * zero8;
						}
					}
					return;
				}
				for (int num46 = 0; num46 < m; num46++)
				{
					int num47 = num46 + shiftArow;
					int num48 = num46 + shiftCrow;
					for (int num49 = 0; num49 < n; num49++)
					{
						int num50 = num49 + shiftBcol;
						Complex zero9 = Complex.Zero;
						for (int num51 = 0; num51 < k; num51++)
						{
							zero9 += matrixA[(num51 + shiftAcol) * constM + num47] * matrixB[num50 * constK + num51 + shiftBrow];
						}
						result[(num49 + shiftCcol) * constM + num48] += alpha * zero9;
					}
				}
				return;
			}
			int m2 = m / 2;
			int n2 = n / 2;
			int k2 = k / 2;
			if (first)
			{
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				});
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
				});
			}
			else
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
			}
		}

		public virtual void LUFactor(Complex[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			Complex[] array = new Complex[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					Complex zero = Complex.Zero;
					for (int m = 0; m < num3; m++)
					{
						zero += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= zero);
				}
				int num4 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (array[n].Magnitude > array[num4].Magnitude)
					{
						num4 = n;
					}
				}
				if (num4 != j)
				{
					for (int num5 = 0; num5 < order; num5++)
					{
						int num6 = num5 * order;
						int num7 = num6 + num4;
						int num8 = num6 + j;
						Complex complex = data[num7];
						data[num7] = data[num8];
						data[num8] = complex;
					}
					ipiv[j] = num4;
				}
				if ((j < order) & (data[num2] != 0.0))
				{
					for (int num9 = j + 1; num9 < order; num9++)
					{
						data[num + num9] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(Complex[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Complex[] array = new Complex[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = Complex.One;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, Complex[] a, int order, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, Complex[] a, int order, int[] ipiv, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						Complex complex = b[num3];
						b[num3] = b[num4];
						b[num4] = complex;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num5 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num6 = m * order;
						b[l + num6] -= b[k + num6] * a[l + num5];
					}
				}
			}
			for (int num7 = order - 1; num7 >= 0; num7--)
			{
				int num8 = num7 + num7 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num7 + n * order] /= a[num8];
				}
				num8 = num7 * order;
				for (int num9 = 0; num9 < num7; num9++)
				{
					for (int num10 = 0; num10 < columnsOfB; num10++)
					{
						int num11 = num10 * order;
						b[num9 + num11] -= b[num7 + num11] * a[num9 + num8];
					}
				}
			}
		}

		public virtual void CholeskyFactor(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			Complex[] array = new Complex[order];
			for (int i = 0; i < order; i++)
			{
				Complex complex = a[i * order + i];
				if (!(complex.Real > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				complex = (array[i] = (a[i * order + i] = complex.SquareRoot()));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= complex;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0.0;
				}
			}
		}

		private static void DoCholeskyStep(Complex[] data, int rowDim, int firstCol, int colLimit, Complex[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				Complex complex = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * complex.Conjugate();
				}
			}
		}

		public virtual void CholeskySolve(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(Complex[] a, int orderA, Complex[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				Complex complex = b[num + i];
				for (int num2 = i - 1; num2 >= 0; num2--)
				{
					complex -= a[num2 * orderA + i] * b[num + num2];
				}
				b[num + i] = complex / a[i * orderA + i];
			}
			for (int num3 = orderA - 1; num3 >= 0; num3--)
			{
				Complex complex = b[num + num3];
				int num4 = num3 * orderA;
				for (int j = num3 + 1; j < orderA; j++)
				{
					complex -= a[num4 + j].Conjugate() * b[num + j];
				}
				b[num + num3] = complex / a[num4 + num3];
			}
		}

		public virtual void QRFactor(Complex[] r, int rowsR, int columnsR, Complex[] q, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			Complex[] work = ((columnsR > rowsR) ? new Complex[rowsR * rowsR] : new Complex[rowsR * columnsR]);
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = Complex.One;
				}
			});
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(Complex[] a, int rowsA, int columnsA, Complex[] r, Complex[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			Complex[] work = new Complex[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = Complex.One;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(Complex[] work, int workIndex, Complex[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				Complex zero = Complex.Zero;
				for (int j = rowStart; j < rowCount; j++)
				{
					zero += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart].Conjugate() * zero;
				}
			}
		}

		private static void GenerateColumn(Complex[] work, Complex[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num3 = tmp + l;
					work[num3 - row] = a[num3];
					a[num3] = Complex.Zero;
				}
			});
			Complex norm = Complex.Zero;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num2 = tmp + i;
				norm += (Complex)(work[num2].Magnitude * work[num2].Magnitude);
			}
			norm = norm.SquareRoot();
			if (row == rowCount - 1 || norm.Magnitude == 0.0)
			{
				a[num] = -work[tmp];
				work[tmp] = new Complex(2.0, 0.0).SquareRoot();
				return;
			}
			if (work[tmp].Magnitude != 0.0)
			{
				norm = norm.Magnitude * (work[tmp] / work[tmp].Magnitude);
			}
			a[num] = -norm;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] /= norm;
				}
			});
			work[tmp] += (Complex)1.0;
			Complex s = (1.0 / work[tmp]).SquareRoot();
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] = work[tmp + j].Conjugate() * s;
				}
			});
		}

		public virtual void QRSolve(Complex[] a, int rows, int columns, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			Complex[] tau = new Complex[rows * columns];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				Complex[] q = new Complex[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				Complex[] r = new Complex[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(Complex[] q, Complex[] r, int rowsA, int columnsA, Complex[] tau, Complex[] b, int columnsB, Complex[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			Complex[] sol = new Complex[b.Length];
			Array.Copy(b, 0, sol, 0, b.Length);
			Complex[] column = new Complex[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						Complex zero = Complex.Zero;
						for (int num9 = 0; num9 < rowsA; num9++)
						{
							zero += q[num8 + num9].Conjugate() * column[num9];
						}
						sol[jm + n] = zero;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, Complex[] a, int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			Complex[] array = new Complex[rowsA];
			Complex[] array2 = new Complex[columnsA];
			Complex[] array3 = new Complex[vt.Length];
			Complex[] array4 = new Complex[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					double num5 = 0.0;
					for (int j = i; j < rowsA; j++)
					{
						num5 += a[i * rowsA + j].Magnitude * a[i * rowsA + j].Magnitude;
					}
					array4[i] = Math.Sqrt(num5);
					if (array4[i] != 0.0)
					{
						if (a[i * rowsA + i] != 0.0)
						{
							array4[i] = array4[i].Magnitude * (a[i * rowsA + i] / a[i * rowsA + i].Magnitude);
						}
						for (int j = i; j < rowsA; j++)
						{
							a[i * rowsA + j] *= 1.0 / array4[i];
						}
						a[i * rowsA + i] = 1.0 + a[i * rowsA + i];
					}
					array4[i] = -array4[i];
				}
				for (int k = num4; k < columnsA; k++)
				{
					if (i < num && array4[i] != 0.0)
					{
						Complex complex = 0.0;
						for (int j = i; j < rowsA; j++)
						{
							complex += a[i * rowsA + j].Conjugate() * a[k * rowsA + j];
						}
						complex = -complex / a[i * rowsA + i];
						for (int l = i; l < rowsA; l++)
						{
							a[k * rowsA + l] += complex * a[i * rowsA + l];
						}
					}
					array2[k] = a[k * rowsA + i].Conjugate();
				}
				if (computeVectors && i < num)
				{
					for (int j = i; j < rowsA; j++)
					{
						u[i * rowsA + j] = a[i * rowsA + j];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				double num6 = 0.0;
				for (int j = num4; j < array2.Length; j++)
				{
					num6 += array2[j].Magnitude * array2[j].Magnitude;
				}
				array2[i] = Math.Sqrt(num6);
				if (array2[i] != 0.0)
				{
					if (array2[num4] != 0.0)
					{
						array2[i] = array2[i].Magnitude * (array2[num4] / array2[num4].Magnitude);
					}
					for (int j = num4; j < array2.Length; j++)
					{
						array2[j] *= 1.0 / array2[i];
					}
					array2[num4] = 1.0 + array2[num4];
				}
				array2[i] = -array2[i].Conjugate();
				if (num4 < rowsA && array2[i] != 0.0)
				{
					for (int j = num4; j < rowsA; j++)
					{
						array[j] = 0.0;
					}
					for (int k = num4; k < columnsA; k++)
					{
						for (int m = num4; m < rowsA; m++)
						{
							array[m] += array2[k] * a[k * rowsA + m];
						}
					}
					for (int k = num4; k < columnsA; k++)
					{
						Complex complex2 = (-array2[k] / array2[num4]).Conjugate();
						for (int n = num4; n < rowsA; n++)
						{
							a[k * rowsA + n] += complex2 * array[n];
						}
					}
				}
				if (computeVectors)
				{
					for (int j = num4; j < columnsA; j++)
					{
						array3[i * columnsA + j] = array2[j];
					}
				}
			}
			int num7 = Math.Min(columnsA, rowsA + 1);
			int num8 = num + 1;
			int num9 = num2 + 1;
			if (num < columnsA)
			{
				array4[num8 - 1] = a[(num8 - 1) * rowsA + (num8 - 1)];
			}
			if (rowsA < num7)
			{
				array4[num7 - 1] = 0.0;
			}
			if (num9 < num7)
			{
				array2[num9 - 1] = a[(num7 - 1) * rowsA + (num9 - 1)];
			}
			array2[num7 - 1] = 0.0;
			if (computeVectors)
			{
				for (int k = num8 - 1; k < rowsA; k++)
				{
					for (int j = 0; j < rowsA; j++)
					{
						u[k * rowsA + j] = 0.0;
					}
					u[k * rowsA + k] = 1.0;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if (array4[i] != 0.0)
					{
						for (int k = i + 1; k < rowsA; k++)
						{
							Complex complex = 0.0;
							for (int j = i; j < rowsA; j++)
							{
								complex += u[i * rowsA + j].Conjugate() * u[k * rowsA + j];
							}
							complex = -complex / u[i * rowsA + i];
							for (int num10 = i; num10 < rowsA; num10++)
							{
								u[k * rowsA + num10] += complex * u[i * rowsA + num10];
							}
						}
						for (int j = i; j < rowsA; j++)
						{
							u[i * rowsA + j] *= (Complex)(-1.0);
						}
						u[i * rowsA + i] = 1.0 + u[i * rowsA + i];
						for (int j = 0; j < i; j++)
						{
							u[i * rowsA + j] = 0.0;
						}
					}
					else
					{
						for (int j = 0; j < rowsA; j++)
						{
							u[i * rowsA + j] = 0.0;
						}
						u[i * rowsA + i] = 1.0;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && array2[i] != 0.0)
					{
						for (int k = num4; k < columnsA; k++)
						{
							Complex complex = 0.0;
							for (int j = num4; j < columnsA; j++)
							{
								complex += array3[i * columnsA + j].Conjugate() * array3[k * columnsA + j];
							}
							complex = -complex / array3[i * columnsA + num4];
							for (int num11 = i; num11 < columnsA; num11++)
							{
								array3[k * columnsA + num11] += complex * array3[i * columnsA + num11];
							}
						}
					}
					for (int j = 0; j < columnsA; j++)
					{
						array3[i * columnsA + j] = 0.0;
					}
					array3[i * columnsA + i] = 1.0;
				}
			}
			for (int j = 0; j < num7; j++)
			{
				Complex complex;
				Complex complex3;
				if (array4[j] != 0.0)
				{
					complex = array4[j].Magnitude;
					complex3 = array4[j] / complex;
					array4[j] = complex;
					if (j < num7 - 1)
					{
						array2[j] /= complex3;
					}
					if (computeVectors)
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[j * rowsA + k] *= complex3;
						}
					}
				}
				if (j == num7 - 1)
				{
					break;
				}
				if (array2[j] == 0.0)
				{
					continue;
				}
				complex = array2[j].Magnitude;
				complex3 = complex / array2[j];
				array2[j] = complex;
				array4[j + 1] *= complex3;
				if (computeVectors)
				{
					for (int k = 0; k < columnsA; k++)
					{
						array3[(j + 1) * columnsA + k] *= complex3;
					}
				}
			}
			int num12 = num7;
			int num13 = 0;
			while (num7 > 0)
			{
				if (num13 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num7 - 2; i >= 0; i--)
				{
					double num14 = array4[i].Magnitude + array4[i + 1].Magnitude;
					if ((num14 + array2[i].Magnitude).AlmostEqualRelative(num14, 15))
					{
						array2[i] = 0.0;
						break;
					}
				}
				int num15;
				if (i == num7 - 2)
				{
					num15 = 4;
				}
				else
				{
					int num16;
					for (num16 = num7 - 1; num16 > i; num16--)
					{
						double num14 = 0.0;
						if (num16 != num7 - 1)
						{
							num14 += array2[num16].Magnitude;
						}
						if (num16 != i + 1)
						{
							num14 += array2[num16 - 1].Magnitude;
						}
						if ((num14 + array4[num16].Magnitude).AlmostEqualRelative(num14, 15))
						{
							array4[num16] = 0.0;
							break;
						}
					}
					if (num16 == i)
					{
						num15 = 3;
					}
					else if (num16 == num7 - 1)
					{
						num15 = 1;
					}
					else
					{
						num15 = 2;
						i = num16;
					}
				}
				i++;
				double c;
				double s2;
				switch (num15)
				{
				case 1:
				{
					double db = array2[num7 - 2].Real;
					array2[num7 - 2] = 0.0;
					for (int num26 = i; num26 < num7 - 1; num26++)
					{
						int num17 = num7 - 2 - num26 + i;
						double da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						if (num17 != i)
						{
							db = (0.0 - s2) * array2[num17 - 1].Real;
							array2[num17 - 1] = c * array2[num17 - 1];
						}
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex complex9 = c * array3[num17 * columnsA + j] + s2 * array3[(num7 - 1) * columnsA + j];
								array3[(num7 - 1) * columnsA + j] = c * array3[(num7 - 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex9;
							}
						}
					}
					break;
				}
				case 2:
				{
					double db = array2[i - 1].Real;
					array2[i - 1] = 0.0;
					for (int num17 = i; num17 < num7; num17++)
					{
						double da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						db = (0.0 - s2) * array2[num17].Real;
						array2[num17] = c * array2[num17];
						if (computeVectors)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex complex6 = c * u[num17 * rowsA + j] + s2 * u[(i - 1) * rowsA + j];
								u[(i - 1) * rowsA + j] = c * u[(i - 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex6;
							}
						}
					}
					break;
				}
				case 3:
				{
					double val = 0.0;
					val = Math.Max(val, array4[num7 - 1].Magnitude);
					val = Math.Max(val, array4[num7 - 2].Magnitude);
					val = Math.Max(val, array2[num7 - 2].Magnitude);
					val = Math.Max(val, array4[i].Magnitude);
					val = Math.Max(val, array2[i].Magnitude);
					double num18 = array4[num7 - 1].Real / val;
					double num19 = array4[num7 - 2].Real / val;
					double num20 = array2[num7 - 2].Real / val;
					double num21 = array4[i].Real / val;
					double num22 = array2[i].Real / val;
					double num23 = ((num19 + num18) * (num19 - num18) + num20 * num20) / 2.0;
					double num24 = num18 * num20 * (num18 * num20);
					double num25 = 0.0;
					if (num23 != 0.0 || num24 != 0.0)
					{
						num25 = Math.Sqrt(num23 * num23 + num24);
						if (num23 < 0.0)
						{
							num25 = 0.0 - num25;
						}
						num25 = num24 / (num23 + num25);
					}
					double db = (num21 + num18) * (num21 - num18) + num25;
					double db2 = num21 * num22;
					for (int num17 = i; num17 < num7 - 1; num17++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num17 != i)
						{
							array2[num17 - 1] = db;
						}
						db = c * array4[num17].Real + s2 * array2[num17].Real;
						array2[num17] = c * array2[num17] - s2 * array4[num17];
						db2 = s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = c * array4[num17 + 1];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex complex7 = c * array3[num17 * columnsA + j] + s2 * array3[(num17 + 1) * columnsA + j];
								array3[(num17 + 1) * columnsA + j] = c * array3[(num17 + 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex7;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num17] = db;
						db = c * array2[num17].Real + s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = -(s2 * array2[num17]) + c * array4[num17 + 1];
						db2 = s2 * array2[num17 + 1].Real;
						array2[num17 + 1] = c * array2[num17 + 1];
						if (computeVectors && num17 < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex complex8 = c * u[num17 * rowsA + j] + s2 * u[(num17 + 1) * rowsA + j];
								u[(num17 + 1) * rowsA + j] = c * u[(num17 + 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex8;
							}
						}
					}
					array2[num7 - 2] = db;
					num13++;
					break;
				}
				case 4:
					if (array4[i].Real < 0.0)
					{
						array4[i] = -array4[i];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								array3[i * columnsA + j] *= (Complex)(-1.0);
							}
						}
					}
					for (; i != num12 - 1 && !(array4[i].Real >= array4[i + 1].Real); i++)
					{
						Complex complex = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = complex;
						if (computeVectors && i < columnsA)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex complex4 = array3[i * columnsA + j];
								array3[i * columnsA + j] = array3[(i + 1) * columnsA + j];
								array3[(i + 1) * columnsA + j] = complex4;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex complex5 = u[i * rowsA + j];
								u[i * rowsA + j] = u[(i + 1) * rowsA + j];
								u[(i + 1) * rowsA + j] = complex5;
							}
						}
					}
					num13 = 0;
					num7--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int j = 0; j < columnsA; j++)
				{
					for (int k = 0; k < columnsA; k++)
					{
						vt[k * columnsA + j] = array3[j * columnsA + k].Conjugate();
					}
				}
			}
			Array.Copy(array4, 0, s, 0, Math.Min(rowsA, columnsA));
		}

		public virtual void SvdSolve(Complex[] a, int rowsA, int columnsA, Complex[] b, int columnsB, Complex[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex[] s = new Complex[Math.Min(rowsA, columnsA)];
			Complex[] u = new Complex[rowsA * rowsA];
			Complex[] vt = new Complex[columnsA * columnsA];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt, Complex[] b, int columnsB, Complex[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			Complex[] array = new Complex[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					Complex zero = Complex.Zero;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							zero += u[j * rowsA + k].Conjugate() * b[i * rowsA + k];
						}
						zero /= s[j];
					}
					array[j] = zero;
				}
				for (int l = 0; l < columnsA; l++)
				{
					Complex zero2 = Complex.Zero;
					for (int m = 0; m < columnsA; m++)
					{
						zero2 += vt[l * columnsA + m].Conjugate() * array[m];
					}
					x[i * columnsA + l] = zero2;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, Complex[] matrix, Complex[] matrixEv, Complex[] vectorEv, Complex[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			Complex[] array = new Complex[matrix.Length];
			Array.Copy(matrix, 0, array, 0, matrix.Length);
			if (isSymmetric)
			{
				Complex[] tau = new Complex[order];
				double[] array2 = new double[order];
				double[] array3 = new double[order];
				ManagedLinearAlgebraProvider.SymmetricTridiagonalize(array, array2, array3, tau, order);
				ManagedLinearAlgebraProvider.SymmetricDiagonalize(matrixEv, array2, array3, order);
				ManagedLinearAlgebraProvider.SymmetricUntridiagonalize(matrixEv, array, tau, order);
				for (int i = 0; i < order; i++)
				{
					vectorEv[i] = new Complex(array2[i], array3[i]);
				}
			}
			else
			{
				ManagedLinearAlgebraProvider.NonsymmetricReduceToHessenberg(matrixEv, array, order);
				ManagedLinearAlgebraProvider.NonsymmetricReduceHessenberToRealSchur(vectorEv, matrixEv, array, order);
			}
			for (int j = 0; j < order; j++)
			{
				matrixD[j * order + j] = vectorEv[j];
			}
		}

		protected static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, Complex[] matrix, Complex[] row)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
			{
				for (int j = 0; j < numCols; j++)
				{
					row[j] = matrix[j * numRows + rowindx];
				}
				break;
			}
			case Transpose.ConjugateTranspose:
			{
				int num = rowindx * numCols;
				for (int i = 0; i < row.Length; i++)
				{
					row[i] = matrix[i + num].Conjugate();
				}
				break;
			}
			default:
				Array.Copy(matrix, rowindx * numCols, row, 0, numCols);
				break;
			}
		}

		protected static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, Complex[] matrix, Complex[] column)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
				Array.Copy(matrix, colindx * numRows, column, 0, numRows);
				break;
			case Transpose.ConjugateTranspose:
			{
				for (int j = 0; j < numRows; j++)
				{
					column[j] = matrix[j * numCols + colindx].Conjugate();
				}
				break;
			}
			default:
			{
				for (int i = 0; i < numRows; i++)
				{
					column[i] = matrix[i * numCols + colindx];
				}
				break;
			}
			}
		}

		public virtual void AddVectorToScaledVector(Complex32[] y, Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (alpha.IsZero())
			{
				y.Copy(result);
				return;
			}
			if (alpha.IsOne())
			{
				CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						result[j] = y[j] + x[j];
					}
				});
				return;
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = y[i] + alpha * x[i];
				}
			});
		}

		public virtual void ScaleArray(Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (alpha.IsZero())
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if (alpha.IsOne())
			{
				x.Copy(result);
				return;
			}
			CommonParallel.For(0, x.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = alpha * x[i];
				}
			});
		}

		public virtual void ConjugateArray(Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			CommonParallel.For(0, x.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i].Conjugate();
				}
			});
		}

		public virtual Complex32 DotProduct(Complex32[] x, Complex32[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Complex32 result = new Complex32(0f, 0f);
			for (int i = 0; i < y.Length; i++)
			{
				result += y[i] * x[i];
			}
			return result;
		}

		public virtual void AddArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] + y[i];
				}
			});
		}

		public virtual void SubtractArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] - y[i];
				}
			});
		}

		public virtual void PointWiseMultiplyArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] * y[i];
				}
			});
		}

		public virtual void PointWiseDivideArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(Complex32[] x, Complex32[] y, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = Complex32.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, Complex32[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += (double)matrix[l * rows + m].Magnitude;
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(matrix[j * rows + k].Magnitude, num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += matrix[n * rows + num5].Magnitude;
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				Complex32[] array = new Complex32[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.ConjugateTranspose, 1f, matrix, rows, columns, matrix, rows, columns, 0f, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += (double)array[i * rows + i].Magnitude;
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(Complex32[] x, int rowsX, int columnsX, Complex32[] y, int rowsY, int columnsY, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentException("x.Length != xRows * xColumns");
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentException("y.Length != yRows * yColumns");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentException("xColumns != yRows");
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentException("xRows * yColumns != result.Length");
			}
			Complex32[] matrixA = ((x != result) ? x : ((Complex32[])x.Clone()));
			Complex32[] matrixB = ((y != result) ? y : ((Complex32[])y.Clone()));
			Array.Clear(result, 0, result.Length);
			CacheObliviousMatrixMultiply(Transpose.DontTranspose, Transpose.DontTranspose, Complex32.One, matrixA, 0, 0, matrixB, 0, 0, result, 0, 0, rowsX, columnsY, columnsX, rowsX, columnsY, columnsX, first: true);
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] a, int rowsA, int columnsA, Complex32[] b, int rowsB, int columnsB, Complex32 beta, Complex32[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			int num;
			int num2;
			int num3;
			if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
			{
				if (rowsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = rowsB;
				num3 = rowsA;
			}
			else if (transposeA > Transpose.DontTranspose)
			{
				if (rowsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = columnsB;
				num3 = rowsA;
			}
			else if (transposeB > Transpose.DontTranspose)
			{
				if (columnsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = rowsB;
				num3 = columnsA;
			}
			else
			{
				if (columnsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = columnsB;
				num3 = columnsA;
			}
			if (alpha.IsZero() && beta.IsZero())
			{
				Array.Clear(c, 0, c.Length);
				return;
			}
			Complex32[] matrixA = ((a != c) ? a : ((Complex32[])a.Clone()));
			Complex32[] matrixB = ((b != c) ? b : ((Complex32[])b.Clone()));
			if (beta.IsZero())
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (!beta.IsOne())
			{
				ScaleArray(beta, c, c);
			}
			if (!alpha.IsZero())
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, 0, 0, matrixB, 0, 0, c, 0, 0, num, num2, num3, num, num2, num3, first: true);
			}
		}

		private static void CacheObliviousMatrixMultiply(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] matrixA, int shiftArow, int shiftAcol, Complex32[] matrixB, int shiftBrow, int shiftBcol, Complex32[] result, int shiftCrow, int shiftCcol, int m, int n, int k, int constM, int constN, int constK, bool first)
		{
			if (m + n <= Control.ParallelizeOrder || m == 1 || n == 1 || k == 1)
			{
				if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
				{
					if (transposeA > Transpose.Transpose && transposeB > Transpose.Transpose)
					{
						for (int i = 0; i < m; i++)
						{
							int num = i + shiftArow;
							int num2 = i + shiftCrow;
							for (int j = 0; j < n; j++)
							{
								int num3 = j + shiftBcol;
								Complex32 zero = Complex32.Zero;
								for (int l = 0; l < k; l++)
								{
									zero += matrixA[num * constK + l + shiftAcol].Conjugate() * matrixB[(l + shiftBrow) * constN + num3].Conjugate();
								}
								result[(j + shiftCcol) * constM + num2] += alpha * zero;
							}
						}
						return;
					}
					if (transposeA > Transpose.Transpose)
					{
						for (int num4 = 0; num4 < m; num4++)
						{
							int num5 = num4 + shiftArow;
							int num6 = num4 + shiftCrow;
							for (int num7 = 0; num7 < n; num7++)
							{
								int num8 = num7 + shiftBcol;
								Complex32 zero2 = Complex32.Zero;
								for (int num9 = 0; num9 < k; num9++)
								{
									zero2 += matrixA[num5 * constK + num9 + shiftAcol].Conjugate() * matrixB[(num9 + shiftBrow) * constN + num8];
								}
								result[(num7 + shiftCcol) * constM + num6] += alpha * zero2;
							}
						}
						return;
					}
					if (transposeB > Transpose.Transpose)
					{
						for (int num10 = 0; num10 < m; num10++)
						{
							int num11 = num10 + shiftArow;
							int num12 = num10 + shiftCrow;
							for (int num13 = 0; num13 < n; num13++)
							{
								int num14 = num13 + shiftBcol;
								Complex32 zero3 = Complex32.Zero;
								for (int num15 = 0; num15 < k; num15++)
								{
									zero3 += matrixA[num11 * constK + num15 + shiftAcol] * matrixB[(num15 + shiftBrow) * constN + num14].Conjugate();
								}
								result[(num13 + shiftCcol) * constM + num12] += alpha * zero3;
							}
						}
						return;
					}
					for (int num16 = 0; num16 < m; num16++)
					{
						int num17 = num16 + shiftArow;
						int num18 = num16 + shiftCrow;
						for (int num19 = 0; num19 < n; num19++)
						{
							int num20 = num19 + shiftBcol;
							Complex32 zero4 = Complex32.Zero;
							for (int num21 = 0; num21 < k; num21++)
							{
								zero4 += matrixA[num17 * constK + num21 + shiftAcol] * matrixB[(num21 + shiftBrow) * constN + num20];
							}
							result[(num19 + shiftCcol) * constM + num18] += alpha * zero4;
						}
					}
					return;
				}
				if (transposeA > Transpose.DontTranspose)
				{
					if (transposeA > Transpose.Transpose)
					{
						for (int num22 = 0; num22 < m; num22++)
						{
							int num23 = num22 + shiftArow;
							int num24 = num22 + shiftCrow;
							for (int num25 = 0; num25 < n; num25++)
							{
								int num26 = num25 + shiftBcol;
								Complex32 zero5 = Complex32.Zero;
								for (int num27 = 0; num27 < k; num27++)
								{
									zero5 += matrixA[num23 * constK + num27 + shiftAcol].Conjugate() * matrixB[num26 * constK + num27 + shiftBrow];
								}
								result[(num25 + shiftCcol) * constM + num24] += alpha * zero5;
							}
						}
						return;
					}
					for (int num28 = 0; num28 < m; num28++)
					{
						int num29 = num28 + shiftArow;
						int num30 = num28 + shiftCrow;
						for (int num31 = 0; num31 < n; num31++)
						{
							int num32 = num31 + shiftBcol;
							Complex32 zero6 = Complex32.Zero;
							for (int num33 = 0; num33 < k; num33++)
							{
								zero6 += matrixA[num29 * constK + num33 + shiftAcol] * matrixB[num32 * constK + num33 + shiftBrow];
							}
							result[(num31 + shiftCcol) * constM + num30] += alpha * zero6;
						}
					}
					return;
				}
				if (transposeB > Transpose.DontTranspose)
				{
					if (transposeB > Transpose.Transpose)
					{
						for (int num34 = 0; num34 < m; num34++)
						{
							int num35 = num34 + shiftArow;
							int num36 = num34 + shiftCrow;
							for (int num37 = 0; num37 < n; num37++)
							{
								int num38 = num37 + shiftBcol;
								Complex32 zero7 = Complex32.Zero;
								for (int num39 = 0; num39 < k; num39++)
								{
									zero7 += matrixA[(num39 + shiftAcol) * constM + num35] * matrixB[(num39 + shiftBrow) * constN + num38].Conjugate();
								}
								result[(num37 + shiftCcol) * constM + num36] += alpha * zero7;
							}
						}
						return;
					}
					for (int num40 = 0; num40 < m; num40++)
					{
						int num41 = num40 + shiftArow;
						int num42 = num40 + shiftCrow;
						for (int num43 = 0; num43 < n; num43++)
						{
							int num44 = num43 + shiftBcol;
							Complex32 zero8 = Complex32.Zero;
							for (int num45 = 0; num45 < k; num45++)
							{
								zero8 += matrixA[(num45 + shiftAcol) * constM + num41] * matrixB[(num45 + shiftBrow) * constN + num44];
							}
							result[(num43 + shiftCcol) * constM + num42] += alpha * zero8;
						}
					}
					return;
				}
				for (int num46 = 0; num46 < m; num46++)
				{
					int num47 = num46 + shiftArow;
					int num48 = num46 + shiftCrow;
					for (int num49 = 0; num49 < n; num49++)
					{
						int num50 = num49 + shiftBcol;
						Complex32 zero9 = Complex32.Zero;
						for (int num51 = 0; num51 < k; num51++)
						{
							zero9 += matrixA[(num51 + shiftAcol) * constM + num47] * matrixB[num50 * constK + num51 + shiftBrow];
						}
						result[(num49 + shiftCcol) * constM + num48] += alpha * zero9;
					}
				}
				return;
			}
			int m2 = m / 2;
			int n2 = n / 2;
			int k2 = k / 2;
			if (first)
			{
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				});
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
				});
			}
			else
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
			}
		}

		public virtual void LUFactor(Complex32[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			Complex32[] array = new Complex32[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					Complex32 zero = Complex32.Zero;
					for (int m = 0; m < num3; m++)
					{
						zero += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= zero);
				}
				int num4 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (array[n].Magnitude > array[num4].Magnitude)
					{
						num4 = n;
					}
				}
				if (num4 != j)
				{
					for (int num5 = 0; num5 < order; num5++)
					{
						int num6 = num5 * order;
						int num7 = num6 + num4;
						int num8 = num6 + j;
						Complex32 complex = data[num7];
						data[num7] = data[num8];
						data[num8] = complex;
					}
					ipiv[j] = num4;
				}
				if ((j < order) & (data[num2] != 0f))
				{
					for (int num9 = j + 1; num9 < order; num9++)
					{
						data[num + num9] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(Complex32[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Complex32[] array = new Complex32[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = Complex32.One;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, Complex32[] a, int order, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, Complex32[] a, int order, int[] ipiv, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						Complex32 complex = b[num3];
						b[num3] = b[num4];
						b[num4] = complex;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num5 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num6 = m * order;
						b[l + num6] -= b[k + num6] * a[l + num5];
					}
				}
			}
			for (int num7 = order - 1; num7 >= 0; num7--)
			{
				int num8 = num7 + num7 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num7 + n * order] /= a[num8];
				}
				num8 = num7 * order;
				for (int num9 = 0; num9 < num7; num9++)
				{
					for (int num10 = 0; num10 < columnsOfB; num10++)
					{
						int num11 = num10 * order;
						b[num9 + num11] -= b[num7 + num11] * a[num9 + num8];
					}
				}
			}
		}

		public virtual void CholeskyFactor(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			Complex32[] array = new Complex32[order];
			for (int i = 0; i < order; i++)
			{
				Complex32 complex = a[i * order + i];
				if (!((double)complex.Real > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				complex = (array[i] = (a[i * order + i] = complex.SquareRoot()));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= complex;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0f;
				}
			}
		}

		private static void DoCholeskyStep(Complex32[] data, int rowDim, int firstCol, int colLimit, Complex32[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				Complex32 complex = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * complex.Conjugate();
				}
			}
		}

		public virtual void CholeskySolve(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(Complex32[] a, int orderA, Complex32[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				Complex32 complex = b[num + i];
				for (int num2 = i - 1; num2 >= 0; num2--)
				{
					complex -= a[num2 * orderA + i] * b[num + num2];
				}
				b[num + i] = complex / a[i * orderA + i];
			}
			for (int num3 = orderA - 1; num3 >= 0; num3--)
			{
				Complex32 complex = b[num + num3];
				int num4 = num3 * orderA;
				for (int j = num3 + 1; j < orderA; j++)
				{
					complex -= a[num4 + j].Conjugate() * b[num + j];
				}
				b[num + num3] = complex / a[num4 + num3];
			}
		}

		public virtual void QRFactor(Complex32[] r, int rowsR, int columnsR, Complex32[] q, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			Complex32[] work = ((columnsR > rowsR) ? new Complex32[rowsR * rowsR] : new Complex32[rowsR * columnsR]);
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = Complex32.One;
				}
			});
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(Complex32[] a, int rowsA, int columnsA, Complex32[] r, Complex32[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			Complex32[] work = new Complex32[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = Complex32.One;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(Complex32[] work, int workIndex, Complex32[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				Complex32 zero = Complex32.Zero;
				for (int j = rowStart; j < rowCount; j++)
				{
					zero += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart].Conjugate() * zero;
				}
			}
		}

		private static void GenerateColumn(Complex32[] work, Complex32[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num3 = tmp + l;
					work[num3 - row] = a[num3];
					a[num3] = Complex32.Zero;
				}
			});
			Complex32 norm = Complex32.Zero;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num2 = tmp + i;
				norm += work[num2].Magnitude * work[num2].Magnitude;
			}
			norm = norm.SquareRoot();
			if (row == rowCount - 1 || norm.Magnitude == 0f)
			{
				a[num] = -work[tmp];
				work[tmp] = new Complex32(2f, 0f).SquareRoot();
				return;
			}
			if (work[tmp].Magnitude != 0f)
			{
				norm = norm.Magnitude * (work[tmp] / work[tmp].Magnitude);
			}
			a[num] = -norm;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] /= norm;
				}
			});
			work[tmp] += 1f;
			Complex32 s = (1f / work[tmp]).SquareRoot();
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] = work[tmp + j].Conjugate() * s;
				}
			});
		}

		public virtual void QRSolve(Complex32[] a, int rows, int columns, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			Complex32[] tau = new Complex32[rows * columns];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				Complex32[] q = new Complex32[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				Complex32[] r = new Complex32[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(Complex32[] q, Complex32[] r, int rowsA, int columnsA, Complex32[] tau, Complex32[] b, int columnsB, Complex32[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			Complex32[] sol = new Complex32[b.Length];
			Array.Copy(b, 0, sol, 0, b.Length);
			Complex32[] column = new Complex32[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						Complex32 zero = Complex32.Zero;
						for (int num9 = 0; num9 < rowsA; num9++)
						{
							zero += q[num8 + num9].Conjugate() * column[num9];
						}
						sol[jm + n] = zero;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, Complex32[] a, int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			Complex32[] array = new Complex32[rowsA];
			Complex32[] array2 = new Complex32[columnsA];
			Complex32[] array3 = new Complex32[vt.Length];
			Complex32[] array4 = new Complex32[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					float num5 = 0f;
					for (int j = i; j < rowsA; j++)
					{
						num5 += a[i * rowsA + j].Magnitude * a[i * rowsA + j].Magnitude;
					}
					array4[i] = (float)Math.Sqrt(num5);
					if (array4[i] != 0f)
					{
						if (a[i * rowsA + i] != 0f)
						{
							array4[i] = array4[i].Magnitude * (a[i * rowsA + i] / a[i * rowsA + i].Magnitude);
						}
						for (int j = i; j < rowsA; j++)
						{
							a[i * rowsA + j] *= 1f / array4[i];
						}
						a[i * rowsA + i] = 1f + a[i * rowsA + i];
					}
					array4[i] = -array4[i];
				}
				for (int k = num4; k < columnsA; k++)
				{
					if (i < num && array4[i] != 0f)
					{
						Complex32 complex = 0f;
						for (int j = i; j < rowsA; j++)
						{
							complex += a[i * rowsA + j].Conjugate() * a[k * rowsA + j];
						}
						complex = -complex / a[i * rowsA + i];
						for (int l = i; l < rowsA; l++)
						{
							a[k * rowsA + l] += complex * a[i * rowsA + l];
						}
					}
					array2[k] = a[k * rowsA + i].Conjugate();
				}
				if (computeVectors && i < num)
				{
					for (int j = i; j < rowsA; j++)
					{
						u[i * rowsA + j] = a[i * rowsA + j];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				float num6 = 0f;
				for (int j = num4; j < array2.Length; j++)
				{
					num6 += array2[j].Magnitude * array2[j].Magnitude;
				}
				array2[i] = (float)Math.Sqrt(num6);
				if (array2[i] != 0f)
				{
					if (array2[num4] != 0f)
					{
						array2[i] = array2[i].Magnitude * (array2[num4] / array2[num4].Magnitude);
					}
					for (int j = num4; j < array2.Length; j++)
					{
						array2[j] *= 1f / array2[i];
					}
					array2[num4] = 1f + array2[num4];
				}
				array2[i] = -array2[i].Conjugate();
				if (num4 < rowsA && array2[i] != 0f)
				{
					for (int j = num4; j < rowsA; j++)
					{
						array[j] = 0f;
					}
					for (int k = num4; k < columnsA; k++)
					{
						for (int m = num4; m < rowsA; m++)
						{
							array[m] += array2[k] * a[k * rowsA + m];
						}
					}
					for (int k = num4; k < columnsA; k++)
					{
						Complex32 complex2 = (-array2[k] / array2[num4]).Conjugate();
						for (int n = num4; n < rowsA; n++)
						{
							a[k * rowsA + n] += complex2 * array[n];
						}
					}
				}
				if (computeVectors)
				{
					for (int j = num4; j < columnsA; j++)
					{
						array3[i * columnsA + j] = array2[j];
					}
				}
			}
			int num7 = Math.Min(columnsA, rowsA + 1);
			int num8 = num + 1;
			int num9 = num2 + 1;
			if (num < columnsA)
			{
				array4[num8 - 1] = a[(num8 - 1) * rowsA + (num8 - 1)];
			}
			if (rowsA < num7)
			{
				array4[num7 - 1] = 0f;
			}
			if (num9 < num7)
			{
				array2[num9 - 1] = a[(num7 - 1) * rowsA + (num9 - 1)];
			}
			array2[num7 - 1] = 0f;
			if (computeVectors)
			{
				for (int k = num8 - 1; k < rowsA; k++)
				{
					for (int j = 0; j < rowsA; j++)
					{
						u[k * rowsA + j] = 0f;
					}
					u[k * rowsA + k] = 1f;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if (array4[i] != 0f)
					{
						for (int k = i + 1; k < rowsA; k++)
						{
							Complex32 complex = 0f;
							for (int j = i; j < rowsA; j++)
							{
								complex += u[i * rowsA + j].Conjugate() * u[k * rowsA + j];
							}
							complex = -complex / u[i * rowsA + i];
							for (int num10 = i; num10 < rowsA; num10++)
							{
								u[k * rowsA + num10] += complex * u[i * rowsA + num10];
							}
						}
						for (int j = i; j < rowsA; j++)
						{
							u[i * rowsA + j] *= -1f;
						}
						u[i * rowsA + i] = 1f + u[i * rowsA + i];
						for (int j = 0; j < i; j++)
						{
							u[i * rowsA + j] = 0f;
						}
					}
					else
					{
						for (int j = 0; j < rowsA; j++)
						{
							u[i * rowsA + j] = 0f;
						}
						u[i * rowsA + i] = 1f;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && array2[i] != 0f)
					{
						for (int k = num4; k < columnsA; k++)
						{
							Complex32 complex = 0f;
							for (int j = num4; j < columnsA; j++)
							{
								complex += array3[i * columnsA + j].Conjugate() * array3[k * columnsA + j];
							}
							complex = -complex / array3[i * columnsA + num4];
							for (int num11 = i; num11 < columnsA; num11++)
							{
								array3[k * columnsA + num11] += complex * array3[i * columnsA + num11];
							}
						}
					}
					for (int j = 0; j < columnsA; j++)
					{
						array3[i * columnsA + j] = 0f;
					}
					array3[i * columnsA + i] = 1f;
				}
			}
			for (int j = 0; j < num7; j++)
			{
				Complex32 complex;
				Complex32 complex3;
				if (array4[j] != 0f)
				{
					complex = array4[j].Magnitude;
					complex3 = array4[j] / complex;
					array4[j] = complex;
					if (j < num7 - 1)
					{
						array2[j] /= complex3;
					}
					if (computeVectors)
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[j * rowsA + k] *= complex3;
						}
					}
				}
				if (j == num7 - 1)
				{
					break;
				}
				if (array2[j] == 0f)
				{
					continue;
				}
				complex = array2[j].Magnitude;
				complex3 = complex / array2[j];
				array2[j] = complex;
				array4[j + 1] *= complex3;
				if (computeVectors)
				{
					for (int k = 0; k < columnsA; k++)
					{
						array3[(j + 1) * columnsA + k] *= complex3;
					}
				}
			}
			int num12 = num7;
			int num13 = 0;
			while (num7 > 0)
			{
				if (num13 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num7 - 2; i >= 0; i--)
				{
					float num14 = array4[i].Magnitude + array4[i + 1].Magnitude;
					if ((num14 + array2[i].Magnitude).AlmostEqualRelative(num14, 7))
					{
						array2[i] = 0f;
						break;
					}
				}
				int num15;
				if (i == num7 - 2)
				{
					num15 = 4;
				}
				else
				{
					int num16;
					for (num16 = num7 - 1; num16 > i; num16--)
					{
						float num14 = 0f;
						if (num16 != num7 - 1)
						{
							num14 += array2[num16].Magnitude;
						}
						if (num16 != i + 1)
						{
							num14 += array2[num16 - 1].Magnitude;
						}
						if ((num14 + array4[num16].Magnitude).AlmostEqualRelative(num14, 7))
						{
							array4[num16] = 0f;
							break;
						}
					}
					if (num16 == i)
					{
						num15 = 3;
					}
					else if (num16 == num7 - 1)
					{
						num15 = 1;
					}
					else
					{
						num15 = 2;
						i = num16;
					}
				}
				i++;
				float c;
				float s2;
				switch (num15)
				{
				case 1:
				{
					float db = array2[num7 - 2].Real;
					array2[num7 - 2] = 0f;
					for (int num26 = i; num26 < num7 - 1; num26++)
					{
						int num17 = num7 - 2 - num26 + i;
						float da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						if (num17 != i)
						{
							db = (0f - s2) * array2[num17 - 1].Real;
							array2[num17 - 1] = c * array2[num17 - 1];
						}
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex32 complex9 = c * array3[num17 * columnsA + j] + s2 * array3[(num7 - 1) * columnsA + j];
								array3[(num7 - 1) * columnsA + j] = c * array3[(num7 - 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex9;
							}
						}
					}
					break;
				}
				case 2:
				{
					float db = array2[i - 1].Real;
					array2[i - 1] = 0f;
					for (int num17 = i; num17 < num7; num17++)
					{
						float da = array4[num17].Real;
						Drotg(ref da, ref db, out c, out s2);
						array4[num17] = da;
						db = (0f - s2) * array2[num17].Real;
						array2[num17] = c * array2[num17];
						if (computeVectors)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex32 complex6 = c * u[num17 * rowsA + j] + s2 * u[(i - 1) * rowsA + j];
								u[(i - 1) * rowsA + j] = c * u[(i - 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex6;
							}
						}
					}
					break;
				}
				case 3:
				{
					float val = 0f;
					val = Math.Max(val, array4[num7 - 1].Magnitude);
					val = Math.Max(val, array4[num7 - 2].Magnitude);
					val = Math.Max(val, array2[num7 - 2].Magnitude);
					val = Math.Max(val, array4[i].Magnitude);
					val = Math.Max(val, array2[i].Magnitude);
					float num18 = array4[num7 - 1].Real / val;
					float num19 = array4[num7 - 2].Real / val;
					float num20 = array2[num7 - 2].Real / val;
					float num21 = array4[i].Real / val;
					float num22 = array2[i].Real / val;
					float num23 = ((num19 + num18) * (num19 - num18) + num20 * num20) / 2f;
					float num24 = num18 * num20 * (num18 * num20);
					float num25 = 0f;
					if (num23 != 0f || num24 != 0f)
					{
						num25 = (float)Math.Sqrt(num23 * num23 + num24);
						if (num23 < 0f)
						{
							num25 = 0f - num25;
						}
						num25 = num24 / (num23 + num25);
					}
					float db = (num21 + num18) * (num21 - num18) + num25;
					float db2 = num21 * num22;
					for (int num17 = i; num17 < num7 - 1; num17++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num17 != i)
						{
							array2[num17 - 1] = db;
						}
						db = c * array4[num17].Real + s2 * array2[num17].Real;
						array2[num17] = c * array2[num17] - s2 * array4[num17];
						db2 = s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = c * array4[num17 + 1];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex32 complex7 = c * array3[num17 * columnsA + j] + s2 * array3[(num17 + 1) * columnsA + j];
								array3[(num17 + 1) * columnsA + j] = c * array3[(num17 + 1) * columnsA + j] - s2 * array3[num17 * columnsA + j];
								array3[num17 * columnsA + j] = complex7;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num17] = db;
						db = c * array2[num17].Real + s2 * array4[num17 + 1].Real;
						array4[num17 + 1] = -(s2 * array2[num17]) + c * array4[num17 + 1];
						db2 = s2 * array2[num17 + 1].Real;
						array2[num17 + 1] = c * array2[num17 + 1];
						if (computeVectors && num17 < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex32 complex8 = c * u[num17 * rowsA + j] + s2 * u[(num17 + 1) * rowsA + j];
								u[(num17 + 1) * rowsA + j] = c * u[(num17 + 1) * rowsA + j] - s2 * u[num17 * rowsA + j];
								u[num17 * rowsA + j] = complex8;
							}
						}
					}
					array2[num7 - 2] = db;
					num13++;
					break;
				}
				case 4:
					if (array4[i].Real < 0f)
					{
						array4[i] = -array4[i];
						if (computeVectors)
						{
							for (int j = 0; j < columnsA; j++)
							{
								array3[i * columnsA + j] *= -1f;
							}
						}
					}
					for (; i != num12 - 1 && !(array4[i].Real >= array4[i + 1].Real); i++)
					{
						Complex32 complex = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = complex;
						if (computeVectors && i < columnsA)
						{
							for (int j = 0; j < columnsA; j++)
							{
								Complex32 complex4 = array3[i * columnsA + j];
								array3[i * columnsA + j] = array3[(i + 1) * columnsA + j];
								array3[(i + 1) * columnsA + j] = complex4;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int j = 0; j < rowsA; j++)
							{
								Complex32 complex5 = u[i * rowsA + j];
								u[i * rowsA + j] = u[(i + 1) * rowsA + j];
								u[(i + 1) * rowsA + j] = complex5;
							}
						}
					}
					num13 = 0;
					num7--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int j = 0; j < columnsA; j++)
				{
					for (int k = 0; k < columnsA; k++)
					{
						vt[k * columnsA + j] = array3[j * columnsA + k].Conjugate();
					}
				}
			}
			Array.Copy(array4, 0, s, 0, Math.Min(rowsA, columnsA));
		}

		public virtual void SvdSolve(Complex32[] a, int rowsA, int columnsA, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex32[] s = new Complex32[Math.Min(rowsA, columnsA)];
			Complex32[] u = new Complex32[rowsA * rowsA];
			Complex32[] vt = new Complex32[columnsA * columnsA];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			Complex32[] array = new Complex32[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					Complex32 zero = Complex32.Zero;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							zero += u[j * rowsA + k].Conjugate() * b[i * rowsA + k];
						}
						zero /= s[j];
					}
					array[j] = zero;
				}
				for (int l = 0; l < columnsA; l++)
				{
					Complex32 zero2 = Complex32.Zero;
					for (int m = 0; m < columnsA; m++)
					{
						zero2 += vt[l * columnsA + m].Conjugate() * array[m];
					}
					x[i * columnsA + l] = zero2;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, Complex32[] matrix, Complex32[] matrixEv, Complex[] vectorEv, Complex32[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			Complex32[] array = new Complex32[matrix.Length];
			Array.Copy(matrix, 0, array, 0, matrix.Length);
			if (isSymmetric)
			{
				Complex32[] tau = new Complex32[order];
				float[] array2 = new float[order];
				float[] array3 = new float[order];
				ManagedLinearAlgebraProvider.SymmetricTridiagonalize(array, array2, array3, tau, order);
				ManagedLinearAlgebraProvider.SymmetricDiagonalize(matrixEv, array2, array3, order);
				ManagedLinearAlgebraProvider.SymmetricUntridiagonalize(matrixEv, array, tau, order);
				for (int i = 0; i < order; i++)
				{
					vectorEv[i] = new Complex(array2[i], array3[i]);
					matrixD[i * order + i] = new Complex32(array2[i], array3[i]);
				}
			}
			else
			{
				Complex32[] array4 = new Complex32[order];
				ManagedLinearAlgebraProvider.NonsymmetricReduceToHessenberg(matrixEv, array, order);
				ManagedLinearAlgebraProvider.NonsymmetricReduceHessenberToRealSchur(array4, matrixEv, array, order);
				for (int j = 0; j < order; j++)
				{
					vectorEv[j] = new Complex(array4[j].Real, array4[j].Imaginary);
					matrixD[j * order + j] = array4[j];
				}
			}
		}

		protected static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, Complex32[] matrix, Complex32[] row)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
			{
				for (int j = 0; j < numCols; j++)
				{
					row[j] = matrix[j * numRows + rowindx];
				}
				break;
			}
			case Transpose.ConjugateTranspose:
			{
				int num = rowindx * numCols;
				for (int i = 0; i < row.Length; i++)
				{
					row[i] = matrix[i + num].Conjugate();
				}
				break;
			}
			default:
				Array.Copy(matrix, rowindx * numCols, row, 0, numCols);
				break;
			}
		}

		protected static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, Complex32[] matrix, Complex32[] column)
		{
			switch (transpose)
			{
			case Transpose.DontTranspose:
				Array.Copy(matrix, colindx * numRows, column, 0, numRows);
				break;
			case Transpose.ConjugateTranspose:
			{
				for (int j = 0; j < numRows; j++)
				{
					column[j] = matrix[j * numCols + colindx].Conjugate();
				}
				break;
			}
			default:
			{
				for (int i = 0; i < numRows; i++)
				{
					column[i] = matrix[i * numCols + colindx];
				}
				break;
			}
			}
		}

		public virtual bool IsAvailable()
		{
			return true;
		}

		public virtual void InitializeVerify()
		{
		}

		public virtual void FreeResources()
		{
		}

		public override string ToString()
		{
			return "Managed";
		}

		public virtual void AddVectorToScaledVector(double[] y, double alpha, double[] x, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (alpha == 0.0)
			{
				y.Copy(result);
				return;
			}
			if (alpha == 1.0)
			{
				CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						result[j] = y[j] + x[j];
					}
				});
				return;
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = y[i] + alpha * x[i];
				}
			});
		}

		public virtual void ScaleArray(double alpha, double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (alpha == 0.0)
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if (alpha == 1.0)
			{
				x.Copy(result);
				return;
			}
			CommonParallel.For(0, x.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = alpha * x[i];
				}
			});
		}

		public virtual void ConjugateArray(double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				x.CopyTo(result, 0);
			}
		}

		public virtual double DotProduct(double[] x, double[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double num = 0.0;
			for (int i = 0; i < y.Length; i++)
			{
				num += y[i] * x[i];
			}
			return num;
		}

		public virtual void AddArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] + y[i];
				}
			});
		}

		public virtual void SubtractArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] - y[i];
				}
			});
		}

		public virtual void PointWiseMultiplyArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] * y[i];
				}
			});
		}

		public virtual void PointWiseDivideArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(double[] x, double[] y, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = Math.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, double[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += Math.Abs(matrix[l * rows + m]);
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(Math.Abs(matrix[j * rows + k]), num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += Math.Abs(matrix[n * rows + num5]);
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				double[] array = new double[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.Transpose, 1.0, matrix, rows, columns, matrix, rows, columns, 0.0, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += Math.Abs(array[i * rows + i]);
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(double[] x, int rowsX, int columnsX, double[] y, int rowsY, int columnsY, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentException("x.Length != xRows * xColumns");
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentException("y.Length != yRows * yColumns");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentException("xColumns != yRows");
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentException("xRows * yColumns != result.Length");
			}
			double[] matrixA = ((x != result) ? x : ((double[])x.Clone()));
			double[] matrixB = ((y != result) ? y : ((double[])y.Clone()));
			Array.Clear(result, 0, result.Length);
			CacheObliviousMatrixMultiply(Transpose.DontTranspose, Transpose.DontTranspose, 1.0, matrixA, 0, 0, matrixB, 0, 0, result, 0, 0, rowsX, columnsY, columnsX, rowsX, columnsY, columnsX, first: true);
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, double alpha, double[] a, int rowsA, int columnsA, double[] b, int rowsB, int columnsB, double beta, double[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			int num;
			int num2;
			int num3;
			if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
			{
				if (rowsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = rowsB;
				num3 = rowsA;
			}
			else if (transposeA > Transpose.DontTranspose)
			{
				if (rowsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = columnsB;
				num3 = rowsA;
			}
			else if (transposeB > Transpose.DontTranspose)
			{
				if (columnsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = rowsB;
				num3 = columnsA;
			}
			else
			{
				if (columnsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = columnsB;
				num3 = columnsA;
			}
			if (alpha == 0.0 && beta == 0.0)
			{
				Array.Clear(c, 0, c.Length);
				return;
			}
			double[] matrixA = ((a != c) ? a : ((double[])a.Clone()));
			double[] matrixB = ((b != c) ? b : ((double[])b.Clone()));
			if (beta == 0.0)
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (beta != 1.0)
			{
				ScaleArray(beta, c, c);
			}
			if (alpha != 0.0)
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, 0, 0, matrixB, 0, 0, c, 0, 0, num, num2, num3, num, num2, num3, first: true);
			}
		}

		private static void CacheObliviousMatrixMultiply(Transpose transposeA, Transpose transposeB, double alpha, double[] matrixA, int shiftArow, int shiftAcol, double[] matrixB, int shiftBrow, int shiftBcol, double[] result, int shiftCrow, int shiftCcol, int m, int n, int k, int constM, int constN, int constK, bool first)
		{
			if (m + n <= Control.ParallelizeOrder || m == 1 || n == 1 || k == 1)
			{
				if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
				{
					for (int i = 0; i < m; i++)
					{
						int num = i + shiftArow;
						int num2 = i + shiftCrow;
						for (int j = 0; j < n; j++)
						{
							int num3 = j + shiftBcol;
							double num4 = 0.0;
							for (int l = 0; l < k; l++)
							{
								num4 += matrixA[num * constK + l + shiftAcol] * matrixB[(l + shiftBrow) * constN + num3];
							}
							result[(j + shiftCcol) * constM + num2] += alpha * num4;
						}
					}
					return;
				}
				if (transposeA > Transpose.DontTranspose)
				{
					for (int num5 = 0; num5 < m; num5++)
					{
						int num6 = num5 + shiftArow;
						int num7 = num5 + shiftCrow;
						for (int num8 = 0; num8 < n; num8++)
						{
							int num9 = num8 + shiftBcol;
							double num10 = 0.0;
							for (int num11 = 0; num11 < k; num11++)
							{
								num10 += matrixA[num6 * constK + num11 + shiftAcol] * matrixB[num9 * constK + num11 + shiftBrow];
							}
							result[(num8 + shiftCcol) * constM + num7] += alpha * num10;
						}
					}
					return;
				}
				if (transposeB > Transpose.DontTranspose)
				{
					for (int num12 = 0; num12 < m; num12++)
					{
						int num13 = num12 + shiftArow;
						int num14 = num12 + shiftCrow;
						for (int num15 = 0; num15 < n; num15++)
						{
							int num16 = num15 + shiftBcol;
							double num17 = 0.0;
							for (int num18 = 0; num18 < k; num18++)
							{
								num17 += matrixA[(num18 + shiftAcol) * constM + num13] * matrixB[(num18 + shiftBrow) * constN + num16];
							}
							result[(num15 + shiftCcol) * constM + num14] += alpha * num17;
						}
					}
					return;
				}
				for (int num19 = 0; num19 < m; num19++)
				{
					int num20 = num19 + shiftArow;
					int num21 = num19 + shiftCrow;
					for (int num22 = 0; num22 < n; num22++)
					{
						int num23 = num22 + shiftBcol;
						double num24 = 0.0;
						for (int num25 = 0; num25 < k; num25++)
						{
							num24 += matrixA[(num25 + shiftAcol) * constM + num20] * matrixB[num23 * constK + num25 + shiftBrow];
						}
						result[(num22 + shiftCcol) * constM + num21] += alpha * num24;
					}
				}
				return;
			}
			int m2 = m / 2;
			int n2 = n / 2;
			int k2 = k / 2;
			if (first)
			{
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				});
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
				});
			}
			else
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
			}
		}

		public virtual void LUFactor(double[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			double[] array = new double[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					double num4 = 0.0;
					for (int m = 0; m < num3; m++)
					{
						num4 += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= num4);
				}
				int num5 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (Math.Abs(array[n]) > Math.Abs(array[num5]))
					{
						num5 = n;
					}
				}
				if (num5 != j)
				{
					for (int num6 = 0; num6 < order; num6++)
					{
						int num7 = num6 * order;
						int num8 = num7 + num5;
						int num9 = num7 + j;
						double num10 = data[num8];
						data[num8] = data[num9];
						data[num9] = num10;
					}
					ipiv[j] = num5;
				}
				if ((j < order) & (data[num2] != 0.0))
				{
					for (int num11 = j + 1; num11 < order; num11++)
					{
						data[num + num11] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(double[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			double[] array = new double[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = 1.0;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, double[] a, int order, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			double[] array = new double[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, double[] a, int order, int[] ipiv, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						double num5 = b[num3];
						b[num3] = b[num4];
						b[num4] = num5;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num6 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num7 = m * order;
						b[l + num7] -= b[k + num7] * a[l + num6];
					}
				}
			}
			for (int num8 = order - 1; num8 >= 0; num8--)
			{
				int num9 = num8 + num8 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num8 + n * order] /= a[num9];
				}
				num9 = num8 * order;
				for (int num10 = 0; num10 < num8; num10++)
				{
					for (int num11 = 0; num11 < columnsOfB; num11++)
					{
						int num12 = num11 * order;
						b[num10 + num12] -= b[num8 + num12] * a[num10 + num9];
					}
				}
			}
		}

		public virtual void CholeskyFactor(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			double[] array = new double[order];
			for (int i = 0; i < order; i++)
			{
				double num = a[i * order + i];
				if (!(num > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				num = (array[i] = (a[i * order + i] = Math.Sqrt(num)));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= num;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0.0;
				}
			}
		}

		private static void DoCholeskyStep(double[] data, int rowDim, int firstCol, int colLimit, double[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				double num2 = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * num2;
				}
			}
		}

		public virtual void CholeskySolve(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			double[] array = new double[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(double[] a, int orderA, double[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				double num2 = b[num + i];
				for (int num3 = i - 1; num3 >= 0; num3--)
				{
					num2 -= a[num3 * orderA + i] * b[num + num3];
				}
				b[num + i] = num2 / a[i * orderA + i];
			}
			for (int num4 = orderA - 1; num4 >= 0; num4--)
			{
				double num2 = b[num + num4];
				int num5 = num4 * orderA;
				for (int j = num4 + 1; j < orderA; j++)
				{
					num2 -= a[num5 + j] * b[num + j];
				}
				b[num + num4] = num2 / a[num5 + num4];
			}
		}

		public virtual void QRFactor(double[] r, int rowsR, int columnsR, double[] q, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = 1.0;
				}
			});
			double[] work = ((columnsR > rowsR) ? new double[rowsR * rowsR] : new double[rowsR * columnsR]);
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(double[] a, int rowsA, int columnsA, double[] r, double[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			double[] work = new double[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = 1.0;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(double[] work, int workIndex, double[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				double num2 = 0.0;
				for (int j = rowStart; j < rowCount; j++)
				{
					num2 += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart] * num2;
				}
			}
		}

		private static void GenerateColumn(double[] work, double[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num4 = tmp + l;
					work[num4 - row] = a[num4];
					a[num4] = 0.0;
				}
			});
			double num2 = 0.0;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num3 = tmp + i;
				num2 += work[num3] * work[num3];
			}
			num2 = Math.Sqrt(num2);
			if (row == rowCount - 1 || num2 == 0.0)
			{
				a[num] = 0.0 - work[tmp];
				work[tmp] = 1.4142135623730951;
				return;
			}
			double scale = 1.0 / num2;
			if (work[tmp] < 0.0)
			{
				scale *= -1.0;
			}
			a[num] = -1.0 / scale;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] *= scale;
				}
			});
			work[tmp] += 1.0;
			double s = Math.Sqrt(1.0 / work[tmp]);
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] *= s;
				}
			});
		}

		public virtual void QRSolve(double[] a, int rows, int columns, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			double[] tau = new double[rows * columns];
			double[] array = new double[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				double[] q = new double[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				double[] r = new double[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(double[] q, double[] r, int rowsA, int columnsA, double[] tau, double[] b, int columnsB, double[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			double[] sol = new double[b.Length];
			Buffer.BlockCopy(b, 0, sol, 0, b.Length * 8);
			double[] column = new double[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						double num9 = 0.0;
						for (int num10 = 0; num10 < rowsA; num10++)
						{
							num9 += q[num8 + num10] * column[num10];
						}
						sol[jm + n] = num9;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, double[] a, int rowsA, int columnsA, double[] s, double[] u, double[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			double[] array = new double[rowsA];
			double[] array2 = new double[columnsA];
			double[] array3 = new double[vt.Length];
			double[] array4 = new double[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					double num5 = 0.0;
					for (int j = i; j < rowsA; j++)
					{
						num5 += a[i * rowsA + j] * a[i * rowsA + j];
					}
					array4[i] = Math.Sqrt(num5);
					if (array4[i] != 0.0)
					{
						if (a[i * rowsA + i] != 0.0)
						{
							array4[i] = Math.Abs(array4[i]) * (a[i * rowsA + i] / Math.Abs(a[i * rowsA + i]));
						}
						for (int k = i; k < rowsA; k++)
						{
							a[i * rowsA + k] *= 1.0 / array4[i];
						}
						a[i * rowsA + i] = 1.0 + a[i * rowsA + i];
					}
					array4[i] = 0.0 - array4[i];
				}
				for (int l = num4; l < columnsA; l++)
				{
					if (i < num && array4[i] != 0.0)
					{
						double num6 = 0.0;
						for (int k = i; k < rowsA; k++)
						{
							num6 += a[l * rowsA + k] * a[i * rowsA + k];
						}
						num6 = (0.0 - num6) / a[i * rowsA + i];
						for (int m = i; m < rowsA; m++)
						{
							a[l * rowsA + m] += num6 * a[i * rowsA + m];
						}
					}
					array2[l] = a[l * rowsA + i];
				}
				if (computeVectors && i < num)
				{
					for (int k = i; k < rowsA; k++)
					{
						u[i * rowsA + k] = a[i * rowsA + k];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				double num7 = 0.0;
				for (int k = num4; k < array2.Length; k++)
				{
					num7 += array2[k] * array2[k];
				}
				array2[i] = Math.Sqrt(num7);
				if (array2[i] != 0.0)
				{
					if (array2[num4] != 0.0)
					{
						array2[i] = Math.Abs(array2[i]) * (array2[num4] / Math.Abs(array2[num4]));
					}
					for (int k = num4; k < array2.Length; k++)
					{
						array2[k] *= 1.0 / array2[i];
					}
					array2[num4] = 1.0 + array2[num4];
				}
				array2[i] = 0.0 - array2[i];
				if (num4 < rowsA && array2[i] != 0.0)
				{
					for (int k = num4; k < rowsA; k++)
					{
						array[k] = 0.0;
					}
					for (int l = num4; l < columnsA; l++)
					{
						for (int n = num4; n < rowsA; n++)
						{
							array[n] += array2[l] * a[l * rowsA + n];
						}
					}
					for (int l = num4; l < columnsA; l++)
					{
						double num8 = (0.0 - array2[l]) / array2[num4];
						for (int num9 = num4; num9 < rowsA; num9++)
						{
							a[l * rowsA + num9] += num8 * array[num9];
						}
					}
				}
				if (computeVectors)
				{
					for (int k = num4; k < columnsA; k++)
					{
						array3[i * columnsA + k] = array2[k];
					}
				}
			}
			int num10 = Math.Min(columnsA, rowsA + 1);
			int num11 = num + 1;
			int num12 = num2 + 1;
			if (num < columnsA)
			{
				array4[num11 - 1] = a[(num11 - 1) * rowsA + (num11 - 1)];
			}
			if (rowsA < num10)
			{
				array4[num10 - 1] = 0.0;
			}
			if (num12 < num10)
			{
				array2[num12 - 1] = a[(num10 - 1) * rowsA + (num12 - 1)];
			}
			array2[num10 - 1] = 0.0;
			if (computeVectors)
			{
				for (int l = num11 - 1; l < rowsA; l++)
				{
					for (int k = 0; k < rowsA; k++)
					{
						u[l * rowsA + k] = 0.0;
					}
					u[l * rowsA + l] = 1.0;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if (array4[i] != 0.0)
					{
						for (int l = i + 1; l < rowsA; l++)
						{
							double num6 = 0.0;
							for (int k = i; k < rowsA; k++)
							{
								num6 += u[l * rowsA + k] * u[i * rowsA + k];
							}
							num6 = (0.0 - num6) / u[i * rowsA + i];
							for (int num13 = i; num13 < rowsA; num13++)
							{
								u[l * rowsA + num13] += num6 * u[i * rowsA + num13];
							}
						}
						for (int k = i; k < rowsA; k++)
						{
							u[i * rowsA + k] *= -1.0;
						}
						u[i * rowsA + i] = 1.0 + u[i * rowsA + i];
						for (int k = 0; k < i; k++)
						{
							u[i * rowsA + k] = 0.0;
						}
					}
					else
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[i * rowsA + k] = 0.0;
						}
						u[i * rowsA + i] = 1.0;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && array2[i] != 0.0)
					{
						for (int l = num4; l < columnsA; l++)
						{
							double num6 = 0.0;
							for (int k = num4; k < columnsA; k++)
							{
								num6 += array3[l * columnsA + k] * array3[i * columnsA + k];
							}
							num6 = (0.0 - num6) / array3[i * columnsA + num4];
							for (int num14 = i; num14 < columnsA; num14++)
							{
								array3[l * columnsA + num14] += num6 * array3[i * columnsA + num14];
							}
						}
					}
					for (int k = 0; k < columnsA; k++)
					{
						array3[i * columnsA + k] = 0.0;
					}
					array3[i * columnsA + i] = 1.0;
				}
			}
			for (int k = 0; k < num10; k++)
			{
				double num6;
				double num15;
				if (array4[k] != 0.0)
				{
					num6 = array4[k];
					num15 = array4[k] / num6;
					array4[k] = num6;
					if (k < num10 - 1)
					{
						array2[k] /= num15;
					}
					if (computeVectors)
					{
						for (int l = 0; l < rowsA; l++)
						{
							u[k * rowsA + l] *= num15;
						}
					}
				}
				if (k == num10 - 1)
				{
					break;
				}
				if (array2[k] == 0.0)
				{
					continue;
				}
				num6 = array2[k];
				num15 = num6 / array2[k];
				array2[k] = num6;
				array4[k + 1] *= num15;
				if (computeVectors)
				{
					for (int l = 0; l < columnsA; l++)
					{
						array3[(k + 1) * columnsA + l] *= num15;
					}
				}
			}
			int num16 = num10;
			int num17 = 0;
			while (num10 > 0)
			{
				if (num17 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num10 - 2; i >= 0; i--)
				{
					double num18 = Math.Abs(array4[i]) + Math.Abs(array4[i + 1]);
					if ((num18 + Math.Abs(array2[i])).AlmostEqualRelative(num18, 15))
					{
						array2[i] = 0.0;
						break;
					}
				}
				int num19;
				if (i == num10 - 2)
				{
					num19 = 4;
				}
				else
				{
					int num20;
					for (num20 = num10 - 1; num20 > i; num20--)
					{
						double num18 = 0.0;
						if (num20 != num10 - 1)
						{
							num18 += Math.Abs(array2[num20]);
						}
						if (num20 != i + 1)
						{
							num18 += Math.Abs(array2[num20 - 1]);
						}
						if ((num18 + Math.Abs(array4[num20])).AlmostEqualRelative(num18, 15))
						{
							array4[num20] = 0.0;
							break;
						}
					}
					if (num20 == i)
					{
						num19 = 3;
					}
					else if (num20 == num10 - 1)
					{
						num19 = 1;
					}
					else
					{
						num19 = 2;
						i = num20;
					}
				}
				i++;
				double c;
				double s2;
				switch (num19)
				{
				case 1:
				{
					double db = array2[num10 - 2];
					array2[num10 - 2] = 0.0;
					for (int num35 = i; num35 < num10 - 1; num35++)
					{
						int num23 = num10 - 2 - num35 + i;
						double da = array4[num23];
						Drotg(ref da, ref db, out c, out s2);
						array4[num23] = da;
						if (num23 != i)
						{
							db = (0.0 - s2) * array2[num23 - 1];
							array2[num23 - 1] = c * array2[num23 - 1];
						}
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								double num36 = c * array3[num23 * columnsA + k] + s2 * array3[(num10 - 1) * columnsA + k];
								array3[(num10 - 1) * columnsA + k] = c * array3[(num10 - 1) * columnsA + k] - s2 * array3[num23 * columnsA + k];
								array3[num23 * columnsA + k] = num36;
							}
						}
					}
					break;
				}
				case 2:
				{
					double db = array2[i - 1];
					array2[i - 1] = 0.0;
					for (int num23 = i; num23 < num10; num23++)
					{
						double da = array4[num23];
						Drotg(ref da, ref db, out c, out s2);
						array4[num23] = da;
						db = (0.0 - s2) * array2[num23];
						array2[num23] = c * array2[num23];
						if (computeVectors)
						{
							for (int k = 0; k < rowsA; k++)
							{
								double num24 = c * u[num23 * rowsA + k] + s2 * u[(i - 1) * rowsA + k];
								u[(i - 1) * rowsA + k] = c * u[(i - 1) * rowsA + k] - s2 * u[num23 * rowsA + k];
								u[num23 * rowsA + k] = num24;
							}
						}
					}
					break;
				}
				case 3:
				{
					double val = 0.0;
					val = Math.Max(val, Math.Abs(array4[num10 - 1]));
					val = Math.Max(val, Math.Abs(array4[num10 - 2]));
					val = Math.Max(val, Math.Abs(array2[num10 - 2]));
					val = Math.Max(val, Math.Abs(array4[i]));
					val = Math.Max(val, Math.Abs(array2[i]));
					double num25 = array4[num10 - 1] / val;
					double num26 = array4[num10 - 2] / val;
					double num27 = array2[num10 - 2] / val;
					double num28 = array4[i] / val;
					double num29 = array2[i] / val;
					double num30 = ((num26 + num25) * (num26 - num25) + num27 * num27) / 2.0;
					double num31 = num25 * num27 * (num25 * num27);
					double num32 = 0.0;
					if (num30 != 0.0 || num31 != 0.0)
					{
						num32 = Math.Sqrt(num30 * num30 + num31);
						if (num30 < 0.0)
						{
							num32 = 0.0 - num32;
						}
						num32 = num31 / (num30 + num32);
					}
					double db = (num28 + num25) * (num28 - num25) + num32;
					double db2 = num28 * num29;
					for (int num23 = i; num23 < num10 - 1; num23++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num23 != i)
						{
							array2[num23 - 1] = db;
						}
						db = c * array4[num23] + s2 * array2[num23];
						array2[num23] = c * array2[num23] - s2 * array4[num23];
						db2 = s2 * array4[num23 + 1];
						array4[num23 + 1] = c * array4[num23 + 1];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								double num33 = c * array3[num23 * columnsA + k] + s2 * array3[(num23 + 1) * columnsA + k];
								array3[(num23 + 1) * columnsA + k] = c * array3[(num23 + 1) * columnsA + k] - s2 * array3[num23 * columnsA + k];
								array3[num23 * columnsA + k] = num33;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num23] = db;
						db = c * array2[num23] + s2 * array4[num23 + 1];
						array4[num23 + 1] = 0.0 - s2 * array2[num23] + c * array4[num23 + 1];
						db2 = s2 * array2[num23 + 1];
						array2[num23 + 1] = c * array2[num23 + 1];
						if (computeVectors && num23 < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								double num34 = c * u[num23 * rowsA + k] + s2 * u[(num23 + 1) * rowsA + k];
								u[(num23 + 1) * rowsA + k] = c * u[(num23 + 1) * rowsA + k] - s2 * u[num23 * rowsA + k];
								u[num23 * rowsA + k] = num34;
							}
						}
					}
					array2[num10 - 2] = db;
					num17++;
					break;
				}
				case 4:
					if (array4[i] < 0.0)
					{
						array4[i] = 0.0 - array4[i];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								array3[i * columnsA + k] *= -1.0;
							}
						}
					}
					for (; i != num16 - 1 && !(array4[i] >= array4[i + 1]); i++)
					{
						double num6 = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = num6;
						if (computeVectors && i < columnsA)
						{
							for (int k = 0; k < columnsA; k++)
							{
								double num21 = array3[i * columnsA + k];
								array3[i * columnsA + k] = array3[(i + 1) * columnsA + k];
								array3[(i + 1) * columnsA + k] = num21;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								double num22 = u[i * rowsA + k];
								u[i * rowsA + k] = u[(i + 1) * rowsA + k];
								u[(i + 1) * rowsA + k] = num22;
							}
						}
					}
					num17 = 0;
					num10--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int k = 0; k < columnsA; k++)
				{
					for (int l = 0; l < columnsA; l++)
					{
						vt[l * columnsA + k] = array3[k * columnsA + l];
					}
				}
			}
			Buffer.BlockCopy(array4, 0, s, 0, Math.Min(rowsA, columnsA) * 8);
		}

		private static void Drotg(ref double da, ref double db, out double c, out double s)
		{
			double num = db;
			double num2 = Math.Abs(da);
			double num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			double num4 = num2 + num3;
			double num5;
			double num6;
			if (num4 == 0.0)
			{
				c = 1.0;
				s = 0.0;
				num5 = 0.0;
				num6 = 0.0;
			}
			else
			{
				double num7 = da / num4;
				double num8 = db / num4;
				num5 = num4 * Math.Sqrt(num7 * num7 + num8 * num8);
				if (num < 0.0)
				{
					num5 = 0.0 - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1.0;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && c != 0.0)
				{
					num6 = 1.0 / c;
				}
			}
			da = num5;
			db = num6;
		}

		public virtual void SvdSolve(double[] a, int rowsA, int columnsA, double[] b, int columnsB, double[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			double[] s = new double[Math.Min(rowsA, columnsA)];
			double[] u = new double[rowsA * rowsA];
			double[] vt = new double[columnsA * columnsA];
			double[] array = new double[a.Length];
			Buffer.BlockCopy(a, 0, array, 0, a.Length * 8);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, double[] s, double[] u, double[] vt, double[] b, int columnsB, double[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			double[] array = new double[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					double num2 = 0.0;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							num2 += u[j * rowsA + k] * b[i * rowsA + k];
						}
						num2 /= s[j];
					}
					array[j] = num2;
				}
				for (int l = 0; l < columnsA; l++)
				{
					double num3 = 0.0;
					for (int m = 0; m < columnsA; m++)
					{
						num3 += vt[l * columnsA + m] * array[m];
					}
					x[i * columnsA + l] = num3;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, double[] matrix, double[] matrixEv, Complex[] vectorEv, double[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			double[] array = new double[order];
			double[] array2 = new double[order];
			if (isSymmetric)
			{
				Buffer.BlockCopy(matrix, 0, matrixEv, 0, matrix.Length * 8);
				int num = order - 1;
				for (int i = 0; i < order; i++)
				{
					array[i] = matrixEv[i * order + num];
				}
				ManagedLinearAlgebraProvider.SymmetricTridiagonalize(matrixEv, array, array2, order);
				ManagedLinearAlgebraProvider.SymmetricDiagonalize(matrixEv, array, array2, order);
			}
			else
			{
				double[] array3 = new double[matrix.Length];
				Buffer.BlockCopy(matrix, 0, array3, 0, matrix.Length * 8);
				ManagedLinearAlgebraProvider.NonsymmetricReduceToHessenberg(matrixEv, array3, order);
				ManagedLinearAlgebraProvider.NonsymmetricReduceHessenberToRealSchur(matrixEv, array3, array, array2, order);
			}
			for (int j = 0; j < order; j++)
			{
				vectorEv[j] = new Complex(array[j], array2[j]);
				int num2 = j * order;
				matrixD[num2 + j] = array[j];
				if (array2[j] > 0.0)
				{
					matrixD[num2 + order + j] = array2[j];
					matrixD[(j + 1) * order + j] = array2[j];
				}
				else if (array2[j] < 0.0)
				{
					matrixD[num2 - order + j] = array2[j];
				}
			}
		}

		public virtual void AddVectorToScaledVector(float[] y, float alpha, float[] x, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if ((double)alpha == 0.0)
			{
				y.Copy(result);
				return;
			}
			if ((double)alpha == 1.0)
			{
				CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						result[j] = y[j] + x[j];
					}
				});
				return;
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = y[i] + alpha * x[i];
				}
			});
		}

		public virtual void ScaleArray(float alpha, float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if ((double)alpha == 0.0)
			{
				Array.Clear(result, 0, result.Length);
				return;
			}
			if ((double)alpha == 1.0)
			{
				x.Copy(result);
				return;
			}
			CommonParallel.For(0, x.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = alpha * x[i];
				}
			});
		}

		public virtual void ConjugateArray(float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				x.CopyTo(result, 0);
			}
		}

		public virtual float DotProduct(float[] x, float[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			float num = 0f;
			for (int i = 0; i < y.Length; i++)
			{
				num += y[i] * x[i];
			}
			return num;
		}

		public virtual void AddArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] + y[i];
				}
			});
		}

		public virtual void SubtractArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] - y[i];
				}
			});
		}

		public virtual void PointWiseMultiplyArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] * y[i];
				}
			});
		}

		public virtual void PointWiseDivideArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = x[i] / y[i];
				}
			});
		}

		public virtual void PointWisePowerArrays(float[] x, float[] y, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (y.Length != x.Length || y.Length != result.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					result[i] = (float)Math.Pow(x[i], y[i]);
				}
			});
		}

		public virtual double MatrixNorm(Norm norm, int rows, int columns, float[] matrix)
		{
			switch (norm)
			{
			case Norm.OneNorm:
			{
				double num3 = 0.0;
				for (int l = 0; l < columns; l++)
				{
					double num4 = 0.0;
					for (int m = 0; m < rows; m++)
					{
						num4 += (double)Math.Abs(matrix[l * rows + m]);
					}
					num3 = Math.Max(num3, num4);
				}
				return num3;
			}
			case Norm.LargestAbsoluteValue:
			{
				double num2 = 0.0;
				for (int j = 0; j < columns; j++)
				{
					for (int k = 0; k < rows; k++)
					{
						num2 = Math.Max(Math.Abs(matrix[j * rows + k]), num2);
					}
				}
				return num2;
			}
			case Norm.InfinityNorm:
			{
				double[] array2 = new double[rows];
				for (int n = 0; n < columns; n++)
				{
					for (int num5 = 0; num5 < rows; num5++)
					{
						array2[num5] += Math.Abs(matrix[n * rows + num5]);
					}
				}
				double num6 = array2[0];
				for (int num7 = 0; num7 < array2.Length; num7++)
				{
					if (array2[num7] > num6)
					{
						num6 = array2[num7];
					}
				}
				return num6;
			}
			case Norm.FrobeniusNorm:
			{
				float[] array = new float[rows * rows];
				MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.Transpose, 1f, matrix, rows, columns, matrix, rows, columns, 0f, array);
				double num = 0.0;
				for (int i = 0; i < rows; i++)
				{
					num += (double)Math.Abs(array[i * rows + i]);
				}
				return Math.Sqrt(num);
			}
			default:
				throw new NotSupportedException();
			}
		}

		public virtual void MatrixMultiply(float[] x, int rowsX, int columnsX, float[] y, int rowsY, int columnsY, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (rowsX * columnsX != x.Length)
			{
				throw new ArgumentException("x.Length != xRows * xColumns");
			}
			if (rowsY * columnsY != y.Length)
			{
				throw new ArgumentException("y.Length != yRows * yColumns");
			}
			if (columnsX != rowsY)
			{
				throw new ArgumentException("xColumns != yRows");
			}
			if (rowsX * columnsY != result.Length)
			{
				throw new ArgumentException("xRows * yColumns != result.Length");
			}
			float[] matrixA = ((x != result) ? x : ((float[])x.Clone()));
			float[] matrixB = ((y != result) ? y : ((float[])y.Clone()));
			Array.Clear(result, 0, result.Length);
			CacheObliviousMatrixMultiply(Transpose.DontTranspose, Transpose.DontTranspose, 1f, matrixA, 0, 0, matrixB, 0, 0, result, 0, 0, rowsX, columnsY, columnsX, rowsX, columnsY, columnsX, first: true);
		}

		public virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, float alpha, float[] a, int rowsA, int columnsA, float[] b, int rowsB, int columnsB, float beta, float[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			int num;
			int num2;
			int num3;
			if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
			{
				if (rowsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = rowsB;
				num3 = rowsA;
			}
			else if (transposeA > Transpose.DontTranspose)
			{
				if (rowsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (columnsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = columnsA;
				num2 = columnsB;
				num3 = rowsA;
			}
			else if (transposeB > Transpose.DontTranspose)
			{
				if (columnsA != columnsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * rowsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = rowsB;
				num3 = columnsA;
			}
			else
			{
				if (columnsA != rowsB)
				{
					throw new ArgumentOutOfRangeException();
				}
				if (rowsA * columnsB != c.Length)
				{
					throw new ArgumentOutOfRangeException();
				}
				num = rowsA;
				num2 = columnsB;
				num3 = columnsA;
			}
			if ((double)alpha == 0.0 && (double)beta == 0.0)
			{
				Array.Clear(c, 0, c.Length);
				return;
			}
			float[] matrixA = ((a != c) ? a : ((float[])a.Clone()));
			float[] matrixB = ((b != c) ? b : ((float[])b.Clone()));
			if (beta == 0f)
			{
				Array.Clear(c, 0, c.Length);
			}
			else if (beta != 1f)
			{
				ScaleArray(beta, c, c);
			}
			if (alpha != 0f)
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, 0, 0, matrixB, 0, 0, c, 0, 0, num, num2, num3, num, num2, num3, first: true);
			}
		}

		private static void CacheObliviousMatrixMultiply(Transpose transposeA, Transpose transposeB, float alpha, float[] matrixA, int shiftArow, int shiftAcol, float[] matrixB, int shiftBrow, int shiftBcol, float[] result, int shiftCrow, int shiftCcol, int m, int n, int k, int constM, int constN, int constK, bool first)
		{
			if (m + n <= Control.ParallelizeOrder || m == 1 || n == 1 || k == 1)
			{
				if (transposeA > Transpose.DontTranspose && transposeB > Transpose.DontTranspose)
				{
					for (int i = 0; i < m; i++)
					{
						int num = i + shiftArow;
						int num2 = i + shiftCrow;
						for (int j = 0; j < n; j++)
						{
							int num3 = j + shiftBcol;
							float num4 = 0f;
							for (int l = 0; l < k; l++)
							{
								num4 += matrixA[num * constK + l + shiftAcol] * matrixB[(l + shiftBrow) * constN + num3];
							}
							result[(j + shiftCcol) * constM + num2] += alpha * num4;
						}
					}
					return;
				}
				if (transposeA > Transpose.DontTranspose)
				{
					for (int num5 = 0; num5 < m; num5++)
					{
						int num6 = num5 + shiftArow;
						int num7 = num5 + shiftCrow;
						for (int num8 = 0; num8 < n; num8++)
						{
							int num9 = num8 + shiftBcol;
							float num10 = 0f;
							for (int num11 = 0; num11 < k; num11++)
							{
								num10 += matrixA[num6 * constK + num11 + shiftAcol] * matrixB[num9 * constK + num11 + shiftBrow];
							}
							result[(num8 + shiftCcol) * constM + num7] += alpha * num10;
						}
					}
					return;
				}
				if (transposeB > Transpose.DontTranspose)
				{
					for (int num12 = 0; num12 < m; num12++)
					{
						int num13 = num12 + shiftArow;
						int num14 = num12 + shiftCrow;
						for (int num15 = 0; num15 < n; num15++)
						{
							int num16 = num15 + shiftBcol;
							float num17 = 0f;
							for (int num18 = 0; num18 < k; num18++)
							{
								num17 += matrixA[(num18 + shiftAcol) * constM + num13] * matrixB[(num18 + shiftBrow) * constN + num16];
							}
							result[(num15 + shiftCcol) * constM + num14] += alpha * num17;
						}
					}
					return;
				}
				for (int num19 = 0; num19 < m; num19++)
				{
					int num20 = num19 + shiftArow;
					int num21 = num19 + shiftCrow;
					for (int num22 = 0; num22 < n; num22++)
					{
						int num23 = num22 + shiftBcol;
						float num24 = 0f;
						for (int num25 = 0; num25 < k; num25++)
						{
							num24 += matrixA[(num25 + shiftAcol) * constM + num20] * matrixB[num23 * constK + num25 + shiftBrow];
						}
						result[(num22 + shiftCcol) * constM + num21] += alpha * num24;
					}
				}
				return;
			}
			int m2 = m / 2;
			int n2 = n / 2;
			int k2 = k / 2;
			if (first)
			{
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				});
				CommonParallel.Invoke(delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				}, delegate
				{
					CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
				});
			}
			else
			{
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow, shiftCcol, m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow, shiftCcol + n2, m2, n - n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol, matrixB, shiftBrow, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol, result, shiftCrow + m2, shiftCcol, m - m2, n2, k - k2, constM, constN, constK, first: false);
				CacheObliviousMatrixMultiply(transposeA, transposeB, alpha, matrixA, shiftArow + m2, shiftAcol + k2, matrixB, shiftBrow + k2, shiftBcol + n2, result, shiftCrow + m2, shiftCcol + n2, m - m2, n - n2, k - k2, constM, constN, constK, first: false);
			}
		}

		public virtual void LUFactor(float[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			for (int i = 0; i < order; i++)
			{
				ipiv[i] = i;
			}
			float[] array = new float[order];
			for (int j = 0; j < order; j++)
			{
				int num = j * order;
				int num2 = num + j;
				for (int k = 0; k < order; k++)
				{
					array[k] = data[num + k];
				}
				for (int l = 0; l < order; l++)
				{
					int num3 = Math.Min(l, j);
					float num4 = 0f;
					for (int m = 0; m < num3; m++)
					{
						num4 += data[m * order + l] * array[m];
					}
					data[num + l] = (array[l] -= num4);
				}
				int num5 = j;
				for (int n = j + 1; n < order; n++)
				{
					if (Math.Abs(array[n]) > Math.Abs(array[num5]))
					{
						num5 = n;
					}
				}
				if (num5 != j)
				{
					for (int num6 = 0; num6 < order; num6++)
					{
						int num7 = num6 * order;
						int num8 = num7 + num5;
						int num9 = num7 + j;
						float num10 = data[num8];
						data[num8] = data[num9];
						data[num9] = num10;
					}
					ipiv[j] = num5;
				}
				if ((j < order) & ((double)data[num2] != 0.0))
				{
					for (int num11 = j + 1; num11 < order; num11++)
					{
						data[num + num11] /= data[num2];
					}
				}
			}
		}

		public virtual void LUInverse(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			int[] ipiv = new int[order];
			LUFactor(a, order, ipiv);
			LUInverseFactored(a, order, ipiv);
		}

		public virtual void LUInverseFactored(float[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			float[] array = new float[a.Length];
			for (int i = 0; i < order; i++)
			{
				array[i + order * i] = 1f;
			}
			LUSolveFactored(order, a, order, ipiv, array);
			array.Copy(a);
		}

		public virtual void LUSolve(int columnsOfB, float[] a, int order, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			int[] ipiv = new int[order];
			float[] array = new float[a.Length];
			a.Copy(array);
			LUFactor(array, order, ipiv);
			LUSolveFactored(columnsOfB, array, order, ipiv, b);
		}

		public virtual void LUSolveFactored(int columnsOfB, float[] a, int order, int[] ipiv, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != order * columnsOfB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			for (int i = 0; i < ipiv.Length; i++)
			{
				if (ipiv[i] != i)
				{
					int num = ipiv[i];
					for (int j = 0; j < columnsOfB; j++)
					{
						int num2 = j * order;
						int num3 = num2 + num;
						int num4 = num2 + i;
						float num5 = b[num3];
						b[num3] = b[num4];
						b[num4] = num5;
					}
				}
			}
			for (int k = 0; k < order; k++)
			{
				int num6 = k * order;
				for (int l = k + 1; l < order; l++)
				{
					for (int m = 0; m < columnsOfB; m++)
					{
						int num7 = m * order;
						b[l + num7] -= b[k + num7] * a[l + num6];
					}
				}
			}
			for (int num8 = order - 1; num8 >= 0; num8--)
			{
				int num9 = num8 + num8 * order;
				for (int n = 0; n < columnsOfB; n++)
				{
					b[num8 + n * order] /= a[num9];
				}
				num9 = num8 * order;
				for (int num10 = 0; num10 < num8; num10++)
				{
					for (int num11 = 0; num11 < columnsOfB; num11++)
					{
						int num12 = num11 * order;
						b[num10 + num12] -= b[num8 + num12] * a[num10 + num9];
					}
				}
			}
		}

		public virtual void CholeskyFactor(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			float[] array = new float[order];
			for (int i = 0; i < order; i++)
			{
				float num = a[i * order + i];
				if (!((double)num > 0.0))
				{
					throw new ArgumentException("Matrix must be positive definite.");
				}
				num = (array[i] = (a[i * order + i] = (float)Math.Sqrt(num)));
				for (int j = i + 1; j < order; j++)
				{
					a[i * order + j] /= num;
					array[j] = a[i * order + j];
				}
				DoCholeskyStep(a, order, i + 1, order, array, Control.MaxDegreeOfParallelism);
				for (int k = i + 1; k < order; k++)
				{
					a[k * order + i] = 0f;
				}
			}
		}

		private static void DoCholeskyStep(float[] data, int rowDim, int firstCol, int colLimit, float[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > Control.ParallelizeElements)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				float num2 = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data[i * rowDim + j] -= multipliers[j] * num2;
				}
			}
		}

		public virtual void CholeskySolve(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			float[] array = new float[a.Length];
			a.Copy(array);
			CholeskyFactor(array, orderA);
			CholeskySolveFactored(array, orderA, b, columnsB);
		}

		public virtual void CholeskySolveFactored(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			CommonParallel.For(0, columnsB, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					DoCholeskySolve(a, orderA, b, i);
				}
			});
		}

		private static void DoCholeskySolve(float[] a, int orderA, float[] b, int index)
		{
			int num = index * orderA;
			for (int i = 0; i < orderA; i++)
			{
				float num2 = b[num + i];
				for (int num3 = i - 1; num3 >= 0; num3--)
				{
					num2 -= a[num3 * orderA + i] * b[num + num3];
				}
				b[num + i] = num2 / a[i * orderA + i];
			}
			for (int num4 = orderA - 1; num4 >= 0; num4--)
			{
				float num2 = b[num + num4];
				int num5 = num4 * orderA;
				for (int j = num4 + 1; j < orderA; j++)
				{
					num2 -= a[num5 + j] * b[num + j];
				}
				b[num + num4] = num2 / a[num5 + num4];
			}
		}

		public virtual void QRFactor(float[] r, int rowsR, int columnsR, float[] q, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (r.Length != rowsR * columnsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "r");
			}
			if (tau.Length < Math.Min(rowsR, columnsR))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (q.Length != rowsR * rowsR)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * rowsR.", "q");
			}
			float[] work = ((columnsR > rowsR) ? new float[rowsR * rowsR] : new float[rowsR * columnsR]);
			CommonParallel.For(0, rowsR, delegate(int a, int b)
			{
				for (int j = a; j < b; j++)
				{
					q[j * rowsR + j] = 1f;
				}
			});
			int num = Math.Min(rowsR, columnsR);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, r, rowsR, i, i);
				ComputeQR(work, i, r, i, rowsR, i + 1, columnsR, Control.MaxDegreeOfParallelism);
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				ComputeQR(work, num2, q, num2, rowsR, num2, rowsR, Control.MaxDegreeOfParallelism);
			}
		}

		public virtual void ThinQRFactor(float[] a, int rowsA, int columnsA, float[] r, float[] tau)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != rowsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be rowsR * columnsR.", "a");
			}
			if (tau.Length < Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The given array is too small. It must be at least min(m,n) long.", "tau");
			}
			if (r.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The given array has the wrong length. Should be columnsA * columnsA.", "r");
			}
			float[] work = new float[rowsA * columnsA];
			int num = Math.Min(rowsA, columnsA);
			for (int i = 0; i < num; i++)
			{
				GenerateColumn(work, a, rowsA, i, i);
				ComputeQR(work, i, a, i, rowsA, i + 1, columnsA, Control.MaxDegreeOfParallelism);
			}
			for (int j = 0; j < columnsA; j++)
			{
				int num2 = j * columnsA;
				int num3 = j * rowsA;
				for (int k = 0; k < columnsA; k++)
				{
					r[num2 + k] = a[num3 + k];
				}
			}
			Array.Clear(a, 0, a.Length);
			for (int l = 0; l < columnsA; l++)
			{
				a[l * rowsA + l] = 1f;
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				ComputeQR(work, num4, a, num4, rowsA, num4, columnsA, Control.MaxDegreeOfParallelism);
			}
		}

		private static void ComputeQR(float[] work, int workIndex, float[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores)
		{
			if (rowStart > rowCount || columnStart > columnCount)
			{
				return;
			}
			int num = columnCount - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(work, workIndex, a, rowStart, rowCount, tmpSplit, columnCount, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnCount; i++)
			{
				float num2 = 0f;
				for (int j = rowStart; j < rowCount; j++)
				{
					num2 += work[workIndex * rowCount + j - rowStart] * a[i * rowCount + j];
				}
				for (int k = rowStart; k < rowCount; k++)
				{
					a[i * rowCount + k] -= work[workIndex * rowCount + k - rowStart] * num2;
				}
			}
		}

		private static void GenerateColumn(float[] work, float[] a, int rowCount, int row, int column)
		{
			int tmp = column * rowCount;
			int num = tmp + row;
			CommonParallel.For(row, rowCount, delegate(int u, int v)
			{
				for (int l = u; l < v; l++)
				{
					int num4 = tmp + l;
					work[num4 - row] = a[num4];
					a[num4] = 0f;
				}
			});
			double num2 = 0.0;
			for (int i = 0; i < rowCount - row; i++)
			{
				int num3 = tmp + i;
				num2 += (double)(work[num3] * work[num3]);
			}
			num2 = Math.Sqrt(num2);
			if (row == rowCount - 1 || num2 == 0.0)
			{
				a[num] = 0f - work[tmp];
				work[tmp] = 1.4142135f;
				return;
			}
			float scale = 1f / (float)num2;
			if ((double)work[tmp] < 0.0)
			{
				scale *= -1f;
			}
			a[num] = -1f / scale;
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int k = u; k < v; k++)
				{
					work[tmp + k] *= scale;
				}
			});
			work[tmp] += 1f;
			float s = (float)Math.Sqrt(1.0 / (double)work[tmp]);
			CommonParallel.For(0, rowCount - row, 4096, delegate(int u, int v)
			{
				for (int j = u; j < v; j++)
				{
					work[tmp + j] *= s;
				}
			});
		}

		public virtual void QRSolve(float[] a, int rows, int columns, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (a.Length != rows * columns)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != rows * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columns * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "x");
			}
			if (rows < columns)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			float[] tau = new float[rows * columns];
			float[] array = new float[a.Length];
			a.Copy(array);
			if (method == QRMethod.Full)
			{
				float[] q = new float[rows * rows];
				QRFactor(array, rows, columns, q, tau);
				QRSolveFactored(q, array, rows, columns, null, b, columnsB, x, method);
			}
			else
			{
				float[] r = new float[columns * columns];
				ThinQRFactor(array, rows, columns, r, tau);
				QRSolveFactored(array, r, rows, columns, null, b, columnsB, x, method);
			}
		}

		public virtual void QRSolveFactored(float[] q, float[] r, int rowsA, int columnsA, float[] tau, float[] b, int columnsB, float[] x, QRMethod method = QRMethod.Full)
		{
			if (r == null)
			{
				throw new ArgumentNullException("r");
			}
			if (q == null)
			{
				throw new ArgumentNullException("q");
			}
			if (b == null)
			{
				throw new ArgumentNullException("q");
			}
			if (x == null)
			{
				throw new ArgumentNullException("q");
			}
			if (rowsA < columnsA)
			{
				throw new ArgumentException("The number of rows must greater than or equal to the number of columns.");
			}
			int num3;
			int num2;
			int num;
			int num4;
			if (method == QRMethod.Full)
			{
				num3 = (num2 = (num = rowsA));
				num4 = columnsA;
			}
			else
			{
				num3 = rowsA;
				num2 = (num = (num4 = columnsA));
			}
			if (r.Length != num * num4)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num * num4}.", "r");
			}
			if (q.Length != num3 * num2)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {num3 * num2}.", "q");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {rowsA * columnsB}.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {columnsA * columnsB}.", "x");
			}
			float[] sol = new float[b.Length];
			Buffer.BlockCopy(b, 0, sol, 0, b.Length * 4);
			float[] column = new float[rowsA];
			for (int i = 0; i < columnsB; i++)
			{
				int jm = i * rowsA;
				Array.Copy(sol, jm, column, 0, rowsA);
				CommonParallel.For(0, columnsA, delegate(int u, int v)
				{
					for (int n = u; n < v; n++)
					{
						int num8 = n * rowsA;
						float num9 = 0f;
						for (int num10 = 0; num10 < rowsA; num10++)
						{
							num9 += q[num8 + num10] * column[num10];
						}
						sol[jm + n] = num9;
					}
				});
			}
			for (int num5 = columnsA - 1; num5 >= 0; num5--)
			{
				int num6 = num5 * num;
				for (int j = 0; j < columnsB; j++)
				{
					sol[j * rowsA + num5] /= r[num6 + num5];
				}
				for (int k = 0; k < num5; k++)
				{
					for (int l = 0; l < columnsB; l++)
					{
						int num7 = l * rowsA;
						sol[num7 + k] -= sol[num7 + num5] * r[num6 + k];
					}
				}
			}
			for (int m = 0; m < columnsB; m++)
			{
				Array.Copy(sol, m * rowsA, x, m * columnsA, num4);
			}
		}

		public virtual void SingularValueDecomposition(bool computeVectors, float[] a, int rowsA, int columnsA, float[] s, float[] u, float[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			float[] array = new float[rowsA];
			float[] array2 = new float[columnsA];
			float[] array3 = new float[vt.Length];
			float[] array4 = new float[Math.Min(rowsA + 1, columnsA)];
			int num = Math.Min(rowsA - 1, columnsA);
			int num2 = Math.Max(0, Math.Min(columnsA - 2, rowsA));
			int num3 = Math.Max(num, num2);
			for (int i = 0; i < num3; i++)
			{
				int num4 = i + 1;
				if (i < num)
				{
					int num5 = i;
					float num6 = 0f;
					for (int j = i; j < rowsA; j++)
					{
						num6 += a[num5 * rowsA + j] * a[num5 * rowsA + j];
					}
					array4[i] = (float)Math.Sqrt(num6);
					if ((double)array4[i] != 0.0)
					{
						if ((double)a[i * rowsA + i] != 0.0)
						{
							array4[i] = Math.Abs(array4[i]) * (a[i * rowsA + i] / Math.Abs(a[i * rowsA + i]));
						}
						for (int k = i; k < rowsA; k++)
						{
							a[i * rowsA + k] *= 1f / array4[i];
						}
						a[i * rowsA + i] = 1f + a[i * rowsA + i];
					}
					array4[i] = 0f - array4[i];
				}
				for (int l = num4; l < columnsA; l++)
				{
					if (i < num && (double)array4[i] != 0.0)
					{
						float num7 = 0f;
						for (int k = i; k < rowsA; k++)
						{
							num7 += a[l * rowsA + k] * a[i * rowsA + k];
						}
						num7 = (0f - num7) / a[i * rowsA + i];
						for (int m = i; m < rowsA; m++)
						{
							a[l * rowsA + m] += num7 * a[i * rowsA + m];
						}
					}
					array2[l] = a[l * rowsA + i];
				}
				if (computeVectors && i < num)
				{
					for (int k = i; k < rowsA; k++)
					{
						u[i * rowsA + k] = a[i * rowsA + k];
					}
				}
				if (i >= num2)
				{
					continue;
				}
				double num8 = 0.0;
				for (int k = num4; k < array2.Length; k++)
				{
					num8 += (double)(array2[k] * array2[k]);
				}
				array2[i] = (float)Math.Sqrt(num8);
				if ((double)array2[i] != 0.0)
				{
					if ((double)array2[num4] != 0.0)
					{
						array2[i] = Math.Abs(array2[i]) * (array2[num4] / Math.Abs(array2[num4]));
					}
					for (int k = num4; k < array2.Length; k++)
					{
						array2[k] *= 1f / array2[i];
					}
					array2[num4] = 1f + array2[num4];
				}
				array2[i] = 0f - array2[i];
				if (num4 < rowsA && (double)array2[i] != 0.0)
				{
					for (int k = num4; k < rowsA; k++)
					{
						array[k] = 0f;
					}
					for (int l = num4; l < columnsA; l++)
					{
						for (int n = num4; n < rowsA; n++)
						{
							array[n] += array2[l] * a[l * rowsA + n];
						}
					}
					for (int l = num4; l < columnsA; l++)
					{
						float num9 = (0f - array2[l]) / array2[num4];
						for (int num10 = num4; num10 < rowsA; num10++)
						{
							a[l * rowsA + num10] += num9 * array[num10];
						}
					}
				}
				if (computeVectors)
				{
					for (int k = num4; k < columnsA; k++)
					{
						array3[i * columnsA + k] = array2[k];
					}
				}
			}
			int num11 = Math.Min(columnsA, rowsA + 1);
			int num12 = num + 1;
			int num13 = num2 + 1;
			if (num < columnsA)
			{
				array4[num12 - 1] = a[(num12 - 1) * rowsA + (num12 - 1)];
			}
			if (rowsA < num11)
			{
				array4[num11 - 1] = 0f;
			}
			if (num13 < num11)
			{
				array2[num13 - 1] = a[(num11 - 1) * rowsA + (num13 - 1)];
			}
			array2[num11 - 1] = 0f;
			if (computeVectors)
			{
				for (int l = num12 - 1; l < rowsA; l++)
				{
					for (int k = 0; k < rowsA; k++)
					{
						u[l * rowsA + k] = 0f;
					}
					u[l * rowsA + l] = 1f;
				}
				for (int i = num - 1; i >= 0; i--)
				{
					if ((double)array4[i] != 0.0)
					{
						for (int l = i + 1; l < rowsA; l++)
						{
							float num7 = 0f;
							for (int k = i; k < rowsA; k++)
							{
								num7 += u[l * rowsA + k] * u[i * rowsA + k];
							}
							num7 = (0f - num7) / u[i * rowsA + i];
							for (int num14 = i; num14 < rowsA; num14++)
							{
								u[l * rowsA + num14] += num7 * u[i * rowsA + num14];
							}
						}
						for (int k = i; k < rowsA; k++)
						{
							u[i * rowsA + k] *= -1f;
						}
						u[i * rowsA + i] = 1f + u[i * rowsA + i];
						for (int k = 0; k < i; k++)
						{
							u[i * rowsA + k] = 0f;
						}
					}
					else
					{
						for (int k = 0; k < rowsA; k++)
						{
							u[i * rowsA + k] = 0f;
						}
						u[i * rowsA + i] = 1f;
					}
				}
			}
			if (computeVectors)
			{
				for (int i = columnsA - 1; i >= 0; i--)
				{
					int num4 = i + 1;
					if (i < num2 && (double)array2[i] != 0.0)
					{
						for (int l = num4; l < columnsA; l++)
						{
							float num7 = 0f;
							for (int k = num4; k < columnsA; k++)
							{
								num7 += array3[l * columnsA + k] * array3[i * columnsA + k];
							}
							num7 = (0f - num7) / array3[i * columnsA + num4];
							for (int num15 = i; num15 < columnsA; num15++)
							{
								array3[l * columnsA + num15] += num7 * array3[i * columnsA + num15];
							}
						}
					}
					for (int k = 0; k < columnsA; k++)
					{
						array3[i * columnsA + k] = 0f;
					}
					array3[i * columnsA + i] = 1f;
				}
			}
			for (int k = 0; k < num11; k++)
			{
				float num7;
				float num16;
				if ((double)array4[k] != 0.0)
				{
					num7 = array4[k];
					num16 = array4[k] / num7;
					array4[k] = num7;
					if (k < num11 - 1)
					{
						array2[k] /= num16;
					}
					if (computeVectors)
					{
						for (int l = 0; l < rowsA; l++)
						{
							u[k * rowsA + l] *= num16;
						}
					}
				}
				if (k == num11 - 1)
				{
					break;
				}
				if ((double)array2[k] == 0.0)
				{
					continue;
				}
				num7 = array2[k];
				num16 = num7 / array2[k];
				array2[k] = num7;
				array4[k + 1] *= num16;
				if (computeVectors)
				{
					for (int l = 0; l < columnsA; l++)
					{
						array3[(k + 1) * columnsA + l] *= num16;
					}
				}
			}
			int num17 = num11;
			int num18 = 0;
			while (num11 > 0)
			{
				if (num18 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num11 - 2; i >= 0; i--)
				{
					double num19 = Math.Abs(array4[i]) + Math.Abs(array4[i + 1]);
					if ((num19 + (double)Math.Abs(array2[i])).AlmostEqualRelative(num19, 7))
					{
						array2[i] = 0f;
						break;
					}
				}
				int num20;
				if (i == num11 - 2)
				{
					num20 = 4;
				}
				else
				{
					int num21;
					for (num21 = num11 - 1; num21 > i; num21--)
					{
						double num19 = 0.0;
						if (num21 != num11 - 1)
						{
							num19 += (double)Math.Abs(array2[num21]);
						}
						if (num21 != i + 1)
						{
							num19 += (double)Math.Abs(array2[num21 - 1]);
						}
						if ((num19 + (double)Math.Abs(array4[num21])).AlmostEqualRelative(num19, 7))
						{
							array4[num21] = 0f;
							break;
						}
					}
					if (num21 == i)
					{
						num20 = 3;
					}
					else if (num21 == num11 - 1)
					{
						num20 = 1;
					}
					else
					{
						num20 = 2;
						i = num21;
					}
				}
				i++;
				float c;
				float s2;
				switch (num20)
				{
				case 1:
				{
					float db = array2[num11 - 2];
					array2[num11 - 2] = 0f;
					for (int num36 = i; num36 < num11 - 1; num36++)
					{
						int num24 = num11 - 2 - num36 + i;
						float da = array4[num24];
						Drotg(ref da, ref db, out c, out s2);
						array4[num24] = da;
						if (num24 != i)
						{
							db = (0f - s2) * array2[num24 - 1];
							array2[num24 - 1] = c * array2[num24 - 1];
						}
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								float num37 = c * array3[num24 * columnsA + k] + s2 * array3[(num11 - 1) * columnsA + k];
								array3[(num11 - 1) * columnsA + k] = c * array3[(num11 - 1) * columnsA + k] - s2 * array3[num24 * columnsA + k];
								array3[num24 * columnsA + k] = num37;
							}
						}
					}
					break;
				}
				case 2:
				{
					float db = array2[i - 1];
					array2[i - 1] = 0f;
					for (int num24 = i; num24 < num11; num24++)
					{
						float da = array4[num24];
						Drotg(ref da, ref db, out c, out s2);
						array4[num24] = da;
						db = (0f - s2) * array2[num24];
						array2[num24] = c * array2[num24];
						if (computeVectors)
						{
							for (int k = 0; k < rowsA; k++)
							{
								float num25 = c * u[num24 * rowsA + k] + s2 * u[(i - 1) * rowsA + k];
								u[(i - 1) * rowsA + k] = c * u[(i - 1) * rowsA + k] - s2 * u[num24 * rowsA + k];
								u[num24 * rowsA + k] = num25;
							}
						}
					}
					break;
				}
				case 3:
				{
					float val = 0f;
					val = Math.Max(val, Math.Abs(array4[num11 - 1]));
					val = Math.Max(val, Math.Abs(array4[num11 - 2]));
					val = Math.Max(val, Math.Abs(array2[num11 - 2]));
					val = Math.Max(val, Math.Abs(array4[i]));
					val = Math.Max(val, Math.Abs(array2[i]));
					float num26 = array4[num11 - 1] / val;
					float num27 = array4[num11 - 2] / val;
					float num28 = array2[num11 - 2] / val;
					float num29 = array4[i] / val;
					float num30 = array2[i] / val;
					float num31 = ((num27 + num26) * (num27 - num26) + num28 * num28) / 2f;
					float num32 = num26 * num28 * (num26 * num28);
					float num33 = 0f;
					if ((double)num31 != 0.0 || (double)num32 != 0.0)
					{
						num33 = (float)Math.Sqrt(num31 * num31 + num32);
						if ((double)num31 < 0.0)
						{
							num33 = 0f - num33;
						}
						num33 = num32 / (num31 + num33);
					}
					float db = (num29 + num26) * (num29 - num26) + num33;
					float db2 = num29 * num30;
					for (int num24 = i; num24 < num11 - 1; num24++)
					{
						Drotg(ref db, ref db2, out c, out s2);
						if (num24 != i)
						{
							array2[num24 - 1] = db;
						}
						db = c * array4[num24] + s2 * array2[num24];
						array2[num24] = c * array2[num24] - s2 * array4[num24];
						db2 = s2 * array4[num24 + 1];
						array4[num24 + 1] = c * array4[num24 + 1];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								float num34 = c * array3[num24 * columnsA + k] + s2 * array3[(num24 + 1) * columnsA + k];
								array3[(num24 + 1) * columnsA + k] = c * array3[(num24 + 1) * columnsA + k] - s2 * array3[num24 * columnsA + k];
								array3[num24 * columnsA + k] = num34;
							}
						}
						Drotg(ref db, ref db2, out c, out s2);
						array4[num24] = db;
						db = c * array2[num24] + s2 * array4[num24 + 1];
						array4[num24 + 1] = 0f - s2 * array2[num24] + c * array4[num24 + 1];
						db2 = s2 * array2[num24 + 1];
						array2[num24 + 1] = c * array2[num24 + 1];
						if (computeVectors && num24 < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								float num35 = c * u[num24 * rowsA + k] + s2 * u[(num24 + 1) * rowsA + k];
								u[(num24 + 1) * rowsA + k] = c * u[(num24 + 1) * rowsA + k] - s2 * u[num24 * rowsA + k];
								u[num24 * rowsA + k] = num35;
							}
						}
					}
					array2[num11 - 2] = db;
					num18++;
					break;
				}
				case 4:
					if ((double)array4[i] < 0.0)
					{
						array4[i] = 0f - array4[i];
						if (computeVectors)
						{
							for (int k = 0; k < columnsA; k++)
							{
								array3[i * columnsA + k] *= -1f;
							}
						}
					}
					for (; i != num17 - 1 && !(array4[i] >= array4[i + 1]); i++)
					{
						float num7 = array4[i];
						array4[i] = array4[i + 1];
						array4[i + 1] = num7;
						if (computeVectors && i < columnsA)
						{
							for (int k = 0; k < columnsA; k++)
							{
								float num22 = array3[i * columnsA + k];
								array3[i * columnsA + k] = array3[(i + 1) * columnsA + k];
								array3[(i + 1) * columnsA + k] = num22;
							}
						}
						if (computeVectors && i < rowsA)
						{
							for (int k = 0; k < rowsA; k++)
							{
								float num23 = u[i * rowsA + k];
								u[i * rowsA + k] = u[(i + 1) * rowsA + k];
								u[(i + 1) * rowsA + k] = num23;
							}
						}
					}
					num18 = 0;
					num11--;
					break;
				}
			}
			if (computeVectors)
			{
				for (int k = 0; k < columnsA; k++)
				{
					for (int l = 0; l < columnsA; l++)
					{
						vt[l * columnsA + k] = array3[k * columnsA + l];
					}
				}
			}
			Buffer.BlockCopy(array4, 0, s, 0, Math.Min(rowsA, columnsA) * 4);
		}

		private static void Drotg(ref float da, ref float db, out float c, out float s)
		{
			float num = db;
			float num2 = Math.Abs(da);
			float num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			float num4 = num2 + num3;
			float num5;
			float num6;
			if ((double)num4 == 0.0)
			{
				c = 1f;
				s = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				float num7 = da / num4;
				float num8 = db / num4;
				num5 = num4 * (float)Math.Sqrt(num7 * num7 + num8 * num8);
				if ((double)num < 0.0)
				{
					num5 = 0f - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1f;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && (double)c != 0.0)
				{
					num6 = 1f / c;
				}
			}
			da = num5;
			db = num6;
		}

		public virtual void SvdSolve(float[] a, int rowsA, int columnsA, float[] b, int columnsB, float[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			float[] s = new float[Math.Min(rowsA, columnsA)];
			float[] u = new float[rowsA * rowsA];
			float[] vt = new float[columnsA * columnsA];
			float[] array = new float[a.Length];
			Buffer.BlockCopy(a, 0, array, 0, a.Length * 4);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		public virtual void SvdSolveFactored(int rowsA, int columnsA, float[] s, float[] u, float[] vt, float[] b, int columnsB, float[] x)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			int num = Math.Min(rowsA, columnsA);
			float[] array = new float[columnsA];
			for (int i = 0; i < columnsB; i++)
			{
				for (int j = 0; j < columnsA; j++)
				{
					float num2 = 0f;
					if (j < num)
					{
						for (int k = 0; k < rowsA; k++)
						{
							num2 += u[j * rowsA + k] * b[i * rowsA + k];
						}
						num2 /= s[j];
					}
					array[j] = num2;
				}
				for (int l = 0; l < columnsA; l++)
				{
					float num3 = 0f;
					for (int m = 0; m < columnsA; m++)
					{
						num3 += vt[l * columnsA + m] * array[m];
					}
					x[i * columnsA + l] = num3;
				}
			}
		}

		public virtual void EigenDecomp(bool isSymmetric, int order, float[] matrix, float[] matrixEv, Complex[] vectorEv, float[] matrixD)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrix");
			}
			if (matrixEv == null)
			{
				throw new ArgumentNullException("matrixEv");
			}
			if (matrixEv.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixEv");
			}
			if (vectorEv == null)
			{
				throw new ArgumentNullException("vectorEv");
			}
			if (vectorEv.Length != order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order}.", "vectorEv");
			}
			if (matrixD == null)
			{
				throw new ArgumentNullException("matrixD");
			}
			if (matrixD.Length != order * order)
			{
				throw new ArgumentException($"The given array has the wrong length. Should be {order * order}.", "matrixD");
			}
			float[] array = new float[order];
			float[] array2 = new float[order];
			if (isSymmetric)
			{
				Buffer.BlockCopy(matrix, 0, matrixEv, 0, matrix.Length * 4);
				int num = order - 1;
				for (int i = 0; i < order; i++)
				{
					array[i] = matrixEv[i * order + num];
				}
				ManagedLinearAlgebraProvider.SymmetricTridiagonalize(matrixEv, array, array2, order);
				ManagedLinearAlgebraProvider.SymmetricDiagonalize(matrixEv, array, array2, order);
			}
			else
			{
				float[] array3 = new float[matrix.Length];
				Buffer.BlockCopy(matrix, 0, array3, 0, matrix.Length * 4);
				ManagedLinearAlgebraProvider.NonsymmetricReduceToHessenberg(matrixEv, array3, order);
				ManagedLinearAlgebraProvider.NonsymmetricReduceHessenberToRealSchur(matrixEv, array3, array, array2, order);
			}
			for (int j = 0; j < order; j++)
			{
				vectorEv[j] = new Complex(array[j], array2[j]);
				int num2 = j * order;
				matrixD[num2 + j] = array[j];
				if (array2[j] > 0f)
				{
					matrixD[num2 + order + j] = array2[j];
				}
				else if (array2[j] < 0f)
				{
					matrixD[num2 - order + j] = array2[j];
				}
			}
		}
	}
}
namespace MathNet.Numerics.Providers.LinearAlgebra.Cuda
{
	internal class CudaLinearAlgebraProvider : ManagedLinearAlgebraProvider, IDisposable
	{
		private const int MinimumCompatibleRevision = 1;

		private readonly string _hintPath;

		private IntPtr _blasHandle;

		private IntPtr _solverHandle;

		[SecuritySafeCritical]
		public override Complex DotProduct(Complex[] x, Complex[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_dot_product(_blasHandle, x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(Complex[] y, Complex alpha, Complex[] x, Complex[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (!(alpha == Complex.Zero))
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_axpy(_blasHandle, y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(Complex alpha, Complex[] x, Complex[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (!(alpha == Complex.One))
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_scale(_blasHandle, x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(Complex[] x, int rowsX, int columnsX, Complex[] y, int rowsY, int columnsY, Complex[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, Complex.One, x, rowsX, columnsX, y, rowsY, columnsY, Complex.Zero, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] a, int rowsA, int columnsA, Complex[] b, int rowsB, int columnsB, Complex beta, Complex[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_matrix_multiply(_blasHandle, transposeA.ToCUDA(), transposeB.ToCUDA(), num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(Complex[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_lu_factor(_solverHandle, order, data, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUInverse(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_lu_inverse(_solverHandle, _blasHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(Complex[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			BLAS(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_lu_inverse_factored(_blasHandle, order, a, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, Complex[] a, int order, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_lu_solve(_solverHandle, order, columnsOfB, a, b));
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, Complex[] a, int order, int[] ipiv, Complex[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_lu_solve_factored(_solverHandle, order, columnsOfB, a, ipiv, b));
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(Complex[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_cholesky_factor(_solverHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_cholesky_solve(_solverHandle, orderA, columnsB, a, b));
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(Complex[] a, int orderA, Complex[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_cholesky_solve_factored(_solverHandle, orderA, columnsB, a, b));
		}

		public override void SvdSolve(Complex[] a, int rowsA, int columnsA, Complex[] b, int columnsB, Complex[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex[] s = new Complex[Math.Min(rowsA, columnsA)];
			Complex[] u = new Complex[rowsA * rowsA];
			Complex[] vt = new Complex[columnsA * columnsA];
			Complex[] array = new Complex[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, Complex[] a, int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (columnsA > rowsA || !computeVectors)
			{
				base.SingularValueDecomposition(computeVectors, a, rowsA, columnsA, s, u, vt);
			}
			else
			{
				Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.z_svd_factor(_solverHandle, computeVectors, rowsA, columnsA, a, s, u, vt));
			}
		}

		[SecuritySafeCritical]
		public override Complex32 DotProduct(Complex32[] x, Complex32[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_dot_product(_blasHandle, x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(Complex32[] y, Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (!(alpha == Complex32.Zero))
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_axpy(_blasHandle, y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(Complex32 alpha, Complex32[] x, Complex32[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (!(alpha == Complex32.One))
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_scale(_blasHandle, x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(Complex32[] x, int rowsX, int columnsX, Complex32[] y, int rowsY, int columnsY, Complex32[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, Complex32.One, x, rowsX, columnsX, y, rowsY, columnsY, Complex32.Zero, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] a, int rowsA, int columnsA, Complex32[] b, int rowsB, int columnsB, Complex32 beta, Complex32[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_matrix_multiply(_blasHandle, transposeA.ToCUDA(), transposeB.ToCUDA(), num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(Complex32[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_lu_factor(_solverHandle, order, data, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUInverse(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_lu_inverse(_solverHandle, _blasHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(Complex32[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			BLAS(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_lu_inverse_factored(_blasHandle, order, a, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, Complex32[] a, int order, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_lu_solve(_solverHandle, order, columnsOfB, a, b));
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, Complex32[] a, int order, int[] ipiv, Complex32[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_lu_solve_factored(_solverHandle, order, columnsOfB, a, ipiv, b));
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(Complex32[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_cholesky_factor(_solverHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_cholesky_solve(_solverHandle, orderA, columnsB, a, b));
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(Complex32[] a, int orderA, Complex32[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_cholesky_solve_factored(_solverHandle, orderA, columnsB, a, b));
		}

		public override void SvdSolve(Complex32[] a, int rowsA, int columnsA, Complex32[] b, int columnsB, Complex32[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			Complex32[] s = new Complex32[Math.Min(rowsA, columnsA)];
			Complex32[] u = new Complex32[rowsA * rowsA];
			Complex32[] vt = new Complex32[columnsA * columnsA];
			Complex32[] array = new Complex32[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, Complex32[] a, int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (columnsA > rowsA || !computeVectors)
			{
				base.SingularValueDecomposition(computeVectors, a, rowsA, columnsA, s, u, vt);
			}
			else
			{
				Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.c_svd_factor(_solverHandle, computeVectors, rowsA, columnsA, a, s, u, vt));
			}
		}

		internal CudaLinearAlgebraProvider(string hintPath)
		{
			_hintPath = hintPath;
		}

		public override bool IsAvailable()
		{
			return CudaProvider.IsAvailable(_hintPath);
		}

		public override void InitializeVerify()
		{
			int num = CudaProvider.Load(_hintPath);
			if (num < 1)
			{
				throw new NotSupportedException(FormattableString.Invariant($"Cuda Native Provider revision r{num} is too old. Consider upgrading to a newer version. Revision r{1} and newer are supported."));
			}
			int num2 = MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.query_capability(128);
			if (num2 != 1)
			{
				throw new NotSupportedException(FormattableString.Invariant($"Cuda Native Provider not compatible. Expecting linear algebra v1 but provider implements v{num2}."));
			}
			BLAS(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.createBLASHandle(ref _blasHandle));
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.createSolverHandle(ref _solverHandle));
		}

		public override void FreeResources()
		{
			CudaProvider.FreeResources();
		}

		private void BLAS(int status)
		{
			switch (status)
			{
			case 0:
				break;
			case 1:
				throw new Exception("The CUDA Runtime initialization failed");
			case 2:
				throw new OutOfMemoryException("The resources could not be allocated");
			case 7:
				throw new ArgumentException("Invalid value");
			case 8:
				throw new NotSupportedException("The device does not support this operation.");
			case 11:
				throw new Exception("Mapping error.");
			case 13:
				throw new Exception("Execution failed");
			case 14:
				throw new Exception("Internal error");
			case 15:
				throw new NotSupportedException();
			case 16:
				throw new Exception("License error");
			default:
				throw new Exception("Unrecognized cuBLAS status code: " + status);
			}
		}

		private void Solver(int status)
		{
			switch (status)
			{
			case 0:
				break;
			case 1:
				throw new Exception("The library was not initialized");
			case 2:
				throw new OutOfMemoryException("The resources could not be allocated");
			case 3:
				throw new ArgumentException("Invalid value");
			case 4:
				throw new NotSupportedException("The device does not support compute capability 2.0 and above");
			case 5:
				throw new Exception("Mapping error");
			case 6:
				throw new NonConvergenceException("Execution failed");
			case 7:
				throw new Exception("Internal error");
			case 8:
				throw new ArgumentException("Matrix type not supported");
			case 9:
				throw new NotSupportedException();
			case 10:
				throw new Exception("Zero pivot");
			case 11:
				throw new Exception("Invalid license");
			default:
				throw new Exception("Unrecognized cuSolverDn status code: " + status);
			}
		}

		public override string ToString()
		{
			return CudaProvider.Describe();
		}

		public void Dispose()
		{
			BLAS(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.destroyBLASHandle(_blasHandle));
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.destroySolverHandle(_solverHandle));
			FreeResources();
		}

		[SecuritySafeCritical]
		public override double DotProduct(double[] x, double[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_dot_product(_blasHandle, x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(double[] y, double alpha, double[] x, double[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (alpha != 0.0)
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_axpy(_blasHandle, y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(double alpha, double[] x, double[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (alpha != 1.0)
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_scale(_blasHandle, x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(double[] x, int rowsX, int columnsX, double[] y, int rowsY, int columnsY, double[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, 1.0, x, rowsX, columnsX, y, rowsY, columnsY, 0.0, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, double alpha, double[] a, int rowsA, int columnsA, double[] b, int rowsB, int columnsB, double beta, double[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_matrix_multiply(_blasHandle, transposeA.ToCUDA(), transposeB.ToCUDA(), num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(double[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_lu_factor(_solverHandle, order, data, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUInverse(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_lu_inverse(_solverHandle, _blasHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(double[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			BLAS(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_lu_inverse_factored(_blasHandle, order, a, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, double[] a, int order, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_lu_solve(_solverHandle, order, columnsOfB, a, b));
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, double[] a, int order, int[] ipiv, double[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_lu_solve_factored(_solverHandle, order, columnsOfB, a, ipiv, b));
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(double[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_cholesky_factor(_solverHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_cholesky_solve(_solverHandle, orderA, columnsB, a, b));
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(double[] a, int orderA, double[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_cholesky_solve_factored(_solverHandle, orderA, columnsB, a, b));
		}

		public override void SvdSolve(double[] a, int rowsA, int columnsA, double[] b, int columnsB, double[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			double[] s = new double[Math.Min(rowsA, columnsA)];
			double[] u = new double[rowsA * rowsA];
			double[] vt = new double[columnsA * columnsA];
			double[] array = new double[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, double[] a, int rowsA, int columnsA, double[] s, double[] u, double[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (columnsA > rowsA || !computeVectors)
			{
				base.SingularValueDecomposition(computeVectors, a, rowsA, columnsA, s, u, vt);
			}
			else
			{
				Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.d_svd_factor(_solverHandle, computeVectors, rowsA, columnsA, a, s, u, vt));
			}
		}

		[SecuritySafeCritical]
		public override float DotProduct(float[] x, float[] y)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != y.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			return MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_dot_product(_blasHandle, x.Length, x, y);
		}

		[SecuritySafeCritical]
		public override void AddVectorToScaledVector(float[] y, float alpha, float[] x, float[] result)
		{
			if (y == null)
			{
				throw new ArgumentNullException("y");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (y.Length != x.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (y != result)
			{
				Array.Copy(y, 0, result, 0, y.Length);
			}
			if (alpha != 0f)
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_axpy(_blasHandle, y.Length, alpha, x, result);
			}
		}

		[SecuritySafeCritical]
		public override void ScaleArray(float alpha, float[] x, float[] result)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x != result)
			{
				Array.Copy(x, 0, result, 0, x.Length);
			}
			if (alpha != 1f)
			{
				MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_scale(_blasHandle, x.Length, alpha, result);
			}
		}

		public override void MatrixMultiply(float[] x, int rowsX, int columnsX, float[] y, int rowsY, int columnsY, float[] result)
		{
			MatrixMultiplyWithUpdate(Transpose.DontTranspose, Transpose.DontTranspose, 1f, x, rowsX, columnsX, y, rowsY, columnsY, 0f, result);
		}

		[SecuritySafeCritical]
		public override void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, float alpha, float[] a, int rowsA, int columnsA, float[] b, int rowsB, int columnsB, float beta, float[] c)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (c == null)
			{
				throw new ArgumentNullException("c");
			}
			int num = ((transposeA == Transpose.DontTranspose) ? rowsA : columnsA);
			int num2 = ((transposeB == Transpose.DontTranspose) ? columnsB : rowsB);
			int num3 = ((transposeA == Transpose.DontTranspose) ? columnsA : rowsA);
			int num4 = ((transposeB == Transpose.DontTranspose) ? rowsB : columnsB);
			if (c.Length != num * num2)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (num3 != num4)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_matrix_multiply(_blasHandle, transposeA.ToCUDA(), transposeB.ToCUDA(), num, num2, num3, alpha, a, b, beta, c);
		}

		[SecuritySafeCritical]
		public override void LUFactor(float[] data, int order, int[] ipiv)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (data.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "data");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_lu_factor(_solverHandle, order, data, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUInverse(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_lu_inverse(_solverHandle, _blasHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void LUInverseFactored(float[] a, int order, int[] ipiv)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			BLAS(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_lu_inverse_factored(_blasHandle, order, a, ipiv));
		}

		[SecuritySafeCritical]
		public override void LUSolve(int columnsOfB, float[] a, int order, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_lu_solve(_solverHandle, order, columnsOfB, a, b));
		}

		[SecuritySafeCritical]
		public override void LUSolveFactored(int columnsOfB, float[] a, int order, int[] ipiv, float[] b)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (ipiv == null)
			{
				throw new ArgumentNullException("ipiv");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			if (ipiv.Length != order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "ipiv");
			}
			if (b.Length != columnsOfB * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_lu_solve_factored(_solverHandle, order, columnsOfB, a, ipiv, b));
		}

		[SecuritySafeCritical]
		public override void CholeskyFactor(float[] a, int order)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (order < 1)
			{
				throw new ArgumentException("Value must be positive.", "order");
			}
			if (a.Length != order * order)
			{
				throw new ArgumentException("The array arguments must have the same length.", "a");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_cholesky_factor(_solverHandle, order, a));
		}

		[SecuritySafeCritical]
		public override void CholeskySolve(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_cholesky_solve(_solverHandle, orderA, columnsB, a, b));
		}

		[SecuritySafeCritical]
		public override void CholeskySolveFactored(float[] a, int orderA, float[] b, int columnsB)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (b.Length != orderA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (a == b)
			{
				throw new ArgumentException("Arguments must be different objects.");
			}
			Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_cholesky_solve_factored(_solverHandle, orderA, columnsB, a, b));
		}

		public override void SvdSolve(float[] a, int rowsA, int columnsA, float[] b, int columnsB, float[] x)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (b == null)
			{
				throw new ArgumentNullException("b");
			}
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (b.Length != rowsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			if (x.Length != columnsA * columnsB)
			{
				throw new ArgumentException("The array arguments must have the same length.", "b");
			}
			float[] s = new float[Math.Min(rowsA, columnsA)];
			float[] u = new float[rowsA * rowsA];
			float[] vt = new float[columnsA * columnsA];
			float[] array = new float[a.Length];
			a.Copy(array);
			SingularValueDecomposition(computeVectors: true, array, rowsA, columnsA, s, u, vt);
			SvdSolveFactored(rowsA, columnsA, s, u, vt, b, columnsB, x);
		}

		[SecuritySafeCritical]
		public override void SingularValueDecomposition(bool computeVectors, float[] a, int rowsA, int columnsA, float[] s, float[] u, float[] vt)
		{
			if (a == null)
			{
				throw new ArgumentNullException("a");
			}
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (u == null)
			{
				throw new ArgumentNullException("u");
			}
			if (vt == null)
			{
				throw new ArgumentNullException("vt");
			}
			if (u.Length != rowsA * rowsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "u");
			}
			if (vt.Length != columnsA * columnsA)
			{
				throw new ArgumentException("The array arguments must have the same length.", "vt");
			}
			if (s.Length != Math.Min(rowsA, columnsA))
			{
				throw new ArgumentException("The array arguments must have the same length.", "s");
			}
			if (columnsA > rowsA || !computeVectors)
			{
				base.SingularValueDecomposition(computeVectors, a, rowsA, columnsA, s, u, vt);
			}
			else
			{
				Solver(MathNet.Numerics.Providers.Common.Cuda.SafeNativeMethods.s_svd_factor(_solverHandle, computeVectors, rowsA, columnsA, a, s, u, vt));
			}
		}
	}
}
namespace MathNet.Numerics.Providers.FourierTransform
{
	public static class FourierTransformControl
	{
		private const string EnvVarFFTProvider = "MathNetNumericsFFTProvider";

		private const string EnvVarFFTProviderPath = "MathNetNumericsFFTProviderPath";

		private static IFourierTransformProvider _fourierTransformProvider;

		private static readonly object StaticLock = new object();

		public static IFourierTransformProvider Provider
		{
			get
			{
				if (_fourierTransformProvider == null)
				{
					lock (StaticLock)
					{
						if (_fourierTransformProvider == null)
						{
							UseDefault();
						}
					}
				}
				return _fourierTransformProvider;
			}
			set
			{
				value.InitializeVerify();
				_fourierTransformProvider = value;
			}
		}

		public static string HintPath { get; set; }

		public static IFourierTransformProvider CreateManaged()
		{
			return new ManagedFourierTransformProvider();
		}

		public static void UseManaged()
		{
			Provider = CreateManaged();
		}

		public static IFourierTransformProvider CreateNativeMKL()
		{
			return new MklFourierTransformProvider(GetCombinedHintPath());
		}

		public static void UseNativeMKL()
		{
			Provider = CreateNativeMKL();
		}

		public static bool TryUseNativeMKL()
		{
			return TryUse(CreateNativeMKL());
		}

		public static bool TryUseNative()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				return false;
			}
			return TryUseNativeMKL();
		}

		private static bool TryUse(IFourierTransformProvider provider)
		{
			try
			{
				if (!provider.IsAvailable())
				{
					return false;
				}
				Provider = provider;
				return true;
			}
			catch
			{
				return false;
			}
		}

		public static void UseBest()
		{
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableNativeProviderProbing)
			{
				UseManaged();
			}
			else if (!TryUseNative())
			{
				UseManaged();
			}
		}

		public static void UseDefault()
		{
			if (AppSwitches.DisableNativeProviders)
			{
				UseManaged();
				return;
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MathNetNumericsFFTProvider");
			string text = ((environmentVariable != null) ? environmentVariable.ToUpperInvariant() : string.Empty);
			if (text != null && text == "MKL")
			{
				UseNativeMKL();
			}
			else
			{
				UseBest();
			}
		}

		public static void FreeResources()
		{
			Provider.FreeResources();
		}

		private static string GetCombinedHintPath()
		{
			if (!string.IsNullOrEmpty(HintPath))
			{
				return HintPath;
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MathNetNumericsFFTProviderPath");
			if (!string.IsNullOrEmpty(environmentVariable))
			{
				return environmentVariable;
			}
			return null;
		}
	}
	public enum FourierTransformScaling
	{
		NoScaling,
		SymmetricScaling,
		BackwardScaling,
		ForwardScaling
	}
	public interface IFourierTransformProvider
	{
		bool IsAvailable();

		void InitializeVerify();

		void FreeResources();

		void Forward(Complex32[] samples, FourierTransformScaling scaling);

		void Forward(Complex[] samples, FourierTransformScaling scaling);

		void Backward(Complex32[] spectrum, FourierTransformScaling scaling);

		void Backward(Complex[] spectrum, FourierTransformScaling scaling);

		void ForwardReal(float[] samples, int n, FourierTransformScaling scaling);

		void ForwardReal(double[] samples, int n, FourierTransformScaling scaling);

		void BackwardReal(float[] spectrum, int n, FourierTransformScaling scaling);

		void BackwardReal(double[] spectrum, int n, FourierTransformScaling scaling);

		void ForwardMultidim(Complex32[] samples, int[] dimensions, FourierTransformScaling scaling);

		void ForwardMultidim(Complex[] samples, int[] dimensions, FourierTransformScaling scaling);

		void BackwardMultidim(Complex32[] spectrum, int[] dimensions, FourierTransformScaling scaling);

		void BackwardMultidim(Complex[] spectrum, int[] dimensions, FourierTransformScaling scaling);
	}
}
namespace MathNet.Numerics.Providers.FourierTransform.Mkl
{
	internal class MklFourierTransformProvider : IFourierTransformProvider, IDisposable
	{
		private class Kernel
		{
			public IntPtr Handle;

			public int[] Dimensions;

			public FourierTransformScaling Scaling;

			public bool Real;

			public bool Single;
		}

		private const int MinimumCompatibleRevision = 11;

		private readonly string _hintPath;

		private Kernel _kernel;

		internal MklFourierTransformProvider(string hintPath)
		{
			_hintPath = hintPath;
		}

		public bool IsAvailable()
		{
			return MklProvider.IsAvailable(_hintPath);
		}

		public void InitializeVerify()
		{
			int num = MklProvider.Load(_hintPath);
			if (num < 11)
			{
				throw new NotSupportedException(FormattableString.Invariant($"MKL Native Provider revision r{num} is too old. Consider upgrading to a newer version. Revision r{11} and newer are supported."));
			}
			int num2 = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(384);
			int num3 = MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.query_capability(385);
			if (num2 != 1 || num3 < 0)
			{
				throw new NotSupportedException(FormattableString.Invariant($"MKL Native Provider not compatible. Expecting Fourier transform v1 but provider implements v{num2}."));
			}
		}

		public virtual void FreeResources()
		{
			Kernel kernel = Interlocked.Exchange(ref _kernel, null);
			if (kernel != null)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.x_fft_free(ref kernel.Handle);
			}
			MklProvider.FreeResources();
		}

		public override string ToString()
		{
			return MklProvider.Describe();
		}

		private Kernel Configure(int length, FourierTransformScaling scaling, bool real, bool single)
		{
			Kernel kernel = Interlocked.Exchange(ref _kernel, null);
			if (kernel == null)
			{
				Kernel kernel2 = new Kernel();
				kernel2.Dimensions = new int[1] { length };
				kernel2.Scaling = scaling;
				kernel2.Real = real;
				kernel2.Single = single;
				kernel = kernel2;
				if (single)
				{
					if (real)
					{
						MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_fft_create(out kernel.Handle, length, (float)ForwardScaling(scaling, length), (float)BackwardScaling(scaling, length));
					}
					else
					{
						MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_create(out kernel.Handle, length, (float)ForwardScaling(scaling, length), (float)BackwardScaling(scaling, length));
					}
				}
				else if (real)
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_fft_create(out kernel.Handle, length, ForwardScaling(scaling, length), BackwardScaling(scaling, length));
				}
				else
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_create(out kernel.Handle, length, ForwardScaling(scaling, length), BackwardScaling(scaling, length));
				}
				return kernel;
			}
			if (kernel.Dimensions.Length != 1 || kernel.Dimensions[0] != length || kernel.Scaling != scaling || kernel.Real != real || kernel.Single != single)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.x_fft_free(ref kernel.Handle);
				if (single)
				{
					if (real)
					{
						MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_fft_create(out kernel.Handle, length, (float)ForwardScaling(scaling, length), (float)BackwardScaling(scaling, length));
					}
					else
					{
						MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_create(out kernel.Handle, length, (float)ForwardScaling(scaling, length), (float)BackwardScaling(scaling, length));
					}
				}
				else if (real)
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_fft_create(out kernel.Handle, length, ForwardScaling(scaling, length), BackwardScaling(scaling, length));
				}
				else
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_create(out kernel.Handle, length, ForwardScaling(scaling, length), BackwardScaling(scaling, length));
				}
				kernel.Dimensions = new int[1] { length };
				kernel.Scaling = scaling;
				kernel.Real = real;
				kernel.Single = single;
				return kernel;
			}
			return kernel;
		}

		private Kernel Configure(int[] dimensions, FourierTransformScaling scaling, bool single)
		{
			if (dimensions.Length == 1)
			{
				return Configure(dimensions[0], scaling, real: false, single);
			}
			Kernel kernel = Interlocked.Exchange(ref _kernel, null);
			if (kernel == null)
			{
				kernel = new Kernel
				{
					Dimensions = dimensions,
					Scaling = scaling,
					Real = false,
					Single = single
				};
				long num = 1L;
				for (int i = 0; i < dimensions.Length; i++)
				{
					num *= dimensions[i];
				}
				if (single)
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_create_multidim(out kernel.Handle, dimensions.Length, dimensions, (float)ForwardScaling(scaling, num), (float)BackwardScaling(scaling, num));
				}
				else
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_create_multidim(out kernel.Handle, dimensions.Length, dimensions, ForwardScaling(scaling, num), BackwardScaling(scaling, num));
				}
				return kernel;
			}
			bool flag = kernel.Dimensions.Length != dimensions.Length || kernel.Scaling != scaling || kernel.Real || kernel.Single != single;
			if (!flag)
			{
				for (int j = 0; j < dimensions.Length; j++)
				{
					if (dimensions[j] != kernel.Dimensions[j])
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				long num2 = 1L;
				for (int k = 0; k < dimensions.Length; k++)
				{
					num2 *= dimensions[k];
				}
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.x_fft_free(ref kernel.Handle);
				if (single)
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_create_multidim(out kernel.Handle, dimensions.Length, dimensions, (float)ForwardScaling(scaling, num2), (float)BackwardScaling(scaling, num2));
				}
				else
				{
					MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_create_multidim(out kernel.Handle, dimensions.Length, dimensions, ForwardScaling(scaling, num2), BackwardScaling(scaling, num2));
				}
				kernel.Dimensions = dimensions;
				kernel.Scaling = scaling;
				kernel.Real = false;
				kernel.Single = single;
				return kernel;
			}
			return kernel;
		}

		private void Release(Kernel kernel)
		{
			Kernel kernel2 = Interlocked.Exchange(ref _kernel, kernel);
			if (kernel2 != null)
			{
				MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.x_fft_free(ref kernel2.Handle);
			}
		}

		public void Forward(Complex32[] samples, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(samples.Length, scaling, real: false, single: true);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_forward(kernel.Handle, samples);
			Release(kernel);
		}

		public void Forward(Complex[] samples, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(samples.Length, scaling, real: false, single: false);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_forward(kernel.Handle, samples);
			Release(kernel);
		}

		public void Backward(Complex32[] spectrum, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(spectrum.Length, scaling, real: false, single: true);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_backward(kernel.Handle, spectrum);
			Release(kernel);
		}

		public void Backward(Complex[] spectrum, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(spectrum.Length, scaling, real: false, single: false);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_backward(kernel.Handle, spectrum);
			Release(kernel);
		}

		public void ForwardReal(float[] samples, int n, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(n, scaling, real: true, single: true);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_fft_forward(kernel.Handle, samples);
			Release(kernel);
		}

		public void ForwardReal(double[] samples, int n, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(n, scaling, real: true, single: false);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_fft_forward(kernel.Handle, samples);
			Release(kernel);
		}

		public void BackwardReal(float[] spectrum, int n, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(n, scaling, real: true, single: true);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.s_fft_backward(kernel.Handle, spectrum);
			Release(kernel);
			spectrum[n] = 0f;
		}

		public void BackwardReal(double[] spectrum, int n, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(n, scaling, real: true, single: false);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.d_fft_backward(kernel.Handle, spectrum);
			Release(kernel);
			spectrum[n] = 0.0;
		}

		public void ForwardMultidim(Complex32[] samples, int[] dimensions, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(dimensions, scaling, single: true);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_forward(kernel.Handle, samples);
			Release(kernel);
		}

		public void ForwardMultidim(Complex[] samples, int[] dimensions, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(dimensions, scaling, single: false);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_forward(kernel.Handle, samples);
			Release(kernel);
		}

		public void BackwardMultidim(Complex32[] spectrum, int[] dimensions, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(dimensions, scaling, single: true);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.c_fft_backward(kernel.Handle, spectrum);
			Release(kernel);
		}

		public void BackwardMultidim(Complex[] spectrum, int[] dimensions, FourierTransformScaling scaling)
		{
			Kernel kernel = Configure(dimensions, scaling, single: false);
			MathNet.Numerics.Providers.Common.Mkl.SafeNativeMethods.z_fft_backward(kernel.Handle, spectrum);
			Release(kernel);
		}

		private static double ForwardScaling(FourierTransformScaling scaling, long length)
		{
			return scaling switch
			{
				FourierTransformScaling.SymmetricScaling => Math.Sqrt(1.0 / (double)length), 
				FourierTransformScaling.ForwardScaling => 1.0 / (double)length, 
				_ => 1.0, 
			};
		}

		private static double BackwardScaling(FourierTransformScaling scaling, long length)
		{
			return scaling switch
			{
				FourierTransformScaling.SymmetricScaling => Math.Sqrt(1.0 / (double)length), 
				FourierTransformScaling.BackwardScaling => 1.0 / (double)length, 
				_ => 1.0, 
			};
		}

		public void Dispose()
		{
			FreeResources();
		}
	}
}
namespace MathNet.Numerics.Providers.FourierTransform.Managed
{
	internal class ManagedFourierTransformProvider : IFourierTransformProvider
	{
		private const int BluesteinSequenceLengthThreshold = 46341;

		private static Complex32[] BluesteinSequence32(int n)
		{
			double num = Math.PI / (double)n;
			Complex32[] array = new Complex32[n];
			if (n > 46341)
			{
				for (int i = 0; i < array.Length; i++)
				{
					double num2 = num * (double)i * (double)i;
					array[i] = new Complex32((float)Math.Cos(num2), (float)Math.Sin(num2));
				}
			}
			else
			{
				for (int j = 0; j < array.Length; j++)
				{
					double num3 = num * (double)(j * j);
					array[j] = new Complex32((float)Math.Cos(num3), (float)Math.Sin(num3));
				}
			}
			return array;
		}

		private static Complex[] BluesteinSequence(int n)
		{
			double num = Math.PI / (double)n;
			Complex[] array = new Complex[n];
			if (n > 46341)
			{
				for (int i = 0; i < array.Length; i++)
				{
					double num2 = num * (double)i * (double)i;
					array[i] = new Complex(Math.Cos(num2), Math.Sin(num2));
				}
			}
			else
			{
				for (int j = 0; j < array.Length; j++)
				{
					double num3 = num * (double)(j * j);
					array[j] = new Complex(Math.Cos(num3), Math.Sin(num3));
				}
			}
			return array;
		}

		private static void BluesteinConvolutionParallel(Complex32[] samples)
		{
			int j = samples.Length;
			Complex32[] sequence = BluesteinSequence32(j);
			int i = ((j << 1) - 1).CeilingToPowerOfTwo();
			Complex32[] b = new Complex32[i];
			Complex32[] a = new Complex32[i];
			CommonParallel.Invoke(delegate
			{
				for (int n = 0; n < j; n++)
				{
					b[n] = sequence[n];
				}
				for (int num2 = i - j + 1; num2 < b.Length; num2++)
				{
					b[num2] = sequence[i - num2];
				}
				Radix2Forward(b);
			}, delegate
			{
				for (int m = 0; m < samples.Length; m++)
				{
					a[m] = sequence[m].Conjugate() * samples[m];
				}
				Radix2Forward(a);
			});
			for (int k = 0; k < a.Length; k++)
			{
				a[k] *= b[k];
			}
			Radix2InverseParallel(a);
			float num = 1f / (float)i;
			for (int l = 0; l < samples.Length; l++)
			{
				samples[l] = num * sequence[l].Conjugate() * a[l];
			}
		}

		private static void BluesteinConvolutionParallel(Complex[] samples)
		{
			int j = samples.Length;
			Complex[] sequence = BluesteinSequence(j);
			int i = ((j << 1) - 1).CeilingToPowerOfTwo();
			Complex[] b = new Complex[i];
			Complex[] a = new Complex[i];
			CommonParallel.Invoke(delegate
			{
				for (int n = 0; n < j; n++)
				{
					b[n] = sequence[n];
				}
				for (int num2 = i - j + 1; num2 < b.Length; num2++)
				{
					b[num2] = sequence[i - num2];
				}
				Radix2Forward(b);
			}, delegate
			{
				for (int m = 0; m < samples.Length; m++)
				{
					a[m] = sequence[m].Conjugate() * samples[m];
				}
				Radix2Forward(a);
			});
			for (int k = 0; k < a.Length; k++)
			{
				a[k] *= b[k];
			}
			Radix2InverseParallel(a);
			double num = 1.0 / (double)i;
			for (int l = 0; l < samples.Length; l++)
			{
				samples[l] = num * sequence[l].Conjugate() * a[l];
			}
		}

		private static void SwapRealImaginary(Complex32[] samples)
		{
			for (int i = 0; i < samples.Length; i++)
			{
				samples[i] = new Complex32(samples[i].Imaginary, samples[i].Real);
			}
		}

		private static void SwapRealImaginary(Complex[] samples)
		{
			for (int i = 0; i < samples.Length; i++)
			{
				samples[i] = new Complex(samples[i].Imaginary, samples[i].Real);
			}
		}

		private static void BluesteinForward(Complex[] samples)
		{
			BluesteinConvolutionParallel(samples);
		}

		private static void BluesteinInverse(Complex[] spectrum)
		{
			SwapRealImaginary(spectrum);
			BluesteinConvolutionParallel(spectrum);
			SwapRealImaginary(spectrum);
		}

		private static void BluesteinForward(Complex32[] samples)
		{
			BluesteinConvolutionParallel(samples);
		}

		private static void BluesteinInverse(Complex32[] spectrum)
		{
			SwapRealImaginary(spectrum);
			BluesteinConvolutionParallel(spectrum);
			SwapRealImaginary(spectrum);
		}

		public bool IsAvailable()
		{
			return true;
		}

		public void InitializeVerify()
		{
		}

		public virtual void FreeResources()
		{
		}

		public override string ToString()
		{
			return "Managed";
		}

		public void Forward(Complex32[] samples, FourierTransformScaling scaling)
		{
			if (samples.Length.IsPowerOfTwo())
			{
				if (samples.Length >= 1024)
				{
					Radix2ForwardParallel(samples);
				}
				else
				{
					Radix2Forward(samples);
				}
			}
			else
			{
				BluesteinForward(samples);
			}
			switch (scaling)
			{
			case FourierTransformScaling.SymmetricScaling:
				HalfRescale(samples);
				break;
			case FourierTransformScaling.ForwardScaling:
				FullRescale(samples);
				break;
			}
		}

		public void Forward(Complex[] samples, FourierTransformScaling scaling)
		{
			if (samples.Length.IsPowerOfTwo())
			{
				if (samples.Length >= 1024)
				{
					Radix2ForwardParallel(samples);
				}
				else
				{
					Radix2Forward(samples);
				}
			}
			else
			{
				BluesteinForward(samples);
			}
			switch (scaling)
			{
			case FourierTransformScaling.SymmetricScaling:
				HalfRescale(samples);
				break;
			case FourierTransformScaling.ForwardScaling:
				FullRescale(samples);
				break;
			}
		}

		public void Backward(Complex32[] spectrum, FourierTransformScaling scaling)
		{
			if (spectrum.Length.IsPowerOfTwo())
			{
				if (spectrum.Length >= 1024)
				{
					Radix2InverseParallel(spectrum);
				}
				else
				{
					Radix2Inverse(spectrum);
				}
			}
			else
			{
				BluesteinInverse(spectrum);
			}
			switch (scaling)
			{
			case FourierTransformScaling.SymmetricScaling:
				HalfRescale(spectrum);
				break;
			case FourierTransformScaling.BackwardScaling:
				FullRescale(spectrum);
				break;
			}
		}

		public void Backward(Complex[] spectrum, FourierTransformScaling scaling)
		{
			if (spectrum.Length.IsPowerOfTwo())
			{
				if (spectrum.Length >= 1024)
				{
					Radix2InverseParallel(spectrum);
				}
				else
				{
					Radix2Inverse(spectrum);
				}
			}
			else
			{
				BluesteinInverse(spectrum);
			}
			switch (scaling)
			{
			case FourierTransformScaling.SymmetricScaling:
				HalfRescale(spectrum);
				break;
			case FourierTransformScaling.BackwardScaling:
				FullRescale(spectrum);
				break;
			}
		}

		public void ForwardReal(float[] samples, int n, FourierTransformScaling scaling)
		{
			Complex32[] array = new Complex32[n];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Complex32(samples[i], 0f);
			}
			Forward(array, scaling);
			samples[0] = array[0].Real;
			samples[1] = 0f;
			int j = 1;
			int num = 2;
			for (; j < array.Length / 2; j++)
			{
				samples[num++] = array[j].Real;
				samples[num++] = array[j].Imaginary;
			}
			if (n.IsEven())
			{
				samples[n] = array[array.Length / 2].Real;
				samples[n + 1] = 0f;
			}
			else
			{
				samples[n - 1] = array[array.Length / 2].Real;
				samples[n] = array[array.Length / 2].Imaginary;
			}
		}

		public void ForwardReal(double[] samples, int n, FourierTransformScaling scaling)
		{
			Complex[] array = new Complex[n];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Complex(samples[i], 0.0);
			}
			Forward(array, scaling);
			samples[0] = array[0].Real;
			samples[1] = 0.0;
			int j = 1;
			int num = 2;
			for (; j < array.Length / 2; j++)
			{
				samples[num++] = array[j].Real;
				samples[num++] = array[j].Imaginary;
			}
			if (n.IsEven())
			{
				samples[n] = array[array.Length / 2].Real;
				samples[n + 1] = 0.0;
			}
			else
			{
				samples[n - 1] = array[array.Length / 2].Real;
				samples[n] = array[array.Length / 2].Imaginary;
			}
		}

		public void BackwardReal(float[] spectrum, int n, FourierTransformScaling scaling)
		{
			Complex32[] array = new Complex32[n];
			array[0] = new Complex32(spectrum[0], 0f);
			int i = 1;
			int num = 2;
			for (; i < array.Length / 2; i++)
			{
				array[i] = new Complex32(spectrum[num++], spectrum[num++]);
				array[array.Length - i] = array[i].Conjugate();
			}
			if (n.IsEven())
			{
				array[array.Length / 2] = new Complex32(spectrum[n], 0f);
			}
			else
			{
				array[array.Length / 2] = new Complex32(spectrum[n - 1], spectrum[n]);
				array[array.Length / 2 + 1] = array[array.Length / 2].Conjugate();
			}
			Backward(array, scaling);
			for (int j = 0; j < array.Length; j++)
			{
				spectrum[j] = array[j].Real;
			}
			spectrum[n] = 0f;
		}

		public void BackwardReal(double[] spectrum, int n, FourierTransformScaling scaling)
		{
			Complex[] array = new Complex[n];
			array[0] = new Complex(spectrum[0], 0.0);
			int i = 1;
			int num = 2;
			for (; i < array.Length / 2; i++)
			{
				array[i] = new Complex(spectrum[num++], spectrum[num++]);
				array[array.Length - i] = array[i].Conjugate();
			}
			if (n.IsEven())
			{
				array[array.Length / 2] = new Complex(spectrum[n], 0.0);
			}
			else
			{
				array[array.Length / 2] = new Complex(spectrum[n - 1], spectrum[n]);
				array[array.Length / 2 + 1] = array[array.Length / 2].Conjugate();
			}
			Backward(array, scaling);
			for (int j = 0; j < array.Length; j++)
			{
				spectrum[j] = array[j].Real;
			}
			spectrum[n] = 0.0;
		}

		public void ForwardMultidim(Complex32[] samples, int[] dimensions, FourierTransformScaling scaling)
		{
			throw new NotSupportedException();
		}

		public void ForwardMultidim(Complex[] samples, int[] dimensions, FourierTransformScaling scaling)
		{
			throw new NotSupportedException();
		}

		public void BackwardMultidim(Complex32[] spectrum, int[] dimensions, FourierTransformScaling scaling)
		{
			throw new NotSupportedException();
		}

		public void BackwardMultidim(Complex[] spectrum, int[] dimensions, FourierTransformScaling scaling)
		{
			throw new NotSupportedException();
		}

		private static void FullRescale(Complex32[] samples)
		{
			float num = 1f / (float)samples.Length;
			for (int i = 0; i < samples.Length; i++)
			{
				samples[i] *= num;
			}
		}

		private static void FullRescale(Complex[] samples)
		{
			double num = 1.0 / (double)samples.Length;
			for (int i = 0; i < samples.Length; i++)
			{
				samples[i] *= (Complex)num;
			}
		}

		private static void HalfRescale(Complex32[] samples)
		{
			float num = (float)Math.Sqrt(1.0 / (double)samples.Length);
			for (int i = 0; i < samples.Length; i++)
			{
				samples[i] *= num;
			}
		}

		private static void HalfRescale(Complex[] samples)
		{
			double num = Math.Sqrt(1.0 / (double)samples.Length);
			for (int i = 0; i < samples.Length; i++)
			{
				samples[i] *= (Complex)num;
			}
		}

		private static void Radix2Reorder<T>(T[] samples)
		{
			int num = 0;
			for (int i = 0; i < samples.Length - 1; i++)
			{
				if (i < num)
				{
					T val = samples[i];
					samples[i] = samples[num];
					samples[num] = val;
				}
				int num2 = samples.Length;
				do
				{
					num2 >>= 1;
					num ^= num2;
				}
				while ((num & num2) == 0);
			}
		}

		private static void Radix2Step(Complex32[] samples, int exponentSign, int levelSize, int k)
		{
			double num = (double)(exponentSign * k) * Math.PI / (double)levelSize;
			Complex32 complex = new Complex32((float)Math.Cos(num), (float)Math.Sin(num));
			int num2 = levelSize << 1;
			for (int i = k; i < samples.Length; i += num2)
			{
				Complex32 complex2 = samples[i];
				Complex32 complex3 = complex * samples[i + levelSize];
				samples[i] = complex2 + complex3;
				samples[i + levelSize] = complex2 - complex3;
			}
		}

		private static void Radix2Step(Complex[] samples, int exponentSign, int levelSize, int k)
		{
			double num = (double)(exponentSign * k) * Math.PI / (double)levelSize;
			Complex complex = new Complex(Math.Cos(num), Math.Sin(num));
			int num2 = levelSize << 1;
			for (int i = k; i < samples.Length; i += num2)
			{
				Complex complex2 = samples[i];
				Complex complex3 = complex * samples[i + levelSize];
				samples[i] = complex2 + complex3;
				samples[i + levelSize] = complex2 - complex3;
			}
		}

		private static void Radix2Forward(Complex32[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				for (int i = 0; i < num; i++)
				{
					Radix2Step(data, -1, num, i);
				}
			}
		}

		private static void Radix2Forward(Complex[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				for (int i = 0; i < num; i++)
				{
					Radix2Step(data, -1, num, i);
				}
			}
		}

		private static void Radix2Inverse(Complex32[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				for (int i = 0; i < num; i++)
				{
					Radix2Step(data, 1, num, i);
				}
			}
		}

		private static void Radix2Inverse(Complex[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				for (int i = 0; i < num; i++)
				{
					Radix2Step(data, 1, num, i);
				}
			}
		}

		private static void Radix2ForwardParallel(Complex32[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				int size = num;
				CommonParallel.For(0, size, 64, delegate(int u, int v)
				{
					for (int i = u; i < v; i++)
					{
						Radix2Step(data, -1, size, i);
					}
				});
			}
		}

		private static void Radix2ForwardParallel(Complex[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				int size = num;
				CommonParallel.For(0, size, 64, delegate(int u, int v)
				{
					for (int i = u; i < v; i++)
					{
						Radix2Step(data, -1, size, i);
					}
				});
			}
		}

		private static void Radix2InverseParallel(Complex32[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				int size = num;
				CommonParallel.For(0, size, 64, delegate(int u, int v)
				{
					for (int i = u; i < v; i++)
					{
						Radix2Step(data, 1, size, i);
					}
				});
			}
		}

		private static void Radix2InverseParallel(Complex[] data)
		{
			Radix2Reorder(data);
			for (int num = 1; num < data.Length; num *= 2)
			{
				int size = num;
				CommonParallel.For(0, size, 64, delegate(int u, int v)
				{
					for (int i = u; i < v; i++)
					{
						Radix2Step(data, 1, size, i);
					}
				});
			}
		}
	}
}
namespace MathNet.Numerics.Providers.Common
{
	internal static class NativeProviderLoader
	{
		[SuppressUnmanagedCodeSecurity]
		[SecurityCritical]
		private static class WindowsLoader
		{
			private const uint LOAD_WITH_ALTERED_SEARCH_PATH = 8u;

			public static IntPtr LoadLibrary(string fileName)
			{
				return LoadLibraryEx(fileName, IntPtr.Zero, 8u);
			}

			[DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
			private static extern IntPtr LoadLibraryEx(string fileName, IntPtr reservedNull, uint flags);
		}

		[SuppressUnmanagedCodeSecurity]
		[SecurityCritical]
		private static class UnixLoader
		{
			private const int RTLD_NOW = 2;

			public static IntPtr LoadLibrary(string fileName)
			{
				return dlopen(fileName, 2);
			}

			[DllImport("libdl.so", SetLastError = true)]
			private static extern IntPtr dlopen(string fileName, int flags);
		}

		private static readonly object StaticLock = new object();

		private const string X86 = "x86";

		private const string X64 = "x64";

		private const string IA64 = "ia64";

		private const string ARM = "arm";

		private const string ARM64 = "arm64";

		private static readonly Lazy<Dictionary<string, IntPtr>> NativeHandles = new Lazy<Dictionary<string, IntPtr>>(LazyThreadSafetyMode.PublicationOnly);

		private static readonly Lazy<string> ArchitectureKey = new Lazy<string>(EvaluateArchitectureKey, LazyThreadSafetyMode.PublicationOnly);

		internal static Exception LastException { get; private set; }

		private static bool IsUnix
		{
			get
			{
				PlatformID platform = Environment.OSVersion.Platform;
				if (platform != PlatformID.Unix)
				{
					return platform == PlatformID.MacOSX;
				}
				return true;
			}
		}

		private static string EvaluateArchitectureKey()
		{
			if (IsUnix)
			{
				if (!Environment.Is64BitProcess)
				{
					return "x86";
				}
				return "x64";
			}
			string environmentVariable = Environment.GetEnvironmentVariable("PROCESSOR_ARCHITECTURE");
			if (string.Equals(environmentVariable, "x86", StringComparison.OrdinalIgnoreCase))
			{
				return "x86";
			}
			if (string.Equals(environmentVariable, "amd64", StringComparison.OrdinalIgnoreCase) || string.Equals(environmentVariable, "x64", StringComparison.OrdinalIgnoreCase))
			{
				if (!Environment.Is64BitProcess)
				{
					return "x86";
				}
				return "x64";
			}
			if (string.Equals(environmentVariable, "ia64", StringComparison.OrdinalIgnoreCase))
			{
				return "ia64";
			}
			if (string.Equals(environmentVariable, "arm", StringComparison.OrdinalIgnoreCase))
			{
				if (!Environment.Is64BitProcess)
				{
					return "arm";
				}
				return "arm64";
			}
			return environmentVariable;
		}

		internal static bool TryLoad(string fileName, string hintPath)
		{
			if (string.IsNullOrEmpty(fileName))
			{
				throw new ArgumentNullException("fileName");
			}
			if (TryLoadFromDirectory(fileName, hintPath))
			{
				return true;
			}
			if (Control.NativeProviderPath != hintPath && TryLoadFromDirectory(fileName, Control.NativeProviderPath))
			{
				return true;
			}
			if (TryLoadFromDirectory(fileName, AppDomain.CurrentDomain.BaseDirectory))
			{
				return true;
			}
			if (TryLoadFromDirectory(fileName, Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)))
			{
				return true;
			}
			return false;
		}

		private static bool TryLoadFromDirectory(string fileName, string directory)
		{
			if (!Directory.Exists(directory))
			{
				return false;
			}
			directory = Path.GetFullPath(directory);
			string value = ArchitectureKey.Value;
			if (!string.IsNullOrEmpty(value) && TryLoadFile(new FileInfo(Path.Combine(Path.Combine(directory, value), fileName))))
			{
				return true;
			}
			return TryLoadFile(new FileInfo(Path.Combine(directory, fileName)));
		}

		private static bool TryLoadFile(FileInfo file)
		{
			lock (StaticLock)
			{
				if (NativeHandles.Value.TryGetValue(file.Name, out var value))
				{
					return true;
				}
				if (!file.Exists)
				{
					return false;
				}
				value = (IsUnix ? UnixLoader.LoadLibrary(file.FullName) : WindowsLoader.LoadLibrary(file.FullName));
				if (value == IntPtr.Zero)
				{
					LastException = new Win32Exception(Marshal.GetLastWin32Error());
				}
				else
				{
					LastException = null;
					NativeHandles.Value[file.Name] = value;
				}
				return value != IntPtr.Zero;
			}
		}
	}
}
namespace MathNet.Numerics.Providers.Common.OpenBlas
{
	public static class OpenBlasProvider
	{
		private const int DesignTimeRevision = 1;

		private const int MinimumCompatibleRevision = 1;

		private static int _nativeRevision;

		private static bool _nativeX86;

		private static bool _nativeX64;

		private static bool _nativeIA64;

		private static bool _nativeARM;

		private static bool _loaded;

		public static bool IsAvailable(string hintPath = null)
		{
			if (_loaded)
			{
				return true;
			}
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableOpenBlasNativeProvider)
			{
				return false;
			}
			try
			{
				if (!NativeProviderLoader.TryLoad(SafeNativeMethods.DllName, hintPath))
				{
					return false;
				}
				int num = SafeNativeMethods.query_capability(0);
				int num2 = SafeNativeMethods.query_capability(1);
				int num3 = SafeNativeMethods.query_capability(64);
				return num == 0 && num2 == -1 && num3 >= 1;
			}
			catch
			{
				return false;
			}
		}

		public static int Load(string hintPath = null)
		{
			if (_loaded)
			{
				return _nativeRevision;
			}
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableOpenBlasNativeProvider)
			{
				throw new NotSupportedException("OpenBLAS Native Provider support is actively disabled by AppSwitches.");
			}
			int num;
			int num2;
			try
			{
				NativeProviderLoader.TryLoad(SafeNativeMethods.DllName, hintPath);
				num = SafeNativeMethods.query_capability(0);
				num2 = SafeNativeMethods.query_capability(1);
				_nativeRevision = SafeNativeMethods.query_capability(64);
				_nativeX86 = SafeNativeMethods.query_capability(8) > 0;
				_nativeX64 = SafeNativeMethods.query_capability(9) > 0;
				_nativeIA64 = SafeNativeMethods.query_capability(10) > 0;
				_nativeARM = SafeNativeMethods.query_capability(11) > 0;
			}
			catch (DllNotFoundException innerException)
			{
				throw new NotSupportedException("OpenBLAS Native Provider not found.", innerException);
			}
			catch (BadImageFormatException innerException2)
			{
				throw new NotSupportedException("OpenBLAS Native Provider found but failed to load. Please verify that the platform matches (x64 vs x32, Windows vs Linux).", innerException2);
			}
			catch (EntryPointNotFoundException innerException3)
			{
				throw new NotSupportedException("OpenBLAS Native Provider does not support capability querying and is therefore not compatible. Consider upgrading to a newer version.", innerException3);
			}
			if (num != 0 || num2 != -1 || _nativeRevision < 1)
			{
				throw new NotSupportedException("OpenBLAS Native Provider too old. Consider upgrading to a newer version.");
			}
			if (SafeNativeMethods.query_capability(66) > 0)
			{
				SafeNativeMethods.set_max_threads(Control.MaxDegreeOfParallelism);
			}
			_loaded = true;
			return _nativeRevision;
		}

		public static void FreeResources()
		{
		}

		internal static void ConfigureThreading()
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(66) > 0)
			{
				SafeNativeMethods.set_max_threads(Control.MaxDegreeOfParallelism);
			}
		}

		public static string Describe()
		{
			if (!_loaded)
			{
				return "OpenBLAS (not loaded)";
			}
			List<string> list = new List<string>();
			if (_nativeX86)
			{
				list.Add("x86");
			}
			if (_nativeX64)
			{
				list.Add("x64");
			}
			if (_nativeIA64)
			{
				list.Add("IA64");
			}
			if (_nativeARM)
			{
				list.Add("ARM");
			}
			list.Add("revision " + _nativeRevision);
			return "OpenBLAS (" + string.Join("; ", list.ToArray()) + ")";
		}
	}
	internal enum ProviderPlatform
	{
		x86 = 8,
		x64,
		ia64,
		arm
	}
	internal enum ProviderConfig
	{
		Revision = 64,
		Threading = 66
	}
	internal enum ProviderCapability
	{
		LinearAlgebraMajor = 128,
		LinearAlgebraMinor
	}
	[SuppressUnmanagedCodeSecurity]
	[SecurityCritical]
	internal static class SafeNativeMethods
	{
		private const string _DllName = "MathNET.Numerics.OpenBLAS.dll";

		internal static string DllName => "MathNET.Numerics.OpenBLAS.dll";

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int query_capability(int capability);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern string get_build_config();

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern string get_cpu_core();

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern ParallelType get_parallel_type();

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void set_max_threads(int num_threads);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_axpy(int n, float alpha, float[] x, [In][Out] float[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_axpy(int n, double alpha, double[] x, [In][Out] double[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_axpy(int n, Complex32 alpha, Complex32[] x, [In][Out] Complex32[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_axpy(int n, Complex alpha, Complex[] x, [In][Out] Complex[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_scale(int n, float alpha, [Out] float[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_scale(int n, double alpha, [Out] double[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_scale(int n, Complex32 alpha, [In][Out] Complex32[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_scale(int n, Complex alpha, [In][Out] Complex[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float s_dot_product(int n, float[] x, float[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double d_dot_product(int n, double[] x, double[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern Complex32 c_dot_product(int n, Complex32[] x, Complex32[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern Complex z_dot_product(int n, Complex[] x, Complex[] y);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, float alpha, float[] x, float[] y, float beta, [In][Out] float[] c);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, double alpha, double[] x, double[] y, double beta, [In][Out] double[] c);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, Complex32 alpha, Complex32[] x, Complex32[] y, Complex32 beta, [In][Out] Complex32[] c);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, Complex alpha, Complex[] x, Complex[] y, Complex beta, [In][Out] Complex[] c);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float s_matrix_norm(byte norm, int rows, int columns, [In] float[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double d_matrix_norm(byte norm, int rows, int columns, [In] double[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float c_matrix_norm(byte norm, int rows, int columns, [In] Complex32[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double z_matrix_norm(byte norm, int rows, int columns, [In] Complex[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_factor(int n, [In][Out] float[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_factor(int n, [In][Out] double[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_factor(int n, [In][Out] Complex32[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_factor(int n, [In][Out] Complex[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_factor(int n, [In][Out] float[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_factor(int n, [In][Out] double[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_factor(int n, [In][Out] Complex32[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_factor(int n, [In][Out] Complex[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_inverse(int n, [In][Out] float[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_inverse(int n, [In][Out] double[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_inverse(int n, [In][Out] Complex32[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_inverse(int n, [In][Out] Complex[] a);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_inverse_factored(int n, [In][Out] float[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_inverse_factored(int n, [In][Out] double[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_inverse_factored(int n, [In][Out] Complex32[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_inverse_factored(int n, [In][Out] Complex[] a, [In][Out] int[] ipiv);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_solve_factored(int n, int nrhs, float[] a, [In][Out] int[] ipiv, [In][Out] float[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_solve_factored(int n, int nrhs, double[] a, [In][Out] int[] ipiv, [In][Out] double[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_solve_factored(int n, int nrhs, Complex32[] a, [In][Out] int[] ipiv, [In][Out] Complex32[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_solve_factored(int n, int nrhs, Complex[] a, [In][Out] int[] ipiv, [In][Out] Complex[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_solve(int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_solve(int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_solve(int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_solve(int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_solve(int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_solve(int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_solve(int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_solve(int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_solve_factored(int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_solve_factored(int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_solve_factored(int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_solve_factored(int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_factor(int m, int n, [In][Out] float[] r, [In][Out] float[] tau, [In][Out] float[] q);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_factor(int m, int n, [In][Out] double[] r, [In][Out] double[] tau, [In][Out] double[] q);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_factor(int m, int n, [In][Out] Complex32[] r, [In][Out] Complex32[] tau, [In][Out] Complex32[] q);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_factor(int m, int n, [In][Out] Complex[] r, [In][Out] Complex[] tau, [In][Out] Complex[] q);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_thin_factor(int m, int n, [In][Out] float[] q, [In][Out] float[] tau, [In][Out] float[] r);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_thin_factor(int m, int n, [In][Out] double[] q, [In][Out] double[] tau, [In][Out] double[] r);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_thin_factor(int m, int n, [In][Out] Complex32[] q, [In][Out] Complex32[] tau, [In][Out] Complex32[] r);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_thin_factor(int m, int n, [In][Out] Complex[] q, [In][Out] Complex[] tau, [In][Out] Complex[] r);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_solve(int m, int n, int bn, float[] r, float[] b, [In][Out] float[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_solve(int m, int n, int bn, double[] r, double[] b, [In][Out] double[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_solve(int m, int n, int bn, Complex32[] r, Complex32[] b, [In][Out] Complex32[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_solve(int m, int n, int bn, Complex[] r, Complex[] b, [In][Out] Complex[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_solve_factored(int m, int n, int bn, float[] r, float[] b, float[] tau, [In][Out] float[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_solve_factored(int m, int n, int bn, double[] r, double[] b, double[] tau, [In][Out] double[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_solve_factored(int m, int n, int bn, Complex32[] r, Complex32[] b, Complex32[] tau, [In][Out] Complex32[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_solve_factored(int m, int n, int bn, Complex[] r, Complex[] b, Complex[] tau, [In][Out] Complex[] x);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] float[] a, [In][Out] float[] s, [In][Out] float[] u, [In][Out] float[] v);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] double[] a, [In][Out] double[] s, [In][Out] double[] u, [In][Out] double[] v);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] Complex32[] a, [In][Out] Complex32[] s, [In][Out] Complex32[] u, [In][Out] Complex32[] v);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] Complex[] a, [In][Out] Complex[] s, [In][Out] Complex[] u, [In][Out] Complex[] v);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] float[] a, [In][Out] float[] vectors, [In][Out] Complex[] values, [In][Out] float[] d);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] double[] a, [In][Out] double[] vectors, [In][Out] Complex[] values, [In][Out] double[] d);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] Complex32[] a, [In][Out] Complex32[] vectors, [In][Out] Complex[] values, [In][Out] Complex32[] d);

		[DllImport("MathNET.Numerics.OpenBLAS.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] Complex[] a, [In][Out] Complex[] vectors, [In][Out] Complex[] values, [In][Out] Complex[] d);
	}
}
namespace MathNet.Numerics.Providers.Common.Mkl
{
	public static class MklProvider
	{
		private enum MklMemoryRequestMode
		{
			Disable = 0,
			Enable = 1,
			PeakMemory = 2,
			PeakMemoryReset = -1
		}

		private const int DesignTimeRevision = 14;

		private const int MinimumCompatibleRevision = 4;

		private static int _nativeRevision;

		private static Version _mklVersion;

		private static bool _nativeX86;

		private static bool _nativeX64;

		private static bool _nativeIA64;

		private static bool _loaded;

		public static bool IsAvailable(string hintPath = null)
		{
			if (_loaded)
			{
				return true;
			}
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableMklNativeProvider)
			{
				return false;
			}
			try
			{
				if (!NativeProviderLoader.TryLoad(SafeNativeMethods.DllName, hintPath))
				{
					return false;
				}
				int num = SafeNativeMethods.query_capability(0);
				int num2 = SafeNativeMethods.query_capability(1);
				int num3 = SafeNativeMethods.query_capability(64);
				return num == 0 && num2 == -1 && num3 >= 4;
			}
			catch
			{
				return false;
			}
		}

		public static int Load(string hintPath = null)
		{
			return Load(hintPath, MklConsistency.Auto, MklPrecision.Double, MklAccuracy.High);
		}

		[CLSCompliant(false)]
		public static int Load(string hintPath = null, MklConsistency consistency = MklConsistency.Auto, MklPrecision precision = MklPrecision.Double, MklAccuracy accuracy = MklAccuracy.High)
		{
			if (_loaded)
			{
				return _nativeRevision;
			}
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableMklNativeProvider)
			{
				throw new NotSupportedException("MKL Native Provider support is actively disabled by AppSwitches.");
			}
			int num;
			int num2;
			try
			{
				NativeProviderLoader.TryLoad(SafeNativeMethods.DllName, hintPath);
				num = SafeNativeMethods.query_capability(0);
				num2 = SafeNativeMethods.query_capability(1);
				_nativeRevision = SafeNativeMethods.query_capability(64);
				_nativeX86 = SafeNativeMethods.query_capability(8) > 0;
				_nativeX64 = SafeNativeMethods.query_capability(9) > 0;
				_nativeIA64 = SafeNativeMethods.query_capability(10) > 0;
				if (SafeNativeMethods.query_capability(65) > 0)
				{
					SafeNativeMethods.set_consistency_mode((int)consistency);
					SafeNativeMethods.set_vml_mode((uint)precision | (uint)accuracy);
				}
				if (SafeNativeMethods.query_capability(66) > 0)
				{
					SafeNativeMethods.set_max_threads(Control.MaxDegreeOfParallelism);
				}
				_mklVersion = new Version(SafeNativeMethods.query_capability(32), SafeNativeMethods.query_capability(33), SafeNativeMethods.query_capability(34));
			}
			catch (DllNotFoundException innerException)
			{
				throw new NotSupportedException("MKL Native Provider not found.", innerException);
			}
			catch (BadImageFormatException innerException2)
			{
				throw new NotSupportedException("MKL Native Provider found but failed to load. Please verify that the platform matches (x64 vs x32, Windows vs Linux).", innerException2);
			}
			catch (EntryPointNotFoundException innerException3)
			{
				throw new NotSupportedException("MKL Native Provider does not support capability querying and is therefore not compatible. Consider upgrading to a newer version.", innerException3);
			}
			if (num != 0 || num2 != -1 || _nativeRevision < 4)
			{
				throw new NotSupportedException("MKL Native Provider too old. Consider upgrading to a newer version.");
			}
			_loaded = true;
			return _nativeRevision;
		}

		public static void FreeResources()
		{
			if (_loaded)
			{
				FreeBuffers();
			}
		}

		public static void FreeBuffers()
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			SafeNativeMethods.free_buffers();
		}

		public static void ThreadFreeBuffers()
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			SafeNativeMethods.thread_free_buffers();
		}

		public static void DisableMemoryPool()
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			SafeNativeMethods.disable_fast_mm();
		}

		public static long MemoryStatistics(out int allocatedBuffers)
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			return SafeNativeMethods.mem_stat(out allocatedBuffers);
		}

		public static void EnablePeakMemoryStatistics()
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			SafeNativeMethods.peak_mem_usage(1);
		}

		public static void DisablePeakMemoryStatistics()
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			SafeNativeMethods.peak_mem_usage(0);
		}

		public static long PeakMemoryStatistics(bool reset = true)
		{
			if (!_loaded)
			{
				throw new InvalidOperationException();
			}
			if (SafeNativeMethods.query_capability(67) < 1)
			{
				throw new NotSupportedException("MKL Native Provider does not support memory management functions. Consider upgrading to a newer version.");
			}
			return SafeNativeMethods.peak_mem_usage(reset ? (-1) : 2);
		}

		public static string Describe()
		{
			if (!_loaded)
			{
				return "Intel MKL (not loaded)";
			}
			List<string> list = new List<string>();
			if (_nativeX86)
			{
				list.Add("x86");
			}
			if (_nativeX64)
			{
				list.Add("x64");
			}
			if (_nativeIA64)
			{
				list.Add("IA64");
			}
			list.Add("revision " + _nativeRevision);
			if (_nativeRevision > 14)
			{
				list.Add("ahead revision " + 14);
			}
			if (_nativeRevision < 14)
			{
				list.Add("behind revision " + 14);
			}
			if (_mklVersion.Major > 0)
			{
				list.Add((_mklVersion.Build == 0) ? ("MKL " + _mklVersion.ToString(2)) : ("MKL " + _mklVersion.ToString(2) + " Update " + _mklVersion.Build));
			}
			return "Intel MKL (" + string.Join("; ", list.ToArray()) + ")";
		}
	}
	internal enum ProviderPlatform
	{
		x86 = 8,
		x64,
		ia64
	}
	internal enum ProviderConfig
	{
		MklMajorVersion = 32,
		MklMinorVersion = 33,
		MklUpdateVersion = 34,
		Revision = 64,
		Precision = 65,
		Threading = 66,
		Memory = 67
	}
	internal enum ProviderCapability
	{
		LinearAlgebraMajor = 128,
		LinearAlgebraMinor = 129,
		VectorFunctionsMajor = 130,
		VectorFunctionsMinor = 131,
		FourierTransformMajor = 384,
		FourierTransformMinor = 385,
		SparseSolverMajor = 512,
		SparseSolverMinor = 513
	}
	public enum MklConsistency
	{
		Auto = 2,
		Compatible = 3,
		SSE2 = 4,
		SSE4_2 = 8,
		AVX = 9,
		AVX2 = 10
	}
	[CLSCompliant(false)]
	public enum MklAccuracy : uint
	{
		Low = 1u,
		High
	}
	[CLSCompliant(false)]
	public enum MklPrecision : uint
	{
		Single = 0x10u,
		Double = 0x20u
	}
	[SuppressUnmanagedCodeSecurity]
	[SecurityCritical]
	internal static class SafeNativeMethods
	{
		private const string _DllName = "MathNet.Numerics.MKL.dll";

		internal static string DllName => "MathNet.Numerics.MKL.dll";

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int query_capability(int capability);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void set_consistency_mode(int mode);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void set_vml_mode(uint mode);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void set_max_threads(int num_threads);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void free_buffers();

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void thread_free_buffers();

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int disable_fast_mm();

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern long mem_stat(out int allocatedBuffers);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern long peak_mem_usage(int mode);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_axpy(int n, float alpha, float[] x, [In][Out] float[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_axpy(int n, double alpha, double[] x, [In][Out] double[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_axpy(int n, Complex32 alpha, Complex32[] x, [In][Out] Complex32[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_axpy(int n, Complex alpha, Complex[] x, [In][Out] Complex[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_scale(int n, float alpha, [Out] float[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_scale(int n, double alpha, [Out] double[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_scale(int n, Complex32 alpha, [In][Out] Complex32[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_scale(int n, Complex alpha, [In][Out] Complex[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float s_dot_product(int n, float[] x, float[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double d_dot_product(int n, double[] x, double[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern Complex32 c_dot_product(int n, Complex32[] x, Complex32[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern Complex z_dot_product(int n, Complex[] x, Complex[] y);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, float alpha, float[] x, float[] y, float beta, [In][Out] float[] c);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, double alpha, double[] x, double[] y, double beta, [In][Out] double[] c);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, Complex32 alpha, Complex32[] x, Complex32[] y, Complex32 beta, [In][Out] Complex32[] c);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_matrix_multiply(Transpose transA, Transpose transB, int m, int n, int k, Complex alpha, Complex[] x, Complex[] y, Complex beta, [In][Out] Complex[] c);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float s_matrix_norm(byte norm, int rows, int columns, [In] float[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double d_matrix_norm(byte norm, int rows, int columns, [In] double[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float c_matrix_norm(byte norm, int rows, int columns, [In] Complex32[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double z_matrix_norm(byte norm, int rows, int columns, [In] Complex[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_factor(int n, [In][Out] float[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_factor(int n, [In][Out] double[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_factor(int n, [In][Out] Complex32[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_factor(int n, [In][Out] Complex[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_factor(int n, [In][Out] float[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_factor(int n, [In][Out] double[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_factor(int n, [In][Out] Complex32[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_factor(int n, [In][Out] Complex[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_inverse(int n, [In][Out] float[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_inverse(int n, [In][Out] double[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_inverse(int n, [In][Out] Complex32[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_inverse(int n, [In][Out] Complex[] a);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_inverse_factored(int n, [In][Out] float[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_inverse_factored(int n, [In][Out] double[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_inverse_factored(int n, [In][Out] Complex32[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_inverse_factored(int n, [In][Out] Complex[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_solve_factored(int n, int nrhs, float[] a, [In][Out] int[] ipiv, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_solve_factored(int n, int nrhs, double[] a, [In][Out] int[] ipiv, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_solve_factored(int n, int nrhs, Complex32[] a, [In][Out] int[] ipiv, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_solve_factored(int n, int nrhs, Complex[] a, [In][Out] int[] ipiv, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_solve(int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_solve(int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_solve(int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_solve(int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_solve(int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_solve(int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_solve(int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_solve(int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_solve_factored(int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_solve_factored(int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_solve_factored(int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_solve_factored(int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_factor(int m, int n, [In][Out] float[] r, [In][Out] float[] tau, [In][Out] float[] q);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_factor(int m, int n, [In][Out] double[] r, [In][Out] double[] tau, [In][Out] double[] q);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_factor(int m, int n, [In][Out] Complex32[] r, [In][Out] Complex32[] tau, [In][Out] Complex32[] q);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_factor(int m, int n, [In][Out] Complex[] r, [In][Out] Complex[] tau, [In][Out] Complex[] q);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_thin_factor(int m, int n, [In][Out] float[] q, [In][Out] float[] tau, [In][Out] float[] r);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_thin_factor(int m, int n, [In][Out] double[] q, [In][Out] double[] tau, [In][Out] double[] r);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_thin_factor(int m, int n, [In][Out] Complex32[] q, [In][Out] Complex32[] tau, [In][Out] Complex32[] r);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_thin_factor(int m, int n, [In][Out] Complex[] q, [In][Out] Complex[] tau, [In][Out] Complex[] r);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_solve(int m, int n, int bn, float[] r, float[] b, [In][Out] float[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_solve(int m, int n, int bn, double[] r, double[] b, [In][Out] double[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_solve(int m, int n, int bn, Complex32[] r, Complex32[] b, [In][Out] Complex32[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_solve(int m, int n, int bn, Complex[] r, Complex[] b, [In][Out] Complex[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_qr_solve_factored(int m, int n, int bn, float[] r, float[] b, float[] tau, [In][Out] float[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_qr_solve_factored(int m, int n, int bn, double[] r, double[] b, double[] tau, [In][Out] double[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_qr_solve_factored(int m, int n, int bn, Complex32[] r, Complex32[] b, Complex32[] tau, [In][Out] Complex32[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_qr_solve_factored(int m, int n, int bn, Complex[] r, Complex[] b, Complex[] tau, [In][Out] Complex[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] float[] a, [In][Out] float[] s, [In][Out] float[] u, [In][Out] float[] v);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] double[] a, [In][Out] double[] s, [In][Out] double[] u, [In][Out] double[] v);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] Complex32[] a, [In][Out] Complex32[] s, [In][Out] Complex32[] u, [In][Out] Complex32[] v);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_svd_factor([MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] Complex[] a, [In][Out] Complex[] s, [In][Out] Complex[] u, [In][Out] Complex[] v);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] float[] a, [In][Out] float[] vectors, [In][Out] Complex[] values, [In][Out] float[] d);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] double[] a, [In][Out] double[] vectors, [In][Out] Complex[] values, [In][Out] double[] d);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] Complex32[] a, [In][Out] Complex32[] vectors, [In][Out] Complex[] values, [In][Out] Complex32[] d);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_eigen([MarshalAs(UnmanagedType.U1)] bool isSymmetric, int n, [In] Complex[] a, [In][Out] Complex[] vectors, [In][Out] Complex[] values, [In][Out] Complex[] d);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_vector_add(int n, float[] x, float[] y, [In][Out] float[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_vector_subtract(int n, float[] x, float[] y, [In][Out] float[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_vector_multiply(int n, float[] x, float[] y, [In][Out] float[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_vector_divide(int n, float[] x, float[] y, [In][Out] float[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_vector_power(int n, float[] x, float[] y, [In][Out] float[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_vector_add(int n, double[] x, double[] y, [In][Out] double[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_vector_subtract(int n, double[] x, double[] y, [In][Out] double[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_vector_multiply(int n, double[] x, double[] y, [In][Out] double[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_vector_divide(int n, double[] x, double[] y, [In][Out] double[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_vector_power(int n, double[] x, double[] y, [In][Out] double[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_vector_add(int n, Complex32[] x, Complex32[] y, [In][Out] Complex32[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_vector_subtract(int n, Complex32[] x, Complex32[] y, [In][Out] Complex32[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_vector_multiply(int n, Complex32[] x, Complex32[] y, [In][Out] Complex32[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_vector_divide(int n, Complex32[] x, Complex32[] y, [In][Out] Complex32[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_vector_power(int n, Complex32[] x, Complex32[] y, [In][Out] Complex32[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_vector_add(int n, Complex[] x, Complex[] y, [In][Out] Complex[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_vector_subtract(int n, Complex[] x, Complex[] y, [In][Out] Complex[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_vector_multiply(int n, Complex[] x, Complex[] y, [In][Out] Complex[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_vector_divide(int n, Complex[] x, Complex[] y, [In][Out] Complex[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_vector_power(int n, Complex[] x, Complex[] y, [In][Out] Complex[] result);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int x_fft_free([In] ref IntPtr handle);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_fft_create(out IntPtr handle, int n, double forward_scale, double backward_scale);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_fft_create(out IntPtr handle, int n, float forward_scale, float backward_scale);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_fft_create(out IntPtr handle, int n, double forward_scale, double backward_scale);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_fft_create(out IntPtr handle, int n, float forward_scale, float backward_scale);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_fft_create_multidim(out IntPtr handle, int dimensions, [In] int[] n, double forward_scale, double backward_scale);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_fft_create_multidim(out IntPtr handle, int dimensions, [In] int[] n, float forward_scale, float backward_scale);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_fft_forward([In] IntPtr handle, [In][Out] Complex[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_fft_forward([In] IntPtr handle, [In][Out] Complex32[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_fft_forward([In] IntPtr handle, [In][Out] double[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_fft_forward([In] IntPtr handle, [In][Out] float[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_fft_backward([In] IntPtr handle, [In][Out] Complex[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_fft_backward([In] IntPtr handle, [In][Out] Complex32[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_fft_backward([In] IntPtr handle, [In][Out] double[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_fft_backward([In] IntPtr handle, [In][Out] float[] x);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_dss_solve(int matrixStructure, int matrixType, int systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, float[] values, int nRhs, [In][Out] float[] rhs, [In][Out] float[] solution);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_dss_solve(int matrixStructure, int matrixType, int systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, double[] values, int nRhs, [In][Out] double[] rhs, [In][Out] double[] solution);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_dss_solve(int matrixStructure, int matrixType, int systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, Complex32[] values, int nRhs, [In][Out] Complex32[] rhs, [In][Out] Complex32[] solution);

		[DllImport("MathNet.Numerics.MKL.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_dss_solve(int matrixStructure, int matrixType, int systemType, int rowCount, int columnCount, int nonZerosCount, int[] rowPointers, int[] columnIndices, Complex[] values, int nRhs, [In][Out] Complex[] rhs, [In][Out] Complex[] solution);
	}
}
namespace MathNet.Numerics.Providers.Common.Cuda
{
	public static class CudaProvider
	{
		private const int DesignTimeRevision = 1;

		private const int MinimumCompatibleRevision = 1;

		private static int _nativeRevision;

		private static bool _nativeX86;

		private static bool _nativeX64;

		private static bool _nativeIA64;

		private static bool _loaded;

		public static bool IsAvailable(string hintPath = null)
		{
			if (_loaded)
			{
				return true;
			}
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableCudaNativeProvider)
			{
				return false;
			}
			try
			{
				if (!NativeProviderLoader.TryLoad(SafeNativeMethods.DllName, hintPath))
				{
					return false;
				}
				int num = SafeNativeMethods.query_capability(0);
				int num2 = SafeNativeMethods.query_capability(1);
				int num3 = SafeNativeMethods.query_capability(64);
				return num == 0 && num2 == -1 && num3 >= 1;
			}
			catch
			{
				return false;
			}
		}

		public static int Load(string hintPath = null)
		{
			if (_loaded)
			{
				return _nativeRevision;
			}
			if (AppSwitches.DisableNativeProviders || AppSwitches.DisableCudaNativeProvider)
			{
				throw new NotSupportedException("CUDA Native Provider support is actively disabled by AppSwitches.");
			}
			int num;
			int num2;
			try
			{
				NativeProviderLoader.TryLoad(SafeNativeMethods.DllName, hintPath);
				num = SafeNativeMethods.query_capability(0);
				num2 = SafeNativeMethods.query_capability(1);
				_nativeRevision = SafeNativeMethods.query_capability(64);
				_nativeX86 = SafeNativeMethods.query_capability(8) > 0;
				_nativeX64 = SafeNativeMethods.query_capability(9) > 0;
				_nativeIA64 = SafeNativeMethods.query_capability(10) > 0;
			}
			catch (DllNotFoundException innerException)
			{
				throw new NotSupportedException("Cuda Native Provider not found.", innerException);
			}
			catch (BadImageFormatException innerException2)
			{
				throw new NotSupportedException("Cuda Native Provider found but failed to load. Please verify that the platform matches (x64 vs x32, Windows vs Linux).", innerException2);
			}
			catch (EntryPointNotFoundException innerException3)
			{
				throw new NotSupportedException("Cuda Native Provider does not support capability querying and is therefore not compatible. Consider upgrading to a newer version.", innerException3);
			}
			if (num != 0 || num2 != -1 || _nativeRevision < 1)
			{
				throw new NotSupportedException("Cuda Native Provider too old. Consider upgrading to a newer version.");
			}
			_loaded = true;
			return _nativeRevision;
		}

		public static void FreeResources()
		{
		}

		public static string Describe()
		{
			if (!_loaded)
			{
				return "Nvidia CUDA (not loaded)";
			}
			List<string> list = new List<string>();
			if (_nativeX86)
			{
				list.Add("x86");
			}
			if (_nativeX64)
			{
				list.Add("x64");
			}
			if (_nativeIA64)
			{
				list.Add("IA64");
			}
			list.Add("revision " + _nativeRevision);
			return "Nvidia CUDA (" + string.Join("; ", list.ToArray()) + ")";
		}
	}
	internal enum ProviderPlatform
	{
		x86 = 8,
		x64,
		ia64
	}
	internal enum ProviderConfig
	{
		Revision = 0x40
	}
	internal enum ProviderCapability
	{
		LinearAlgebraMajor = 128,
		LinearAlgebraMinor
	}
	[SuppressUnmanagedCodeSecurity]
	[SecurityCritical]
	internal static class SafeNativeMethods
	{
		private const string _DllName = "MathNet.Numerics.CUDA.dll";

		internal static string DllName => "MathNet.Numerics.CUDA.dll";

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int query_capability(int capability);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int createBLASHandle(ref IntPtr blasHandle);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int destroyBLASHandle(IntPtr blasHandle);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int createSolverHandle(ref IntPtr solverHandle);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int destroySolverHandle(IntPtr solverHandle);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_axpy(IntPtr blasHandle, int n, float alpha, float[] x, [In][Out] float[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_axpy(IntPtr blasHandle, int n, double alpha, double[] x, [In][Out] double[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_axpy(IntPtr blasHandle, int n, Complex32 alpha, Complex32[] x, [In][Out] Complex32[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_axpy(IntPtr blasHandle, int n, Complex alpha, Complex[] x, [In][Out] Complex[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_scale(IntPtr blasHandle, int n, float alpha, [Out] float[] x);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_scale(IntPtr blasHandle, int n, double alpha, [Out] double[] x);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_scale(IntPtr blasHandle, int n, Complex32 alpha, [In][Out] Complex32[] x);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_scale(IntPtr blasHandle, int n, Complex alpha, [In][Out] Complex[] x);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern float s_dot_product(IntPtr blasHandle, int n, float[] x, float[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern double d_dot_product(IntPtr blasHandle, int n, double[] x, double[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern Complex32 c_dot_product(IntPtr blasHandle, int n, Complex32[] x, Complex32[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern Complex z_dot_product(IntPtr blasHandle, int n, Complex[] x, Complex[] y);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void s_matrix_multiply(IntPtr blasHandle, int transA, int transB, int m, int n, int k, float alpha, float[] x, float[] y, float beta, [In][Out] float[] c);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void d_matrix_multiply(IntPtr blasHandle, int transA, int transB, int m, int n, int k, double alpha, double[] x, double[] y, double beta, [In][Out] double[] c);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void c_matrix_multiply(IntPtr blasHandle, int transA, int transB, int m, int n, int k, Complex32 alpha, Complex32[] x, Complex32[] y, Complex32 beta, [In][Out] Complex32[] c);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern void z_matrix_multiply(IntPtr blasHandle, int transA, int transB, int m, int n, int k, Complex alpha, Complex[] x, Complex[] y, Complex beta, [In][Out] Complex[] c);

		internal static int ToCUDA(this Transpose transpose)
		{
			return transpose switch
			{
				Transpose.DontTranspose => 0, 
				Transpose.Transpose => 1, 
				Transpose.ConjugateTranspose => 2, 
				_ => throw new ArgumentException("Unsupported transpose: " + transpose), 
			};
		}

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_factor(IntPtr solverHandle, int n, [In][Out] float[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_factor(IntPtr solverHandle, int n, [In][Out] double[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_factor(IntPtr solverHandle, int n, [In][Out] Complex32[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_factor(IntPtr solverHandle, int n, [In][Out] Complex[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_factor(IntPtr solverHandle, int n, [In][Out] float[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_factor(IntPtr solverHandle, int n, [In][Out] double[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_factor(IntPtr solverHandle, int n, [In][Out] Complex32[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_factor(IntPtr solverHandle, int n, [In][Out] Complex[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_inverse(IntPtr solverHandle, IntPtr blasHandle, int n, [In][Out] float[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_inverse(IntPtr solverHandle, IntPtr blasHandle, int n, [In][Out] double[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_inverse(IntPtr solverHandle, IntPtr blasHandle, int n, [In][Out] Complex32[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_inverse(IntPtr solverHandle, IntPtr blasHandle, int n, [In][Out] Complex[] a);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_inverse_factored(IntPtr blasHandle, int n, [In][Out] float[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_inverse_factored(IntPtr blasHandle, int n, [In][Out] double[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_inverse_factored(IntPtr blasHandle, int n, [In][Out] Complex32[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_inverse_factored(IntPtr blasHandle, int n, [In][Out] Complex[] a, [In][Out] int[] ipiv);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_solve_factored(IntPtr solverHandle, int n, int nrhs, float[] a, [In][Out] int[] ipiv, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_solve_factored(IntPtr solverHandle, int n, int nrhs, double[] a, [In][Out] int[] ipiv, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_solve_factored(IntPtr solverHandle, int n, int nrhs, Complex32[] a, [In][Out] int[] ipiv, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_solve_factored(IntPtr solverHandle, int n, int nrhs, Complex[] a, [In][Out] int[] ipiv, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_lu_solve(IntPtr solverHandle, int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_lu_solve(IntPtr solverHandle, int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_lu_solve(IntPtr solverHandle, int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_lu_solve(IntPtr solverHandle, int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_solve(IntPtr solverHandle, int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_solve(IntPtr solverHandle, int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_solve(IntPtr solverHandle, int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_solve(IntPtr solverHandle, int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_cholesky_solve_factored(IntPtr solverHandle, int n, int nrhs, float[] a, [In][Out] float[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_cholesky_solve_factored(IntPtr solverHandle, int n, int nrhs, double[] a, [In][Out] double[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_cholesky_solve_factored(IntPtr solverHandle, int n, int nrhs, Complex32[] a, [In][Out] Complex32[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_cholesky_solve_factored(IntPtr solverHandle, int n, int nrhs, Complex[] a, [In][Out] Complex[] b);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int s_svd_factor(IntPtr solverHandle, [MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] float[] a, [In][Out] float[] s, [In][Out] float[] u, [In][Out] float[] v);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int d_svd_factor(IntPtr solverHandle, [MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] double[] a, [In][Out] double[] s, [In][Out] double[] u, [In][Out] double[] v);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int c_svd_factor(IntPtr solverHandle, [MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] Complex32[] a, [In][Out] Complex32[] s, [In][Out] Complex32[] u, [In][Out] Complex32[] v);

		[DllImport("MathNet.Numerics.CUDA.dll", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
		internal static extern int z_svd_factor(IntPtr solverHandle, [MarshalAs(UnmanagedType.U1)] bool computeVectors, int m, int n, [In][Out] Complex[] a, [In][Out] Complex[] s, [In][Out] Complex[] u, [In][Out] Complex[] v);
	}
}
namespace MathNet.Numerics.Optimization
{
	public class BfgsBMinimizer : BfgsMinimizerBase
	{
		private Vector<double> _lowerBound;

		private Vector<double> _upperBound;

		public BfgsBMinimizer(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations = 1000)
			: base(gradientTolerance, parameterTolerance, functionProgressTolerance, maximumIterations)
		{
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objective, Vector<double> lowerBound, Vector<double> upperBound, Vector<double> initialGuess)
		{
			_lowerBound = lowerBound;
			_upperBound = upperBound;
			if (!objective.IsGradientSupported)
			{
				throw new IncompatibleObjectiveException("Gradient not supported in objective function, but required for BFGS minimization.");
			}
			if (lowerBound.Count != upperBound.Count || lowerBound.Count != initialGuess.Count)
			{
				throw new ArgumentException("Dimensions of bounds and/or initial guess do not match.");
			}
			for (int i = 0; i < initialGuess.Count; i++)
			{
				if (initialGuess[i] < lowerBound[i] || initialGuess[i] > upperBound[i])
				{
					throw new ArgumentException("Initial guess is not in the feasible region");
				}
			}
			objective.EvaluateAt(initialGuess);
			ValidateGradientAndObjective(objective);
			ExitCondition exitCondition = ExitCriteriaSatisfied(objective, null, 0);
			if (exitCondition != 0)
			{
				return new MinimizationResult(objective, 0, exitCondition);
			}
			StrongWolfeLineSearch strongWolfeLineSearch = new StrongWolfeLineSearch(0.0001, 0.9, Math.Max(base.ParameterTolerance, 1E-05), 1000);
			Matrix<double> inversePseudoHessian = CreateMatrix.DiagonalIdentity<double>(initialGuess.Count);
			QuadraticGradientProjectionSearch.GradientProjectionResult gradientProjectionResult = QuadraticGradientProjectionSearch.Search(objective.Point, objective.Gradient, inversePseudoHessian, lowerBound, upperBound);
			Vector<double> cauchyPoint = gradientProjectionResult.CauchyPoint;
			int fixedCount = gradientProjectionResult.FixedCount;
			List<bool> isFixed = gradientProjectionResult.IsFixed;
			int num = lowerBound.Count - fixedCount;
			Vector<double> vector3;
			if (num > 0)
			{
				Vector<double> vector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num);
				Matrix<double> matrix = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix(num, num);
				List<int> reducedMap = new List<int>(num);
				Vector<double> vector2 = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num);
				Vector<double> reducedCauchyPoint = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num);
				CreateReducedData(objective.Point, cauchyPoint, isFixed, lowerBound, upperBound, objective.Gradient, inversePseudoHessian, vector2, reducedCauchyPoint, vector, matrix, reducedMap);
				Vector<double> reducedVector = vector2 + matrix.Cholesky().Solve(-vector);
				vector3 = ReducedToFull(reducedMap, reducedVector, cauchyPoint);
			}
			else
			{
				vector3 = cauchyPoint;
			}
			Vector<double> vector4 = vector3 - cauchyPoint;
			double val = FindMaxStep(cauchyPoint, vector4, lowerBound, upperBound);
			Vector<double> lineSearchDirection = cauchyPoint + Math.Min(val, 1.0) * vector4 - objective.Point;
			double num2 = FindMaxStep(objective.Point, lineSearchDirection, lowerBound, upperBound);
			double initialStep = Math.Min(Math.Max(-objective.Gradient * lineSearchDirection / (lineSearchDirection * inversePseudoHessian * lineSearchDirection), 1.0), num2);
			LineSearchResult lineSearchResult;
			try
			{
				lineSearchResult = strongWolfeLineSearch.FindConformingStep(objective, lineSearchDirection, initialStep, num2);
			}
			catch (Exception inner_exception)
			{
				throw new InnerOptimizationException("Line search failed.", inner_exception);
			}
			IObjectiveFunction previousPoint = objective.Fork();
			IObjectiveFunction candidate = lineSearchResult.FunctionInfoAtMinimum;
			ValidateGradientAndObjective(candidate);
			exitCondition = ExitCriteriaSatisfied(candidate, previousPoint, 0);
			if (exitCondition != 0)
			{
				return new MinimizationResult(candidate, 0, exitCondition);
			}
			_ = candidate.Gradient;
			Vector<double> step = candidate.Point - initialGuess;
			int totalLineSearchSteps = lineSearchResult.Iterations;
			int iterationsWithNontrivialLineSearch = ((lineSearchResult.Iterations <= 0) ? 1 : 0);
			int num3 = DoBfgsUpdate(ref exitCondition, strongWolfeLineSearch, ref inversePseudoHessian, ref lineSearchDirection, ref previousPoint, ref lineSearchResult, ref candidate, ref step, ref totalLineSearchSteps, ref iterationsWithNontrivialLineSearch);
			if (num3 == base.MaximumIterations && exitCondition == ExitCondition.None)
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({base.MaximumIterations}) reached."));
			}
			return new MinimizationWithLineSearchResult(candidate, num3, exitCondition, totalLineSearchSteps, iterationsWithNontrivialLineSearch);
		}

		protected override Vector<double> CalculateSearchDirection(ref Matrix<double> pseudoHessian, out double maxLineSearchStep, out double startingStepSize, IObjectiveFunction previousPoint, IObjectiveFunction candidatePoint, Vector<double> step)
		{
			Vector<double> vector = candidatePoint.Gradient - previousPoint.Gradient;
			double num = step * vector;
			if (num > 0.0)
			{
				_ = step * step;
				Vector<double> vector2 = pseudoHessian * step;
				double num2 = step * pseudoHessian * step;
				pseudoHessian = pseudoHessian + vector.OuterProduct(vector) * (1.0 / num) - vector2.OuterProduct(vector2) * (1.0 / num2);
			}
			QuadraticGradientProjectionSearch.GradientProjectionResult gradientProjectionResult = QuadraticGradientProjectionSearch.Search(candidatePoint.Point, candidatePoint.Gradient, pseudoHessian, _lowerBound, _upperBound);
			Vector<double> cauchyPoint = gradientProjectionResult.CauchyPoint;
			int fixedCount = gradientProjectionResult.FixedCount;
			List<bool> isFixed = gradientProjectionResult.IsFixed;
			int num3 = _lowerBound.Count - fixedCount;
			Vector<double> vector3;
			if (num3 > 0)
			{
				MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num3);
				MathNet.Numerics.LinearAlgebra.Double.DenseMatrix denseMatrix = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix(num3, num3);
				List<int> reducedMap = new List<int>(num3);
				MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector2 = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num3);
				MathNet.Numerics.LinearAlgebra.Double.DenseVector reducedCauchyPoint = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num3);
				CreateReducedData(candidatePoint.Point, cauchyPoint, isFixed, _lowerBound, _upperBound, candidatePoint.Gradient, pseudoHessian, denseVector2, reducedCauchyPoint, denseVector, denseMatrix, reducedMap);
				Vector<double> reducedVector = denseVector2 + denseMatrix.Cholesky().Solve(-denseVector);
				vector3 = ReducedToFull(reducedMap, reducedVector, cauchyPoint);
			}
			else
			{
				vector3 = cauchyPoint;
			}
			Vector<double> vector4 = vector3 - cauchyPoint;
			double val = FindMaxStep(cauchyPoint, vector4, _lowerBound, _upperBound);
			Vector<double> vector5 = cauchyPoint + Math.Min(val, 1.0) * vector4 - candidatePoint.Point;
			maxLineSearchStep = FindMaxStep(candidatePoint.Point, vector5, _lowerBound, _upperBound);
			if (maxLineSearchStep == 0.0)
			{
				vector5 = cauchyPoint - candidatePoint.Point;
				maxLineSearchStep = FindMaxStep(candidatePoint.Point, vector5, _lowerBound, _upperBound);
			}
			double val2 = -candidatePoint.Gradient * vector5 / (vector5 * pseudoHessian * vector5);
			startingStepSize = Math.Min(Math.Max(val2, 1.0), maxLineSearchStep);
			return vector5;
		}

		private static Vector<double> ReducedToFull(List<int> reducedMap, Vector<double> reducedVector, Vector<double> fullVector)
		{
			Vector<double> vector = fullVector.Clone();
			for (int i = 0; i < reducedMap.Count; i++)
			{
				vector[reducedMap[i]] = reducedVector[i];
			}
			return vector;
		}

		private static double FindMaxStep(Vector<double> startingPoint, Vector<double> searchDirection, Vector<double> lowerBound, Vector<double> upperBound)
		{
			double num = double.PositiveInfinity;
			for (int i = 0; i < startingPoint.Count; i++)
			{
				double num2 = ((searchDirection[i] > 0.0) ? ((upperBound[i] - startingPoint[i]) / searchDirection[i]) : ((!(searchDirection[i] < 0.0)) ? double.PositiveInfinity : ((startingPoint[i] - lowerBound[i]) / (0.0 - searchDirection[i]))));
				if (num2 < num)
				{
					num = num2;
				}
			}
			return num;
		}

		private static void CreateReducedData(Vector<double> initialPoint, Vector<double> cauchyPoint, List<bool> isFixed, Vector<double> lowerBound, Vector<double> upperBound, Vector<double> gradient, Matrix<double> pseudoHessian, Vector<double> reducedInitialPoint, Vector<double> reducedCauchyPoint, Vector<double> reducedGradient, Matrix<double> reducedHessian, List<int> reducedMap)
		{
			int num = 0;
			for (int i = 0; i < lowerBound.Count; i++)
			{
				if (isFixed[i])
				{
					continue;
				}
				int num2 = 0;
				for (int j = 0; j < lowerBound.Count; j++)
				{
					if (!isFixed[j])
					{
						reducedHessian[num, num2++] = pseudoHessian[i, j];
					}
				}
				reducedInitialPoint[num] = initialPoint[i];
				reducedCauchyPoint[num] = cauchyPoint[i];
				reducedGradient[num] = gradient[i];
				num++;
				reducedMap.Add(i);
			}
		}

		protected override double GetProjectedGradient(IObjectiveFunctionEvaluation candidatePoint, int ii)
		{
			bool flag = candidatePoint.Point[ii] - _lowerBound[ii] < 1E-15;
			bool flag2 = _upperBound[ii] - candidatePoint.Point[ii] < 1E-15;
			if (flag && flag2)
			{
				return 0.0;
			}
			if (flag)
			{
				return Math.Min(candidatePoint.Gradient[ii], 0.0);
			}
			if (flag2)
			{
				return Math.Max(candidatePoint.Gradient[ii], 0.0);
			}
			return base.GetProjectedGradient(candidatePoint, ii);
		}
	}
	public class BfgsMinimizer : BfgsMinimizerBase, IUnconstrainedMinimizer
	{
		public BfgsMinimizer(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations = 1000)
			: base(gradientTolerance, parameterTolerance, functionProgressTolerance, maximumIterations)
		{
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objective, Vector<double> initialGuess)
		{
			if (!objective.IsGradientSupported)
			{
				throw new IncompatibleObjectiveException("Gradient not supported in objective function, but required for BFGS minimization.");
			}
			objective.EvaluateAt(initialGuess);
			ValidateGradientAndObjective(objective);
			ExitCondition currentExitCondition = ExitCriteriaSatisfied(objective, null, 0);
			if (currentExitCondition != 0)
			{
				return new MinimizationResult(objective, 0, currentExitCondition);
			}
			WeakWolfeLineSearch weakWolfeLineSearch = new WeakWolfeLineSearch(0.0001, 0.9, Math.Max(base.ParameterTolerance, 1E-10), 1000);
			Matrix<double> inversePseudoHessian = CreateMatrix.DenseIdentity<double>(initialGuess.Count);
			Vector<double> lineSearchDirection = -objective.Gradient;
			double initialStep = 100.0 * base.GradientTolerance / (lineSearchDirection * lineSearchDirection);
			IObjectiveFunction previousPoint = objective;
			LineSearchResult lineSearchResult;
			try
			{
				lineSearchResult = weakWolfeLineSearch.FindConformingStep(objective, lineSearchDirection, initialStep);
			}
			catch (OptimizationException inner_exception)
			{
				throw new InnerOptimizationException("Line search failed.", inner_exception);
			}
			catch (ArgumentException inner_exception2)
			{
				throw new InnerOptimizationException("Line search failed.", inner_exception2);
			}
			IObjectiveFunction candidate = lineSearchResult.FunctionInfoAtMinimum;
			ValidateGradientAndObjective(candidate);
			_ = candidate.Gradient;
			Vector<double> step = candidate.Point - initialGuess;
			CreateMatrix.DiagonalIdentity<double>(initialGuess.Count);
			int totalLineSearchSteps = lineSearchResult.Iterations;
			int iterationsWithNontrivialLineSearch = ((lineSearchResult.Iterations <= 0) ? 1 : 0);
			int num = DoBfgsUpdate(ref currentExitCondition, weakWolfeLineSearch, ref inversePseudoHessian, ref lineSearchDirection, ref previousPoint, ref lineSearchResult, ref candidate, ref step, ref totalLineSearchSteps, ref iterationsWithNontrivialLineSearch);
			if (num == base.MaximumIterations && currentExitCondition == ExitCondition.None)
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({base.MaximumIterations}) reached."));
			}
			return new MinimizationWithLineSearchResult(candidate, num, ExitCondition.AbsoluteGradient, totalLineSearchSteps, iterationsWithNontrivialLineSearch);
		}

		protected override Vector<double> CalculateSearchDirection(ref Matrix<double> inversePseudoHessian, out double maxLineSearchStep, out double startingStepSize, IObjectiveFunction previousPoint, IObjectiveFunction candidate, Vector<double> step)
		{
			startingStepSize = 1.0;
			maxLineSearchStep = double.PositiveInfinity;
			Vector<double> vector = candidate.Gradient - previousPoint.Gradient;
			double num = step * vector;
			inversePseudoHessian = inversePseudoHessian + (num + vector * inversePseudoHessian * vector) / Math.Pow(num, 2.0) * step.OuterProduct(step) - (inversePseudoHessian * vector.ToColumnMatrix() * step.ToRowMatrix() + step.ToColumnMatrix() * (vector.ToRowMatrix() * inversePseudoHessian)) * (1.0 / num);
			Vector<double> vector2 = -inversePseudoHessian * candidate.Gradient;
			if (vector2 * candidate.Gradient >= 0.0)
			{
				vector2 = -candidate.Gradient;
				inversePseudoHessian = CreateMatrix.DenseIdentity<double>(candidate.Point.Count);
			}
			return vector2;
		}
	}
	public abstract class BfgsMinimizerBase : MinimizerBase
	{
		protected BfgsMinimizerBase(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations)
			: base(gradientTolerance, parameterTolerance, functionProgressTolerance, maximumIterations)
		{
		}

		protected int DoBfgsUpdate(ref ExitCondition currentExitCondition, WolfeLineSearch lineSearcher, ref Matrix<double> inversePseudoHessian, ref Vector<double> lineSearchDirection, ref IObjectiveFunction previousPoint, ref LineSearchResult lineSearchResult, ref IObjectiveFunction candidate, ref Vector<double> step, ref int totalLineSearchSteps, ref int iterationsWithNontrivialLineSearch)
		{
			int i;
			for (i = 1; i < base.MaximumIterations; i++)
			{
				lineSearchDirection = CalculateSearchDirection(ref inversePseudoHessian, out var maxLineSearchStep, out var startingStepSize, previousPoint, candidate, step);
				try
				{
					lineSearchResult = lineSearcher.FindConformingStep(candidate, lineSearchDirection, startingStepSize, maxLineSearchStep);
				}
				catch (Exception inner_exception)
				{
					throw new InnerOptimizationException("Line search failed.", inner_exception);
				}
				iterationsWithNontrivialLineSearch += ((lineSearchResult.Iterations > 0) ? 1 : 0);
				totalLineSearchSteps += lineSearchResult.Iterations;
				step = lineSearchResult.FunctionInfoAtMinimum.Point - candidate.Point;
				previousPoint = candidate;
				candidate = lineSearchResult.FunctionInfoAtMinimum;
				currentExitCondition = ExitCriteriaSatisfied(candidate, previousPoint, i);
				if (currentExitCondition != 0)
				{
					break;
				}
			}
			return i;
		}

		protected abstract Vector<double> CalculateSearchDirection(ref Matrix<double> inversePseudoHessian, out double maxLineSearchStep, out double startingStepSize, IObjectiveFunction previousPoint, IObjectiveFunction candidate, Vector<double> step);
	}
	public static class BfgsSolver
	{
		private const double GradientTolerance = 1E-05;

		private const int MaxIterations = 100000;

		public static Vector<double> Solve(MathNet.Numerics.LinearAlgebra.Double.Vector initialGuess, Func<Vector<double>, double> functionValue, Func<Vector<double>, Vector<double>> functionGradient)
		{
			IObjectiveFunction objectiveFunction = ObjectiveFunction.Gradient(functionValue, functionGradient);
			objectiveFunction.EvaluateAt(initialGuess);
			int count = initialGuess.Count;
			int num = 0;
			Matrix<double> matrix = MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.CreateIdentity(count);
			Vector<double> vector = initialGuess;
			Vector<double> vector2 = vector;
			WolfeLineSearch wolfeLineSearch = new WeakWolfeLineSearch(0.0001, 0.9, 1E-05, 200);
			Vector<double> gradient;
			do
			{
				gradient = objectiveFunction.Gradient;
				Vector<double> vector3 = -1.0 * matrix * gradient;
				double finalStep = wolfeLineSearch.FindConformingStep(objectiveFunction, vector3, 1.0).FinalStep;
				vector += finalStep * vector3;
				Vector<double> vector4 = gradient;
				objectiveFunction.EvaluateAt(vector);
				gradient = objectiveFunction.Gradient;
				Vector<double> vector5 = vector - vector2;
				Vector<double> vector6 = gradient - vector4;
				double num2 = 1.0 / (vector6 * vector5);
				if (num == 0)
				{
					matrix = vector6 * vector5 / (vector6 * vector6) * MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.CreateIdentity(count);
				}
				Matrix<double> matrix2 = vector5.ToColumnMatrix();
				Matrix<double> matrix3 = vector6.ToColumnMatrix();
				matrix = matrix - num2 * (matrix2 * matrix3.TransposeThisAndMultiply(matrix) + (matrix * matrix3).TransposeAndMultiply(matrix2)) + num2 * num2 * (vector6.DotProduct(matrix * vector6) + 1.0 / num2) * matrix2.TransposeAndMultiply(matrix2);
				vector2 = vector;
				num++;
			}
			while (gradient.InfinityNorm() > 1E-05 && num < 100000);
			return vector;
		}
	}
	public class ConjugateGradientMinimizer : IUnconstrainedMinimizer
	{
		public double GradientTolerance { get; set; }

		public int MaximumIterations { get; set; }

		public ConjugateGradientMinimizer(double gradientTolerance, int maximumIterations)
		{
			GradientTolerance = gradientTolerance;
			MaximumIterations = maximumIterations;
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objective, Vector<double> initialGuess)
		{
			return Minimum(objective, initialGuess, GradientTolerance, MaximumIterations);
		}

		public static MinimizationResult Minimum(IObjectiveFunction objective, Vector<double> initialGuess, double gradientTolerance = 1E-08, int maxIterations = 1000)
		{
			if (!objective.IsGradientSupported)
			{
				throw new IncompatibleObjectiveException("Gradient not supported in objective function, but required for ConjugateGradient minimization.");
			}
			objective.EvaluateAt(initialGuess);
			Vector<double> gradient = objective.Gradient;
			ValidateGradient(objective);
			if (gradient.Norm(2.0) < gradientTolerance)
			{
				return new MinimizationResult(objective, 0, ExitCondition.AbsoluteGradient);
			}
			WeakWolfeLineSearch weakWolfeLineSearch = new WeakWolfeLineSearch(0.0001, 0.1, 0.0001, 1000);
			Vector<double> vector = -gradient;
			Vector<double> vector2 = vector;
			double initialStep = 100.0 * gradientTolerance / (gradient * gradient);
			LineSearchResult lineSearchResult;
			try
			{
				lineSearchResult = weakWolfeLineSearch.FindConformingStep(objective, vector2, initialStep);
			}
			catch (Exception inner_exception)
			{
				throw new InnerOptimizationException("Line search failed.", inner_exception);
			}
			objective = lineSearchResult.FunctionInfoAtMinimum;
			ValidateGradient(objective);
			double finalStep = lineSearchResult.FinalStep;
			int num = 1;
			int num2 = lineSearchResult.Iterations;
			int num3 = ((lineSearchResult.Iterations <= 0) ? 1 : 0);
			int num4 = 0;
			while (objective.Gradient.Norm(2.0) >= gradientTolerance && num < maxIterations)
			{
				Vector<double> vector3 = vector;
				vector = -objective.Gradient;
				double num5 = Math.Max(0.0, vector * (vector - vector3) / (vector3 * vector3));
				vector2 = vector + num5 * vector2;
				if (vector2 * objective.Gradient >= 0.0)
				{
					vector2 = vector;
					num4++;
				}
				try
				{
					lineSearchResult = weakWolfeLineSearch.FindConformingStep(objective, vector2, finalStep);
				}
				catch (Exception inner_exception2)
				{
					throw new InnerOptimizationException("Line search failed.", inner_exception2);
				}
				num3 += ((lineSearchResult.Iterations == 0) ? 1 : 0);
				num2 += lineSearchResult.Iterations;
				finalStep = lineSearchResult.FinalStep;
				objective = lineSearchResult.FunctionInfoAtMinimum;
				num++;
			}
			if (num == maxIterations)
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({maxIterations}) reached."));
			}
			return new MinimizationWithLineSearchResult(objective, num, ExitCondition.AbsoluteGradient, num2, num3);
		}

		private static void ValidateGradient(IObjectiveFunctionEvaluation objective)
		{
			foreach (double item in (IEnumerable<double>)objective.Gradient)
			{
				if (double.IsNaN(item) || double.IsInfinity(item))
				{
					throw new EvaluationException("Non-finite gradient returned.", objective);
				}
			}
		}

		private static void ValidateObjective(IObjectiveFunctionEvaluation objective)
		{
			if (double.IsNaN(objective.Value) || double.IsInfinity(objective.Value))
			{
				throw new EvaluationException("Non-finite objective function returned.", objective);
			}
		}
	}
	public class OptimizationException : Exception
	{
		public OptimizationException(string message)
			: base(message)
		{
		}

		public OptimizationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
	public class MaximumIterationsException : OptimizationException
	{
		public MaximumIterationsException(string message)
			: base(message)
		{
		}
	}
	public class EvaluationException : OptimizationException
	{
		public IObjectiveFunctionEvaluation ObjectiveFunction { get; private set; }

		public EvaluationException(string message, IObjectiveFunctionEvaluation eval)
			: base(message)
		{
			ObjectiveFunction = eval;
		}

		public EvaluationException(string message, IObjectiveFunctionEvaluation eval, Exception innerException)
			: base(message, innerException)
		{
			ObjectiveFunction = eval;
		}
	}
	public class InnerOptimizationException : OptimizationException
	{
		public InnerOptimizationException(string message)
			: base(message)
		{
		}

		public InnerOptimizationException(string message, Exception inner_exception)
			: base(message, inner_exception)
		{
		}
	}
	public class IncompatibleObjectiveException : OptimizationException
	{
		public IncompatibleObjectiveException(string message)
			: base(message)
		{
		}
	}
	public enum ExitCondition
	{
		None,
		InvalidValues,
		ExceedIterations,
		RelativePoints,
		RelativeGradient,
		LackOfProgress,
		AbsoluteGradient,
		WeakWolfeCriteria,
		BoundTolerance,
		StrongWolfeCriteria,
		Converged,
		ManuallyStopped
	}
	public class GoldenSectionMinimizer
	{
		public double XTolerance { get; set; }

		public int MaximumIterations { get; set; }

		public int MaximumExpansionSteps { get; set; }

		public double LowerExpansionFactor { get; set; }

		public double UpperExpansionFactor { get; set; }

		public GoldenSectionMinimizer(double xTolerance = 1E-05, int maxIterations = 1000, int maxExpansionSteps = 10, double lowerExpansionFactor = 2.0, double upperExpansionFactor = 2.0)
		{
			XTolerance = xTolerance;
			MaximumIterations = maxIterations;
			MaximumExpansionSteps = maxExpansionSteps;
			LowerExpansionFactor = lowerExpansionFactor;
			UpperExpansionFactor = upperExpansionFactor;
		}

		public ScalarMinimizationResult FindMinimum(IScalarObjectiveFunction objective, double lowerBound, double upperBound)
		{
			return Minimum(objective, lowerBound, upperBound, XTolerance, MaximumIterations, MaximumExpansionSteps, LowerExpansionFactor, UpperExpansionFactor);
		}

		public static ScalarMinimizationResult Minimum(IScalarObjectiveFunction objective, double lowerBound, double upperBound, double xTolerance = 1E-05, int maxIterations = 1000, int maxExpansionSteps = 10, double lowerExpansionFactor = 2.0, double upperExpansionFactor = 2.0)
		{
			if (upperBound <= lowerBound)
			{
				throw new OptimizationException("Lower bound must be lower than upper bound.");
			}
			double point = lowerBound + (upperBound - lowerBound) / 2.618033988749895;
			IScalarObjectiveFunctionEvaluation scalarObjectiveFunctionEvaluation = objective.Evaluate(lowerBound);
			IScalarObjectiveFunctionEvaluation scalarObjectiveFunctionEvaluation2 = objective.Evaluate(point);
			IScalarObjectiveFunctionEvaluation scalarObjectiveFunctionEvaluation3 = objective.Evaluate(upperBound);
			ValueChecker(scalarObjectiveFunctionEvaluation.Value, lowerBound);
			ValueChecker(scalarObjectiveFunctionEvaluation2.Value, point);
			ValueChecker(scalarObjectiveFunctionEvaluation3.Value, upperBound);
			for (int i = 0; i < maxExpansionSteps; i++)
			{
				if (!(scalarObjectiveFunctionEvaluation3.Value < scalarObjectiveFunctionEvaluation2.Value) && !(scalarObjectiveFunctionEvaluation.Value < scalarObjectiveFunctionEvaluation2.Value))
				{
					break;
				}
				if (scalarObjectiveFunctionEvaluation.Value < scalarObjectiveFunctionEvaluation2.Value)
				{
					lowerBound = 0.5 * (upperBound + lowerBound) - lowerExpansionFactor * 0.5 * (upperBound - lowerBound);
					scalarObjectiveFunctionEvaluation = objective.Evaluate(lowerBound);
				}
				if (scalarObjectiveFunctionEvaluation3.Value < scalarObjectiveFunctionEvaluation2.Value)
				{
					upperBound = 0.5 * (upperBound + lowerBound) + upperExpansionFactor * 0.5 * (upperBound - lowerBound);
					scalarObjectiveFunctionEvaluation3 = objective.Evaluate(upperBound);
				}
				point = lowerBound + (upperBound - lowerBound) / 2.618033988749895;
				scalarObjectiveFunctionEvaluation2 = objective.Evaluate(point);
			}
			if (scalarObjectiveFunctionEvaluation3.Value < scalarObjectiveFunctionEvaluation2.Value || scalarObjectiveFunctionEvaluation.Value < scalarObjectiveFunctionEvaluation2.Value)
			{
				throw new OptimizationException("Lower and upper bounds do not necessarily bound a minimum.");
			}
			int num = 0;
			while (Math.Abs(scalarObjectiveFunctionEvaluation3.Point - scalarObjectiveFunctionEvaluation.Point) > xTolerance && num < maxIterations)
			{
				point = scalarObjectiveFunctionEvaluation.Point + (scalarObjectiveFunctionEvaluation3.Point - scalarObjectiveFunctionEvaluation.Point) / 2.618033988749895;
				scalarObjectiveFunctionEvaluation2 = objective.Evaluate(point);
				ValueChecker(scalarObjectiveFunctionEvaluation2.Value, point);
				double point2 = scalarObjectiveFunctionEvaluation.Point + (scalarObjectiveFunctionEvaluation3.Point - scalarObjectiveFunctionEvaluation2.Point);
				IScalarObjectiveFunctionEvaluation scalarObjectiveFunctionEvaluation4 = objective.Evaluate(point2);
				ValueChecker(scalarObjectiveFunctionEvaluation4.Value, point2);
				if (scalarObjectiveFunctionEvaluation4.Point < scalarObjectiveFunctionEvaluation2.Point)
				{
					if (scalarObjectiveFunctionEvaluation4.Value > scalarObjectiveFunctionEvaluation2.Value)
					{
						scalarObjectiveFunctionEvaluation = scalarObjectiveFunctionEvaluation4;
					}
					else
					{
						scalarObjectiveFunctionEvaluation3 = scalarObjectiveFunctionEvaluation2;
					}
				}
				else if (scalarObjectiveFunctionEvaluation4.Value > scalarObjectiveFunctionEvaluation2.Value)
				{
					scalarObjectiveFunctionEvaluation3 = scalarObjectiveFunctionEvaluation4;
				}
				else
				{
					scalarObjectiveFunctionEvaluation = scalarObjectiveFunctionEvaluation2;
				}
				num++;
			}
			if (num == maxIterations)
			{
				throw new MaximumIterationsException("Max iterations reached.");
			}
			return new ScalarMinimizationResult(scalarObjectiveFunctionEvaluation2, num, ExitCondition.BoundTolerance);
		}

		private static void ValueChecker(double value, double point)
		{
			if (double.IsNaN(value) || double.IsInfinity(value))
			{
				throw new Exception("Objective function returned non-finite value.");
			}
		}
	}
	public interface IObjectiveFunctionEvaluation
	{
		Vector<double> Point { get; }

		double Value { get; }

		bool IsGradientSupported { get; }

		Vector<double> Gradient { get; }

		bool IsHessianSupported { get; }

		Matrix<double> Hessian { get; }

		IObjectiveFunction CreateNew();
	}
	public interface IObjectiveFunction : IObjectiveFunctionEvaluation
	{
		void EvaluateAt(Vector<double> point);

		IObjectiveFunction Fork();
	}
	public interface IScalarObjectiveFunctionEvaluation
	{
		double Point { get; }

		double Value { get; }

		double Derivative { get; }

		double SecondDerivative { get; }
	}
	public interface IScalarObjectiveFunction
	{
		bool IsDerivativeSupported { get; }

		bool IsSecondDerivativeSupported { get; }

		IScalarObjectiveFunctionEvaluation Evaluate(double point);
	}
	public interface IObjectiveModelEvaluation
	{
		Vector<double> ObservedY { get; }

		Matrix<double> Weights { get; }

		Vector<double> ModelValues { get; }

		Vector<double> Point { get; }

		double Value { get; }

		Vector<double> Gradient { get; }

		Matrix<double> Hessian { get; }

		int FunctionEvaluations { get; set; }

		int JacobianEvaluations { get; set; }

		int DegreeOfFreedom { get; }

		bool IsGradientSupported { get; }

		bool IsHessianSupported { get; }

		IObjectiveModel CreateNew();
	}
	public interface IObjectiveModel : IObjectiveModelEvaluation
	{
		void SetParameters(Vector<double> initialGuess, List<bool> isFixed = null);

		void EvaluateAt(Vector<double> parameters);

		IObjectiveModel Fork();

		IObjectiveFunction ToObjectiveFunction();
	}
	public interface IUnconstrainedMinimizer
	{
		MinimizationResult FindMinimum(IObjectiveFunction objective, Vector<double> initialGuess);
	}
	public class LevenbergMarquardtMinimizer : NonlinearMinimizerBase
	{
		public static double InitialMu { get; set; }

		public LevenbergMarquardtMinimizer(double initialMu = 0.001, double gradientTolerance = 1E-15, double stepTolerance = 1E-15, double functionTolerance = 1E-15, int maximumIterations = -1)
			: base(gradientTolerance, stepTolerance, functionTolerance, maximumIterations)
		{
			InitialMu = initialMu;
		}

		public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, Vector<double> initialGuess, Vector<double> lowerBound = null, Vector<double> upperBound = null, Vector<double> scales = null, List<bool> isFixed = null)
		{
			return Minimum(objective, initialGuess, lowerBound, upperBound, scales, isFixed, InitialMu, NonlinearMinimizerBase.GradientTolerance, NonlinearMinimizerBase.StepTolerance, NonlinearMinimizerBase.FunctionTolerance, NonlinearMinimizerBase.MaximumIterations);
		}

		public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, double[] initialGuess, double[] lowerBound = null, double[] upperBound = null, double[] scales = null, bool[] isFixed = null)
		{
			if (objective == null)
			{
				throw new ArgumentNullException("objective");
			}
			if (initialGuess == null)
			{
				throw new ArgumentNullException("initialGuess");
			}
			Vector<double> lowerBound2 = ((lowerBound == null) ? null : CreateVector.Dense(lowerBound));
			Vector<double> upperBound2 = ((upperBound == null) ? null : CreateVector.Dense(upperBound));
			Vector<double> scales2 = ((scales == null) ? null : CreateVector.Dense(scales));
			List<bool> isFixed2 = isFixed?.ToList();
			return Minimum(objective, CreateVector.DenseOfArray(initialGuess), lowerBound2, upperBound2, scales2, isFixed2, InitialMu, NonlinearMinimizerBase.GradientTolerance, NonlinearMinimizerBase.StepTolerance, NonlinearMinimizerBase.FunctionTolerance, NonlinearMinimizerBase.MaximumIterations);
		}

		public static NonlinearMinimizationResult Minimum(IObjectiveModel objective, Vector<double> initialGuess, Vector<double> lowerBound = null, Vector<double> upperBound = null, Vector<double> scales = null, List<bool> isFixed = null, double initialMu = 0.001, double gradientTolerance = 1E-15, double stepTolerance = 1E-15, double functionTolerance = 1E-15, int maximumIterations = -1)
		{
			if (objective == null)
			{
				throw new ArgumentNullException("objective");
			}
			NonlinearMinimizerBase.ValidateBounds(initialGuess, lowerBound, upperBound, scales);
			objective.SetParameters(initialGuess, isFixed);
			ExitCondition exitCondition = ExitCondition.None;
			Vector<double> vector = NonlinearMinimizerBase.ProjectToInternalParameters(initialGuess);
			Vector<double> vector2 = Vector<double>.Build.Dense(vector.Count);
			double num = NonlinearMinimizerBase.EvaluateFunction(objective, vector);
			if (maximumIterations < 0)
			{
				maximumIterations = 200 * (initialGuess.Count + 1);
			}
			if (double.IsNaN(num))
			{
				exitCondition = ExitCondition.InvalidValues;
				return new NonlinearMinimizationResult(objective, -1, exitCondition);
			}
			if (maximumIterations == 0)
			{
				exitCondition = ExitCondition.ManuallyStopped;
			}
			if (num <= functionTolerance)
			{
				exitCondition = ExitCondition.Converged;
			}
			Tuple<Vector<double>, Matrix<double>> tuple = NonlinearMinimizerBase.EvaluateJacobian(objective, vector);
			Vector<double> item = tuple.Item1;
			Matrix<double> item2 = tuple.Item2;
			Vector<double> vector3 = item2.Diagonal();
			if (item.InfinityNorm() <= gradientTolerance)
			{
				exitCondition = ExitCondition.RelativeGradient;
			}
			if (exitCondition != 0)
			{
				return new NonlinearMinimizationResult(objective, -1, exitCondition);
			}
			double num2 = initialMu * vector3.Max();
			double num3 = 2.0;
			int num4 = 0;
			while (num4 < maximumIterations && exitCondition == ExitCondition.None)
			{
				num4++;
				while (true)
				{
					item2.SetDiagonal(item2.Diagonal() + num2);
					vector2 = item2.Solve(-item);
					if (vector2.L2Norm() <= stepTolerance * (stepTolerance + vector.DotProduct(vector)))
					{
						exitCondition = ExitCondition.RelativePoints;
						break;
					}
					Vector<double> vector4 = vector + vector2;
					double num5 = NonlinearMinimizerBase.EvaluateFunction(objective, vector4);
					if (double.IsNaN(num5))
					{
						exitCondition = ExitCondition.InvalidValues;
						break;
					}
					double num6 = vector2.DotProduct(num2 * vector2 - item);
					double num7 = ((num6 != 0.0) ? ((num - num5) / num6) : 0.0);
					if (num7 > 0.0)
					{
						vector4.CopyTo(vector);
						num = num5;
						Tuple<Vector<double>, Matrix<double>> tuple2 = NonlinearMinimizerBase.EvaluateJacobian(objective, vector);
						item = tuple2.Item1;
						item2 = tuple2.Item2;
						vector3 = item2.Diagonal();
						if (item.InfinityNorm() <= gradientTolerance)
						{
							exitCondition = ExitCondition.RelativeGradient;
						}
						if (num <= functionTolerance)
						{
							exitCondition = ExitCondition.Converged;
						}
						num2 *= Math.Max(1.0 / 3.0, 1.0 - Math.Pow(2.0 * num7 - 1.0, 3.0));
						num3 = 2.0;
						break;
					}
					num2 *= num3;
					num3 = 2.0 * num3;
					item2.SetDiagonal(vector3);
				}
			}
			if (num4 >= maximumIterations)
			{
				exitCondition = ExitCondition.ExceedIterations;
			}
			return new NonlinearMinimizationResult(objective, num4, exitCondition);
		}
	}
	public class LimitedMemoryBfgsMinimizer : MinimizerBase, IUnconstrainedMinimizer
	{
		public int Memory { get; set; }

		public LimitedMemoryBfgsMinimizer(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int memory, int maximumIterations = 1000)
			: base(gradientTolerance, parameterTolerance, functionProgressTolerance, maximumIterations)
		{
			Memory = memory;
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objective, Vector<double> initialGuess)
		{
			if (!objective.IsGradientSupported)
			{
				throw new IncompatibleObjectiveException("Gradient not supported in objective function, but required for L-BFGS minimization.");
			}
			objective.EvaluateAt(initialGuess);
			ValidateGradientAndObjective(objective);
			ExitCondition exitCondition = ExitCriteriaSatisfied(objective, null, 0);
			if (exitCondition != 0)
			{
				return new MinimizationResult(objective, 0, exitCondition);
			}
			WeakWolfeLineSearch weakWolfeLineSearch = new WeakWolfeLineSearch(0.0001, 0.9, Math.Max(base.ParameterTolerance, 1E-10), 1000);
			Vector<double> vector = -objective.Gradient;
			double initialStep = 100.0 * base.GradientTolerance / (vector * vector);
			IObjectiveFunction objectiveFunction = objective;
			LineSearchResult lineSearchResult;
			try
			{
				lineSearchResult = weakWolfeLineSearch.FindConformingStep(objective, vector, initialStep);
			}
			catch (OptimizationException inner_exception)
			{
				throw new InnerOptimizationException("Line search failed.", inner_exception);
			}
			catch (ArgumentException inner_exception2)
			{
				throw new InnerOptimizationException("Line search failed.", inner_exception2);
			}
			IObjectiveFunction functionInfoAtMinimum = lineSearchResult.FunctionInfoAtMinimum;
			ValidateGradientAndObjective(functionInfoAtMinimum);
			_ = functionInfoAtMinimum.Gradient;
			Vector<double> vector2 = functionInfoAtMinimum.Point - initialGuess;
			Vector<double> vector3 = functionInfoAtMinimum.Gradient - objectiveFunction.Gradient;
			List<Vector<double>> list = new List<Vector<double>> { vector3 };
			List<Vector<double>> list2 = new List<Vector<double>> { vector2 };
			List<double> list3 = new List<double> { 1.0 / vector3.DotProduct(vector2) };
			int num = 1;
			int num2 = lineSearchResult.Iterations;
			int num3 = ((lineSearchResult.Iterations <= 0) ? 1 : 0);
			objectiveFunction = functionInfoAtMinimum;
			while (num++ < base.MaximumIterations && objectiveFunction.Gradient.Norm(2.0) >= base.GradientTolerance)
			{
				vector = -ApplyLbfgsUpdate(objectiveFunction, list, list2, list3);
				if (objectiveFunction.Gradient.DotProduct(vector) > 0.0)
				{
					throw new InnerOptimizationException("Direction is not a descent direction.");
				}
				try
				{
					lineSearchResult = weakWolfeLineSearch.FindConformingStep(objectiveFunction, vector, 1.0);
				}
				catch (OptimizationException inner_exception3)
				{
					throw new InnerOptimizationException("Line search failed.", inner_exception3);
				}
				catch (ArgumentException inner_exception4)
				{
					throw new InnerOptimizationException("Line search failed.", inner_exception4);
				}
				num3 += ((lineSearchResult.Iterations > 0) ? 1 : 0);
				num2 += lineSearchResult.Iterations;
				functionInfoAtMinimum = lineSearchResult.FunctionInfoAtMinimum;
				exitCondition = ExitCriteriaSatisfied(functionInfoAtMinimum, objectiveFunction, num);
				if (exitCondition != 0)
				{
					break;
				}
				vector2 = functionInfoAtMinimum.Point - objectiveFunction.Point;
				vector3 = functionInfoAtMinimum.Gradient - objectiveFunction.Gradient;
				list.Add(vector3);
				list2.Add(vector2);
				list3.Add(1.0 / vector3.DotProduct(vector2));
				objectiveFunction = functionInfoAtMinimum;
				if (list.Count > Memory)
				{
					list.RemoveAt(0);
					list2.RemoveAt(0);
					list3.RemoveAt(0);
				}
			}
			if (num == base.MaximumIterations && exitCondition == ExitCondition.None)
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({base.MaximumIterations}) reached."));
			}
			return new MinimizationWithLineSearchResult(functionInfoAtMinimum, num, ExitCondition.AbsoluteGradient, num2, num3);
		}

		private Vector<double> ApplyLbfgsUpdate(IObjectiveFunction previousPoint, List<Vector<double>> ykhistory, List<Vector<double>> skhistory, List<double> rhokhistory)
		{
			Vector<double> vector = previousPoint.Gradient.Clone();
			Stack<double> stack = new Stack<double>();
			for (int num = ykhistory.Count - 1; num >= 0; num--)
			{
				double num2 = rhokhistory[num] * vector.DotProduct(skhistory[num]);
				stack.Push(num2);
				vector -= num2 * ykhistory[num];
			}
			Vector<double> vector2 = ykhistory.Last();
			Vector<double> other = skhistory.Last();
			vector *= vector2.DotProduct(other) / vector2.DotProduct(vector2);
			for (int i = 0; i < ykhistory.Count; i++)
			{
				double num3 = rhokhistory[i] * ykhistory[i].DotProduct(vector);
				vector += skhistory[i] * (stack.Pop() - num3);
			}
			return vector;
		}
	}
	public class MinimizationResult
	{
		public Vector<double> MinimizingPoint => FunctionInfoAtMinimum.Point;

		public IObjectiveFunction FunctionInfoAtMinimum { get; }

		public int Iterations { get; }

		public ExitCondition ReasonForExit { get; }

		public MinimizationResult(IObjectiveFunction functionInfo, int iterations, ExitCondition reasonForExit)
		{
			FunctionInfoAtMinimum = functionInfo;
			Iterations = iterations;
			ReasonForExit = reasonForExit;
		}
	}
	public class MinimizationWithLineSearchResult : MinimizationResult
	{
		public int TotalLineSearchIterations { get; private set; }

		public int IterationsWithNonTrivialLineSearch { get; private set; }

		public MinimizationWithLineSearchResult(IObjectiveFunction functionInfo, int iterations, ExitCondition reasonForExit, int totalLineSearchIterations, int iterationsWithNonTrivialLineSearch)
			: base(functionInfo, iterations, reasonForExit)
		{
			TotalLineSearchIterations = totalLineSearchIterations;
			IterationsWithNonTrivialLineSearch = iterationsWithNonTrivialLineSearch;
		}
	}
	public abstract class MinimizerBase
	{
		protected const double VerySmall = 1E-15;

		public double GradientTolerance { get; set; }

		public double ParameterTolerance { get; set; }

		public double FunctionProgressTolerance { get; set; }

		public int MaximumIterations { get; set; }

		protected MinimizerBase(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations)
		{
			GradientTolerance = gradientTolerance;
			ParameterTolerance = parameterTolerance;
			FunctionProgressTolerance = functionProgressTolerance;
			MaximumIterations = maximumIterations;
		}

		protected ExitCondition ExitCriteriaSatisfied(IObjectiveFunctionEvaluation candidatePoint, IObjectiveFunctionEvaluation lastPoint, int iterations)
		{
			Vector<double> vector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(candidatePoint.Point.Count);
			double num = 0.0;
			double num2 = Math.Max(Math.Abs(candidatePoint.Value), 1.0);
			for (int i = 0; i < vector.Count; i++)
			{
				double value = GetProjectedGradient(candidatePoint, i) * Math.Max(Math.Abs(candidatePoint.Point[i]), 1.0) / num2;
				num = Math.Max(num, Math.Abs(value));
			}
			if (num < GradientTolerance)
			{
				return ExitCondition.RelativeGradient;
			}
			if (lastPoint != null)
			{
				double num3 = 0.0;
				for (int j = 0; j < candidatePoint.Point.Count; j++)
				{
					double val = Math.Abs(candidatePoint.Point[j] - lastPoint.Point[j]) / Math.Max(Math.Abs(lastPoint.Point[j]), 1.0);
					num3 = Math.Max(num3, val);
				}
				if (num3 < ParameterTolerance)
				{
					return ExitCondition.LackOfProgress;
				}
				double num4 = candidatePoint.Value - lastPoint.Value;
				if (iterations > 500 && num4 < 0.0 && Math.Abs(num4) < FunctionProgressTolerance)
				{
					return ExitCondition.LackOfProgress;
				}
			}
			return ExitCondition.None;
		}

		protected virtual double GetProjectedGradient(IObjectiveFunctionEvaluation candidatePoint, int ii)
		{
			return candidatePoint.Gradient[ii];
		}

		protected void ValidateGradientAndObjective(IObjectiveFunctionEvaluation eval)
		{
			foreach (double item in (IEnumerable<double>)eval.Gradient)
			{
				if (double.IsNaN(item) || double.IsInfinity(item))
				{
					throw new EvaluationException("Non-finite gradient returned.", eval);
				}
			}
			if (double.IsNaN(eval.Value) || double.IsInfinity(eval.Value))
			{
				throw new EvaluationException("Non-finite objective function returned.", eval);
			}
		}
	}
	public sealed class NelderMeadSimplex : IUnconstrainedMinimizer
	{
		private sealed class SimplexConstant
		{
			public double Value { get; }

			public double InitialPerturbation { get; }

			public SimplexConstant(double value, double initialPerturbation)
			{
				Value = value;
				InitialPerturbation = initialPerturbation;
			}

			public static SimplexConstant[] CreateSimplexConstantsFromVectors(Vector<double> initialGuess, Vector<double> initialPertubation)
			{
				SimplexConstant[] array = new SimplexConstant[initialGuess.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = new SimplexConstant(initialGuess[i], initialPertubation[i]);
				}
				return array;
			}
		}

		private sealed class ErrorProfile
		{
			public int HighestIndex { get; set; }

			public int NextHighestIndex { get; set; }

			public int LowestIndex { get; set; }
		}

		private static readonly double JITTER = 1E-10;

		public double ConvergenceTolerance { get; set; }

		public int MaximumIterations { get; set; }

		public NelderMeadSimplex(double convergenceTolerance, int maximumIterations)
		{
			ConvergenceTolerance = convergenceTolerance;
			MaximumIterations = maximumIterations;
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objectiveFunction, Vector<double> initialGuess)
		{
			return Minimum(objectiveFunction, initialGuess, ConvergenceTolerance, MaximumIterations);
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objectiveFunction, Vector<double> initialGuess, Vector<double> initalPertubation)
		{
			return Minimum(objectiveFunction, initialGuess, initalPertubation, ConvergenceTolerance, MaximumIterations);
		}

		public static MinimizationResult Minimum(IObjectiveFunction objectiveFunction, Vector<double> initialGuess, double convergenceTolerance = 1E-08, int maximumIterations = 1000)
		{
			MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(initialGuess.Count);
			for (int i = 0; i < initialGuess.Count; i++)
			{
				denseVector[i] = ((initialGuess[i] == 0.0) ? 0.00025 : (initialGuess[i] * 0.05));
			}
			return Minimum(objectiveFunction, initialGuess, denseVector, convergenceTolerance, maximumIterations);
		}

		public static MinimizationResult Minimum(IObjectiveFunction objectiveFunction, Vector<double> initialGuess, Vector<double> initalPertubation, double convergenceTolerance = 1E-08, int maximumIterations = 1000)
		{
			if (objectiveFunction == null)
			{
				throw new ArgumentNullException("objectiveFunction", "ObjectiveFunction must be set to a valid ObjectiveFunctionDelegate");
			}
			if (initialGuess == null)
			{
				throw new ArgumentNullException("initialGuess", "initialGuess must be initialized");
			}
			if (initalPertubation == null)
			{
				throw new ArgumentNullException("initalPertubation", "initalPertubation must be initialized, if unknown use overloaded version of FindMinimum()");
			}
			SimplexConstant[] array = SimplexConstant.CreateSimplexConstantsFromVectors(initialGuess, initalPertubation);
			int num = array.Length + 1;
			Vector<double>[] array2 = InitializeVertices(array);
			double[] array3 = new double[num];
			int num2 = 0;
			ExitCondition exitCondition = ExitCondition.None;
			array3 = InitializeErrorValues(array2, objectiveFunction);
			int num3 = 0;
			do
			{
				ErrorProfile errorProfile = EvaluateSimplex(array3);
				num3 = (HasConverged(convergenceTolerance, errorProfile, array3) ? (num3 + 1) : 0);
				if (num3 == 2)
				{
					exitCondition = ExitCondition.Converged;
					objectiveFunction.EvaluateAt(array2[errorProfile.LowestIndex]);
					return new MinimizationResult(objectiveFunction, num2, exitCondition);
				}
				double num4 = TryToScaleSimplex(-1.0, ref errorProfile, array2, array3, objectiveFunction);
				num2++;
				if (num4 <= array3[errorProfile.LowestIndex])
				{
					TryToScaleSimplex(2.0, ref errorProfile, array2, array3, objectiveFunction);
					num2++;
				}
				else if (num4 >= array3[errorProfile.NextHighestIndex])
				{
					double num5 = array3[errorProfile.HighestIndex];
					double num6 = TryToScaleSimplex(0.5, ref errorProfile, array2, array3, objectiveFunction);
					num2++;
					if (num6 >= num5)
					{
						ShrinkSimplex(errorProfile, array2, array3, objectiveFunction);
						num2 += num;
					}
				}
			}
			while (num2 < maximumIterations);
			throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({maximumIterations}) reached."));
		}

		private static double[] InitializeErrorValues(Vector<double>[] vertices, IObjectiveFunction objectiveFunction)
		{
			double[] array = new double[vertices.Length];
			for (int i = 0; i < vertices.Length; i++)
			{
				objectiveFunction.EvaluateAt(vertices[i]);
				array[i] = objectiveFunction.Value;
			}
			return array;
		}

		private static bool HasConverged(double convergenceTolerance, ErrorProfile errorProfile, double[] errorValues)
		{
			if (2.0 * Math.Abs(errorValues[errorProfile.HighestIndex] - errorValues[errorProfile.LowestIndex]) / (Math.Abs(errorValues[errorProfile.HighestIndex]) + Math.Abs(errorValues[errorProfile.LowestIndex]) + JITTER) < convergenceTolerance)
			{
				return true;
			}
			return false;
		}

		private static ErrorProfile EvaluateSimplex(double[] errorValues)
		{
			ErrorProfile errorProfile = new ErrorProfile();
			if (errorValues[0] > errorValues[1])
			{
				errorProfile.HighestIndex = 0;
				errorProfile.NextHighestIndex = 1;
			}
			else
			{
				errorProfile.HighestIndex = 1;
				errorProfile.NextHighestIndex = 0;
			}
			for (int i = 0; i < errorValues.Length; i++)
			{
				double num = errorValues[i];
				if (num <= errorValues[errorProfile.LowestIndex])
				{
					errorProfile.LowestIndex = i;
				}
				if (num > errorValues[errorProfile.HighestIndex])
				{
					errorProfile.NextHighestIndex = errorProfile.HighestIndex;
					errorProfile.HighestIndex = i;
				}
				else if (num > errorValues[errorProfile.NextHighestIndex] && i != errorProfile.HighestIndex)
				{
					errorProfile.NextHighestIndex = i;
				}
			}
			return errorProfile;
		}

		private static Vector<double>[] InitializeVertices(SimplexConstant[] simplexConstants)
		{
			int num = simplexConstants.Length;
			Vector<double>[] array = new Vector<double>[num + 1];
			MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num);
			for (int i = 0; i < num; i++)
			{
				denseVector[i] = simplexConstants[i].Value;
			}
			array[0] = denseVector;
			for (int j = 0; j < num; j++)
			{
				double initialPerturbation = simplexConstants[j].InitialPerturbation;
				Vector<double> vector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num);
				vector[j] = 1.0;
				array[j + 1] = denseVector.Add(vector.Multiply(initialPerturbation));
			}
			return array;
		}

		private static double TryToScaleSimplex(double scaleFactor, ref ErrorProfile errorProfile, Vector<double>[] vertices, double[] errorValues, IObjectiveFunction objectiveFunction)
		{
			Vector<double> other = ComputeCentroid(vertices, errorProfile);
			Vector<double> vector = vertices[errorProfile.HighestIndex].Subtract(other).Multiply(scaleFactor).Add(other);
			objectiveFunction.EvaluateAt(vector);
			double value = objectiveFunction.Value;
			if (value < errorValues[errorProfile.HighestIndex])
			{
				vertices[errorProfile.HighestIndex] = vector;
				errorValues[errorProfile.HighestIndex] = value;
			}
			return value;
		}

		private static void ShrinkSimplex(ErrorProfile errorProfile, Vector<double>[] vertices, double[] errorValues, IObjectiveFunction objectiveFunction)
		{
			Vector<double> other = vertices[errorProfile.LowestIndex];
			for (int i = 0; i < vertices.Length; i++)
			{
				if (i != errorProfile.LowestIndex)
				{
					vertices[i] = vertices[i].Add(other).Multiply(0.5);
					objectiveFunction.EvaluateAt(vertices[i]);
					errorValues[i] = objectiveFunction.Value;
				}
			}
		}

		private static Vector<double> ComputeCentroid(Vector<double>[] vertices, ErrorProfile errorProfile)
		{
			int num = vertices.Length;
			Vector<double> vector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(num - 1);
			for (int i = 0; i < num; i++)
			{
				if (i != errorProfile.HighestIndex)
				{
					vector = vector.Add(vertices[i]);
				}
			}
			return vector.Multiply(1.0 / (double)(num - 1));
		}
	}
	public sealed class NewtonMinimizer : IUnconstrainedMinimizer
	{
		public double GradientTolerance { get; set; }

		public int MaximumIterations { get; set; }

		public bool UseLineSearch { get; set; }

		public NewtonMinimizer(double gradientTolerance, int maximumIterations, bool useLineSearch = false)
		{
			GradientTolerance = gradientTolerance;
			MaximumIterations = maximumIterations;
			UseLineSearch = useLineSearch;
		}

		public MinimizationResult FindMinimum(IObjectiveFunction objective, Vector<double> initialGuess)
		{
			return Minimum(objective, initialGuess, GradientTolerance, MaximumIterations, UseLineSearch);
		}

		public static MinimizationResult Minimum(IObjectiveFunction objective, Vector<double> initialGuess, double gradientTolerance = 1E-08, int maxIterations = 1000, bool useLineSearch = false)
		{
			if (!objective.IsGradientSupported)
			{
				throw new IncompatibleObjectiveException("Gradient not supported in objective function, but required for Newton minimization.");
			}
			if (!objective.IsHessianSupported)
			{
				throw new IncompatibleObjectiveException("Hessian not supported in objective function, but required for Newton minimization.");
			}
			objective.EvaluateAt(initialGuess);
			ValidateGradient(objective);
			if (objective.Gradient.Norm(2.0) < gradientTolerance)
			{
				return new MinimizationResult(objective, 0, ExitCondition.AbsoluteGradient);
			}
			WeakWolfeLineSearch weakWolfeLineSearch = new WeakWolfeLineSearch(0.0001, 0.9, 0.0001, 1000);
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			bool flag = false;
			while (objective.Gradient.Norm(2.0) >= gradientTolerance && num < maxIterations)
			{
				ValidateHessian(objective);
				Vector<double> vector = objective.Hessian.LU().Solve(-objective.Gradient);
				if (vector * objective.Gradient >= 0.0)
				{
					vector = -objective.Gradient;
					flag = true;
				}
				if (useLineSearch || flag)
				{
					LineSearchResult lineSearchResult;
					try
					{
						lineSearchResult = weakWolfeLineSearch.FindConformingStep(objective, vector, 1.0);
					}
					catch (Exception inner_exception)
					{
						throw new InnerOptimizationException("Line search failed.", inner_exception);
					}
					num3 += ((lineSearchResult.Iterations > 0) ? 1 : 0);
					num2 += lineSearchResult.Iterations;
					objective = lineSearchResult.FunctionInfoAtMinimum;
				}
				else
				{
					objective.EvaluateAt(objective.Point + vector);
				}
				ValidateGradient(objective);
				flag = false;
				num++;
			}
			if (num == maxIterations)
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({maxIterations}) reached."));
			}
			return new MinimizationWithLineSearchResult(objective, num, ExitCondition.AbsoluteGradient, num2, num3);
		}

		private static void ValidateGradient(IObjectiveFunctionEvaluation eval)
		{
			foreach (double item in (IEnumerable<double>)eval.Gradient)
			{
				if (double.IsNaN(item) || double.IsInfinity(item))
				{
					throw new EvaluationException("Non-finite gradient returned.", eval);
				}
			}
		}

		private static void ValidateHessian(IObjectiveFunctionEvaluation eval)
		{
			for (int i = 0; i < eval.Hessian.RowCount; i++)
			{
				for (int j = 0; j < eval.Hessian.ColumnCount; j++)
				{
					if (double.IsNaN(eval.Hessian[i, j]) || double.IsInfinity(eval.Hessian[i, j]))
					{
						throw new EvaluationException("Non-finite Hessian returned.", eval);
					}
				}
			}
		}
	}
	public class NonlinearMinimizationResult
	{
		public IObjectiveModel ModelInfoAtMinimum { get; }

		public Vector<double> MinimizingPoint => ModelInfoAtMinimum.Point;

		public Vector<double> StandardErrors { get; private set; }

		public Vector<double> MinimizedValues => ModelInfoAtMinimum.ModelValues;

		public Matrix<double> Covariance { get; private set; }

		public Matrix<double> Correlation { get; private set; }

		public int Iterations { get; }

		public ExitCondition ReasonForExit { get; }

		public NonlinearMinimizationResult(IObjectiveModel modelInfo, int iterations, ExitCondition reasonForExit)
		{
			ModelInfoAtMinimum = modelInfo;
			Iterations = iterations;
			ReasonForExit = reasonForExit;
			EvaluateCovariance(modelInfo);
		}

		private void EvaluateCovariance(IObjectiveModel objective)
		{
			objective.EvaluateAt(objective.Point);
			Matrix<double> hessian = objective.Hessian;
			if (hessian == null || objective.DegreeOfFreedom < 1)
			{
				Covariance = null;
				Correlation = null;
				StandardErrors = null;
				return;
			}
			Covariance = hessian.PseudoInverse() * objective.Value / objective.DegreeOfFreedom;
			if (Covariance != null)
			{
				StandardErrors = Covariance.Diagonal().PointwiseSqrt();
				Matrix<double> matrix = Covariance.Clone();
				Vector<double> vector = matrix.Diagonal().PointwiseSqrt();
				Matrix<double> divisor = vector.OuterProduct(vector);
				Correlation = matrix.PointwiseDivide(divisor);
			}
			else
			{
				StandardErrors = null;
				Correlation = null;
			}
		}
	}
	public abstract class NonlinearMinimizerBase
	{
		public static double FunctionTolerance { get; set; }

		public static double StepTolerance { get; set; }

		public static double GradientTolerance { get; set; }

		public static int MaximumIterations { get; set; }

		public static Vector<double> LowerBound { get; private set; }

		public static Vector<double> UpperBound { get; private set; }

		public static Vector<double> Scales { get; private set; }

		private static bool IsBounded
		{
			get
			{
				if (LowerBound == null && UpperBound == null)
				{
					return Scales != null;
				}
				return true;
			}
		}

		protected NonlinearMinimizerBase(double gradientTolerance = 1E-18, double stepTolerance = 1E-18, double functionTolerance = 1E-18, int maximumIterations = -1)
		{
			GradientTolerance = gradientTolerance;
			StepTolerance = stepTolerance;
			FunctionTolerance = functionTolerance;
			MaximumIterations = maximumIterations;
		}

		protected static void ValidateBounds(Vector<double> parameters, Vector<double> lowerBound = null, Vector<double> upperBound = null, Vector<double> scales = null)
		{
			if (parameters == null)
			{
				throw new ArgumentNullException("parameters");
			}
			if (lowerBound != null && lowerBound.Count((double x) => double.IsInfinity(x) || double.IsNaN(x)) > 0)
			{
				throw new ArgumentException("The lower bounds must be finite.");
			}
			if (lowerBound != null && lowerBound.Count != parameters.Count)
			{
				throw new ArgumentException("The lower bounds can't have different size from the parameters.");
			}
			LowerBound = lowerBound;
			if (upperBound != null && upperBound.Count((double x) => double.IsInfinity(x) || double.IsNaN(x)) > 0)
			{
				throw new ArgumentException("The upper bounds must be finite.");
			}
			if (upperBound != null && upperBound.Count != parameters.Count)
			{
				throw new ArgumentException("The upper bounds can't have different size from the parameetrs.");
			}
			UpperBound = upperBound;
			if (scales != null && scales.Count((double x) => double.IsInfinity(x) || double.IsNaN(x) || x == 0.0) > 0)
			{
				throw new ArgumentException("The scales must be finite.");
			}
			if (scales != null && scales.Count != parameters.Count)
			{
				throw new ArgumentException("The scales can't have different size from the parameters.");
			}
			if (scales != null && scales.Count((double x) => x < 0.0) > 0)
			{
				scales.PointwiseAbs();
			}
			Scales = scales;
		}

		protected static double EvaluateFunction(IObjectiveModel objective, Vector<double> Pint)
		{
			Vector<double> parameters = ProjectToExternalParameters(Pint);
			objective.EvaluateAt(parameters);
			return objective.Value;
		}

		protected static Tuple<Vector<double>, Matrix<double>> EvaluateJacobian(IObjectiveModel objective, Vector<double> Pint)
		{
			Vector<double> gradient = objective.Gradient;
			Matrix<double> hessian = objective.Hessian;
			if (IsBounded)
			{
				Vector<double> vector = ScaleFactorsOfJacobian(Pint);
				for (int i = 0; i < gradient.Count; i++)
				{
					gradient[i] *= vector[i];
				}
				for (int j = 0; j < hessian.RowCount; j++)
				{
					for (int k = 0; k < hessian.ColumnCount; k++)
					{
						hessian[j, k] = hessian[j, k] * vector[j] * vector[k];
					}
				}
			}
			return new Tuple<Vector<double>, Matrix<double>>(gradient, hessian);
		}

		protected static Vector<double> ProjectToInternalParameters(Vector<double> Pext)
		{
			Vector<double> vector = Pext.Clone();
			if (LowerBound != null && UpperBound != null)
			{
				for (int i = 0; i < Pext.Count; i++)
				{
					vector[i] = Math.Asin(2.0 * (Pext[i] - LowerBound[i]) / (UpperBound[i] - LowerBound[i]) - 1.0);
				}
				return vector;
			}
			if (LowerBound != null && UpperBound == null)
			{
				for (int j = 0; j < Pext.Count; j++)
				{
					vector[j] = ((Scales == null) ? Math.Sqrt(Math.Pow(Pext[j] - LowerBound[j] + 1.0, 2.0) - 1.0) : Math.Sqrt(Math.Pow((Pext[j] - LowerBound[j]) / Scales[j] + 1.0, 2.0) - 1.0));
				}
				return vector;
			}
			if (LowerBound == null && UpperBound != null)
			{
				for (int k = 0; k < Pext.Count; k++)
				{
					vector[k] = ((Scales == null) ? Math.Sqrt(Math.Pow(UpperBound[k] - Pext[k] + 1.0, 2.0) - 1.0) : Math.Sqrt(Math.Pow((UpperBound[k] - Pext[k]) / Scales[k] + 1.0, 2.0) - 1.0));
				}
				return vector;
			}
			if (Scales != null)
			{
				for (int l = 0; l < Pext.Count; l++)
				{
					vector[l] = Pext[l] / Scales[l];
				}
				return vector;
			}
			return vector;
		}

		protected static Vector<double> ProjectToExternalParameters(Vector<double> Pint)
		{
			Vector<double> vector = Pint.Clone();
			if (LowerBound != null && UpperBound != null)
			{
				for (int i = 0; i < Pint.Count; i++)
				{
					vector[i] = LowerBound[i] + (UpperBound[i] / 2.0 - LowerBound[i] / 2.0) * (Math.Sin(Pint[i]) + 1.0);
				}
				return vector;
			}
			if (LowerBound != null && UpperBound == null)
			{
				for (int j = 0; j < Pint.Count; j++)
				{
					vector[j] = ((Scales == null) ? (LowerBound[j] + Math.Sqrt(Pint[j] * Pint[j] + 1.0) - 1.0) : (LowerBound[j] + Scales[j] * (Math.Sqrt(Pint[j] * Pint[j] + 1.0) - 1.0)));
				}
				return vector;
			}
			if (LowerBound == null && UpperBound != null)
			{
				for (int k = 0; k < Pint.Count; k++)
				{
					vector[k] = ((Scales == null) ? (UpperBound[k] - Math.Sqrt(Pint[k] * Pint[k] + 1.0) + 1.0) : (UpperBound[k] - Scales[k] * (Math.Sqrt(Pint[k] * Pint[k] + 1.0) - 1.0)));
				}
				return vector;
			}
			if (Scales != null)
			{
				for (int l = 0; l < Pint.Count; l++)
				{
					vector[l] = Pint[l] * Scales[l];
				}
				return vector;
			}
			return vector;
		}

		protected static Vector<double> ScaleFactorsOfJacobian(Vector<double> Pint)
		{
			Vector<double> vector = Vector<double>.Build.Dense(Pint.Count, 1.0);
			if (LowerBound != null && UpperBound != null)
			{
				for (int i = 0; i < Pint.Count; i++)
				{
					vector[i] = (UpperBound[i] - LowerBound[i]) / 2.0 * Math.Cos(Pint[i]);
				}
				return vector;
			}
			if (LowerBound != null && UpperBound == null)
			{
				for (int j = 0; j < Pint.Count; j++)
				{
					vector[j] = ((Scales == null) ? (Pint[j] / Math.Sqrt(Pint[j] * Pint[j] + 1.0)) : (Scales[j] * Pint[j] / Math.Sqrt(Pint[j] * Pint[j] + 1.0)));
				}
				return vector;
			}
			if (LowerBound == null && UpperBound != null)
			{
				for (int k = 0; k < Pint.Count; k++)
				{
					vector[k] = ((Scales == null) ? ((0.0 - Pint[k]) / Math.Sqrt(Pint[k] * Pint[k] + 1.0)) : ((0.0 - Scales[k]) * Pint[k] / Math.Sqrt(Pint[k] * Pint[k] + 1.0)));
				}
				return vector;
			}
			if (Scales != null)
			{
				return Scales;
			}
			return vector;
		}
	}
	public static class ObjectiveFunction
	{
		public static IObjectiveFunction Value(Func<Vector<double>, double> function)
		{
			return new ValueObjectiveFunction(function);
		}

		public static IObjectiveFunction Gradient(Func<Vector<double>, Tuple<double, Vector<double>>> function)
		{
			return new GradientObjectiveFunction(function);
		}

		public static IObjectiveFunction Gradient(Func<Vector<double>, double> function, Func<Vector<double>, Vector<double>> gradient)
		{
			return new LazyObjectiveFunction(function, gradient);
		}

		public static IObjectiveFunction Hessian(Func<Vector<double>, Tuple<double, Matrix<double>>> function)
		{
			return new HessianObjectiveFunction(function);
		}

		public static IObjectiveFunction Hessian(Func<Vector<double>, double> function, Func<Vector<double>, Matrix<double>> hessian)
		{
			return new LazyObjectiveFunction(function, null, hessian);
		}

		public static IObjectiveFunction GradientHessian(Func<Vector<double>, Tuple<double, Vector<double>, Matrix<double>>> function)
		{
			return new GradientHessianObjectiveFunction(function);
		}

		public static IObjectiveFunction GradientHessian(Func<Vector<double>, double> function, Func<Vector<double>, Vector<double>> gradient, Func<Vector<double>, Matrix<double>> hessian)
		{
			return new LazyObjectiveFunction(function, gradient, hessian);
		}

		public static IScalarObjectiveFunction ScalarValue(Func<double, double> function)
		{
			return new ScalarValueObjectiveFunction(function);
		}

		public static IScalarObjectiveFunction ScalarDerivative(Func<double, double> function, Func<double, double> derivative)
		{
			return new ScalarObjectiveFunction(function, derivative);
		}

		public static IScalarObjectiveFunction ScalarSecondDerivative(Func<double, double> function, Func<double, double> derivative, Func<double, double> secondDerivative)
		{
			return new ScalarObjectiveFunction(function, derivative, secondDerivative);
		}

		public static IObjectiveModel NonlinearModel(Func<Vector<double>, Vector<double>, Vector<double>> function, Func<Vector<double>, Vector<double>, Matrix<double>> derivatives, Vector<double> observedX, Vector<double> observedY, Vector<double> weight = null)
		{
			NonlinearObjectiveFunction nonlinearObjectiveFunction = new NonlinearObjectiveFunction(function, derivatives);
			nonlinearObjectiveFunction.SetObserved(observedX, observedY, weight);
			return nonlinearObjectiveFunction;
		}

		public static IObjectiveModel NonlinearModel(Func<Vector<double>, Vector<double>, Vector<double>> function, Vector<double> observedX, Vector<double> observedY, Vector<double> weight = null, int accuracyOrder = 2)
		{
			NonlinearObjectiveFunction nonlinearObjectiveFunction = new NonlinearObjectiveFunction(function, null, accuracyOrder);
			nonlinearObjectiveFunction.SetObserved(observedX, observedY, weight);
			return nonlinearObjectiveFunction;
		}

		public static IObjectiveModel NonlinearModel(Func<Vector<double>, double, double> function, Func<Vector<double>, double, Vector<double>> derivatives, Vector<double> observedX, Vector<double> observedY, Vector<double> weight = null)
		{
			NonlinearObjectiveFunction nonlinearObjectiveFunction = new NonlinearObjectiveFunction(func, prime);
			nonlinearObjectiveFunction.SetObserved(observedX, observedY, weight);
			return nonlinearObjectiveFunction;
			Vector<double> func(Vector<double> point, Vector<double> x)
			{
				Vector<double> vector = CreateVector.Dense<double>(x.Count);
				for (int j = 0; j < x.Count; j++)
				{
					vector[j] = function(point, x[j]);
				}
				return vector;
			}
			Matrix<double> prime(Vector<double> point, Vector<double> x)
			{
				Matrix<double> matrix = CreateMatrix.Dense<double>(x.Count, point.Count);
				for (int i = 0; i < x.Count; i++)
				{
					matrix.SetRow(i, derivatives(point, x[i]));
				}
				return matrix;
			}
		}

		public static IObjectiveModel NonlinearModel(Func<Vector<double>, double, double> function, Vector<double> observedX, Vector<double> observedY, Vector<double> weight = null, int accuracyOrder = 2)
		{
			NonlinearObjectiveFunction nonlinearObjectiveFunction = new NonlinearObjectiveFunction(func, null, accuracyOrder);
			nonlinearObjectiveFunction.SetObserved(observedX, observedY, weight);
			return nonlinearObjectiveFunction;
			Vector<double> func(Vector<double> point, Vector<double> x)
			{
				Vector<double> vector = CreateVector.Dense<double>(x.Count);
				for (int i = 0; i < x.Count; i++)
				{
					vector[i] = function(point, x[i]);
				}
				return vector;
			}
		}

		public static IObjectiveFunction NonlinearFunction(Func<Vector<double>, Vector<double>, Vector<double>> function, Func<Vector<double>, Vector<double>, Matrix<double>> derivatives, Vector<double> observedX, Vector<double> observedY, Vector<double> weight = null)
		{
			NonlinearObjectiveFunction nonlinearObjectiveFunction = new NonlinearObjectiveFunction(function, derivatives);
			nonlinearObjectiveFunction.SetObserved(observedX, observedY, weight);
			return nonlinearObjectiveFunction.ToObjectiveFunction();
		}

		public static IObjectiveFunction NonlinearFunction(Func<Vector<double>, Vector<double>, Vector<double>> function, Vector<double> observedX, Vector<double> observedY, Vector<double> weight = null, int accuracyOrder = 2)
		{
			NonlinearObjectiveFunction nonlinearObjectiveFunction = new NonlinearObjectiveFunction(function, null, accuracyOrder);
			nonlinearObjectiveFunction.SetObserved(observedX, observedY, weight);
			return nonlinearObjectiveFunction.ToObjectiveFunction();
		}
	}
	public static class QuadraticGradientProjectionSearch
	{
		public readonly struct GradientProjectionResult
		{
			public Vector<double> CauchyPoint { get; }

			public int FixedCount { get; }

			public List<bool> IsFixed { get; }

			public GradientProjectionResult(Vector<double> cauchyPoint, int fixedCount, List<bool> isFixed)
			{
				CauchyPoint = cauchyPoint;
				FixedCount = fixedCount;
				IsFixed = isFixed;
			}
		}

		public static GradientProjectionResult Search(Vector<double> x0, Vector<double> gradient, Matrix<double> hessian, Vector<double> lowerBound, Vector<double> upperBound)
		{
			List<bool> list = new List<bool>(x0.Count);
			List<double> list2 = new List<double>(x0.Count);
			for (int i = 0; i < x0.Count; i++)
			{
				list2.Add(0.0);
				list.Add(item: false);
				if (gradient[i] < 0.0)
				{
					list2[i] = (x0[i] - upperBound[i]) / gradient[i];
				}
				else if (gradient[i] > 0.0)
				{
					list2[i] = (x0[i] - lowerBound[i]) / gradient[i];
				}
				else if (Math.Abs(x0[i] - upperBound[i]) < 4.94E-322 || Math.Abs(x0[i] - lowerBound[i]) < 4.94E-322)
				{
					list2[i] = 0.0;
				}
				else
				{
					list2[i] = double.PositiveInfinity;
				}
			}
			List<double> list3 = new List<double>(x0.Count);
			list3.AddRange(list2);
			list3.Sort();
			Vector<double> vector = -gradient;
			for (int j = 0; j < vector.Count; j++)
			{
				if (list2[j] <= 0.0)
				{
					vector[j] *= 0.0;
				}
			}
			int num = -1;
			Vector<double> vector2 = x0;
			double num2 = gradient * vector;
			double num3 = 0.5 * vector * hessian * vector;
			double num4 = (0.0 - num2) / num3;
			double num5 = list3[0];
			if (num4 < num5)
			{
				return new GradientProjectionResult(vector2 + num4 * vector, 0, list);
			}
			do
			{
				num++;
				vector2 += vector * num5;
				num5 = list3[num + 1] - list3[num];
				int num6 = 0;
				for (int k = 0; k < vector.Count; k++)
				{
					if (list3[num] >= list2[k])
					{
						vector[k] *= 0.0;
						list[k] = true;
						num6++;
					}
				}
				if (double.IsPositiveInfinity(list3[num + 1]))
				{
					return new GradientProjectionResult(vector2, num6, list);
				}
				double num7 = gradient * vector + (vector2 - x0) * hessian * vector;
				num3 = vector * hessian * vector;
				num4 = (0.0 - num7) / num3;
				if (num4 < num5)
				{
					return new GradientProjectionResult(vector2 + num4 * vector, num6, list);
				}
			}
			while (num + 1 < list3.Count - 1);
			list[list.Count - 1] = true;
			return new GradientProjectionResult(vector2 + num5 * vector, lowerBound.Count, list);
		}
	}
	public class ScalarMinimizationResult
	{
		public double MinimizingPoint => FunctionInfoAtMinimum.Point;

		public IScalarObjectiveFunctionEvaluation FunctionInfoAtMinimum { get; }

		public int Iterations { get; }

		public ExitCondition ReasonForExit { get; }

		public ScalarMinimizationResult(IScalarObjectiveFunctionEvaluation functionInfo, int iterations, ExitCondition reasonForExit)
		{
			FunctionInfoAtMinimum = functionInfo;
			Iterations = iterations;
			ReasonForExit = reasonForExit;
		}
	}
}
namespace MathNet.Numerics.Optimization.TrustRegion
{
	public interface ITrustRegionSubproblem
	{
		Vector<double> Pstep { get; }

		bool HitBoundary { get; }

		void Solve(IObjectiveModel objective, double radius);
	}
	public sealed class TrustRegionDogLegMinimizer : TrustRegionMinimizerBase
	{
		public TrustRegionDogLegMinimizer(double gradientTolerance = 1E-08, double stepTolerance = 1E-08, double functionTolerance = 1E-08, double radiusTolerance = 1E-08, int maximumIterations = -1)
			: base(TrustRegionSubproblem.DogLeg(), gradientTolerance, stepTolerance, functionTolerance, radiusTolerance, maximumIterations)
		{
		}
	}
	public abstract class TrustRegionMinimizerBase : NonlinearMinimizerBase
	{
		public static ITrustRegionSubproblem Subproblem;

		public static double RadiusTolerance { get; set; }

		public TrustRegionMinimizerBase(ITrustRegionSubproblem subproblem, double gradientTolerance = 1E-08, double stepTolerance = 1E-08, double functionTolerance = 1E-08, double radiusTolerance = 1E-08, int maximumIterations = -1)
			: base(gradientTolerance, stepTolerance, functionTolerance, maximumIterations)
		{
			if (subproblem == null)
			{
				throw new ArgumentNullException("subproblem");
			}
			Subproblem = subproblem;
			RadiusTolerance = radiusTolerance;
		}

		public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, Vector<double> initialGuess, Vector<double> lowerBound = null, Vector<double> upperBound = null, Vector<double> scales = null, List<bool> isFixed = null)
		{
			return Minimum(Subproblem, objective, initialGuess, lowerBound, upperBound, scales, isFixed, NonlinearMinimizerBase.GradientTolerance, NonlinearMinimizerBase.StepTolerance, NonlinearMinimizerBase.FunctionTolerance, RadiusTolerance, NonlinearMinimizerBase.MaximumIterations);
		}

		public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, double[] initialGuess, double[] lowerBound = null, double[] upperBound = null, double[] scales = null, bool[] isFixed = null)
		{
			Vector<double> lowerBound2 = ((lowerBound == null) ? null : CreateVector.Dense(lowerBound));
			Vector<double> upperBound2 = ((upperBound == null) ? null : CreateVector.Dense(upperBound));
			Vector<double> scales2 = ((scales == null) ? null : CreateVector.Dense(scales));
			List<bool> isFixed2 = isFixed?.ToList();
			return Minimum(Subproblem, objective, CreateVector.DenseOfArray(initialGuess), lowerBound2, upperBound2, scales2, isFixed2, NonlinearMinimizerBase.GradientTolerance, NonlinearMinimizerBase.StepTolerance, NonlinearMinimizerBase.FunctionTolerance, RadiusTolerance, NonlinearMinimizerBase.MaximumIterations);
		}

		public static NonlinearMinimizationResult Minimum(ITrustRegionSubproblem subproblem, IObjectiveModel objective, Vector<double> initialGuess, Vector<double> lowerBound = null, Vector<double> upperBound = null, Vector<double> scales = null, List<bool> isFixed = null, double gradientTolerance = 1E-08, double stepTolerance = 1E-08, double functionTolerance = 1E-08, double radiusTolerance = 1E-18, int maximumIterations = -1)
		{
			double val = 1000.0;
			double num = 0.0;
			if (objective == null)
			{
				throw new ArgumentNullException("objective");
			}
			NonlinearMinimizerBase.ValidateBounds(initialGuess, lowerBound, upperBound, scales);
			objective.SetParameters(initialGuess, isFixed);
			ExitCondition exitCondition = ExitCondition.None;
			Vector<double> vector = NonlinearMinimizerBase.ProjectToInternalParameters(initialGuess);
			Vector<double> vector2 = Vector<double>.Build.Dense(vector.Count);
			double num2 = NonlinearMinimizerBase.EvaluateFunction(objective, initialGuess);
			if (maximumIterations < 0)
			{
				maximumIterations = 200 * (initialGuess.Count + 1);
			}
			if (double.IsNaN(num2))
			{
				exitCondition = ExitCondition.InvalidValues;
				return new NonlinearMinimizationResult(objective, -1, exitCondition);
			}
			if (maximumIterations == 0)
			{
				exitCondition = ExitCondition.ManuallyStopped;
			}
			if (num2 <= functionTolerance)
			{
				exitCondition = ExitCondition.Converged;
			}
			Tuple<Vector<double>, Matrix<double>> tuple = NonlinearMinimizerBase.EvaluateJacobian(objective, vector);
			Vector<double> item = tuple.Item1;
			Matrix<double> item2 = tuple.Item2;
			if (item.InfinityNorm() <= gradientTolerance)
			{
				exitCondition = ExitCondition.RelativeGradient;
			}
			if (exitCondition != 0)
			{
				return new NonlinearMinimizationResult(objective, -1, exitCondition);
			}
			double val2 = item.DotProduct(item) / (item2 * item).DotProduct(item);
			val2 = Math.Max(1.0, Math.Min(val2, val));
			int num3 = 0;
			bool flag = false;
			while (num3 < maximumIterations && exitCondition == ExitCondition.None)
			{
				num3++;
				subproblem.Solve(objective, val2);
				vector2 = subproblem.Pstep;
				flag = subproblem.HitBoundary;
				double num4 = 0.0 - item.DotProduct(vector2) - 0.5 * vector2.DotProduct(item2 * vector2);
				if (vector2.L2Norm() <= stepTolerance * (stepTolerance + vector.L2Norm()))
				{
					exitCondition = ExitCondition.RelativePoints;
					break;
				}
				Vector<double> vector3 = vector + vector2;
				double num5 = NonlinearMinimizerBase.EvaluateFunction(objective, vector3);
				if (double.IsNaN(num5))
				{
					exitCondition = ExitCondition.InvalidValues;
					break;
				}
				double num6 = ((num4 != 0.0) ? ((num2 - num5) / num4) : 0.0);
				if (num6 > 0.75 && flag)
				{
					val2 = Math.Min(2.0 * val2, val);
				}
				else if (num6 < 0.25)
				{
					val2 *= 0.25;
					if (val2 <= radiusTolerance * (radiusTolerance + vector.DotProduct(vector)))
					{
						exitCondition = ExitCondition.LackOfProgress;
						break;
					}
				}
				if (num6 > num)
				{
					vector3.CopyTo(vector);
					num2 = num5;
					Tuple<Vector<double>, Matrix<double>> tuple2 = NonlinearMinimizerBase.EvaluateJacobian(objective, vector);
					item = tuple2.Item1;
					item2 = tuple2.Item2;
					if (item.InfinityNorm() <= gradientTolerance)
					{
						exitCondition = ExitCondition.RelativeGradient;
					}
					if (num2 <= functionTolerance)
					{
						exitCondition = ExitCondition.Converged;
					}
				}
			}
			if (num3 >= maximumIterations)
			{
				exitCondition = ExitCondition.ExceedIterations;
			}
			return new NonlinearMinimizationResult(objective, num3, exitCondition);
		}
	}
	public sealed class TrustRegionNewtonCGMinimizer : TrustRegionMinimizerBase
	{
		public TrustRegionNewtonCGMinimizer(double gradientTolerance = 1E-08, double stepTolerance = 1E-08, double functionTolerance = 1E-08, double radiusTolerance = 1E-08, int maximumIterations = -1)
			: base(TrustRegionSubproblem.NewtonCG(), gradientTolerance, stepTolerance, functionTolerance, radiusTolerance, maximumIterations)
		{
		}
	}
	public static class TrustRegionSubproblem
	{
		public static ITrustRegionSubproblem DogLeg()
		{
			return new DogLegSubproblem();
		}

		public static ITrustRegionSubproblem NewtonCG()
		{
			return new NewtonCGSubproblem();
		}
	}
}
namespace MathNet.Numerics.Optimization.TrustRegion.Subproblems
{
	internal class DogLegSubproblem : ITrustRegionSubproblem
	{
		public Vector<double> Pstep { get; private set; }

		public bool HitBoundary { get; private set; }

		public void Solve(IObjectiveModel objective, double delta)
		{
			Vector<double> gradient = objective.Gradient;
			Matrix<double> hessian = objective.Hessian;
			Vector<double> vector = -hessian.PseudoInverse() * gradient;
			double num = gradient.DotProduct(gradient) / (hessian * gradient).DotProduct(gradient);
			Vector<double> vector2 = (0.0 - num) * gradient;
			if (vector.L2Norm() <= delta)
			{
				HitBoundary = false;
				Pstep = vector;
			}
			else if (num * vector2.L2Norm() >= delta)
			{
				HitBoundary = true;
				Pstep = delta / vector2.L2Norm() * vector2;
			}
			else
			{
				HitBoundary = true;
				double item = Util.FindBeta(num, vector2, vector, delta).Item2;
				Pstep = num * vector2 + item * (vector - num * vector2);
			}
		}
	}
	internal class NewtonCGSubproblem : ITrustRegionSubproblem
	{
		public Vector<double> Pstep { get; private set; }

		public bool HitBoundary { get; private set; }

		public void Solve(IObjectiveModel objective, double delta)
		{
			Vector<double> gradient = objective.Gradient;
			Matrix<double> hessian = objective.Hessian;
			double num = gradient.L2Norm();
			double num2 = Math.Min(0.5, Math.Sqrt(num)) * num;
			Vector<double> vector = Vector<double>.Build.Dense(hessian.RowCount);
			Vector<double> vector2 = gradient;
			Vector<double> vector3 = -vector2;
			Vector<double> vector5;
			while (true)
			{
				Vector<double> vector4 = hessian * vector3;
				double num3 = vector3.DotProduct(vector4);
				if (num3 <= 0.0)
				{
					Tuple<double, double> tuple = Util.FindBeta(1.0, vector, vector3, delta);
					Pstep = vector + tuple.Item1 * vector3;
					HitBoundary = true;
					return;
				}
				double num4 = vector2.DotProduct(vector2);
				double num5 = num4 / num3;
				vector5 = vector + num5 * vector3;
				if (vector5.L2Norm() >= delta)
				{
					Tuple<double, double> tuple2 = Util.FindBeta(1.0, vector, vector3, delta);
					Pstep = vector + tuple2.Item2 * vector3;
					HitBoundary = true;
					return;
				}
				Vector<double> vector6 = vector2 + num5 * vector4;
				double num6 = vector6.DotProduct(vector6);
				if (Math.Sqrt(num6) < num2)
				{
					break;
				}
				vector = vector5;
				vector2 = vector6;
				vector3 = -vector6 + num6 / num4 * vector3;
			}
			Pstep = vector5;
			HitBoundary = false;
		}
	}
	internal static class Util
	{
		public static Tuple<double, double> FindBeta(double alpha, Vector<double> sd, Vector<double> gn, double delta)
		{
			Vector<double> vector = alpha * sd;
			Vector<double> vector2 = gn - vector;
			double num = vector2.DotProduct(vector2);
			double num2 = 2.0 * vector.DotProduct(vector2);
			double num3 = vector.DotProduct(vector) - delta * delta;
			double num4 = num2 + ((num2 >= 0.0) ? 1.0 : (-1.0)) * Math.Sqrt(num2 * num2 - 4.0 * num * num3);
			double num5 = (0.0 - num4) / 2.0 / num;
			double num6 = -2.0 * num3 / num4;
			if (!(num5 < num6))
			{
				return new Tuple<double, double>(num6, num5);
			}
			return new Tuple<double, double>(num5, num6);
		}
	}
}
namespace MathNet.Numerics.Optimization.ObjectiveFunctions
{
	public class ForwardDifferenceGradientObjectiveFunction : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private Vector<double> _gradient;

		public IObjectiveFunction InnerObjectiveFunction { get; protected set; }

		protected Vector<double> LowerBound { get; set; }

		protected Vector<double> UpperBound { get; set; }

		protected bool ValueEvaluated { get; set; }

		protected bool GradientEvaluated { get; set; }

		public double MinimumIncrement { get; set; }

		public double RelativeIncrement { get; set; }

		public Vector<double> Gradient
		{
			get
			{
				if (!GradientEvaluated)
				{
					EvaluateGradient();
				}
				return _gradient;
			}
			protected set
			{
				_gradient = value;
			}
		}

		public Matrix<double> Hessian
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public bool IsGradientSupported => true;

		public bool IsHessianSupported => false;

		public Vector<double> Point { get; protected set; }

		public double Value
		{
			get
			{
				if (!ValueEvaluated)
				{
					EvaluateValue();
				}
				return InnerObjectiveFunction.Value;
			}
		}

		public ForwardDifferenceGradientObjectiveFunction(IObjectiveFunction valueOnlyObj, Vector<double> lowerBound, Vector<double> upperBound, double relativeIncrement = 1E-05, double minimumIncrement = 1E-08)
		{
			InnerObjectiveFunction = valueOnlyObj;
			LowerBound = lowerBound;
			UpperBound = upperBound;
			_gradient = new MathNet.Numerics.LinearAlgebra.Double.DenseVector(LowerBound.Count);
			RelativeIncrement = relativeIncrement;
			MinimumIncrement = minimumIncrement;
		}

		protected void EvaluateValue()
		{
			ValueEvaluated = true;
		}

		protected void EvaluateGradient()
		{
			if (!ValueEvaluated)
			{
				EvaluateValue();
			}
			Vector<double> vector = Point.Clone();
			IObjectiveFunction objectiveFunction = InnerObjectiveFunction.CreateNew();
			for (int i = 0; i < _gradient.Count; i++)
			{
				double num = vector[i];
				double num2 = Math.Max(num * RelativeIncrement, MinimumIncrement);
				int num3 = 1;
				if (num + num2 > UpperBound[i])
				{
					num3 = -1;
				}
				vector[i] = num + (double)num3 * num2;
				objectiveFunction.EvaluateAt(vector);
				double value = objectiveFunction.Value;
				_gradient[i] = ((double)num3 * value - (double)num3 * InnerObjectiveFunction.Value) / num2;
				vector[i] = num;
			}
			GradientEvaluated = true;
		}

		public IObjectiveFunction CreateNew()
		{
			return new ForwardDifferenceGradientObjectiveFunction(InnerObjectiveFunction.CreateNew(), LowerBound, UpperBound, RelativeIncrement, MinimumIncrement);
		}

		public void EvaluateAt(Vector<double> point)
		{
			Point = point;
			ValueEvaluated = false;
			GradientEvaluated = false;
			InnerObjectiveFunction.EvaluateAt(point);
		}

		public IObjectiveFunction Fork()
		{
			return new ForwardDifferenceGradientObjectiveFunction(InnerObjectiveFunction.Fork(), LowerBound, UpperBound, RelativeIncrement, MinimumIncrement)
			{
				Point = Point?.Clone(),
				GradientEvaluated = GradientEvaluated,
				ValueEvaluated = ValueEvaluated,
				_gradient = _gradient?.Clone()
			};
		}
	}
	internal class GradientHessianObjectiveFunction : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private readonly Func<Vector<double>, Tuple<double, Vector<double>, Matrix<double>>> _function;

		public bool IsGradientSupported => true;

		public bool IsHessianSupported => true;

		public Vector<double> Point { get; private set; }

		public double Value { get; private set; }

		public Vector<double> Gradient { get; private set; }

		public Matrix<double> Hessian { get; private set; }

		public GradientHessianObjectiveFunction(Func<Vector<double>, Tuple<double, Vector<double>, Matrix<double>>> function)
		{
			_function = function;
		}

		public IObjectiveFunction CreateNew()
		{
			return new GradientHessianObjectiveFunction(_function);
		}

		public IObjectiveFunction Fork()
		{
			return new GradientHessianObjectiveFunction(_function)
			{
				Point = Point,
				Value = Value,
				Gradient = Gradient,
				Hessian = Hessian
			};
		}

		public void EvaluateAt(Vector<double> point)
		{
			Point = point;
			Tuple<double, Vector<double>, Matrix<double>> tuple = _function(point);
			Value = tuple.Item1;
			Gradient = tuple.Item2;
			Hessian = tuple.Item3;
		}
	}
	internal class GradientObjectiveFunction : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private readonly Func<Vector<double>, Tuple<double, Vector<double>>> _function;

		public bool IsGradientSupported => true;

		public bool IsHessianSupported => false;

		public Vector<double> Point { get; private set; }

		public double Value { get; private set; }

		public Vector<double> Gradient { get; private set; }

		public Matrix<double> Hessian
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public GradientObjectiveFunction(Func<Vector<double>, Tuple<double, Vector<double>>> function)
		{
			_function = function;
		}

		public IObjectiveFunction CreateNew()
		{
			return new GradientObjectiveFunction(_function);
		}

		public IObjectiveFunction Fork()
		{
			return new GradientObjectiveFunction(_function)
			{
				Point = Point,
				Value = Value,
				Gradient = Gradient
			};
		}

		public void EvaluateAt(Vector<double> point)
		{
			Point = point;
			Tuple<double, Vector<double>> tuple = _function(point);
			Value = tuple.Item1;
			Gradient = tuple.Item2;
		}
	}
	internal class HessianObjectiveFunction : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private readonly Func<Vector<double>, Tuple<double, Matrix<double>>> _function;

		public bool IsGradientSupported => false;

		public bool IsHessianSupported => true;

		public Vector<double> Point { get; private set; }

		public double Value { get; private set; }

		public Matrix<double> Hessian { get; private set; }

		public Vector<double> Gradient
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public HessianObjectiveFunction(Func<Vector<double>, Tuple<double, Matrix<double>>> function)
		{
			_function = function;
		}

		public IObjectiveFunction CreateNew()
		{
			return new HessianObjectiveFunction(_function);
		}

		public IObjectiveFunction Fork()
		{
			return new HessianObjectiveFunction(_function)
			{
				Point = Point,
				Value = Value,
				Hessian = Hessian
			};
		}

		public void EvaluateAt(Vector<double> point)
		{
			Point = point;
			Tuple<double, Matrix<double>> tuple = _function(point);
			Value = tuple.Item1;
			Hessian = tuple.Item2;
		}
	}
	internal class LazyObjectiveFunction : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private readonly Func<Vector<double>, double> _function;

		private readonly Func<Vector<double>, Vector<double>> _gradient;

		private readonly Func<Vector<double>, Matrix<double>> _hessian;

		private Vector<double> _point;

		private bool _hasFunctionValue;

		private double _functionValue;

		private bool _hasGradientValue;

		private Vector<double> _gradientValue;

		private bool _hasHessianValue;

		private Matrix<double> _hessianValue;

		public bool IsGradientSupported { get; private set; }

		public bool IsHessianSupported { get; private set; }

		public Vector<double> Point => _point;

		public double Value
		{
			get
			{
				if (!_hasFunctionValue)
				{
					_functionValue = _function(_point);
					_hasFunctionValue = true;
				}
				return _functionValue;
			}
		}

		public Vector<double> Gradient
		{
			get
			{
				if (!_hasGradientValue)
				{
					_gradientValue = _gradient(_point);
					_hasGradientValue = true;
				}
				return _gradientValue;
			}
		}

		public Matrix<double> Hessian
		{
			get
			{
				if (!_hasHessianValue)
				{
					_hessianValue = _hessian(_point);
					_hasHessianValue = true;
				}
				return _hessianValue;
			}
		}

		public LazyObjectiveFunction(Func<Vector<double>, double> function, Func<Vector<double>, Vector<double>> gradient = null, Func<Vector<double>, Matrix<double>> hessian = null)
		{
			_function = function;
			_gradient = gradient;
			_hessian = hessian;
			IsGradientSupported = gradient != null;
			IsHessianSupported = hessian != null;
		}

		public IObjectiveFunction CreateNew()
		{
			return new LazyObjectiveFunction(_function, _gradient, _hessian);
		}

		public IObjectiveFunction Fork()
		{
			return new LazyObjectiveFunction(_function, _gradient, _hessian)
			{
				_point = _point,
				_hasFunctionValue = _hasFunctionValue,
				_functionValue = _functionValue,
				_hasGradientValue = _hasGradientValue,
				_gradientValue = _gradientValue,
				_hasHessianValue = _hasHessianValue,
				_hessianValue = _hessianValue
			};
		}

		public void EvaluateAt(Vector<double> point)
		{
			_point = point;
			_hasFunctionValue = false;
			_hasGradientValue = false;
			_hasHessianValue = false;
			_gradientValue = null;
			_hessianValue = null;
		}
	}
	public abstract class LazyObjectiveFunctionBase : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private Vector<double> _point;

		protected bool HasFunctionValue { get; set; }

		protected double FunctionValue { get; set; }

		protected bool HasGradientValue { get; set; }

		protected Vector<double> GradientValue { get; set; }

		protected bool HasHessianValue { get; set; }

		protected Matrix<double> HessianValue { get; set; }

		public bool IsGradientSupported { get; private set; }

		public bool IsHessianSupported { get; private set; }

		public Vector<double> Point => _point;

		public double Value
		{
			get
			{
				if (!HasFunctionValue)
				{
					EvaluateValue();
				}
				return FunctionValue;
			}
			protected set
			{
				FunctionValue = value;
				HasFunctionValue = true;
			}
		}

		public Vector<double> Gradient
		{
			get
			{
				if (!HasGradientValue)
				{
					EvaluateGradient();
				}
				return GradientValue;
			}
			protected set
			{
				GradientValue = value;
				HasGradientValue = true;
			}
		}

		public Matrix<double> Hessian
		{
			get
			{
				if (!HasHessianValue)
				{
					EvaluateHessian();
				}
				return HessianValue;
			}
			protected set
			{
				HessianValue = value;
				HasHessianValue = true;
			}
		}

		protected LazyObjectiveFunctionBase(bool gradientSupported, bool hessianSupported)
		{
			IsGradientSupported = gradientSupported;
			IsHessianSupported = hessianSupported;
		}

		public abstract IObjectiveFunction CreateNew();

		public virtual IObjectiveFunction Fork()
		{
			LazyObjectiveFunctionBase obj = (LazyObjectiveFunctionBase)CreateNew();
			obj._point = _point?.Clone();
			obj.HasFunctionValue = HasFunctionValue;
			obj.FunctionValue = FunctionValue;
			obj.HasGradientValue = HasGradientValue;
			obj.GradientValue = GradientValue?.Clone();
			obj.HasHessianValue = HasHessianValue;
			obj.HessianValue = HessianValue?.Clone();
			return obj;
		}

		public void EvaluateAt(Vector<double> point)
		{
			_point = point;
			HasFunctionValue = false;
			HasGradientValue = false;
			HasHessianValue = false;
		}

		protected abstract void EvaluateValue();

		protected virtual void EvaluateGradient()
		{
			Gradient = null;
		}

		protected virtual void EvaluateHessian()
		{
			Hessian = null;
		}
	}
	internal class NonlinearObjectiveFunction : IObjectiveModel, IObjectiveModelEvaluation
	{
		private readonly Func<Vector<double>, Vector<double>, Vector<double>> userFunction;

		private readonly Func<Vector<double>, Vector<double>, Matrix<double>> userDerivative;

		private readonly int accuracyOrder;

		private Vector<double> coefficients;

		private bool hasFunctionValue;

		private double functionValue;

		private Vector<double> residuals;

		private bool hasJacobianValue;

		private Matrix<double> jacobianValue;

		private Vector<double> gradientValue;

		private Matrix<double> hessianValue;

		private Vector<double> L;

		public Vector<double> ObservedX { get; private set; }

		public Vector<double> ObservedY { get; private set; }

		public Matrix<double> Weights { get; private set; }

		public List<bool> IsFixed { get; private set; }

		public int NumberOfObservations => ObservedY?.Count ?? 0;

		public int NumberOfParameters => Point?.Count ?? 0;

		public int DegreeOfFreedom
		{
			get
			{
				int num = NumberOfObservations - NumberOfParameters;
				if (IsFixed != null)
				{
					num += IsFixed.Count((bool p) => p);
				}
				return num;
			}
		}

		public int FunctionEvaluations { get; set; }

		public int JacobianEvaluations { get; set; }

		public Vector<double> Point => coefficients;

		public Vector<double> ModelValues { get; private set; }

		public double Value
		{
			get
			{
				if (!hasFunctionValue)
				{
					EvaluateFunction();
					hasFunctionValue = true;
				}
				return functionValue;
			}
		}

		public Vector<double> Gradient
		{
			get
			{
				if (!hasJacobianValue)
				{
					EvaluateJacobian();
					hasJacobianValue = true;
				}
				return gradientValue;
			}
		}

		public Matrix<double> Hessian
		{
			get
			{
				if (!hasJacobianValue)
				{
					EvaluateJacobian();
					hasJacobianValue = true;
				}
				return hessianValue;
			}
		}

		public bool IsGradientSupported => true;

		public bool IsHessianSupported => true;

		public NonlinearObjectiveFunction(Func<Vector<double>, Vector<double>, Vector<double>> function, Func<Vector<double>, Vector<double>, Matrix<double>> derivative = null, int accuracyOrder = 2)
		{
			userFunction = function;
			userDerivative = derivative;
			this.accuracyOrder = Math.Min(6, Math.Max(1, accuracyOrder));
		}

		public IObjectiveModel Fork()
		{
			return new NonlinearObjectiveFunction(userFunction, userDerivative, accuracyOrder)
			{
				ObservedX = ObservedX,
				ObservedY = ObservedY,
				Weights = Weights,
				coefficients = coefficients,
				hasFunctionValue = hasFunctionValue,
				functionValue = functionValue,
				hasJacobianValue = hasJacobianValue,
				jacobianValue = jacobianValue,
				gradientValue = gradientValue,
				hessianValue = hessianValue
			};
		}

		public IObjectiveModel CreateNew()
		{
			return new NonlinearObjectiveFunction(userFunction, userDerivative, accuracyOrder);
		}

		public void SetObserved(Vector<double> observedX, Vector<double> observedY, Vector<double> weights = null)
		{
			if (observedX == null || observedY == null)
			{
				throw new ArgumentNullException("The data set can't be null.");
			}
			if (observedX.Count != observedY.Count)
			{
				throw new ArgumentException("The observed x data can't have different from observed y data.");
			}
			ObservedX = observedX;
			ObservedY = observedY;
			if (weights != null && weights.Count != observedY.Count)
			{
				throw new ArgumentException("The weightings can't have different from observations.");
			}
			if (weights != null && weights.Count((double x) => double.IsInfinity(x) || double.IsNaN(x)) > 0)
			{
				throw new ArgumentException("The weightings are not well-defined.");
			}
			if (weights != null && weights.Count((double x) => x == 0.0) == weights.Count)
			{
				throw new ArgumentException("All the weightings can't be zero.");
			}
			if (weights != null && weights.Count((double x) => x < 0.0) > 0)
			{
				weights = weights.PointwiseAbs();
			}
			Weights = ((weights == null) ? null : Matrix<double>.Build.DenseOfDiagonalVector(weights));
			L = ((weights == null) ? null : Weights.Diagonal().PointwiseSqrt());
		}

		public void SetParameters(Vector<double> initialGuess, List<bool> isFixed = null)
		{
			if (initialGuess == null)
			{
				throw new ArgumentNullException("initialGuess");
			}
			coefficients = initialGuess;
			if (isFixed != null && isFixed.Count != initialGuess.Count)
			{
				throw new ArgumentException("The isFixed can't have different size from the initial guess.");
			}
			if (isFixed != null && isFixed.Count((bool p) => p) == isFixed.Count)
			{
				throw new ArgumentException("All the parameters can't be fixed.");
			}
			IsFixed = isFixed;
		}

		public void EvaluateAt(Vector<double> parameters)
		{
			if (parameters == null)
			{
				throw new ArgumentNullException("parameters");
			}
			if (parameters.Count((double p) => double.IsNaN(p) || double.IsInfinity(p)) > 0)
			{
				throw new ArgumentException("The parameters must be finite.");
			}
			coefficients = parameters;
			hasFunctionValue = false;
			hasJacobianValue = false;
			jacobianValue = null;
			gradientValue = null;
			hessianValue = null;
		}

		public IObjectiveFunction ToObjectiveFunction()
		{
			return new GradientHessianObjectiveFunction(function);
			Tuple<double, Vector<double>, Matrix<double>> function(Vector<double> point)
			{
				EvaluateAt(point);
				return new Tuple<double, Vector<double>, Matrix<double>>(Value, Gradient, Hessian);
			}
		}

		private void EvaluateFunction()
		{
			if (ModelValues == null)
			{
				ModelValues = Vector<double>.Build.Dense(NumberOfObservations);
			}
			ModelValues = userFunction(Point, ObservedX);
			FunctionEvaluations++;
			residuals = ((Weights == null) ? (ObservedY - ModelValues) : (ObservedY - ModelValues).PointwiseMultiply(L));
			functionValue = residuals.DotProduct(residuals);
		}

		private void EvaluateJacobian()
		{
			if (userDerivative != null)
			{
				jacobianValue = userDerivative(Point, ObservedX);
				JacobianEvaluations++;
			}
			else
			{
				jacobianValue = NumericalJacobian(Point, ModelValues, accuracyOrder);
				FunctionEvaluations += accuracyOrder;
			}
			for (int i = 0; i < NumberOfObservations; i++)
			{
				for (int j = 0; j < NumberOfParameters; j++)
				{
					if (IsFixed != null && IsFixed[j])
					{
						jacobianValue[i, j] = 0.0;
					}
					else if (Weights != null)
					{
						jacobianValue[i, j] *= L[i];
					}
				}
			}
			gradientValue = -jacobianValue.Transpose() * residuals;
			hessianValue = jacobianValue.Transpose() * jacobianValue;
		}

		private Matrix<double> NumericalJacobian(Vector<double> parameters, Vector<double> currentValues, int accuracyOrder = 2)
		{
			Matrix<double> matrix = Matrix<double>.Build.Dense(NumberOfObservations, NumberOfParameters);
			Vector<double> vector = 3E-06 * parameters.PointwiseAbs().PointwiseMaximum(1.4901161193847656E-08);
			Vector<double> vector2 = Vector<double>.Build.Dense(NumberOfParameters);
			for (int i = 0; i < NumberOfParameters; i++)
			{
				vector2[i] = vector[i];
				if (accuracyOrder >= 6)
				{
					Vector<double> vector3 = userFunction(parameters - 3.0 * vector2, ObservedX);
					Vector<double> vector4 = userFunction(parameters - 2.0 * vector2, ObservedX);
					Vector<double> vector5 = userFunction(parameters - vector2, ObservedX);
					Vector<double> vector6 = userFunction(parameters + vector2, ObservedX);
					Vector<double> vector7 = userFunction(parameters + 2.0 * vector2, ObservedX);
					Vector<double> vector8 = userFunction(parameters + 3.0 * vector2, ObservedX);
					Vector<double> column = (-vector3 + 9.0 * vector4 - 45.0 * vector5 + 45.0 * vector6 - 9.0 * vector7 + vector8) / (60.0 * vector2[i]);
					matrix.SetColumn(i, column);
				}
				else
				{
					switch (accuracyOrder)
					{
					case 5:
					{
						Vector<double> vector19 = userFunction(parameters + vector2, ObservedX);
						Vector<double> vector20 = userFunction(parameters + 2.0 * vector2, ObservedX);
						Vector<double> vector21 = userFunction(parameters + 3.0 * vector2, ObservedX);
						Vector<double> vector22 = userFunction(parameters + 4.0 * vector2, ObservedX);
						Vector<double> vector23 = userFunction(parameters + 5.0 * vector2, ObservedX);
						Vector<double> column6 = (-137.0 * currentValues + 300.0 * vector19 - 300.0 * vector20 + 200.0 * vector21 - 75.0 * vector22 + 12.0 * vector23) / (60.0 * vector2[i]);
						matrix.SetColumn(i, column6);
						break;
					}
					case 4:
					{
						Vector<double> vector15 = userFunction(parameters - 2.0 * vector2, ObservedX);
						Vector<double> vector16 = userFunction(parameters - vector2, ObservedX);
						Vector<double> vector17 = userFunction(parameters + vector2, ObservedX);
						Vector<double> vector18 = userFunction(parameters + 2.0 * vector2, ObservedX);
						Vector<double> column5 = (vector15 - 8.0 * vector16 + 8.0 * vector17 - vector18) / (12.0 * vector2[i]);
						matrix.SetColumn(i, column5);
						break;
					}
					case 3:
					{
						Vector<double> vector12 = userFunction(parameters + vector2, ObservedX);
						Vector<double> vector13 = userFunction(parameters + 2.0 * vector2, ObservedX);
						Vector<double> vector14 = userFunction(parameters + 3.0 * vector2, ObservedX);
						Vector<double> column4 = (-11.0 * currentValues + 18.0 * vector12 - 9.0 * vector13 + 2.0 * vector14) / (6.0 * vector2[i]);
						matrix.SetColumn(i, column4);
						break;
					}
					case 2:
					{
						Vector<double> vector10 = userFunction(parameters + vector2, ObservedX);
						Vector<double> vector11 = userFunction(parameters - vector2, ObservedX);
						Vector<double> column3 = (vector10 - vector11) / (2.0 * vector2[i]);
						matrix.SetColumn(i, column3);
						break;
					}
					default:
					{
						Vector<double> vector9 = userFunction(parameters + vector2, ObservedX);
						Vector<double> column2 = (-currentValues + vector9) / vector2[i];
						matrix.SetColumn(i, column2);
						break;
					}
					}
				}
				vector2[i] = 0.0;
			}
			return matrix;
		}
	}
	public abstract class ObjectiveFunctionBase : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		public bool IsGradientSupported { get; private set; }

		public bool IsHessianSupported { get; private set; }

		public Vector<double> Point { get; private set; }

		public double Value { get; protected set; }

		public Vector<double> Gradient { get; protected set; }

		public Matrix<double> Hessian { get; protected set; }

		protected ObjectiveFunctionBase(bool isGradientSupported, bool isHessianSupported)
		{
			IsGradientSupported = isGradientSupported;
			IsHessianSupported = isHessianSupported;
		}

		public abstract IObjectiveFunction CreateNew();

		public virtual IObjectiveFunction Fork()
		{
			ObjectiveFunctionBase obj = (ObjectiveFunctionBase)CreateNew();
			obj.Point = ((Point == null) ? null : Point.Clone());
			obj.Value = Value;
			obj.Gradient = ((Gradient == null) ? null : Gradient.Clone());
			obj.Hessian = ((Hessian == null) ? null : Hessian.Clone());
			return obj;
		}

		public void EvaluateAt(Vector<double> point)
		{
			Point = point;
			Evaluate();
		}

		protected abstract void Evaluate();
	}
	internal class LazyScalarObjectiveFunctionEvaluation : IScalarObjectiveFunctionEvaluation
	{
		private double? _value;

		private double? _derivative;

		private double? _secondDerivative;

		private readonly ScalarObjectiveFunction _objectiveObject;

		private readonly double _point;

		public double Point => _point;

		public double Value => _value ?? SetValue();

		public double Derivative => _derivative ?? SetDerivative();

		public double SecondDerivative => _secondDerivative ?? SetSecondDerivative();

		public LazyScalarObjectiveFunctionEvaluation(ScalarObjectiveFunction f, double point)
		{
			_objectiveObject = f;
			_point = point;
		}

		private double SetValue()
		{
			_value = _objectiveObject.Objective(_point);
			return _value.Value;
		}

		private double SetDerivative()
		{
			_derivative = _objectiveObject.Derivative(_point);
			return _derivative.Value;
		}

		private double SetSecondDerivative()
		{
			_secondDerivative = _objectiveObject.SecondDerivative(_point);
			return _secondDerivative.Value;
		}
	}
	internal class ScalarObjectiveFunction : IScalarObjectiveFunction
	{
		public Func<double, double> Objective { get; }

		public Func<double, double> Derivative { get; }

		public Func<double, double> SecondDerivative { get; }

		public bool IsDerivativeSupported => Derivative != null;

		public bool IsSecondDerivativeSupported => SecondDerivative != null;

		public ScalarObjectiveFunction(Func<double, double> objective)
		{
			Objective = objective;
			Derivative = null;
			SecondDerivative = null;
		}

		public ScalarObjectiveFunction(Func<double, double> objective, Func<double, double> derivative)
		{
			Objective = objective;
			Derivative = derivative;
			SecondDerivative = null;
		}

		public ScalarObjectiveFunction(Func<double, double> objective, Func<double, double> derivative, Func<double, double> secondDerivative)
		{
			Objective = objective;
			Derivative = derivative;
			SecondDerivative = secondDerivative;
		}

		public IScalarObjectiveFunctionEvaluation Evaluate(double point)
		{
			return new LazyScalarObjectiveFunctionEvaluation(this, point);
		}
	}
	internal class ScalarValueObjectiveFunctionEvaluation : IScalarObjectiveFunctionEvaluation
	{
		public double Point { get; }

		public double Value { get; }

		public double Derivative
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double SecondDerivative
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public ScalarValueObjectiveFunctionEvaluation(double point, double value)
		{
			Point = point;
			Value = value;
		}
	}
	internal class ScalarValueObjectiveFunction : IScalarObjectiveFunction
	{
		public Func<double, double> Objective { get; }

		public bool IsDerivativeSupported => false;

		public bool IsSecondDerivativeSupported => false;

		public ScalarValueObjectiveFunction(Func<double, double> objective)
		{
			Objective = objective;
		}

		public IScalarObjectiveFunctionEvaluation Evaluate(double point)
		{
			return new ScalarValueObjectiveFunctionEvaluation(point, Objective(point));
		}
	}
	internal class ValueObjectiveFunction : IObjectiveFunction, IObjectiveFunctionEvaluation
	{
		private readonly Func<Vector<double>, double> _function;

		public bool IsGradientSupported => false;

		public bool IsHessianSupported => false;

		public Vector<double> Point { get; private set; }

		public double Value { get; private set; }

		public Matrix<double> Hessian
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public Vector<double> Gradient
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public ValueObjectiveFunction(Func<Vector<double>, double> function)
		{
			_function = function;
		}

		public IObjectiveFunction CreateNew()
		{
			return new ValueObjectiveFunction(_function);
		}

		public IObjectiveFunction Fork()
		{
			return new ValueObjectiveFunction(_function)
			{
				Point = Point,
				Value = Value
			};
		}

		public void EvaluateAt(Vector<double> point)
		{
			Point = point;
			Value = _function(point);
		}
	}
}
namespace MathNet.Numerics.Optimization.LineSearch
{
	public class LineSearchResult : MinimizationResult
	{
		public double FinalStep { get; private set; }

		public LineSearchResult(IObjectiveFunction functionInfo, int iterations, double finalStep, ExitCondition reasonForExit)
			: base(functionInfo, iterations, reasonForExit)
		{
			FinalStep = finalStep;
		}
	}
	public class StrongWolfeLineSearch : WolfeLineSearch
	{
		protected override ExitCondition WolfeExitCondition => ExitCondition.StrongWolfeCriteria;

		public StrongWolfeLineSearch(double c1, double c2, double parameterTolerance, int maxIterations = 10)
			: base(c1, c2, parameterTolerance, maxIterations)
		{
		}

		protected override bool WolfeCondition(double stepDd, double initialDd)
		{
			return Math.Abs(stepDd) > base.C2 * Math.Abs(initialDd);
		}
	}
	public class WeakWolfeLineSearch : WolfeLineSearch
	{
		protected override ExitCondition WolfeExitCondition => ExitCondition.WeakWolfeCriteria;

		public WeakWolfeLineSearch(double c1, double c2, double parameterTolerance, int maxIterations = 10)
			: base(c1, c2, parameterTolerance, maxIterations)
		{
		}

		protected override bool WolfeCondition(double stepDd, double initialDd)
		{
			return stepDd < base.C2 * initialDd;
		}

		protected override void ValidateValue(IObjectiveFunctionEvaluation eval)
		{
			if (!IsFinite(eval.Value))
			{
				throw new EvaluationException(FormattableString.Invariant($"Non-finite value returned by objective function: {eval.Value}"), eval);
			}
		}

		protected override void ValidateInputArguments(IObjectiveFunctionEvaluation startingPoint, Vector<double> searchDirection, double initialStep, double upperBound)
		{
			if (!startingPoint.IsGradientSupported)
			{
				throw new ArgumentException("objective function does not support gradient");
			}
		}

		protected override void ValidateGradient(IObjectiveFunctionEvaluation eval)
		{
			foreach (double item in (IEnumerable<double>)eval.Gradient)
			{
				if (!IsFinite(item))
				{
					throw new EvaluationException(FormattableString.Invariant($"Non-finite value returned by gradient: {item}"), eval);
				}
			}
		}

		private static bool IsFinite(double x)
		{
			if (!double.IsNaN(x))
			{
				return !double.IsInfinity(x);
			}
			return false;
		}
	}
	public abstract class WolfeLineSearch
	{
		protected double C1 { get; }

		protected double C2 { get; }

		protected double ParameterTolerance { get; }

		protected int MaximumIterations { get; }

		protected abstract ExitCondition WolfeExitCondition { get; }

		public WolfeLineSearch(double c1, double c2, double parameterTolerance, int maxIterations = 10)
		{
			if (c1 <= 0.0)
			{
				throw new ArgumentException(FormattableString.Invariant($"c1 {c1} should be greater than 0"));
			}
			if (c2 <= c1)
			{
				throw new ArgumentException(FormattableString.Invariant($"c1 {c1} should be less than c2 {c2}"));
			}
			if (c2 >= 1.0)
			{
				throw new ArgumentException(FormattableString.Invariant($"c2 {c2} should be less than 1"));
			}
			C1 = c1;
			C2 = c2;
			ParameterTolerance = parameterTolerance;
			MaximumIterations = maxIterations;
		}

		public LineSearchResult FindConformingStep(IObjectiveFunctionEvaluation startingPoint, Vector<double> searchDirection, double initialStep)
		{
			return FindConformingStep(startingPoint, searchDirection, initialStep, double.PositiveInfinity);
		}

		public LineSearchResult FindConformingStep(IObjectiveFunctionEvaluation startingPoint, Vector<double> searchDirection, double initialStep, double upperBound)
		{
			ValidateInputArguments(startingPoint, searchDirection, initialStep, upperBound);
			double num = 0.0;
			double num2 = initialStep;
			double value = startingPoint.Value;
			Vector<double> gradient = startingPoint.Gradient;
			double num3 = searchDirection * gradient;
			IObjectiveFunction objectiveFunction = startingPoint.CreateNew();
			ExitCondition reasonForExit = ExitCondition.None;
			int i;
			for (i = 0; i < MaximumIterations; i++)
			{
				objectiveFunction.EvaluateAt(startingPoint.Point + searchDirection * num2);
				ValidateGradient(objectiveFunction);
				ValidateValue(objectiveFunction);
				double stepDd = searchDirection * objectiveFunction.Gradient;
				if (objectiveFunction.Value > value + C1 * num2 * num3)
				{
					upperBound = num2;
					num2 = 0.5 * (num + upperBound);
				}
				else
				{
					if (!WolfeCondition(stepDd, num3))
					{
						reasonForExit = WolfeExitCondition;
						break;
					}
					num = num2;
					num2 = (double.IsPositiveInfinity(upperBound) ? (2.0 * num) : (0.5 * (num + upperBound)));
				}
				if (!double.IsInfinity(upperBound))
				{
					double num4 = 0.0;
					for (int j = 0; j < objectiveFunction.Point.Count; j++)
					{
						double val = Math.Abs(searchDirection[j] * (upperBound - num)) / Math.Max(Math.Abs(objectiveFunction.Point[j]), 1.0);
						num4 = Math.Max(num4, val);
					}
					if (num4 < ParameterTolerance)
					{
						reasonForExit = ExitCondition.LackOfProgress;
						break;
					}
				}
			}
			if (i == MaximumIterations && double.IsPositiveInfinity(upperBound))
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({MaximumIterations}) reached. Function appears to be unbounded in search direction."));
			}
			if (i == MaximumIterations)
			{
				throw new MaximumIterationsException(FormattableString.Invariant($"Maximum iterations ({MaximumIterations}) reached."));
			}
			return new LineSearchResult(objectiveFunction, i, num2, reasonForExit);
		}

		protected abstract bool WolfeCondition(double stepDd, double initialDd);

		protected virtual void ValidateGradient(IObjectiveFunctionEvaluation objective)
		{
		}

		protected virtual void ValidateValue(IObjectiveFunctionEvaluation objective)
		{
		}

		protected virtual void ValidateInputArguments(IObjectiveFunctionEvaluation startingPoint, Vector<double> searchDirection, double initialStep, double upperBound)
		{
		}
	}
}
namespace MathNet.Numerics.OdeSolvers
{
	public static class AdamsBashforth
	{
		public static double[] FirstOrder(double y0, double start, double end, int N, Func<double, double, double> f)
		{
			double num = (end - start) / (double)(N - 1);
			double num2 = start;
			double[] array = new double[N];
			array[0] = y0;
			for (int i = 1; i < N; i++)
			{
				array[i] = y0 + num * f(num2, y0);
				num2 += num;
				y0 = array[i];
			}
			return array;
		}

		public static double[] SecondOrder(double y0, double start, double end, int N, Func<double, double, double> f)
		{
			double num = (end - start) / (double)(N - 1);
			double num2 = start;
			double[] array = new double[N];
			double num3 = f(num2, y0);
			double num4 = f(num2 + num, y0 + num * num3);
			double num5 = y0 + 0.5 * num * (num3 + num4);
			array[0] = y0;
			array[1] = num5;
			for (int i = 2; i < N; i++)
			{
				array[i] = num5 + num * (1.5 * f(num2 + num, num5) - 0.5 * f(num2, y0));
				num2 += num;
				y0 = array[i - 1];
				num5 = array[i];
			}
			return array;
		}

		public static double[] ThirdOrder(double y0, double start, double end, int N, Func<double, double, double> f)
		{
			double num = (end - start) / (double)(N - 1);
			double num2 = start;
			double[] array = new double[N];
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = 0.0;
			array[0] = y0;
			for (int i = 1; i < 3; i++)
			{
				num3 = num * f(num2, y0);
				num4 = num * f(num2 + num / 2.0, y0 + num3 / 2.0);
				num5 = num * f(num2 + num / 2.0, y0 + num4 / 2.0);
				num6 = num * f(num2 + num, y0 + num5);
				array[i] = y0 + (num3 + 2.0 * num4 + 2.0 * num5 + num6) / 6.0;
				num2 += num;
				y0 = array[i];
			}
			for (int j = 3; j < N; j++)
			{
				array[j] = array[j - 1] + num * (23.0 * f(num2, array[j - 1]) - 16.0 * f(num2 - num, array[j - 2]) + 5.0 * f(num2 - 2.0 * num, array[j - 3])) / 12.0;
				num2 += num;
			}
			return array;
		}

		public static double[] FourthOrder(double y0, double start, double end, int N, Func<double, double, double> f)
		{
			double num = (end - start) / (double)(N - 1);
			double num2 = start;
			double[] array = new double[N];
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = 0.0;
			array[0] = y0;
			for (int i = 1; i < 4; i++)
			{
				num3 = num * f(num2, y0);
				num4 = num * f(num2 + num / 2.0, y0 + num3 / 2.0);
				num5 = num * f(num2 + num / 2.0, y0 + num4 / 2.0);
				num6 = num * f(num2 + num, y0 + num5);
				array[i] = y0 + (num3 + 2.0 * num4 + 2.0 * num5 + num6) / 6.0;
				num2 += num;
				y0 = array[i];
			}
			for (int j = 4; j < N; j++)
			{
				array[j] = array[j - 1] + num * (55.0 * f(num2, array[j - 1]) - 59.0 * f(num2 - num, array[j - 2]) + 37.0 * f(num2 - 2.0 * num, array[j - 3]) - 9.0 * f(num2 - 3.0 * num, array[j - 4])) / 24.0;
				num2 += num;
			}
			return array;
		}
	}
	public static class RungeKutta
	{
		public static double[] SecondOrder(double y0, double start, double end, int N, Func<double, double, double> f)
		{
			double num = (end - start) / (double)(N - 1);
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = start;
			double[] array = new double[N];
			array[0] = y0;
			for (int i = 1; i < N; i++)
			{
				num2 = f(num4, y0);
				num3 = f(num4 + num, y0 + num2 * num);
				array[i] = y0 + num * 0.5 * (num2 + num3);
				num4 += num;
				y0 = array[i];
			}
			return array;
		}

		public static double[] FourthOrder(double y0, double start, double end, int N, Func<double, double, double> f)
		{
			double num = (end - start) / (double)(N - 1);
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = start;
			double[] array = new double[N];
			array[0] = y0;
			for (int i = 1; i < N; i++)
			{
				num2 = f(num6, y0);
				num3 = f(num6 + num / 2.0, y0 + num2 * num / 2.0);
				num4 = f(num6 + num / 2.0, y0 + num3 * num / 2.0);
				num5 = f(num6 + num, y0 + num4 * num);
				array[i] = y0 + num / 6.0 * (num2 + 2.0 * num3 + 2.0 * num4 + num5);
				num6 += num;
				y0 = array[i];
			}
			return array;
		}

		public static Vector<double>[] SecondOrder(Vector<double> y0, double start, double end, int N, Func<double, Vector<double>, Vector<double>> f)
		{
			double num = (end - start) / (double)(N - 1);
			Vector<double>[] array = new Vector<double>[N];
			double num2 = start;
			array[0] = y0;
			for (int i = 1; i < N; i++)
			{
				Vector<double> vector = f(num2, y0);
				Vector<double> vector2 = f(num2, y0 + vector * num);
				array[i] = y0 + num * 0.5 * (vector + vector2);
				num2 += num;
				y0 = array[i];
			}
			return array;
		}

		public static Vector<double>[] FourthOrder(Vector<double> y0, double start, double end, int N, Func<double, Vector<double>, Vector<double>> f)
		{
			double num = (end - start) / (double)(N - 1);
			Vector<double>[] array = new Vector<double>[N];
			double num2 = start;
			array[0] = y0;
			for (int i = 1; i < N; i++)
			{
				Vector<double> vector = f(num2, y0);
				Vector<double> vector2 = f(num2 + num / 2.0, y0 + vector * num / 2.0);
				Vector<double> vector3 = f(num2 + num / 2.0, y0 + vector2 * num / 2.0);
				Vector<double> vector4 = f(num2 + num, y0 + vector3 * num);
				array[i] = y0 + num / 6.0 * (vector + 2.0 * vector2 + 2.0 * vector3 + vector4);
				num2 += num;
				y0 = array[i];
			}
			return array;
		}
	}
}
namespace MathNet.Numerics.LinearRegression
{
	public static class MultipleRegression
	{
		public static Vector<T> DirectMethod<T>(Matrix<T> x, Vector<T> y, DirectRegressionMethod method = DirectRegressionMethod.NormalEquations) where T : struct, IEquatable<T>, IFormattable
		{
			return method switch
			{
				DirectRegressionMethod.NormalEquations => NormalEquations(x, y), 
				DirectRegressionMethod.QR => QR(x, y), 
				DirectRegressionMethod.Svd => Svd(x, y), 
				_ => throw new NotSupportedException(method.ToString()), 
			};
		}

		public static Matrix<T> DirectMethod<T>(Matrix<T> x, Matrix<T> y, DirectRegressionMethod method = DirectRegressionMethod.NormalEquations) where T : struct, IEquatable<T>, IFormattable
		{
			return method switch
			{
				DirectRegressionMethod.NormalEquations => NormalEquations(x, y), 
				DirectRegressionMethod.QR => QR(x, y), 
				DirectRegressionMethod.Svd => Svd(x, y), 
				_ => throw new NotSupportedException(method.ToString()), 
			};
		}

		public static T[] DirectMethod<T>(T[][] x, T[] y, bool intercept = false, DirectRegressionMethod method = DirectRegressionMethod.NormalEquations) where T : struct, IEquatable<T>, IFormattable
		{
			return method switch
			{
				DirectRegressionMethod.NormalEquations => NormalEquations(x, y, intercept), 
				DirectRegressionMethod.QR => QR(x, y, intercept), 
				DirectRegressionMethod.Svd => Svd(x, y, intercept), 
				_ => throw new NotSupportedException(method.ToString()), 
			};
		}

		public static T[] DirectMethod<T>(IEnumerable<Tuple<T[], T>> samples, bool intercept = false, DirectRegressionMethod method = DirectRegressionMethod.NormalEquations) where T : struct, IEquatable<T>, IFormattable
		{
			return method switch
			{
				DirectRegressionMethod.NormalEquations => NormalEquations(samples, intercept), 
				DirectRegressionMethod.QR => QR(samples, intercept), 
				DirectRegressionMethod.Svd => Svd(samples, intercept), 
				_ => throw new NotSupportedException(method.ToString()), 
			};
		}

		public static Vector<T> NormalEquations<T>(Matrix<T> x, Vector<T> y) where T : struct, IEquatable<T>, IFormattable
		{
			if (x.RowCount != y.Count)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.RowCount} and {y.Count} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.ColumnCount > y.Count)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {x.ColumnCount} samples. Only {y.Count} samples have been provided.");
			}
			return x.TransposeThisAndMultiply(x).Cholesky().Solve(x.TransposeThisAndMultiply(y));
		}

		public static Matrix<T> NormalEquations<T>(Matrix<T> x, Matrix<T> y) where T : struct, IEquatable<T>, IFormattable
		{
			if (x.RowCount != y.RowCount)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.RowCount} and {y.RowCount} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.ColumnCount > y.RowCount)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {x.ColumnCount} samples. Only {y.RowCount} samples have been provided.");
			}
			return x.TransposeThisAndMultiply(x).Cholesky().Solve(x.TransposeThisAndMultiply(y));
		}

		public static T[] NormalEquations<T>(T[][] x, T[] y, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Matrix<T> matrix = Matrix<T>.Build.DenseOfRowArrays(x);
			if (intercept)
			{
				matrix = matrix.InsertColumn(0, Vector<T>.Build.Dense(matrix.RowCount, Vector<T>.One));
			}
			if (matrix.RowCount != y.Length)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {matrix.RowCount} and {y.Length} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (matrix.ColumnCount > y.Length)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {matrix.ColumnCount} samples. Only {y.Length} samples have been provided.");
			}
			Vector<T> rightSide = Vector<T>.Build.Dense(y);
			return matrix.TransposeThisAndMultiply(matrix).Cholesky().Solve(matrix.TransposeThisAndMultiply(rightSide))
				.ToArray();
		}

		public static T[] NormalEquations<T>(IEnumerable<Tuple<T[], T>> samples, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Tuple<T[][], T[]> tuple = samples.UnpackSinglePass();
			return NormalEquations(tuple.Item1, tuple.Item2, intercept);
		}

		public static Vector<T> QR<T>(Matrix<T> x, Vector<T> y) where T : struct, IEquatable<T>, IFormattable
		{
			if (x.RowCount != y.Count)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.RowCount} and {y.Count} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.ColumnCount > y.Count)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {x.ColumnCount} samples. Only {y.Count} samples have been provided.");
			}
			return x.QR().Solve(y);
		}

		public static Matrix<T> QR<T>(Matrix<T> x, Matrix<T> y) where T : struct, IEquatable<T>, IFormattable
		{
			if (x.RowCount != y.RowCount)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.RowCount} and {y.RowCount} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.ColumnCount > y.RowCount)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {x.ColumnCount} samples. Only {y.RowCount} samples have been provided.");
			}
			return x.QR().Solve(y);
		}

		public static T[] QR<T>(T[][] x, T[] y, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Matrix<T> matrix = Matrix<T>.Build.DenseOfRowArrays(x);
			if (intercept)
			{
				matrix = matrix.InsertColumn(0, Vector<T>.Build.Dense(matrix.RowCount, Vector<T>.One));
			}
			if (matrix.RowCount != y.Length)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {matrix.RowCount} and {y.Length} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (matrix.ColumnCount > y.Length)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {matrix.ColumnCount} samples. Only {y.Length} samples have been provided.");
			}
			return matrix.QR().Solve(Vector<T>.Build.Dense(y)).ToArray();
		}

		public static T[] QR<T>(IEnumerable<Tuple<T[], T>> samples, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Tuple<T[][], T[]> tuple = samples.UnpackSinglePass();
			return QR(tuple.Item1, tuple.Item2, intercept);
		}

		public static Vector<T> Svd<T>(Matrix<T> x, Vector<T> y) where T : struct, IEquatable<T>, IFormattable
		{
			if (x.RowCount != y.Count)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.RowCount} and {y.Count} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.ColumnCount > y.Count)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {x.ColumnCount} samples. Only {y.Count} samples have been provided.");
			}
			return x.Svd().Solve(y);
		}

		public static Matrix<T> Svd<T>(Matrix<T> x, Matrix<T> y) where T : struct, IEquatable<T>, IFormattable
		{
			if (x.RowCount != y.RowCount)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.RowCount} and {y.RowCount} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.ColumnCount > y.RowCount)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {x.ColumnCount} samples. Only {y.RowCount} samples have been provided.");
			}
			return x.Svd().Solve(y);
		}

		public static T[] Svd<T>(T[][] x, T[] y, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Matrix<T> matrix = Matrix<T>.Build.DenseOfRowArrays(x);
			if (intercept)
			{
				matrix = matrix.InsertColumn(0, Vector<T>.Build.Dense(matrix.RowCount, Vector<T>.One));
			}
			if (matrix.RowCount != y.Length)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {matrix.RowCount} and {y.Length} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (matrix.ColumnCount > y.Length)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {matrix.ColumnCount} samples. Only {y.Length} samples have been provided.");
			}
			return matrix.Svd().Solve(Vector<T>.Build.Dense(y)).ToArray();
		}

		public static T[] Svd<T>(IEnumerable<Tuple<T[], T>> samples, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Tuple<T[][], T[]> tuple = samples.UnpackSinglePass();
			return Svd(tuple.Item1, tuple.Item2, intercept);
		}
	}
	public enum DirectRegressionMethod
	{
		NormalEquations,
		QR,
		Svd
	}
	public static class SimpleRegression
	{
		public static Tuple<double, double> Fit(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.Length} and {y.Length} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.Length <= 1)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {2} samples. Only {x.Length} samples have been provided.");
			}
			double num = 0.0;
			double num2 = 0.0;
			for (int i = 0; i < x.Length; i++)
			{
				num += x[i];
				num2 += y[i];
			}
			num /= (double)x.Length;
			num2 /= (double)y.Length;
			double num3 = 0.0;
			double num4 = 0.0;
			for (int j = 0; j < x.Length; j++)
			{
				double num5 = x[j] - num;
				num3 += num5 * (y[j] - num2);
				num4 += num5 * num5;
			}
			double num6 = num3 / num4;
			return new Tuple<double, double>(num2 - num6 * num, num6);
		}

		public static Tuple<double, double> Fit(IEnumerable<Tuple<double, double>> samples)
		{
			Tuple<double[], double[]> tuple = samples.UnpackSinglePass();
			return Fit(tuple.Item1, tuple.Item2);
		}

		public static double FitThroughOrigin(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException($"All sample vectors must have the same length. However, vectors with disagreeing length {x.Length} and {y.Length} have been provided. A sample with index i is given by the value at index i of each provided vector.");
			}
			if (x.Length <= 1)
			{
				throw new ArgumentException($"A regression of the requested order requires at least {2} samples. Only {x.Length} samples have been provided.");
			}
			double num = 0.0;
			double num2 = 0.0;
			for (int i = 0; i < x.Length; i++)
			{
				num2 += x[i] * x[i];
				num += x[i] * y[i];
			}
			return num / num2;
		}

		public static double FitThroughOrigin(IEnumerable<Tuple<double, double>> samples)
		{
			double num = 0.0;
			double num2 = 0.0;
			foreach (Tuple<double, double> sample in samples)
			{
				num2 += sample.Item1 * sample.Item1;
				num += sample.Item1 * sample.Item2;
			}
			return num / num2;
		}
	}
	internal static class Util
	{
		public static Tuple<TU[], TV[]> UnpackSinglePass<TU, TV>(this IEnumerable<Tuple<TU, TV>> samples)
		{
			List<TU> list = new List<TU>();
			List<TV> list2 = new List<TV>();
			foreach (Tuple<TU, TV> sample in samples)
			{
				list.Add(sample.Item1);
				list2.Add(sample.Item2);
			}
			return new Tuple<TU[], TV[]>(list.ToArray(), list2.ToArray());
		}
	}
	public static class WeightedRegression
	{
		public static Vector<T> Weighted<T>(Matrix<T> x, Vector<T> y, Matrix<T> w) where T : struct, IEquatable<T>, IFormattable
		{
			return x.TransposeThisAndMultiply(w * x).Cholesky().Solve(x.TransposeThisAndMultiply(w * y));
		}

		public static Matrix<T> Weighted<T>(Matrix<T> x, Matrix<T> y, Matrix<T> w) where T : struct, IEquatable<T>, IFormattable
		{
			return x.TransposeThisAndMultiply(w * x).Cholesky().Solve(x.TransposeThisAndMultiply(w * y));
		}

		public static T[] Weighted<T>(T[][] x, T[] y, T[] w, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Matrix<T> matrix = Matrix<T>.Build.DenseOfRowArrays(x);
			if (intercept)
			{
				matrix = matrix.InsertColumn(0, Vector<T>.Build.Dense(matrix.RowCount, Vector<T>.One));
			}
			Vector<T> vector = Vector<T>.Build.Dense(y);
			Matrix<T> matrix2 = Matrix<T>.Build.Diagonal(w);
			return matrix.TransposeThisAndMultiply(matrix2 * matrix).Cholesky().Solve(matrix.TransposeThisAndMultiply(matrix2 * vector))
				.ToArray();
		}

		public static T[] Weighted<T>(IEnumerable<Tuple<T[], T>> samples, T[] weights, bool intercept = false) where T : struct, IEquatable<T>, IFormattable
		{
			Tuple<T[][], T[]> tuple = samples.UnpackSinglePass();
			return Weighted(tuple.Item1, tuple.Item2, weights, intercept);
		}

		[Obsolete("Warning: This function is here to stay but its signature will likely change. Opting out from semantic versioning.")]
		public static Vector<T> Local<T>(Matrix<T> x, Vector<T> y, Vector<T> t, double radius, Func<double, T> kernel) where T : struct, IEquatable<T>, IFormattable
		{
			Matrix<T> matrix = Matrix<T>.Build.Dense(x.RowCount, x.RowCount);
			for (int i = 0; i < x.RowCount; i++)
			{
				matrix.At(i, i, kernel(Distance.Euclidean(t, x.Row(i)) / radius));
			}
			return Weighted(x, y, matrix);
		}

		[Obsolete("Warning: This function is here to stay but its signature will likely change. Opting out from semantic versioning.")]
		public static Matrix<T> Local<T>(Matrix<T> x, Matrix<T> y, Vector<T> t, double radius, Func<double, T> kernel) where T : struct, IEquatable<T>, IFormattable
		{
			Matrix<T> matrix = Matrix<T>.Build.Dense(x.RowCount, x.RowCount);
			for (int i = 0; i < x.RowCount; i++)
			{
				matrix.At(i, i, kernel(Distance.Euclidean(t, x.Row(i)) / radius));
			}
			return Weighted(x, y, matrix);
		}

		[Obsolete("Warning: This function is here to stay but will likely be refactored and/or moved to another place. Opting out from semantic versioning.")]
		public static double GaussianKernel(double normalizedDistance)
		{
			return Math.Exp(-0.5 * normalizedDistance * normalizedDistance);
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra
{
	public abstract class MatrixBuilder<T> where T : struct, IEquatable<T>, IFormattable
	{
		public abstract T Zero { get; }

		public abstract T One { get; }

		internal abstract T Add(T x, T y);

		public Matrix<T> OfStorage(MatrixStorage<T> storage)
		{
			if (storage == null)
			{
				throw new ArgumentNullException("storage");
			}
			if (storage is DenseColumnMajorMatrixStorage<T> storage2)
			{
				return Dense(storage2);
			}
			if (storage is SparseCompressedRowMatrixStorage<T> storage3)
			{
				return Sparse(storage3);
			}
			if (storage is DiagonalMatrixStorage<T> storage4)
			{
				return Diagonal(storage4);
			}
			throw new NotSupportedException(FormattableString.Invariant($"Matrix storage type '{storage.GetType().Name}' is not supported. Only DenseColumnMajorMatrixStorage, SparseCompressedRowMatrixStorage and DiagonalMatrixStorage are supported as this point."));
		}

		public Matrix<T> SameAs<TU>(Matrix<TU> example, int rows, int columns, bool fullyMutable = false) where TU : struct, IEquatable<TU>, IFormattable
		{
			MatrixStorage<TU> storage = example.Storage;
			if (storage is DenseColumnMajorMatrixStorage<T>)
			{
				return Dense(rows, columns);
			}
			if (storage is DiagonalMatrixStorage<T>)
			{
				if (!fullyMutable)
				{
					return Diagonal(rows, columns);
				}
				return Sparse(rows, columns);
			}
			if (storage is SparseCompressedRowMatrixStorage<T>)
			{
				return Sparse(rows, columns);
			}
			return Dense(rows, columns);
		}

		public Matrix<T> SameAs<TU>(Matrix<TU> example) where TU : struct, IEquatable<TU>, IFormattable
		{
			return SameAs(example, example.RowCount, example.ColumnCount);
		}

		public Matrix<T> SameAs(Vector<T> example, int rows, int columns)
		{
			if (!example.Storage.IsDense)
			{
				return Sparse(rows, columns);
			}
			return Dense(rows, columns);
		}

		public Matrix<T> SameAs(Matrix<T> example, Matrix<T> otherExample, int rows, int columns, bool fullyMutable = false)
		{
			MatrixStorage<T> storage = example.Storage;
			MatrixStorage<T> storage2 = otherExample.Storage;
			if (storage is DenseColumnMajorMatrixStorage<T> || storage2 is DenseColumnMajorMatrixStorage<T>)
			{
				return Dense(rows, columns);
			}
			if (storage is DiagonalMatrixStorage<T> && storage2 is DiagonalMatrixStorage<T>)
			{
				if (!fullyMutable)
				{
					return Diagonal(rows, columns);
				}
				return Sparse(rows, columns);
			}
			if (storage is SparseCompressedRowMatrixStorage<T> || storage2 is SparseCompressedRowMatrixStorage<T>)
			{
				return Sparse(rows, columns);
			}
			return Dense(rows, columns);
		}

		public Matrix<T> SameAs(Matrix<T> example, Matrix<T> otherExample)
		{
			return SameAs(example, otherExample, example.RowCount, example.ColumnCount);
		}

		public abstract Matrix<T> Random(int rows, int columns, IContinuousDistribution distribution);

		public Matrix<T> Random(int rows, int columns)
		{
			return Random(rows, columns, new Normal(SystemRandomSource.Default));
		}

		public Matrix<T> Random(int rows, int columns, int seed)
		{
			return Random(rows, columns, new Normal(new SystemRandomSource(seed, threadSafe: true)));
		}

		public Matrix<T> RandomPositiveDefinite(int order, IContinuousDistribution distribution)
		{
			Matrix<T> matrix = Random(order, order, distribution);
			return matrix.ConjugateTransposeThisAndMultiply(matrix);
		}

		public Matrix<T> RandomPositiveDefinite(int order)
		{
			Matrix<T> matrix = Random(order, order, new Normal(SystemRandomSource.Default));
			return matrix.ConjugateTransposeThisAndMultiply(matrix);
		}

		public Matrix<T> RandomPositiveDefinite(int order, int seed)
		{
			Matrix<T> matrix = Random(order, order, new Normal(new SystemRandomSource(seed, threadSafe: true)));
			return matrix.ConjugateTransposeThisAndMultiply(matrix);
		}

		public abstract Matrix<T> Dense(DenseColumnMajorMatrixStorage<T> storage);

		public Matrix<T> Dense(int rows, int columns)
		{
			return Dense(new DenseColumnMajorMatrixStorage<T>(rows, columns));
		}

		public Matrix<T> Dense(int rows, int columns, T[] storage)
		{
			return Dense(new DenseColumnMajorMatrixStorage<T>(rows, columns, storage));
		}

		public Matrix<T> Dense(int rows, int columns, T value)
		{
			if (Zero.Equals(value))
			{
				return Dense(rows, columns);
			}
			return Dense(DenseColumnMajorMatrixStorage<T>.OfValue(rows, columns, value));
		}

		public Matrix<T> Dense(int rows, int columns, Func<int, int, T> init)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfInit(rows, columns, init));
		}

		public Matrix<T> DenseDiagonal(int rows, int columns, T value)
		{
			if (Zero.Equals(value))
			{
				return Dense(rows, columns);
			}
			return Dense(DenseColumnMajorMatrixStorage<T>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public Matrix<T> DenseDiagonal(int order, T value)
		{
			if (Zero.Equals(value))
			{
				return Dense(order, order);
			}
			return Dense(DenseColumnMajorMatrixStorage<T>.OfDiagonalInit(order, order, (int i) => value));
		}

		public Matrix<T> DenseDiagonal(int rows, int columns, Func<int, T> init)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfDiagonalInit(rows, columns, init));
		}

		public Matrix<T> DenseIdentity(int rows, int columns)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfDiagonalInit(rows, columns, (int i) => One));
		}

		public Matrix<T> DenseIdentity(int order)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfDiagonalInit(order, order, (int i) => One));
		}

		public Matrix<T> DenseOfMatrix(Matrix<T> matrix)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfMatrix(matrix.Storage));
		}

		public Matrix<T> DenseOfArray(T[,] array)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfArray(array));
		}

		public Matrix<T> DenseOfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, T>> enumerable)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public Matrix<T> DenseOfColumnMajor(int rows, int columns, IEnumerable<T> columnMajor)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnMajorEnumerable(rows, columns, columnMajor));
		}

		public Matrix<T> DenseOfColumns(IEnumerable<IEnumerable<T>> data)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnArrays(data.Select((IEnumerable<T> v) => (v as T[]) ?? v.ToArray()).ToArray()));
		}

		public Matrix<T> DenseOfColumns(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnEnumerables(rows, columns, data));
		}

		public Matrix<T> DenseOfColumnArrays(params T[][] columns)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnArrays(columns));
		}

		public Matrix<T> DenseOfColumnArrays(IEnumerable<T[]> columns)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnArrays((columns as T[][]) ?? columns.ToArray()));
		}

		public Matrix<T> DenseOfColumnVectors(params Vector<T>[] columns)
		{
			VectorStorage<T>[] array = new VectorStorage<T>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnVectors(array));
		}

		public Matrix<T> DenseOfColumnVectors(IEnumerable<Vector<T>> columns)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfColumnVectors(columns.Select((Vector<T> c) => c.Storage).ToArray()));
		}

		public Matrix<T> DenseOfRowMajor(int rows, int columns, IEnumerable<T> columnMajor)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowMajorEnumerable(rows, columns, columnMajor));
		}

		public Matrix<T> DenseOfRows(IEnumerable<IEnumerable<T>> data)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowArrays(data.Select((IEnumerable<T> v) => (v as T[]) ?? v.ToArray()).ToArray()));
		}

		public Matrix<T> DenseOfRows(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowEnumerables(rows, columns, data));
		}

		public Matrix<T> DenseOfRowArrays(params T[][] rows)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowArrays(rows));
		}

		public Matrix<T> DenseOfRowArrays(IEnumerable<T[]> rows)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowArrays((rows as T[][]) ?? rows.ToArray()));
		}

		public Matrix<T> DenseOfRowVectors(params Vector<T>[] rows)
		{
			VectorStorage<T>[] array = new VectorStorage<T>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowVectors(array));
		}

		public Matrix<T> DenseOfRowVectors(IEnumerable<Vector<T>> rows)
		{
			return Dense(DenseColumnMajorMatrixStorage<T>.OfRowVectors(rows.Select((Vector<T> r) => r.Storage).ToArray()));
		}

		public Matrix<T> DenseOfDiagonalVector(Vector<T> diagonal)
		{
			Matrix<T> matrix = Dense(diagonal.Count, diagonal.Count);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DenseOfDiagonalVector(int rows, int columns, Vector<T> diagonal)
		{
			Matrix<T> matrix = Dense(rows, columns);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DenseOfDiagonalArray(T[] diagonal)
		{
			Matrix<T> matrix = Dense(diagonal.Length, diagonal.Length);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DenseOfDiagonalArray(int rows, int columns, T[] diagonal)
		{
			Matrix<T> matrix = Dense(rows, columns);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DenseOfMatrixArray(Matrix<T>[,] matrices)
		{
			int[] array = new int[matrices.GetLength(0)];
			int[] array2 = new int[matrices.GetLength(1)];
			for (int i = 0; i < array.Length; i++)
			{
				for (int j = 0; j < array2.Length; j++)
				{
					array[i] = Math.Max(array[i], matrices[i, j].RowCount);
					array2[j] = Math.Max(array2[j], matrices[i, j].ColumnCount);
				}
			}
			Matrix<T> matrix = Dense(array.Sum(), array2.Sum());
			int num = 0;
			for (int k = 0; k < array.Length; k++)
			{
				int num2 = 0;
				for (int l = 0; l < array2.Length; l++)
				{
					matrix.SetSubMatrix(num, num2, matrices[k, l]);
					num2 += array2[l];
				}
				num += array[k];
			}
			return matrix;
		}

		public abstract Matrix<T> Sparse(SparseCompressedRowMatrixStorage<T> storage);

		public Matrix<T> Sparse(int rows, int columns)
		{
			return Sparse(new SparseCompressedRowMatrixStorage<T>(rows, columns));
		}

		public Matrix<T> Sparse(int rows, int columns, T value)
		{
			if (Zero.Equals(value))
			{
				return Sparse(rows, columns);
			}
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfValue(rows, columns, value));
		}

		public Matrix<T> Sparse(int rows, int columns, Func<int, int, T> init)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfInit(rows, columns, init));
		}

		public Matrix<T> SparseDiagonal(int rows, int columns, T value)
		{
			if (Zero.Equals(value))
			{
				return Sparse(rows, columns);
			}
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public Matrix<T> SparseDiagonal(int order, T value)
		{
			if (Zero.Equals(value))
			{
				return Sparse(order, order);
			}
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfDiagonalInit(order, order, (int i) => value));
		}

		public Matrix<T> SparseDiagonal(int rows, int columns, Func<int, T> init)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfDiagonalInit(rows, columns, init));
		}

		public Matrix<T> SparseIdentity(int rows, int columns)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfDiagonalInit(rows, columns, (int i) => One));
		}

		public Matrix<T> SparseIdentity(int order)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfDiagonalInit(order, order, (int i) => One));
		}

		public Matrix<T> SparseOfMatrix(Matrix<T> matrix)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfMatrix(matrix.Storage));
		}

		public Matrix<T> SparseOfArray(T[,] array)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfArray(array));
		}

		public Matrix<T> SparseOfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, T>> enumerable)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public Matrix<T> SparseOfRowMajor(int rows, int columns, IEnumerable<T> rowMajor)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowMajorEnumerable(rows, columns, rowMajor));
		}

		public Matrix<T> SparseOfColumnMajor(int rows, int columns, IList<T> columnMajor)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnMajorList(rows, columns, columnMajor));
		}

		public Matrix<T> SparseOfColumns(IEnumerable<IEnumerable<T>> data)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnArrays(data.Select((IEnumerable<T> v) => (v as T[]) ?? v.ToArray()).ToArray()));
		}

		public Matrix<T> SparseOfColumns(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnEnumerables(rows, columns, data));
		}

		public Matrix<T> SparseOfColumnArrays(params T[][] columns)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnArrays(columns));
		}

		public Matrix<T> SparseOfColumnArrays(IEnumerable<T[]> columns)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnArrays((columns as T[][]) ?? columns.ToArray()));
		}

		public Matrix<T> SparseOfColumnVectors(params Vector<T>[] columns)
		{
			VectorStorage<T>[] array = new VectorStorage<T>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnVectors(array));
		}

		public Matrix<T> SparseOfColumnVectors(IEnumerable<Vector<T>> columns)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfColumnVectors(columns.Select((Vector<T> c) => c.Storage).ToArray()));
		}

		public Matrix<T> SparseOfRows(IEnumerable<IEnumerable<T>> data)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowArrays(data.Select((IEnumerable<T> v) => (v as T[]) ?? v.ToArray()).ToArray()));
		}

		public Matrix<T> SparseOfRows(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowEnumerables(rows, columns, data));
		}

		public Matrix<T> SparseOfRowArrays(params T[][] rows)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowArrays(rows));
		}

		public Matrix<T> SparseOfRowArrays(IEnumerable<T[]> rows)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowArrays((rows as T[][]) ?? rows.ToArray()));
		}

		public Matrix<T> SparseOfRowVectors(params Vector<T>[] rows)
		{
			VectorStorage<T>[] array = new VectorStorage<T>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowVectors(array));
		}

		public Matrix<T> SparseOfRowVectors(IEnumerable<Vector<T>> rows)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfRowVectors(rows.Select((Vector<T> r) => r.Storage).ToArray()));
		}

		public Matrix<T> SparseOfDiagonalVector(Vector<T> diagonal)
		{
			Matrix<T> matrix = Sparse(diagonal.Count, diagonal.Count);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> SparseOfDiagonalVector(int rows, int columns, Vector<T> diagonal)
		{
			Matrix<T> matrix = Sparse(rows, columns);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> SparseOfDiagonalArray(T[] diagonal)
		{
			Matrix<T> matrix = Sparse(diagonal.Length, diagonal.Length);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> SparseOfDiagonalArray(int rows, int columns, T[] diagonal)
		{
			Matrix<T> matrix = Sparse(rows, columns);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> SparseOfMatrixArray(Matrix<T>[,] matrices)
		{
			int[] array = new int[matrices.GetLength(0)];
			int[] array2 = new int[matrices.GetLength(1)];
			for (int i = 0; i < array.Length; i++)
			{
				for (int j = 0; j < array2.Length; j++)
				{
					array[i] = Math.Max(array[i], matrices[i, j].RowCount);
					array2[j] = Math.Max(array2[j], matrices[i, j].ColumnCount);
				}
			}
			Matrix<T> matrix = Sparse(array.Sum(), array2.Sum());
			int num = 0;
			for (int k = 0; k < array.Length; k++)
			{
				int num2 = 0;
				for (int l = 0; l < array2.Length; l++)
				{
					matrix.SetSubMatrix(num, num2, matrices[k, l]);
					num2 += array2[l];
				}
				num += array[k];
			}
			return matrix;
		}

		public Matrix<T> SparseFromCoordinateFormat(int rows, int columns, int valueCount, int[] rowIndices, int[] columnIndices, T[] values)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfCoordinateFormat(rows, columns, valueCount, rowIndices, columnIndices, values));
		}

		public Matrix<T> SparseFromCompressedSparseRowFormat(int rows, int columns, int valueCount, int[] rowPointers, int[] columnIndices, T[] values)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfCompressedSparseRowFormat(rows, columns, valueCount, rowPointers, columnIndices, values));
		}

		public Matrix<T> SparseFromCompressedSparseColumnFormat(int rows, int columns, int valueCount, int[] rowIndices, int[] columnPointers, T[] values)
		{
			return Sparse(SparseCompressedRowMatrixStorage<T>.OfCompressedSparseColumnFormat(rows, columns, valueCount, rowIndices, columnPointers, values));
		}

		public abstract Matrix<T> Diagonal(DiagonalMatrixStorage<T> storage);

		public Matrix<T> Diagonal(int rows, int columns)
		{
			return Diagonal(new DiagonalMatrixStorage<T>(rows, columns));
		}

		public Matrix<T> Diagonal(int rows, int columns, T[] storage)
		{
			return Diagonal(new DiagonalMatrixStorage<T>(rows, columns, storage));
		}

		public Matrix<T> Diagonal(T[] storage)
		{
			return Diagonal(new DiagonalMatrixStorage<T>(storage.Length, storage.Length, storage));
		}

		public Matrix<T> Diagonal(int rows, int columns, T value)
		{
			if (Zero.Equals(value))
			{
				return Diagonal(rows, columns);
			}
			return Diagonal(DiagonalMatrixStorage<T>.OfValue(rows, columns, value));
		}

		public Matrix<T> Diagonal(int rows, int columns, Func<int, T> init)
		{
			return Diagonal(DiagonalMatrixStorage<T>.OfInit(rows, columns, init));
		}

		public Matrix<T> DiagonalIdentity(int rows, int columns)
		{
			return Diagonal(DiagonalMatrixStorage<T>.OfValue(rows, columns, One));
		}

		public Matrix<T> DiagonalIdentity(int order)
		{
			return Diagonal(DiagonalMatrixStorage<T>.OfValue(order, order, One));
		}

		public Matrix<T> DiagonalOfDiagonalVector(Vector<T> diagonal)
		{
			Matrix<T> matrix = Diagonal(diagonal.Count, diagonal.Count);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DiagonalOfDiagonalVector(int rows, int columns, Vector<T> diagonal)
		{
			Matrix<T> matrix = Diagonal(rows, columns);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DiagonalOfDiagonalArray(T[] diagonal)
		{
			Matrix<T> matrix = Diagonal(diagonal.Length, diagonal.Length);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public Matrix<T> DiagonalOfDiagonalArray(int rows, int columns, T[] diagonal)
		{
			Matrix<T> matrix = Diagonal(rows, columns);
			matrix.SetDiagonal(diagonal);
			return matrix;
		}

		public abstract IIterationStopCriterion<T>[] IterativeSolverStopCriteria(int maxIterations = 1000);
	}
	public abstract class VectorBuilder<T> where T : struct, IEquatable<T>, IFormattable
	{
		public abstract T Zero { get; }

		public abstract T One { get; }

		public Vector<T> OfStorage(VectorStorage<T> storage)
		{
			if (storage == null)
			{
				throw new ArgumentNullException("storage");
			}
			if (storage is DenseVectorStorage<T> storage2)
			{
				return Dense(storage2);
			}
			if (storage is SparseVectorStorage<T> storage3)
			{
				return Sparse(storage3);
			}
			throw new NotSupportedException(FormattableString.Invariant($"Vector storage type '{storage.GetType().Name}' is not supported. Only DenseVectorStorage and SparseVectorStorage are supported as this point."));
		}

		public Vector<T> SameAs<TU>(Vector<TU> example, int length) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (!example.Storage.IsDense)
			{
				return Sparse(length);
			}
			return Dense(length);
		}

		public Vector<T> SameAs<TU>(Vector<TU> example) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (!example.Storage.IsDense)
			{
				return Sparse(example.Count);
			}
			return Dense(example.Count);
		}

		public Vector<T> SameAs<TU>(Matrix<TU> example, int length) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (!example.Storage.IsDense)
			{
				return Sparse(length);
			}
			return Dense(length);
		}

		public Vector<T> SameAs(Vector<T> example, Vector<T> otherExample, int length)
		{
			if (!example.Storage.IsDense && !otherExample.Storage.IsDense)
			{
				return Sparse(length);
			}
			return Dense(length);
		}

		public Vector<T> SameAs(Vector<T> example, Vector<T> otherExample)
		{
			if (!example.Storage.IsDense && !otherExample.Storage.IsDense)
			{
				return Sparse(example.Count);
			}
			return Dense(example.Count);
		}

		public Vector<T> SameAs(Matrix<T> matrix, Vector<T> vector, int length)
		{
			if (!matrix.Storage.IsDense && !vector.Storage.IsDense)
			{
				return Sparse(length);
			}
			return Dense(length);
		}

		public abstract Vector<T> Random(int length, IContinuousDistribution distribution);

		public Vector<T> Random(int length)
		{
			return Random(length, new Normal(SystemRandomSource.Default));
		}

		public Vector<T> Random(int length, int seed)
		{
			return Random(length, new Normal(new SystemRandomSource(seed, threadSafe: true)));
		}

		public abstract Vector<T> Dense(DenseVectorStorage<T> storage);

		public Vector<T> Dense(int size)
		{
			return Dense(new DenseVectorStorage<T>(size));
		}

		public Vector<T> Dense(T[] array)
		{
			return Dense(new DenseVectorStorage<T>(array.Length, array));
		}

		public Vector<T> Dense(int length, T value)
		{
			if (Zero.Equals(value))
			{
				return Dense(length);
			}
			return Dense(DenseVectorStorage<T>.OfValue(length, value));
		}

		public Vector<T> Dense(int length, Func<int, T> init)
		{
			return Dense(DenseVectorStorage<T>.OfInit(length, init));
		}

		public Vector<T> DenseOfVector(Vector<T> vector)
		{
			return Dense(DenseVectorStorage<T>.OfVector(vector.Storage));
		}

		public Vector<T> DenseOfArray(T[] array)
		{
			return Dense(DenseVectorStorage<T>.OfVector(new DenseVectorStorage<T>(array.Length, array)));
		}

		public Vector<T> DenseOfEnumerable(IEnumerable<T> enumerable)
		{
			return Dense(DenseVectorStorage<T>.OfEnumerable(enumerable));
		}

		public Vector<T> DenseOfIndexed(int length, IEnumerable<Tuple<int, T>> enumerable)
		{
			return Dense(DenseVectorStorage<T>.OfIndexedEnumerable(length, enumerable));
		}

		public abstract Vector<T> Sparse(SparseVectorStorage<T> storage);

		public Vector<T> Sparse(int size)
		{
			return Sparse(new SparseVectorStorage<T>(size));
		}

		public Vector<T> Sparse(int length, T value)
		{
			if (Zero.Equals(value))
			{
				return Sparse(length);
			}
			return Sparse(SparseVectorStorage<T>.OfValue(length, value));
		}

		public Vector<T> Sparse(int length, Func<int, T> init)
		{
			return Sparse(SparseVectorStorage<T>.OfInit(length, init));
		}

		public Vector<T> SparseOfVector(Vector<T> vector)
		{
			return Sparse(SparseVectorStorage<T>.OfVector(vector.Storage));
		}

		public Vector<T> SparseOfArray(T[] array)
		{
			return Sparse(SparseVectorStorage<T>.OfEnumerable(array));
		}

		public Vector<T> SparseOfEnumerable(IEnumerable<T> enumerable)
		{
			return Sparse(SparseVectorStorage<T>.OfEnumerable(enumerable));
		}

		public Vector<T> SparseOfIndexed(int length, IEnumerable<Tuple<int, T>> enumerable)
		{
			return Sparse(SparseVectorStorage<T>.OfIndexedEnumerable(length, enumerable));
		}
	}
	internal static class BuilderInstance<T> where T : struct, IEquatable<T>, IFormattable
	{
		private static Lazy<Tuple<MatrixBuilder<T>, VectorBuilder<T>>> _singleton = new Lazy<Tuple<MatrixBuilder<T>, VectorBuilder<T>>>(Create);

		public static MatrixBuilder<T> Matrix => _singleton.Value.Item1;

		public static VectorBuilder<T> Vector => _singleton.Value.Item2;

		private static Tuple<MatrixBuilder<T>, VectorBuilder<T>> Create()
		{
			if (typeof(T) == typeof(System.Numerics.Complex))
			{
				return new Tuple<MatrixBuilder<T>, VectorBuilder<T>>((MatrixBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Complex.MatrixBuilder(), (VectorBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Complex.VectorBuilder());
			}
			if (typeof(T) == typeof(MathNet.Numerics.Complex32))
			{
				return new Tuple<MatrixBuilder<T>, VectorBuilder<T>>((MatrixBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Complex32.MatrixBuilder(), (VectorBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Complex32.VectorBuilder());
			}
			if (typeof(T) == typeof(double))
			{
				return new Tuple<MatrixBuilder<T>, VectorBuilder<T>>((MatrixBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Double.MatrixBuilder(), (VectorBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Double.VectorBuilder());
			}
			if (typeof(T) == typeof(float))
			{
				return new Tuple<MatrixBuilder<T>, VectorBuilder<T>>((MatrixBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Single.MatrixBuilder(), (VectorBuilder<T>)(object)new MathNet.Numerics.LinearAlgebra.Single.VectorBuilder());
			}
			throw new NotSupportedException(FormattableString.Invariant($"Matrices and vectors of type '{typeof(T).Name}' are not supported. Only Double, Single, Complex or Complex32 are supported at this point."));
		}

		public static void Register(MatrixBuilder<T> matrixBuilder, VectorBuilder<T> vectorBuilder)
		{
			_singleton = new Lazy<Tuple<MatrixBuilder<T>, VectorBuilder<T>>>(() => new Tuple<MatrixBuilder<T>, VectorBuilder<T>>(matrixBuilder, vectorBuilder));
		}
	}
	public static class CreateMatrix
	{
		public static Matrix<T> WithStorage<T>(MatrixStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.OfStorage(storage);
		}

		public static Matrix<T> SameAs<T, TU>(Matrix<TU> example, int rows, int columns, bool fullyMutable = false) where T : struct, IEquatable<T>, IFormattable where TU : struct, IEquatable<TU>, IFormattable
		{
			return Matrix<T>.Build.SameAs(example, rows, columns, fullyMutable);
		}

		public static Matrix<T> SameAs<T, TU>(Matrix<TU> example) where T : struct, IEquatable<T>, IFormattable where TU : struct, IEquatable<TU>, IFormattable
		{
			return Matrix<T>.Build.SameAs(example);
		}

		public static Matrix<T> SameAs<T>(Vector<T> example, int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SameAs(example, rows, columns);
		}

		public static Matrix<T> SameAs<T>(Matrix<T> example, Matrix<T> otherExample, int rows, int columns, bool fullyMutable = false) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SameAs(example, otherExample, rows, columns, fullyMutable);
		}

		public static Matrix<T> SameAs<T>(Matrix<T> example, Matrix<T> otherExample) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SameAs(example, otherExample);
		}

		public static Matrix<T> Random<T>(int rows, int columns, IContinuousDistribution distribution) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Random(rows, columns, distribution);
		}

		public static Matrix<T> Random<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Random(rows, columns);
		}

		public static Matrix<T> Random<T>(int rows, int columns, int seed) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Random(rows, columns, seed);
		}

		public static Matrix<T> RandomPositiveDefinite<T>(int order, IContinuousDistribution distribution) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.RandomPositiveDefinite(order, distribution);
		}

		public static Matrix<T> RandomPositiveDefinite<T>(int order) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.RandomPositiveDefinite(order);
		}

		public static Matrix<T> RandomPositiveDefinite<T>(int order, int seed) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.RandomPositiveDefinite(order, seed);
		}

		public static Matrix<T> Dense<T>(DenseColumnMajorMatrixStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Dense(storage);
		}

		public static Matrix<T> Dense<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Dense(rows, columns);
		}

		public static Matrix<T> Dense<T>(int rows, int columns, T[] storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Dense(rows, columns, storage);
		}

		public static Matrix<T> Dense<T>(int rows, int columns, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Dense(rows, columns, value);
		}

		public static Matrix<T> Dense<T>(int rows, int columns, Func<int, int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Dense(rows, columns, init);
		}

		public static Matrix<T> DenseDiagonal<T>(int rows, int columns, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseDiagonal(rows, columns, value);
		}

		public static Matrix<T> DenseDiagonal<T>(int order, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseDiagonal(order, value);
		}

		public static Matrix<T> DenseDiagonal<T>(int rows, int columns, Func<int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseDiagonal(rows, columns, init);
		}

		public static Matrix<T> DenseIdentity<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseIdentity(rows, columns);
		}

		public static Matrix<T> DenseIdentity<T>(int order) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseIdentity(order);
		}

		public static Matrix<T> DenseOfMatrix<T>(Matrix<T> matrix) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfMatrix(matrix);
		}

		public static Matrix<T> DenseOfArray<T>(T[,] array) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfArray(array);
		}

		public static Matrix<T> DenseOfIndexed<T>(int rows, int columns, IEnumerable<Tuple<int, int, T>> enumerable) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfIndexed(rows, columns, enumerable);
		}

		public static Matrix<T> DenseOfColumnMajor<T>(int rows, int columns, IEnumerable<T> columnMajor) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumnMajor(rows, columns, columnMajor);
		}

		public static Matrix<T> DenseOfColumns<T>(IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumns(data);
		}

		public static Matrix<T> DenseOfColumns<T>(int rows, int columns, IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumns(rows, columns, data);
		}

		public static Matrix<T> DenseOfColumnArrays<T>(params T[][] columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumnArrays(columns);
		}

		public static Matrix<T> DenseOfColumnArrays<T>(IEnumerable<T[]> columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumnArrays(columns);
		}

		public static Matrix<T> DenseOfColumnVectors<T>(params Vector<T>[] columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumnVectors(columns);
		}

		public static Matrix<T> DenseOfColumnVectors<T>(IEnumerable<Vector<T>> columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfColumnVectors(columns);
		}

		public static Matrix<T> DenseOfRows<T>(IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfRows(data);
		}

		public static Matrix<T> DenseOfRows<T>(int rows, int columns, IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfRows(rows, columns, data);
		}

		public static Matrix<T> DenseOfRowArrays<T>(params T[][] rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfRowArrays(rows);
		}

		public static Matrix<T> DenseOfRowArrays<T>(IEnumerable<T[]> rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfRowArrays(rows);
		}

		public static Matrix<T> DenseOfRowVectors<T>(params Vector<T>[] rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfRowVectors(rows);
		}

		public static Matrix<T> DenseOfRowVectors<T>(IEnumerable<Vector<T>> rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfRowVectors(rows);
		}

		public static Matrix<T> DenseOfDiagonalVector<T>(Vector<T> diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfDiagonalVector(diagonal);
		}

		public static Matrix<T> DenseOfDiagonalVector<T>(int rows, int columns, Vector<T> diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfDiagonalVector(rows, columns, diagonal);
		}

		public static Matrix<T> DenseOfDiagonalArray<T>(T[] diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfDiagonalArray(diagonal);
		}

		public static Matrix<T> DenseOfDiagonalArray<T>(int rows, int columns, T[] diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfDiagonalArray(rows, columns, diagonal);
		}

		public static Matrix<T> DenseOfMatrixArray<T>(Matrix<T>[,] matrices) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DenseOfMatrixArray(matrices);
		}

		public static Matrix<T> Sparse<T>(SparseCompressedRowMatrixStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Sparse(storage);
		}

		public static Matrix<T> Sparse<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Sparse(rows, columns);
		}

		public static Matrix<T> Sparse<T>(int rows, int columns, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Sparse(rows, columns, value);
		}

		public static Matrix<T> Sparse<T>(int rows, int columns, Func<int, int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Sparse(rows, columns, init);
		}

		public static Matrix<T> SparseDiagonal<T>(int rows, int columns, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseDiagonal(rows, columns, value);
		}

		public static Matrix<T> SparseDiagonal<T>(int order, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseDiagonal(order, value);
		}

		public static Matrix<T> SparseDiagonal<T>(int rows, int columns, Func<int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseDiagonal(rows, columns, init);
		}

		public static Matrix<T> SparseIdentity<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseIdentity(rows, columns);
		}

		public static Matrix<T> SparseIdentity<T>(int order) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseIdentity(order);
		}

		public static Matrix<T> SparseOfMatrix<T>(Matrix<T> matrix) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfMatrix(matrix);
		}

		public static Matrix<T> SparseOfArray<T>(T[,] array) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfArray(array);
		}

		public static Matrix<T> SparseOfIndexed<T>(int rows, int columns, IEnumerable<Tuple<int, int, T>> enumerable) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfIndexed(rows, columns, enumerable);
		}

		public static Matrix<T> SparseOfRowMajor<T>(int rows, int columns, IEnumerable<T> rowMajor) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRowMajor(rows, columns, rowMajor);
		}

		public static Matrix<T> SparseOfColumnMajor<T>(int rows, int columns, IList<T> columnMajor) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumnMajor(rows, columns, columnMajor);
		}

		public static Matrix<T> SparseOfColumns<T>(IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumns(data);
		}

		public static Matrix<T> SparseOfColumns<T>(int rows, int columns, IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumns(rows, columns, data);
		}

		public static Matrix<T> SparseOfColumnArrays<T>(params T[][] columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumnArrays(columns);
		}

		public static Matrix<T> SparseOfColumnArrays<T>(IEnumerable<T[]> columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumnArrays(columns);
		}

		public static Matrix<T> SparseOfColumnVectors<T>(params Vector<T>[] columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumnVectors(columns);
		}

		public static Matrix<T> SparseOfColumnVectors<T>(IEnumerable<Vector<T>> columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfColumnVectors(columns);
		}

		public static Matrix<T> SparseOfRows<T>(IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRows(data);
		}

		public static Matrix<T> SparseOfRows<T>(int rows, int columns, IEnumerable<IEnumerable<T>> data) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRows(rows, columns, data);
		}

		public static Matrix<T> SparseOfRowArrays<T>(params T[][] rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRowArrays(rows);
		}

		public static Matrix<T> SparseOfRowArrays<T>(IEnumerable<T[]> rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRowArrays(rows);
		}

		public static Matrix<T> SparseOfRowVectors<T>(params Vector<T>[] rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRowVectors(rows);
		}

		public static Matrix<T> SparseOfRowVectors<T>(IEnumerable<Vector<T>> rows) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfRowVectors(rows);
		}

		public static Matrix<T> SparseOfDiagonalVector<T>(Vector<T> diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfDiagonalVector(diagonal);
		}

		public static Matrix<T> SparseOfDiagonalVector<T>(int rows, int columns, Vector<T> diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfDiagonalVector(rows, columns, diagonal);
		}

		public static Matrix<T> SparseOfDiagonalArray<T>(T[] diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfDiagonalArray(diagonal);
		}

		public static Matrix<T> SparseOfDiagonalArray<T>(int rows, int columns, T[] diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfDiagonalArray(rows, columns, diagonal);
		}

		public static Matrix<T> SparseOfMatrixArray<T>(Matrix<T>[,] matrices) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseOfMatrixArray(matrices);
		}

		public static Matrix<T> SparseFromCoordinateFormat<T>(int rows, int columns, int valueCount, int[] rowIndices, int[] columnIndices, T[] values) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseFromCoordinateFormat(rows, columns, valueCount, rowIndices, columnIndices, values);
		}

		public static Matrix<T> SparseFromCompressedSparseRowFormat<T>(int rows, int columns, int valueCount, int[] rowPointers, int[] columnIndices, T[] values) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseFromCompressedSparseRowFormat(rows, columns, valueCount, rowPointers, columnIndices, values);
		}

		public static Matrix<T> SparseFromCompressedSparseColumnFormat<T>(int rows, int columns, int valueCount, int[] rowIndices, int[] columnPointers, T[] values) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.SparseFromCompressedSparseColumnFormat(rows, columns, valueCount, rowIndices, columnPointers, values);
		}

		public static Matrix<T> Diagonal<T>(DiagonalMatrixStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Diagonal(storage);
		}

		public static Matrix<T> Diagonal<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Diagonal(rows, columns);
		}

		public static Matrix<T> Diagonal<T>(int rows, int columns, T[] storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Diagonal(rows, columns, storage);
		}

		public static Matrix<T> Diagonal<T>(T[] storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Diagonal(storage);
		}

		public static Matrix<T> Diagonal<T>(int rows, int columns, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Diagonal(rows, columns, value);
		}

		public static Matrix<T> Diagonal<T>(int rows, int columns, Func<int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.Diagonal(rows, columns, init);
		}

		public static Matrix<T> DiagonalIdentity<T>(int rows, int columns) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DiagonalIdentity(rows, columns);
		}

		public static Matrix<T> DiagonalIdentity<T>(int order) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DiagonalIdentity(order);
		}

		public static Matrix<T> DiagonalOfDiagonalVector<T>(Vector<T> diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DiagonalOfDiagonalVector(diagonal);
		}

		public static Matrix<T> DiagonalOfDiagonalVector<T>(int rows, int columns, Vector<T> diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DiagonalOfDiagonalVector(rows, columns, diagonal);
		}

		public static Matrix<T> DiagonalOfDiagonalArray<T>(T[] diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DiagonalOfDiagonalArray(diagonal);
		}

		public static Matrix<T> DiagonalOfDiagonalArray<T>(int rows, int columns, T[] diagonal) where T : struct, IEquatable<T>, IFormattable
		{
			return Matrix<T>.Build.DiagonalOfDiagonalArray(rows, columns, diagonal);
		}
	}
	public static class CreateVector
	{
		public static Vector<T> WithStorage<T>(VectorStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.OfStorage(storage);
		}

		public static Vector<T> SameAs<T, TU>(Vector<TU> example, int length) where T : struct, IEquatable<T>, IFormattable where TU : struct, IEquatable<TU>, IFormattable
		{
			return Vector<T>.Build.SameAs(example, length);
		}

		public static Vector<T> SameAs<T, TU>(Vector<TU> example) where T : struct, IEquatable<T>, IFormattable where TU : struct, IEquatable<TU>, IFormattable
		{
			return Vector<T>.Build.SameAs(example);
		}

		public static Vector<T> SameAs<T, TU>(Matrix<TU> example, int length) where T : struct, IEquatable<T>, IFormattable where TU : struct, IEquatable<TU>, IFormattable
		{
			return Vector<T>.Build.SameAs(example, length);
		}

		public static Vector<T> SameAs<T>(Vector<T> example, Vector<T> otherExample, int length) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SameAs(example, otherExample, length);
		}

		public static Vector<T> SameAs<T>(Vector<T> example, Vector<T> otherExample) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SameAs(example, otherExample);
		}

		public static Vector<T> SameAs<T>(Matrix<T> matrix, Vector<T> vector, int length) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SameAs(matrix, vector, length);
		}

		public static Vector<T> Random<T>(int length, IContinuousDistribution distribution) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Random(length, distribution);
		}

		public static Vector<T> Random<T>(int length) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Random(length);
		}

		public static Vector<T> Random<T>(int length, int seed) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Random(length, seed);
		}

		public static Vector<T> Dense<T>(DenseVectorStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Dense(storage);
		}

		public static Vector<T> Dense<T>(int size) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Dense(size);
		}

		public static Vector<T> Dense<T>(T[] array) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Dense(array);
		}

		public static Vector<T> Dense<T>(int length, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Dense(length, value);
		}

		public static Vector<T> Dense<T>(int length, Func<int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Dense(length, init);
		}

		public static Vector<T> DenseOfVector<T>(Vector<T> vector) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.DenseOfVector(vector);
		}

		public static Vector<T> DenseOfArray<T>(T[] array) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.DenseOfArray(array);
		}

		public static Vector<T> DenseOfEnumerable<T>(IEnumerable<T> enumerable) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.DenseOfEnumerable(enumerable);
		}

		public static Vector<T> DenseOfIndexed<T>(int length, IEnumerable<Tuple<int, T>> enumerable) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.DenseOfIndexed(length, enumerable);
		}

		public static Vector<T> Sparse<T>(SparseVectorStorage<T> storage) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Sparse(storage);
		}

		public static Vector<T> Sparse<T>(int size) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Sparse(size);
		}

		public static Vector<T> Sparse<T>(int length, T value) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Sparse(length, value);
		}

		public static Vector<T> Sparse<T>(int length, Func<int, T> init) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.Sparse(length, init);
		}

		public static Vector<T> SparseOfVector<T>(Vector<T> vector) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SparseOfVector(vector);
		}

		public static Vector<T> SparseOfArray<T>(T[] array) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SparseOfArray(array);
		}

		public static Vector<T> SparseOfEnumerable<T>(IEnumerable<T> enumerable) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SparseOfEnumerable(enumerable);
		}

		public static Vector<T> SparseOfIndexed<T>(int length, IEnumerable<Tuple<int, T>> enumerable) where T : struct, IEquatable<T>, IFormattable
		{
			return Vector<T>.Build.SparseOfIndexed(length, enumerable);
		}
	}
	[Serializable]
	[DebuggerDisplay("Matrix {RowCount}x{ColumnCount}")]
	public abstract class Matrix<T> : IFormattable, IEquatable<Matrix<T>>, ICloneable where T : struct, IEquatable<T>, IFormattable
	{
		public static readonly T One = BuilderInstance<T>.Matrix.One;

		public static readonly T Zero = BuilderInstance<T>.Matrix.Zero;

		public static readonly MatrixBuilder<T> Build = BuilderInstance<T>.Matrix;

		public MatrixStorage<T> Storage { get; private set; }

		public int ColumnCount { get; private set; }

		public int RowCount { get; private set; }

		public T this[int row, int column]
		{
			[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
			get
			{
				return Storage[row, column];
			}
			[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
			set
			{
				Storage[row, column] = value;
			}
		}

		protected abstract void DoNegate(Matrix<T> result);

		protected abstract void DoConjugate(Matrix<T> result);

		protected abstract void DoAdd(T scalar, Matrix<T> result);

		protected abstract void DoAdd(Matrix<T> other, Matrix<T> result);

		protected abstract void DoSubtract(T scalar, Matrix<T> result);

		protected void DoSubtractFrom(T scalar, Matrix<T> result)
		{
			DoNegate(result);
			result.DoAdd(scalar, result);
		}

		protected abstract void DoSubtract(Matrix<T> other, Matrix<T> result);

		protected abstract void DoMultiply(T scalar, Matrix<T> result);

		protected abstract void DoMultiply(Vector<T> rightSide, Vector<T> result);

		protected abstract void DoMultiply(Matrix<T> other, Matrix<T> result);

		protected abstract void DoTransposeAndMultiply(Matrix<T> other, Matrix<T> result);

		protected abstract void DoConjugateTransposeAndMultiply(Matrix<T> other, Matrix<T> result);

		protected abstract void DoTransposeThisAndMultiply(Vector<T> rightSide, Vector<T> result);

		protected abstract void DoConjugateTransposeThisAndMultiply(Vector<T> rightSide, Vector<T> result);

		protected abstract void DoTransposeThisAndMultiply(Matrix<T> other, Matrix<T> result);

		protected abstract void DoConjugateTransposeThisAndMultiply(Matrix<T> other, Matrix<T> result);

		protected abstract void DoDivide(T divisor, Matrix<T> result);

		protected abstract void DoDivideByThis(T dividend, Matrix<T> result);

		protected abstract void DoModulus(T divisor, Matrix<T> result);

		protected abstract void DoModulusByThis(T dividend, Matrix<T> result);

		protected abstract void DoRemainder(T divisor, Matrix<T> result);

		protected abstract void DoRemainderByThis(T dividend, Matrix<T> result);

		protected abstract void DoPointwiseMultiply(Matrix<T> other, Matrix<T> result);

		protected abstract void DoPointwiseDivide(Matrix<T> divisor, Matrix<T> result);

		protected abstract void DoPointwisePower(T exponent, Matrix<T> result);

		protected abstract void DoPointwisePower(Matrix<T> exponent, Matrix<T> result);

		protected abstract void DoPointwiseModulus(Matrix<T> divisor, Matrix<T> result);

		protected abstract void DoPointwiseRemainder(Matrix<T> divisor, Matrix<T> result);

		protected abstract void DoPointwiseExp(Matrix<T> result);

		protected abstract void DoPointwiseLog(Matrix<T> result);

		protected abstract void DoPointwiseAbs(Matrix<T> result);

		protected abstract void DoPointwiseAcos(Matrix<T> result);

		protected abstract void DoPointwiseAsin(Matrix<T> result);

		protected abstract void DoPointwiseAtan(Matrix<T> result);

		protected abstract void DoPointwiseCeiling(Matrix<T> result);

		protected abstract void DoPointwiseCos(Matrix<T> result);

		protected abstract void DoPointwiseCosh(Matrix<T> result);

		protected abstract void DoPointwiseFloor(Matrix<T> result);

		protected abstract void DoPointwiseLog10(Matrix<T> result);

		protected abstract void DoPointwiseRound(Matrix<T> result);

		protected abstract void DoPointwiseSign(Matrix<T> result);

		protected abstract void DoPointwiseSin(Matrix<T> result);

		protected abstract void DoPointwiseSinh(Matrix<T> result);

		protected abstract void DoPointwiseSqrt(Matrix<T> result);

		protected abstract void DoPointwiseTan(Matrix<T> result);

		protected abstract void DoPointwiseTanh(Matrix<T> result);

		protected abstract void DoPointwiseAtan2(Matrix<T> other, Matrix<T> result);

		protected abstract void DoPointwiseMinimum(T scalar, Matrix<T> result);

		protected abstract void DoPointwiseMinimum(Matrix<T> other, Matrix<T> result);

		protected abstract void DoPointwiseMaximum(T scalar, Matrix<T> result);

		protected abstract void DoPointwiseMaximum(Matrix<T> other, Matrix<T> result);

		protected abstract void DoPointwiseAbsoluteMinimum(T scalar, Matrix<T> result);

		protected abstract void DoPointwiseAbsoluteMinimum(Matrix<T> other, Matrix<T> result);

		protected abstract void DoPointwiseAbsoluteMaximum(T scalar, Matrix<T> result);

		protected abstract void DoPointwiseAbsoluteMaximum(Matrix<T> other, Matrix<T> result);

		public Matrix<T> Add(T scalar)
		{
			if (scalar.Equals(Zero))
			{
				return Clone();
			}
			Matrix<T> result = Build.SameAs(this);
			DoAdd(scalar, result);
			return result;
		}

		public void Add(T scalar, Matrix<T> result)
		{
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, result, "result");
			}
			if (scalar.Equals(Zero))
			{
				CopyTo(result);
			}
			else
			{
				DoAdd(scalar, result);
			}
		}

		public Matrix<T> Add(Matrix<T> other)
		{
			if (other.RowCount != RowCount || other.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, RowCount, ColumnCount);
			DoAdd(other, result);
			return result;
		}

		public void Add(Matrix<T> other, Matrix<T> result)
		{
			if (other.RowCount != RowCount || other.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, "other");
			}
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, result, "result");
			}
			DoAdd(other, result);
		}

		public Matrix<T> Subtract(T scalar)
		{
			if (scalar.Equals(Zero))
			{
				return Clone();
			}
			Matrix<T> result = Build.SameAs(this);
			DoSubtract(scalar, result);
			return result;
		}

		public void Subtract(T scalar, Matrix<T> result)
		{
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, result, "result");
			}
			if (scalar.Equals(Zero))
			{
				CopyTo(result);
			}
			else
			{
				DoSubtract(scalar, result);
			}
		}

		public Matrix<T> SubtractFrom(T scalar)
		{
			Matrix<T> result = Build.SameAs(this);
			DoSubtractFrom(scalar, result);
			return result;
		}

		public void SubtractFrom(T scalar, Matrix<T> result)
		{
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, result, "result");
			}
			DoSubtractFrom(scalar, result);
		}

		public Matrix<T> Subtract(Matrix<T> other)
		{
			if (other.RowCount != RowCount || other.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, RowCount, ColumnCount);
			DoSubtract(other, result);
			return result;
		}

		public void Subtract(Matrix<T> other, Matrix<T> result)
		{
			if (other.RowCount != RowCount || other.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, "other");
			}
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, result, "result");
			}
			DoSubtract(other, result);
		}

		public Matrix<T> Multiply(T scalar)
		{
			if (scalar.Equals(One))
			{
				return Clone();
			}
			if (scalar.Equals(Zero))
			{
				return Build.SameAs(this);
			}
			Matrix<T> result = Build.SameAs(this);
			DoMultiply(scalar, result);
			return result;
		}

		public void Multiply(T scalar, Matrix<T> result)
		{
			if (result.RowCount != RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "result");
			}
			if (result.ColumnCount != ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "result");
			}
			if (scalar.Equals(One))
			{
				CopyTo(result);
			}
			else if (scalar.Equals(Zero))
			{
				result.Clear();
			}
			else
			{
				DoMultiply(scalar, result);
			}
		}

		public Matrix<T> Divide(T scalar)
		{
			if (scalar.Equals(One))
			{
				return Clone();
			}
			if (scalar.Equals(Zero))
			{
				throw new DivideByZeroException();
			}
			Matrix<T> result = Build.SameAs(this);
			DoDivide(scalar, result);
			return result;
		}

		public void Divide(T scalar, Matrix<T> result)
		{
			if (result.RowCount != RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "result");
			}
			if (result.ColumnCount != ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "result");
			}
			if (scalar.Equals(One))
			{
				CopyTo(result);
				return;
			}
			if (scalar.Equals(Zero))
			{
				throw new DivideByZeroException();
			}
			DoDivide(scalar, result);
		}

		public Matrix<T> DivideByThis(T scalar)
		{
			Matrix<T> result = Build.SameAs(this);
			DoDivideByThis(scalar, result);
			return result;
		}

		public void DivideByThis(T scalar, Matrix<T> result)
		{
			if (result.RowCount != RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "result");
			}
			if (result.ColumnCount != ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "result");
			}
			DoDivideByThis(scalar, result);
		}

		public Vector<T> Multiply(Vector<T> rightSide)
		{
			if (ColumnCount != rightSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, rightSide, "rightSide");
			}
			Vector<T> result = Vector<T>.Build.SameAs(this, rightSide, RowCount);
			DoMultiply(rightSide, result);
			return result;
		}

		public void Multiply(Vector<T> rightSide, Vector<T> result)
		{
			if (ColumnCount != rightSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, rightSide, "rightSide");
			}
			if (RowCount != result.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (rightSide == result)
			{
				Vector<T> vector = Vector<T>.Build.SameAs(result);
				DoMultiply(rightSide, vector);
				vector.CopyTo(result);
			}
			else
			{
				DoMultiply(rightSide, result);
			}
		}

		public Vector<T> LeftMultiply(Vector<T> leftSide)
		{
			if (RowCount != leftSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, leftSide, "leftSide");
			}
			Vector<T> result = Vector<T>.Build.SameAs(this, leftSide, ColumnCount);
			DoLeftMultiply(leftSide, result);
			return result;
		}

		public void LeftMultiply(Vector<T> leftSide, Vector<T> result)
		{
			if (RowCount != leftSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, leftSide, "leftSide");
			}
			if (ColumnCount != result.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (leftSide == result)
			{
				Vector<T> vector = Vector<T>.Build.SameAs(result);
				DoLeftMultiply(leftSide, vector);
				vector.CopyTo(result);
			}
			else
			{
				DoLeftMultiply(leftSide, result);
			}
		}

		protected void DoLeftMultiply(Vector<T> leftSide, Vector<T> result)
		{
			DoTransposeThisAndMultiply(leftSide, result);
		}

		public void Multiply(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != other.RowCount || result.RowCount != RowCount || result.ColumnCount != other.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			if (this == result || other == result)
			{
				Matrix<T> matrix = Build.SameAs(result);
				DoMultiply(other, matrix);
				matrix.CopyTo(result);
			}
			else
			{
				DoMultiply(other, result);
			}
		}

		public Matrix<T> Multiply(Matrix<T> other)
		{
			if (ColumnCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, RowCount, other.ColumnCount);
			DoMultiply(other, result);
			return result;
		}

		public void TransposeAndMultiply(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != other.ColumnCount || result.RowCount != RowCount || result.ColumnCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			if (this == result || other == result)
			{
				Matrix<T> matrix = Build.SameAs(result);
				DoTransposeAndMultiply(other, matrix);
				matrix.CopyTo(result);
			}
			else
			{
				DoTransposeAndMultiply(other, result);
			}
		}

		public Matrix<T> TransposeAndMultiply(Matrix<T> other)
		{
			if (ColumnCount != other.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, RowCount, other.RowCount);
			DoTransposeAndMultiply(other, result);
			return result;
		}

		public Vector<T> TransposeThisAndMultiply(Vector<T> rightSide)
		{
			if (RowCount != rightSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, rightSide, "rightSide");
			}
			Vector<T> result = Vector<T>.Build.SameAs(this, rightSide, ColumnCount);
			DoTransposeThisAndMultiply(rightSide, result);
			return result;
		}

		public void TransposeThisAndMultiply(Vector<T> rightSide, Vector<T> result)
		{
			if (RowCount != rightSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, rightSide, "rightSide");
			}
			if (ColumnCount != result.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (rightSide == result)
			{
				Vector<T> vector = Vector<T>.Build.SameAs(result);
				DoTransposeThisAndMultiply(rightSide, vector);
				vector.CopyTo(result);
			}
			else
			{
				DoTransposeThisAndMultiply(rightSide, result);
			}
		}

		public void TransposeThisAndMultiply(Matrix<T> other, Matrix<T> result)
		{
			if (RowCount != other.RowCount || result.RowCount != ColumnCount || result.ColumnCount != other.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			if (this == result || other == result)
			{
				Matrix<T> matrix = Build.SameAs(result);
				DoTransposeThisAndMultiply(other, matrix);
				matrix.CopyTo(result);
			}
			else
			{
				DoTransposeThisAndMultiply(other, result);
			}
		}

		public Matrix<T> TransposeThisAndMultiply(Matrix<T> other)
		{
			if (RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, ColumnCount, other.ColumnCount);
			DoTransposeThisAndMultiply(other, result);
			return result;
		}

		public void ConjugateTransposeAndMultiply(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != other.ColumnCount || result.RowCount != RowCount || result.ColumnCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			if (this == result || other == result)
			{
				Matrix<T> matrix = Build.SameAs(result);
				DoConjugateTransposeAndMultiply(other, matrix);
				matrix.CopyTo(result);
			}
			else
			{
				DoConjugateTransposeAndMultiply(other, result);
			}
		}

		public Matrix<T> ConjugateTransposeAndMultiply(Matrix<T> other)
		{
			if (ColumnCount != other.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, RowCount, other.RowCount);
			DoConjugateTransposeAndMultiply(other, result);
			return result;
		}

		public Vector<T> ConjugateTransposeThisAndMultiply(Vector<T> rightSide)
		{
			if (RowCount != rightSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, rightSide, "rightSide");
			}
			Vector<T> result = Vector<T>.Build.SameAs(this, rightSide, ColumnCount);
			DoConjugateTransposeThisAndMultiply(rightSide, result);
			return result;
		}

		public void ConjugateTransposeThisAndMultiply(Vector<T> rightSide, Vector<T> result)
		{
			if (RowCount != rightSide.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, rightSide, "rightSide");
			}
			if (ColumnCount != result.Count)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (rightSide == result)
			{
				Vector<T> vector = Vector<T>.Build.SameAs(result);
				DoConjugateTransposeThisAndMultiply(rightSide, vector);
				vector.CopyTo(result);
			}
			else
			{
				DoConjugateTransposeThisAndMultiply(rightSide, result);
			}
		}

		public void ConjugateTransposeThisAndMultiply(Matrix<T> other, Matrix<T> result)
		{
			if (RowCount != other.RowCount || result.RowCount != ColumnCount || result.ColumnCount != other.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			if (this == result || other == result)
			{
				Matrix<T> matrix = Build.SameAs(result);
				DoConjugateTransposeThisAndMultiply(other, matrix);
				matrix.CopyTo(result);
			}
			else
			{
				DoConjugateTransposeThisAndMultiply(other, result);
			}
		}

		public Matrix<T> ConjugateTransposeThisAndMultiply(Matrix<T> other)
		{
			if (RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other);
			}
			Matrix<T> result = Build.SameAs(this, other, ColumnCount, other.ColumnCount);
			DoConjugateTransposeThisAndMultiply(other, result);
			return result;
		}

		private static Matrix<T> IntPower(int exponent, Matrix<T> x, Matrix<T> y, Matrix<T> work)
		{
			switch (exponent)
			{
			case 1:
				if (y == null)
				{
					return x;
				}
				if (work == null)
				{
					work = y.Multiply(x);
				}
				else
				{
					y.Multiply(x, work);
				}
				return work;
			case 2:
				if (work == null)
				{
					work = x.Multiply(x);
				}
				else
				{
					x.Multiply(x, work);
				}
				if (y == null)
				{
					return work;
				}
				y.Multiply(work, x);
				return x;
			default:
				if (exponent.IsEven())
				{
					if (work == null)
					{
						work = x.Multiply(x);
					}
					else
					{
						x.Multiply(x, work);
					}
					return IntPower(exponent / 2, work, y, x);
				}
				if (y == null)
				{
					if (work == null)
					{
						work = x.Multiply(x);
					}
					else
					{
						x.Multiply(x, work);
					}
					return IntPower((exponent - 1) / 2, work, x, null);
				}
				if (work == null)
				{
					work = y.Multiply(x);
				}
				else
				{
					y.Multiply(x, work);
				}
				x.Multiply(x, y);
				return IntPower((exponent - 1) / 2, y, work, x);
			}
		}

		public void Power(int exponent, Matrix<T> result)
		{
			if (RowCount != ColumnCount || result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			if (exponent < 0)
			{
				throw new ArgumentException("Value must not be negative (zero is ok).");
			}
			switch (exponent)
			{
			case 0:
				Build.DiagonalIdentity(RowCount, ColumnCount).CopyTo(result);
				return;
			case 1:
				CopyTo(result);
				return;
			case 2:
				Multiply(this, result);
				return;
			}
			Matrix<T> matrix = IntPower(exponent, Clone(), null, result);
			if (matrix != result)
			{
				matrix.CopyTo(result);
			}
		}

		public Matrix<T> Power(int exponent)
		{
			if (RowCount != ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			if (exponent < 0)
			{
				throw new ArgumentException("Value must not be negative (zero is ok).");
			}
			return exponent switch
			{
				0 => Build.DiagonalIdentity(RowCount, ColumnCount), 
				1 => this, 
				2 => Multiply(this), 
				_ => IntPower(exponent, Clone(), null, null), 
			};
		}

		public Matrix<T> Negate()
		{
			Matrix<T> result = Build.SameAs(this);
			DoNegate(result);
			return result;
		}

		public void Negate(Matrix<T> result)
		{
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoNegate(result);
		}

		public Matrix<T> Conjugate()
		{
			Matrix<T> result = Build.SameAs(this);
			DoConjugate(result);
			return result;
		}

		public void Conjugate(Matrix<T> result)
		{
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoConjugate(result);
		}

		public Matrix<T> Modulus(T divisor)
		{
			Matrix<T> result = Build.SameAs(this);
			DoModulus(divisor, result);
			return result;
		}

		public void Modulus(T divisor, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoModulus(divisor, result);
		}

		public Matrix<T> ModulusByThis(T dividend)
		{
			Matrix<T> result = Build.SameAs(this);
			DoModulusByThis(dividend, result);
			return result;
		}

		public void ModulusByThis(T dividend, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoModulusByThis(dividend, result);
		}

		public Matrix<T> Remainder(T divisor)
		{
			Matrix<T> result = Build.SameAs(this);
			DoRemainder(divisor, result);
			return result;
		}

		public void Remainder(T divisor, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoRemainder(divisor, result);
		}

		public Matrix<T> RemainderByThis(T dividend)
		{
			Matrix<T> result = Build.SameAs(this);
			DoRemainderByThis(dividend, result);
			return result;
		}

		public void RemainderByThis(T dividend, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoRemainderByThis(dividend, result);
		}

		public Matrix<T> PointwiseMultiply(Matrix<T> other)
		{
			if (ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, "other");
			}
			Matrix<T> result = Build.SameAs(this, other);
			DoPointwiseMultiply(other, result);
			return result;
		}

		public void PointwiseMultiply(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			DoPointwiseMultiply(other, result);
		}

		public Matrix<T> PointwiseDivide(Matrix<T> divisor)
		{
			if (ColumnCount != divisor.ColumnCount || RowCount != divisor.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, divisor);
			}
			Matrix<T> result = Build.SameAs(this, divisor);
			DoPointwiseDivide(divisor, result);
			return result;
		}

		public void PointwiseDivide(Matrix<T> divisor, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != divisor.ColumnCount || RowCount != divisor.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, divisor, result);
			}
			DoPointwiseDivide(divisor, result);
		}

		public Matrix<T> PointwisePower(T exponent)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwisePower(exponent, result);
			return result;
		}

		public void PointwisePower(T exponent, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoPointwisePower(exponent, result);
		}

		public Matrix<T> PointwisePower(Matrix<T> exponent)
		{
			if (ColumnCount != exponent.ColumnCount || RowCount != exponent.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, exponent);
			}
			Matrix<T> result = Build.SameAs(this);
			DoPointwisePower(exponent, result);
			return result;
		}

		public void PointwisePower(Matrix<T> exponent, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != exponent.ColumnCount || RowCount != exponent.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, exponent, result);
			}
			DoPointwisePower(exponent, result);
		}

		public Matrix<T> PointwiseModulus(Matrix<T> divisor)
		{
			if (ColumnCount != divisor.ColumnCount || RowCount != divisor.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, divisor);
			}
			Matrix<T> result = Build.SameAs(this, divisor);
			DoPointwiseModulus(divisor, result);
			return result;
		}

		public void PointwiseModulus(Matrix<T> divisor, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != divisor.ColumnCount || RowCount != divisor.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, divisor, result);
			}
			DoPointwiseModulus(divisor, result);
		}

		public Matrix<T> PointwiseRemainder(Matrix<T> divisor)
		{
			if (ColumnCount != divisor.ColumnCount || RowCount != divisor.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, divisor);
			}
			Matrix<T> result = Build.SameAs(this, divisor);
			DoPointwiseRemainder(divisor, result);
			return result;
		}

		public void PointwiseRemainder(Matrix<T> divisor, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != divisor.ColumnCount || RowCount != divisor.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, divisor, result);
			}
			DoPointwiseRemainder(divisor, result);
		}

		protected Matrix<T> PointwiseUnary(Action<Matrix<T>> f)
		{
			Matrix<T> matrix = Build.SameAs(this);
			f(matrix);
			return matrix;
		}

		protected void PointwiseUnary(Action<Matrix<T>> f, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			f(result);
		}

		protected Matrix<T> PointwiseBinary(Action<Matrix<T>, Matrix<T>> f, Matrix<T> other)
		{
			if (ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other);
			}
			Matrix<T> matrix = Build.SameAs(this, other);
			f(other, matrix);
			return matrix;
		}

		protected void PointwiseBinary(Action<Matrix<T>, Matrix<T>> f, Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			f(other, result);
		}

		public Matrix<T> PointwiseExp()
		{
			return PointwiseUnary(DoPointwiseExp);
		}

		public void PointwiseExp(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseExp, result);
		}

		public Matrix<T> PointwiseLog()
		{
			return PointwiseUnary(DoPointwiseLog);
		}

		public void PointwiseLog(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseLog, result);
		}

		public Matrix<T> PointwiseAbs()
		{
			return PointwiseUnary(DoPointwiseAbs);
		}

		public void PointwiseAbs(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseAbs, result);
		}

		public Matrix<T> PointwiseAcos()
		{
			return PointwiseUnary(DoPointwiseAcos);
		}

		public void PointwiseAcos(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseAcos, result);
		}

		public Matrix<T> PointwiseAsin()
		{
			return PointwiseUnary(DoPointwiseAsin);
		}

		public void PointwiseAsin(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseAsin, result);
		}

		public Matrix<T> PointwiseAtan()
		{
			return PointwiseUnary(DoPointwiseAtan);
		}

		public void PointwiseAtan(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseAtan, result);
		}

		public Matrix<T> PointwiseAtan2(Matrix<T> other)
		{
			return PointwiseBinary(DoPointwiseAtan2, other);
		}

		public void PointwiseAtan2(Matrix<T> other, Matrix<T> result)
		{
			PointwiseBinary(DoPointwiseAtan2, other, result);
		}

		public Matrix<T> PointwiseCeiling()
		{
			return PointwiseUnary(DoPointwiseCeiling);
		}

		public void PointwiseCeiling(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseCeiling, result);
		}

		public Matrix<T> PointwiseCos()
		{
			return PointwiseUnary(DoPointwiseCos);
		}

		public void PointwiseCos(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseCos, result);
		}

		public Matrix<T> PointwiseCosh()
		{
			return PointwiseUnary(DoPointwiseCosh);
		}

		public void PointwiseCosh(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseCosh, result);
		}

		public Matrix<T> PointwiseFloor()
		{
			return PointwiseUnary(DoPointwiseFloor);
		}

		public void PointwiseFloor(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseFloor, result);
		}

		public Matrix<T> PointwiseLog10()
		{
			return PointwiseUnary(DoPointwiseLog10);
		}

		public void PointwiseLog10(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseLog10, result);
		}

		public Matrix<T> PointwiseRound()
		{
			return PointwiseUnary(DoPointwiseRound);
		}

		public void PointwiseRound(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseRound, result);
		}

		public Matrix<T> PointwiseSign()
		{
			return PointwiseUnary(DoPointwiseSign);
		}

		public void PointwiseSign(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseSign, result);
		}

		public Matrix<T> PointwiseSin()
		{
			return PointwiseUnary(DoPointwiseSin);
		}

		public void PointwiseSin(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseSin, result);
		}

		public Matrix<T> PointwiseSinh()
		{
			return PointwiseUnary(DoPointwiseSinh);
		}

		public void PointwiseSinh(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseSinh, result);
		}

		public Matrix<T> PointwiseSqrt()
		{
			return PointwiseUnary(DoPointwiseSqrt);
		}

		public void PointwiseSqrt(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseSqrt, result);
		}

		public Matrix<T> PointwiseTan()
		{
			return PointwiseUnary(DoPointwiseTan);
		}

		public void PointwiseTan(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseTan, result);
		}

		public Matrix<T> PointwiseTanh()
		{
			return PointwiseUnary(DoPointwiseTanh);
		}

		public void PointwiseTanh(Matrix<T> result)
		{
			PointwiseUnary(DoPointwiseTanh, result);
		}

		public abstract T Trace();

		public virtual int Rank()
		{
			return Svd(computeVectors: false).Rank;
		}

		public int Nullity()
		{
			return ColumnCount - Rank();
		}

		public virtual T ConditionNumber()
		{
			return Svd(computeVectors: false).ConditionNumber;
		}

		public virtual T Determinant()
		{
			if (RowCount != ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			return LU().Determinant;
		}

		public virtual Vector<T>[] Kernel()
		{
			Svd<T> svd = Svd();
			return svd.VT.EnumerateRows(svd.Rank, ColumnCount - svd.Rank).ToArray();
		}

		public virtual Vector<T>[] Range()
		{
			Svd<T> svd = Svd();
			return svd.U.EnumerateColumns(0, svd.Rank).ToArray();
		}

		public virtual Matrix<T> Inverse()
		{
			if (RowCount != ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			return LU().Inverse();
		}

		public abstract Matrix<T> PseudoInverse();

		public Matrix<T> KroneckerProduct(Matrix<T> other)
		{
			Matrix<T> result = Build.SameAs(this, other, RowCount * other.RowCount, ColumnCount * other.ColumnCount);
			KroneckerProduct(other, result);
			return result;
		}

		public virtual void KroneckerProduct(Matrix<T> other, Matrix<T> result)
		{
			if (result.RowCount != RowCount * other.RowCount || result.ColumnCount != ColumnCount * other.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, result);
			}
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < RowCount; j++)
				{
					result.SetSubMatrix(j * other.RowCount, other.RowCount, i * other.ColumnCount, other.ColumnCount, At(j, i) * other);
				}
			}
		}

		public Matrix<T> PointwiseMinimum(T scalar)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseMinimum(scalar, result);
			return result;
		}

		public void PointwiseMinimum(T scalar, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoPointwiseMinimum(scalar, result);
		}

		public Matrix<T> PointwiseMaximum(T scalar)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseMaximum(scalar, result);
			return result;
		}

		public void PointwiseMaximum(T scalar, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoPointwiseMaximum(scalar, result);
		}

		public Matrix<T> PointwiseAbsoluteMinimum(T scalar)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMinimum(scalar, result);
			return result;
		}

		public void PointwiseAbsoluteMinimum(T scalar, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoPointwiseAbsoluteMinimum(scalar, result);
		}

		public Matrix<T> PointwiseAbsoluteMaximum(T scalar)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMaximum(scalar, result);
			return result;
		}

		public void PointwiseAbsoluteMaximum(T scalar, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result);
			}
			DoPointwiseAbsoluteMaximum(scalar, result);
		}

		public Matrix<T> PointwiseMinimum(Matrix<T> other)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseMinimum(other, result);
			return result;
		}

		public void PointwiseMinimum(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			DoPointwiseMinimum(other, result);
		}

		public Matrix<T> PointwiseMaximum(Matrix<T> other)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseMaximum(other, result);
			return result;
		}

		public void PointwiseMaximum(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			DoPointwiseMaximum(other, result);
		}

		public Matrix<T> PointwiseAbsoluteMinimum(Matrix<T> other)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMinimum(other, result);
			return result;
		}

		public void PointwiseAbsoluteMinimum(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			DoPointwiseAbsoluteMinimum(other, result);
		}

		public Matrix<T> PointwiseAbsoluteMaximum(Matrix<T> other)
		{
			Matrix<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMaximum(other, result);
			return result;
		}

		public void PointwiseAbsoluteMaximum(Matrix<T> other, Matrix<T> result)
		{
			if (ColumnCount != result.ColumnCount || RowCount != result.RowCount || ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, other, result);
			}
			DoPointwiseAbsoluteMaximum(other, result);
		}

		public abstract double L1Norm();

		public virtual double L2Norm()
		{
			return Svd(computeVectors: false).L2Norm;
		}

		public abstract double InfinityNorm();

		public abstract double FrobeniusNorm();

		public abstract Vector<double> RowNorms(double norm);

		public abstract Vector<double> ColumnNorms(double norm);

		public abstract Matrix<T> NormalizeRows(double norm);

		public abstract Matrix<T> NormalizeColumns(double norm);

		public abstract Vector<T> RowSums();

		public abstract Vector<T> ColumnSums();

		public abstract Vector<T> RowAbsoluteSums();

		public abstract Vector<T> ColumnAbsoluteSums();

		internal static Exception DimensionsDontMatch<TException>(Matrix<T> left, Matrix<T> right, Matrix<T> result, string paramName = null) where TException : Exception
		{
			return CreateException<TException>($"Matrix dimensions must agree: op1 is {left.RowCount}x{left.ColumnCount}, op2 is {right.RowCount}x{right.ColumnCount}, op3 is {result.RowCount}x{result.ColumnCount}.", paramName);
		}

		internal static Exception DimensionsDontMatch<TException>(Matrix<T> left, Matrix<T> right, string paramName = null) where TException : Exception
		{
			return CreateException<TException>($"Matrix dimensions must agree: op1 is {left.RowCount}x{left.ColumnCount}, op2 is {right.RowCount}x{right.ColumnCount}.", paramName);
		}

		internal static Exception DimensionsDontMatch<TException>(Matrix<T> matrix) where TException : Exception
		{
			return CreateException<TException>($"Matrix dimensions must agree: {matrix.RowCount}x{matrix.ColumnCount}.");
		}

		internal static Exception DimensionsDontMatch<TException>(Matrix<T> left, Vector<T> right, Vector<T> result, string paramName = null) where TException : Exception
		{
			return DimensionsDontMatch<TException>(left, right.ToColumnMatrix(), result.ToColumnMatrix(), paramName);
		}

		internal static Exception DimensionsDontMatch<TException>(Matrix<T> left, Vector<T> right, string paramName = null) where TException : Exception
		{
			return DimensionsDontMatch<TException>(left, right.ToColumnMatrix(), paramName);
		}

		internal static Exception DimensionsDontMatch<TException>(Vector<T> left, Matrix<T> right, string paramName = null) where TException : Exception
		{
			return DimensionsDontMatch<TException>(left.ToColumnMatrix(), right, paramName);
		}

		internal static Exception DimensionsDontMatch<TException>(Vector<T> left, Vector<T> right, string paramName = null) where TException : Exception
		{
			return DimensionsDontMatch<TException>(left.ToColumnMatrix(), right.ToColumnMatrix(), paramName);
		}

		private static Exception CreateException<TException>(string message, string paramName = null) where TException : Exception
		{
			if (typeof(TException) == typeof(ArgumentException))
			{
				return new ArgumentException(message, paramName);
			}
			if (typeof(TException) == typeof(ArgumentOutOfRangeException))
			{
				return new ArgumentOutOfRangeException(paramName, message);
			}
			return new Exception(message);
		}

		public bool Equals(Matrix<T> other)
		{
			if (other != null)
			{
				return Storage.Equals(other.Storage);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is Matrix<T> matrix)
			{
				return Storage.Equals(matrix.Storage);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return Storage.GetHashCode();
		}

		object ICloneable.Clone()
		{
			return Clone();
		}

		public virtual string ToTypeString()
		{
			return FormattableString.Invariant($"{GetType().Name} {RowCount}x{ColumnCount}-{typeof(T).Name}");
		}

		public string[,] ToMatrixStringArray(int upperRows, int lowerRows, int leftColumns, int rightColumns, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, Func<T, string> formatValue)
		{
			upperRows = Math.Max(upperRows, 1);
			lowerRows = Math.Max(lowerRows, 0);
			leftColumns = Math.Max(leftColumns, 1);
			rightColumns = Math.Max(rightColumns, 0);
			int num = ((RowCount <= upperRows) ? RowCount : upperRows);
			int num2 = ((RowCount > upperRows) ? ((RowCount <= upperRows + lowerRows) ? (RowCount - upperRows) : lowerRows) : 0);
			bool flag = RowCount > num + num2;
			int num3 = (flag ? (num + num2 + 1) : (num + num2));
			int num4 = ((ColumnCount <= leftColumns) ? ColumnCount : leftColumns);
			int num5 = ((ColumnCount > leftColumns) ? ((ColumnCount <= leftColumns + rightColumns) ? (ColumnCount - leftColumns) : rightColumns) : 0);
			bool flag2 = ColumnCount > num4 + num5;
			int num6 = (flag2 ? (num4 + num5 + 1) : (num4 + num5));
			string[,] array = new string[num3, num6];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num4; j++)
				{
					array[i, j] = formatValue(At(i, j));
				}
				int num7 = num4;
				if (flag2)
				{
					array[i, num4] = horizontalEllipsis;
					num7++;
				}
				for (int k = 0; k < num5; k++)
				{
					array[i, num7 + k] = formatValue(At(i, ColumnCount - num5 + k));
				}
			}
			int num8 = num;
			if (flag)
			{
				for (int l = 0; l < num4; l++)
				{
					array[num, l] = verticalEllipsis;
				}
				int num9 = num4;
				if (flag2)
				{
					array[num, num4] = diagonalEllipsis;
					num9++;
				}
				for (int m = 0; m < num5; m++)
				{
					array[num, num9 + m] = verticalEllipsis;
				}
				num8++;
			}
			for (int n = 0; n < num2; n++)
			{
				for (int num10 = 0; num10 < num4; num10++)
				{
					array[num8 + n, num10] = formatValue(At(RowCount - num2 + n, num10));
				}
				int num11 = num4;
				if (flag2)
				{
					array[num8 + n, num4] = horizontalEllipsis;
					num11++;
				}
				for (int num12 = 0; num12 < num5; num12++)
				{
					array[num8 + n, num11 + num12] = formatValue(At(RowCount - num2 + n, ColumnCount - num5 + num12));
				}
			}
			return array;
		}

		public string[,] ToMatrixStringArray(int upperRows, int lowerRows, int minLeftColumns, int rightColumns, int maxWidth, int padding, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, Func<T, string> formatValue)
		{
			upperRows = Math.Max(upperRows, 1);
			lowerRows = Math.Max(lowerRows, 0);
			minLeftColumns = Math.Max(minLeftColumns, 1);
			maxWidth = Math.Max(maxWidth, 12);
			int num = ((RowCount <= upperRows) ? RowCount : upperRows);
			int num2 = ((RowCount > upperRows) ? ((RowCount <= upperRows + lowerRows) ? (RowCount - upperRows) : lowerRows) : 0);
			bool flag = RowCount > num + num2;
			int num3 = (flag ? (num + num2 + 1) : (num + num2));
			int num4 = ((ColumnCount <= minLeftColumns) ? ColumnCount : minLeftColumns);
			int num5 = ((ColumnCount > minLeftColumns) ? ((ColumnCount <= minLeftColumns + rightColumns) ? (ColumnCount - minLeftColumns) : rightColumns) : 0);
			List<Tuple<int, string[]>> list = new List<Tuple<int, string[]>>();
			for (int i = 0; i < num4; i++)
			{
				list.Add(FormatColumn(i, num3, num, num2, flag, verticalEllipsis, formatValue));
			}
			List<Tuple<int, string[]>> list2 = new List<Tuple<int, string[]>>();
			for (int j = 0; j < num5; j++)
			{
				list2.Add(FormatColumn(ColumnCount - num5 + j, num3, num, num2, flag, verticalEllipsis, formatValue));
			}
			int num6 = list.Sum((Tuple<int, string[]> t) => t.Item1 + padding) + list2.Sum((Tuple<int, string[]> t) => t.Item1 + padding);
			for (int k = num4; k < ColumnCount - num5; k++)
			{
				Tuple<int, string[]> tuple = FormatColumn(k, num3, num, num2, flag, verticalEllipsis, formatValue);
				num6 += tuple.Item1 + padding;
				if (num6 > maxWidth)
				{
					break;
				}
				list.Add(tuple);
			}
			int num7 = list.Count + list2.Count;
			bool flag2 = ColumnCount > num7;
			if (flag2)
			{
				num7++;
			}
			string[,] array = new string[num3, num7];
			int num8 = 0;
			foreach (Tuple<int, string[]> item in list)
			{
				for (int l = 0; l < item.Item2.Length; l++)
				{
					array[l, num8] = item.Item2[l];
				}
				num8++;
			}
			if (flag2)
			{
				int num9 = 0;
				for (int m = 0; m < num; m++)
				{
					array[num9++, num8] = horizontalEllipsis;
				}
				if (flag)
				{
					array[num9++, num8] = diagonalEllipsis;
				}
				for (int n = RowCount - num2; n < RowCount; n++)
				{
					array[num9++, num8] = horizontalEllipsis;
				}
				num8++;
			}
			foreach (Tuple<int, string[]> item2 in list2)
			{
				for (int num10 = 0; num10 < item2.Item2.Length; num10++)
				{
					array[num10, num8] = item2.Item2[num10];
				}
				num8++;
			}
			return array;
		}

		private Tuple<int, string[]> FormatColumn(int column, int height, int upper, int lower, bool withEllipsis, string ellipsis, Func<T, string> formatValue)
		{
			string[] array = new string[height];
			int num = 0;
			for (int i = 0; i < upper; i++)
			{
				array[num++] = formatValue(At(i, column));
			}
			if (withEllipsis)
			{
				array[num++] = "";
			}
			for (int j = RowCount - lower; j < RowCount; j++)
			{
				array[num++] = formatValue(At(j, column));
			}
			int item = array.Max((string x) => x.Length);
			if (withEllipsis)
			{
				array[upper] = ellipsis;
			}
			return new Tuple<int, string[]>(item, array);
		}

		private static string FormatStringArrayToString(string[,] array, string columnSeparator, string rowSeparator)
		{
			int length = array.GetLength(0);
			int length2 = array.GetLength(1);
			int[] array2 = new int[length2];
			for (int i = 0; i < length; i++)
			{
				for (int j = 0; j < length2; j++)
				{
					array2[j] = Math.Max(array2[j], array[i, j].Length);
				}
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int k = 0; k < length; k++)
			{
				stringBuilder.Append(array[k, 0].PadLeft(array2[0]));
				for (int l = 1; l < length2; l++)
				{
					stringBuilder.Append(columnSeparator);
					stringBuilder.Append(array[k, l].PadLeft(array2[l]));
				}
				stringBuilder.Append(rowSeparator);
			}
			return stringBuilder.ToString();
		}

		public string ToMatrixString(int upperRows, int lowerRows, int leftColumns, int rightColumns, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, string columnSeparator, string rowSeparator, Func<T, string> formatValue)
		{
			return FormatStringArrayToString(ToMatrixStringArray(upperRows, lowerRows, leftColumns, rightColumns, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, formatValue), columnSeparator, rowSeparator);
		}

		public string ToMatrixString(int upperRows, int lowerRows, int minLeftColumns, int rightColumns, int maxWidth, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, string columnSeparator, string rowSeparator, Func<T, string> formatValue)
		{
			return FormatStringArrayToString(ToMatrixStringArray(upperRows, lowerRows, minLeftColumns, rightColumns, maxWidth, columnSeparator.Length, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, formatValue), columnSeparator, rowSeparator);
		}

		public string ToMatrixString(int maxRows, int maxColumns, string format = null, IFormatProvider provider = null)
		{
			if (format == null)
			{
				format = "G6";
			}
			int num = ((maxRows > 4) ? 2 : 0);
			int num2 = ((maxColumns > 4) ? 2 : 0);
			return ToMatrixString(maxRows - num, num, maxColumns - num2, num2, "..", "..", "..", "  ", Environment.NewLine, (T x) => x.ToString(format, provider));
		}

		public string ToMatrixString(string format = null, IFormatProvider provider = null)
		{
			if (format == null)
			{
				format = "G6";
			}
			return ToMatrixString(8, 4, 5, 2, 76, "..", "..", "..", "  ", Environment.NewLine, (T x) => x.ToString(format, provider));
		}

		public string ToString(int maxRows, int maxColumns, string format = null, IFormatProvider formatProvider = null)
		{
			return ToTypeString() + Environment.NewLine + ToMatrixString(maxRows, maxColumns, format, formatProvider);
		}

		public sealed override string ToString()
		{
			return ToTypeString() + Environment.NewLine + ToMatrixString();
		}

		public string ToString(string format = null, IFormatProvider formatProvider = null)
		{
			return ToTypeString() + Environment.NewLine + ToMatrixString(format, formatProvider);
		}

		protected Matrix(MatrixStorage<T> storage)
		{
			Storage = storage;
			RowCount = storage.RowCount;
			ColumnCount = storage.ColumnCount;
		}

		[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
		public T At(int row, int column)
		{
			return Storage.At(row, column);
		}

		[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
		public void At(int row, int column, T value)
		{
			Storage.At(row, column, value);
		}

		public void Clear()
		{
			Storage.Clear();
		}

		public void ClearRow(int rowIndex)
		{
			if ((uint)rowIndex >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			Storage.ClearUnchecked(rowIndex, 1, 0, ColumnCount);
		}

		public void ClearColumn(int columnIndex)
		{
			if ((uint)columnIndex >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			Storage.ClearUnchecked(0, RowCount, columnIndex, 1);
		}

		public void ClearRows(params int[] rowIndices)
		{
			Storage.ClearRows(rowIndices);
		}

		public void ClearColumns(params int[] columnIndices)
		{
			Storage.ClearColumns(columnIndices);
		}

		public void ClearSubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			Storage.Clear(rowIndex, rowCount, columnIndex, columnCount);
		}

		public abstract void CoerceZero(double threshold);

		public void CoerceZero(Func<T, bool> zeroPredicate)
		{
			MapInplace((T x) => (!zeroPredicate(x)) ? x : Zero);
		}

		public Matrix<T> Clone()
		{
			Matrix<T> matrix = Build.SameAs(this);
			Storage.CopyToUnchecked(matrix.Storage, ExistingData.AssumeZeros);
			return matrix;
		}

		public void CopyTo(Matrix<T> target)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			Storage.CopyTo(target.Storage);
		}

		public Vector<T> Row(int index)
		{
			if ((uint)index >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			Vector<T> vector = Vector<T>.Build.SameAs(this, ColumnCount);
			Storage.CopySubRowToUnchecked(vector.Storage, index, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			return vector;
		}

		public void Row(int index, Vector<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			Storage.CopyRowTo(result.Storage, index);
		}

		public Vector<T> Row(int rowIndex, int columnIndex, int length)
		{
			Vector<T> vector = Vector<T>.Build.SameAs(this, length);
			Storage.CopySubRowTo(vector.Storage, rowIndex, columnIndex, 0, length);
			return vector;
		}

		public void Row(int rowIndex, int columnIndex, int length, Vector<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			Storage.CopySubRowTo(result.Storage, rowIndex, columnIndex, 0, length);
		}

		public Vector<T> Column(int index)
		{
			if ((uint)index >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			Vector<T> vector = Vector<T>.Build.SameAs(this, RowCount);
			Storage.CopySubColumnToUnchecked(vector.Storage, index, 0, 0, RowCount, ExistingData.AssumeZeros);
			return vector;
		}

		public void Column(int index, Vector<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			Storage.CopyColumnTo(result.Storage, index);
		}

		public Vector<T> Column(int columnIndex, int rowIndex, int length)
		{
			Vector<T> vector = Vector<T>.Build.SameAs(this, length);
			Storage.CopySubColumnTo(vector.Storage, columnIndex, rowIndex, 0, length);
			return vector;
		}

		public void Column(int columnIndex, int rowIndex, int length, Vector<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			Storage.CopySubColumnTo(result.Storage, columnIndex, rowIndex, 0, length);
		}

		public virtual Matrix<T> UpperTriangle()
		{
			Matrix<T> matrix = Build.SameAs(this);
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = i; j < ColumnCount; j++)
				{
					matrix.At(i, j, At(i, j));
				}
			}
			return matrix;
		}

		public virtual Matrix<T> LowerTriangle()
		{
			Matrix<T> matrix = Build.SameAs(this);
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j <= i && j < ColumnCount; j++)
				{
					matrix.At(i, j, At(i, j));
				}
			}
			return matrix;
		}

		public virtual void LowerTriangle(Matrix<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					result.At(i, j, (i >= j) ? At(i, j) : Zero);
				}
			}
		}

		public virtual void UpperTriangle(Matrix<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					result.At(i, j, (i <= j) ? At(i, j) : Zero);
				}
			}
		}

		public virtual Matrix<T> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			Matrix<T> matrix = Build.SameAs(this, rowCount, columnCount);
			Storage.CopySubMatrixTo(matrix.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public virtual Vector<T> Diagonal()
		{
			int num = Math.Min(RowCount, ColumnCount);
			Vector<T> vector = Vector<T>.Build.SameAs(this, num);
			for (int i = 0; i < num; i++)
			{
				vector.At(i, At(i, i));
			}
			return vector;
		}

		public virtual Matrix<T> StrictlyLowerTriangle()
		{
			Matrix<T> matrix = Build.SameAs(this);
			for (int i = 0; i < RowCount; i++)
			{
				int num = Math.Min(i, ColumnCount);
				for (int j = 0; j < num; j++)
				{
					matrix.At(i, j, At(i, j));
				}
			}
			return matrix;
		}

		public virtual void StrictlyLowerTriangle(Matrix<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					result.At(i, j, (i > j) ? At(i, j) : Zero);
				}
			}
		}

		public virtual Matrix<T> StrictlyUpperTriangle()
		{
			Matrix<T> matrix = Build.SameAs(this);
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = i + 1; j < ColumnCount; j++)
				{
					matrix.At(i, j, At(i, j));
				}
			}
			return matrix;
		}

		public virtual void StrictlyUpperTriangle(Matrix<T> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					result.At(i, j, (i < j) ? At(i, j) : Zero);
				}
			}
		}

		public Matrix<T> InsertColumn(int columnIndex, Vector<T> column)
		{
			if (column == null)
			{
				throw new ArgumentNullException("column");
			}
			if ((uint)columnIndex > (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			if (column.Count != RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "column");
			}
			Matrix<T> matrix = Build.SameAs(this, RowCount, ColumnCount + 1, fullyMutable: true);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, RowCount, 0, 0, columnIndex, ExistingData.AssumeZeros);
			matrix.SetColumn(columnIndex, column);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, RowCount, columnIndex, columnIndex + 1, ColumnCount - columnIndex, ExistingData.AssumeZeros);
			return matrix;
		}

		public Matrix<T> RemoveColumn(int columnIndex)
		{
			if ((uint)columnIndex >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			Matrix<T> matrix = Build.SameAs(this, RowCount, ColumnCount - 1, fullyMutable: true);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, RowCount, 0, 0, columnIndex, ExistingData.AssumeZeros);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, RowCount, columnIndex + 1, columnIndex, ColumnCount - columnIndex - 1, ExistingData.AssumeZeros);
			return matrix;
		}

		public void SetColumn(int columnIndex, Vector<T> column)
		{
			if (column == null)
			{
				throw new ArgumentNullException("column");
			}
			column.Storage.CopyToColumn(Storage, columnIndex);
		}

		public void SetColumn(int columnIndex, int rowIndex, int length, Vector<T> column)
		{
			if (column == null)
			{
				throw new ArgumentNullException("column");
			}
			column.Storage.CopyToSubColumn(Storage, columnIndex, 0, rowIndex, length);
		}

		public void SetColumn(int columnIndex, T[] column)
		{
			if (column == null)
			{
				throw new ArgumentNullException("column");
			}
			new DenseVectorStorage<T>(column.Length, column).CopyToColumn(Storage, columnIndex);
		}

		public Matrix<T> InsertRow(int rowIndex, Vector<T> row)
		{
			if (row == null)
			{
				throw new ArgumentNullException("row");
			}
			if ((uint)rowIndex > (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			if (row.Count != ColumnCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "row");
			}
			Matrix<T> matrix = Build.SameAs(this, RowCount + 1, ColumnCount, fullyMutable: true);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, rowIndex, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			matrix.SetRow(rowIndex, row);
			Storage.CopySubMatrixTo(matrix.Storage, rowIndex, rowIndex + 1, RowCount - rowIndex, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public Matrix<T> RemoveRow(int rowIndex)
		{
			if ((uint)rowIndex >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			Matrix<T> matrix = Build.SameAs(this, RowCount - 1, ColumnCount, fullyMutable: true);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, rowIndex, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			Storage.CopySubMatrixTo(matrix.Storage, rowIndex + 1, rowIndex, RowCount - rowIndex - 1, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public void SetRow(int rowIndex, Vector<T> row)
		{
			if (row == null)
			{
				throw new ArgumentNullException("row");
			}
			row.Storage.CopyToRow(Storage, rowIndex);
		}

		public void SetRow(int rowIndex, int columnIndex, int length, Vector<T> row)
		{
			if (row == null)
			{
				throw new ArgumentNullException("row");
			}
			row.Storage.CopyToSubRow(Storage, rowIndex, 0, columnIndex, length);
		}

		public void SetRow(int rowIndex, T[] row)
		{
			if (row == null)
			{
				throw new ArgumentNullException("row");
			}
			new DenseVectorStorage<T>(row.Length, row).CopyToRow(Storage, rowIndex);
		}

		public void SetSubMatrix(int rowIndex, int columnIndex, Matrix<T> subMatrix)
		{
			subMatrix.Storage.CopySubMatrixTo(Storage, 0, rowIndex, subMatrix.RowCount, 0, columnIndex, subMatrix.ColumnCount);
		}

		public void SetSubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount, Matrix<T> subMatrix)
		{
			subMatrix.Storage.CopySubMatrixTo(Storage, 0, rowIndex, rowCount, 0, columnIndex, columnCount);
		}

		public void SetSubMatrix(int rowIndex, int sorceRowIndex, int rowCount, int columnIndex, int sourceColumnIndex, int columnCount, Matrix<T> subMatrix)
		{
			subMatrix.Storage.CopySubMatrixTo(Storage, sorceRowIndex, rowIndex, rowCount, sourceColumnIndex, columnIndex, columnCount);
		}

		public virtual void SetDiagonal(Vector<T> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			int num = Math.Min(RowCount, ColumnCount);
			if (source.Count != num)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "source");
			}
			for (int i = 0; i < num; i++)
			{
				At(i, i, source.At(i));
			}
		}

		public virtual void SetDiagonal(T[] source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			int num = Math.Min(RowCount, ColumnCount);
			if (source.Length != num)
			{
				throw new ArgumentException("The array arguments must have the same length.", "source");
			}
			for (int i = 0; i < num; i++)
			{
				At(i, i, source[i]);
			}
		}

		public Matrix<T> Resize(int rowCount, int columnCount)
		{
			Matrix<T> matrix = Build.SameAs(this, rowCount, columnCount, fullyMutable: true);
			Storage.CopySubMatrixTo(matrix.Storage, 0, 0, Math.Min(RowCount, rowCount), 0, 0, Math.Min(ColumnCount, columnCount), ExistingData.AssumeZeros);
			return matrix;
		}

		public Matrix<T> Transpose()
		{
			Matrix<T> matrix = Build.SameAs(this, ColumnCount, RowCount);
			Storage.TransposeToUnchecked(matrix.Storage, ExistingData.AssumeZeros);
			return matrix;
		}

		public void Transpose(Matrix<T> result)
		{
			Storage.TransposeTo(result.Storage);
		}

		public abstract Matrix<T> ConjugateTranspose();

		public abstract void ConjugateTranspose(Matrix<T> result);

		public virtual void PermuteRows(Permutation p)
		{
			if (p.Dimension != RowCount)
			{
				throw new ArgumentException("The array arguments must have the same length.", "p");
			}
			int[] array = p.ToInversions();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != i)
				{
					int row = array[i];
					for (int j = 0; j < ColumnCount; j++)
					{
						T value = At(row, j);
						At(row, j, At(i, j));
						At(i, j, value);
					}
				}
			}
		}

		public virtual void PermuteColumns(Permutation p)
		{
			if (p.Dimension != ColumnCount)
			{
				throw new ArgumentException("The array arguments must have the same length.", "p");
			}
			int[] array = p.ToInversions();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != i)
				{
					int column = array[i];
					for (int j = 0; j < RowCount; j++)
					{
						T value = At(j, column);
						At(j, column, At(j, i));
						At(j, i, value);
					}
				}
			}
		}

		public Matrix<T> Append(Matrix<T> right)
		{
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			if (right.RowCount != RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			Matrix<T> matrix = Build.SameAs(this, right, RowCount, ColumnCount + right.ColumnCount, fullyMutable: true);
			Storage.CopySubMatrixToUnchecked(matrix.Storage, 0, 0, RowCount, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			right.Storage.CopySubMatrixToUnchecked(matrix.Storage, 0, 0, right.RowCount, 0, ColumnCount, right.ColumnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public void Append(Matrix<T> right, Matrix<T> result)
		{
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			if (right.RowCount != RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.ColumnCount != ColumnCount + right.ColumnCount || result.RowCount != RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, RowCount, 0, 0, ColumnCount, ExistingData.Clear);
			right.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, right.RowCount, 0, ColumnCount, right.ColumnCount, ExistingData.Clear);
		}

		public Matrix<T> Stack(Matrix<T> lower)
		{
			if (lower == null)
			{
				throw new ArgumentNullException("lower");
			}
			if (lower.ColumnCount != ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "lower");
			}
			Matrix<T> matrix = Build.SameAs(this, lower, RowCount + lower.RowCount, ColumnCount, fullyMutable: true);
			Storage.CopySubMatrixToUnchecked(matrix.Storage, 0, 0, RowCount, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			lower.Storage.CopySubMatrixToUnchecked(matrix.Storage, 0, RowCount, lower.RowCount, 0, 0, lower.ColumnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public void Stack(Matrix<T> lower, Matrix<T> result)
		{
			if (lower == null)
			{
				throw new ArgumentNullException("lower");
			}
			if (lower.ColumnCount != ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "lower");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != RowCount + lower.RowCount || result.ColumnCount != ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, RowCount, 0, 0, ColumnCount, ExistingData.Clear);
			lower.Storage.CopySubMatrixToUnchecked(result.Storage, 0, RowCount, lower.RowCount, 0, 0, lower.ColumnCount, ExistingData.Clear);
		}

		public Matrix<T> DiagonalStack(Matrix<T> lower)
		{
			if (lower == null)
			{
				throw new ArgumentNullException("lower");
			}
			Matrix<T> matrix = Build.SameAs(this, lower, RowCount + lower.RowCount, ColumnCount + lower.ColumnCount, RowCount != ColumnCount);
			Storage.CopySubMatrixToUnchecked(matrix.Storage, 0, 0, RowCount, 0, 0, ColumnCount, ExistingData.AssumeZeros);
			lower.Storage.CopySubMatrixToUnchecked(matrix.Storage, 0, RowCount, lower.RowCount, 0, ColumnCount, lower.ColumnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public void DiagonalStack(Matrix<T> lower, Matrix<T> result)
		{
			if (lower == null)
			{
				throw new ArgumentNullException("lower");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != RowCount + lower.RowCount || result.ColumnCount != ColumnCount + lower.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, RowCount, 0, 0, ColumnCount, ExistingData.Clear);
			lower.Storage.CopySubMatrixToUnchecked(result.Storage, 0, RowCount, lower.RowCount, 0, ColumnCount, lower.ColumnCount, ExistingData.Clear);
		}

		public virtual bool IsSymmetric()
		{
			if (RowCount != ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = i + 1; j < ColumnCount; j++)
				{
					if (!At(i, j).Equals(At(j, i)))
					{
						return false;
					}
				}
			}
			return true;
		}

		public abstract bool IsHermitian();

		public T[,] ToArray()
		{
			return Storage.ToArray();
		}

		public T[] ToColumnMajorArray()
		{
			return Storage.ToColumnMajorArray();
		}

		public T[] ToRowMajorArray()
		{
			return Storage.ToRowMajorArray();
		}

		public T[][] ToRowArrays()
		{
			return Storage.ToRowArrays();
		}

		public T[][] ToColumnArrays()
		{
			return Storage.ToColumnArrays();
		}

		public T[,] AsArray()
		{
			return Storage.AsArray();
		}

		public T[] AsColumnMajorArray()
		{
			return Storage.AsColumnMajorArray();
		}

		public T[] AsRowMajorArray()
		{
			return Storage.AsRowMajorArray();
		}

		public T[][] AsRowArrays()
		{
			return Storage.AsRowArrays();
		}

		public T[][] AsColumnArrays()
		{
			return Storage.AsColumnArrays();
		}

		public IEnumerable<T> Enumerate()
		{
			return Storage.Enumerate();
		}

		public IEnumerable<T> Enumerate(Zeros zeros = Zeros.Include)
		{
			if (zeros == Zeros.AllowSkip)
			{
				return Storage.EnumerateNonZero();
			}
			return Storage.Enumerate();
		}

		public IEnumerable<Tuple<int, int, T>> EnumerateIndexed()
		{
			return Storage.EnumerateIndexed();
		}

		public IEnumerable<Tuple<int, int, T>> EnumerateIndexed(Zeros zeros = Zeros.Include)
		{
			if (zeros == Zeros.AllowSkip)
			{
				return Storage.EnumerateNonZeroIndexed();
			}
			return Storage.EnumerateIndexed();
		}

		public IEnumerable<Vector<T>> EnumerateColumns()
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				yield return Column(i);
			}
		}

		public IEnumerable<Vector<T>> EnumerateColumns(int index, int length)
		{
			int maxIndex = Math.Min(index + length, ColumnCount);
			for (int i = Math.Max(index, 0); i < maxIndex; i++)
			{
				yield return Column(i);
			}
		}

		public IEnumerable<Tuple<int, Vector<T>>> EnumerateColumnsIndexed()
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				yield return new Tuple<int, Vector<T>>(i, Column(i));
			}
		}

		public IEnumerable<Tuple<int, Vector<T>>> EnumerateColumnsIndexed(int index, int length)
		{
			int maxIndex = Math.Min(index + length, ColumnCount);
			for (int i = Math.Max(index, 0); i < maxIndex; i++)
			{
				yield return new Tuple<int, Vector<T>>(i, Column(i));
			}
		}

		public IEnumerable<Vector<T>> EnumerateRows()
		{
			for (int i = 0; i < RowCount; i++)
			{
				yield return Row(i);
			}
		}

		public IEnumerable<Vector<T>> EnumerateRows(int index, int length)
		{
			int maxIndex = Math.Min(index + length, RowCount);
			for (int i = Math.Max(index, 0); i < maxIndex; i++)
			{
				yield return Row(i);
			}
		}

		public IEnumerable<Tuple<int, Vector<T>>> EnumerateRowsIndexed()
		{
			for (int i = 0; i < RowCount; i++)
			{
				yield return new Tuple<int, Vector<T>>(i, Row(i));
			}
		}

		public IEnumerable<Tuple<int, Vector<T>>> EnumerateRowsIndexed(int index, int length)
		{
			int maxIndex = Math.Min(index + length, RowCount);
			for (int i = Math.Max(index, 0); i < maxIndex; i++)
			{
				yield return new Tuple<int, Vector<T>>(i, Row(i));
			}
		}

		public void MapInplace(Func<T, T> f, Zeros zeros = Zeros.AllowSkip)
		{
			Storage.MapInplace(f, zeros);
		}

		public void MapIndexedInplace(Func<int, int, T, T> f, Zeros zeros = Zeros.AllowSkip)
		{
			Storage.MapIndexedInplace(f, zeros);
		}

		public void Map(Func<T, T> f, Matrix<T> result, Zeros zeros = Zeros.AllowSkip)
		{
			if (this == result)
			{
				Storage.MapInplace(f, zeros);
			}
			else
			{
				Storage.MapTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
			}
		}

		public void MapIndexed(Func<int, int, T, T> f, Matrix<T> result, Zeros zeros = Zeros.AllowSkip)
		{
			if (this == result)
			{
				Storage.MapIndexedInplace(f, zeros);
			}
			else
			{
				Storage.MapIndexedTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
			}
		}

		public void MapConvert<TU>(Func<T, TU> f, Matrix<TU> result, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Storage.MapTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
		}

		public void MapIndexedConvert<TU>(Func<int, int, T, TU> f, Matrix<TU> result, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Storage.MapIndexedTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
		}

		public Matrix<TU> Map<TU>(Func<T, TU> f, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Matrix<TU> matrix = Matrix<TU>.Build.SameAs(this, RowCount, ColumnCount, zeros == Zeros.Include);
			Storage.MapToUnchecked(matrix.Storage, f, zeros, ExistingData.AssumeZeros);
			return matrix;
		}

		public Matrix<TU> MapIndexed<TU>(Func<int, int, T, TU> f, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Matrix<TU> matrix = Matrix<TU>.Build.SameAs(this, RowCount, ColumnCount, zeros == Zeros.Include);
			Storage.MapIndexedToUnchecked(matrix.Storage, f, zeros, ExistingData.AssumeZeros);
			return matrix;
		}

		public TU[] FoldByRow<TU>(Func<TU, T, TU> f, TU state, Zeros zeros = Zeros.AllowSkip)
		{
			TU[] result = new TU[RowCount];
			if (!EqualityComparer<TU>.Default.Equals(state, default(TU)))
			{
				CommonParallel.For(0, result.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						result[i] = state;
					}
				});
			}
			Storage.FoldByRowUnchecked(result, f, (TU x, int c) => x, result, zeros);
			return result;
		}

		public TU[] FoldByColumn<TU>(Func<TU, T, TU> f, TU state, Zeros zeros = Zeros.AllowSkip)
		{
			TU[] result = new TU[ColumnCount];
			if (!EqualityComparer<TU>.Default.Equals(state, default(TU)))
			{
				CommonParallel.For(0, result.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						result[i] = state;
					}
				});
			}
			Storage.FoldByColumnUnchecked(result, f, (TU x, int c) => x, result, zeros);
			return result;
		}

		public Vector<TU> FoldRows<TU>(Func<Vector<TU>, Vector<T>, Vector<TU>> f, Vector<TU> state) where TU : struct, IEquatable<TU>, IFormattable
		{
			foreach (Vector<T> item in EnumerateRows())
			{
				state = f(state, item);
			}
			return state;
		}

		public Vector<TU> FoldColumns<TU>(Func<Vector<TU>, Vector<T>, Vector<TU>> f, Vector<TU> state) where TU : struct, IEquatable<TU>, IFormattable
		{
			foreach (Vector<T> item in EnumerateColumns())
			{
				state = f(state, item);
			}
			return state;
		}

		public Vector<T> ReduceRows(Func<Vector<T>, Vector<T>, Vector<T>> f)
		{
			return EnumerateRows().Aggregate(f);
		}

		public Vector<T> ReduceColumns(Func<Vector<T>, Vector<T>, Vector<T>> f)
		{
			return EnumerateColumns().Aggregate(f);
		}

		public void Map2(Func<T, T, T> f, Matrix<T> other, Matrix<T> result, Zeros zeros = Zeros.AllowSkip)
		{
			Storage.Map2To(result.Storage, other.Storage, f, zeros, ExistingData.Clear);
		}

		public Matrix<T> Map2(Func<T, T, T> f, Matrix<T> other, Zeros zeros = Zeros.AllowSkip)
		{
			Matrix<T> matrix = Build.SameAs(this);
			Storage.Map2To(matrix.Storage, other.Storage, f, zeros, ExistingData.AssumeZeros);
			return matrix;
		}

		public TState Fold2<TOther, TState>(Func<TState, T, TOther, TState> f, TState state, Matrix<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Fold2(other.Storage, f, state, zeros);
		}

		public Tuple<int, int, T> Find(Func<T, bool> predicate, Zeros zeros = Zeros.AllowSkip)
		{
			return Storage.Find(predicate, zeros);
		}

		public Tuple<int, int, T, TOther> Find2<TOther>(Func<T, TOther, bool> predicate, Matrix<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Find2(other.Storage, predicate, zeros);
		}

		public bool Exists(Func<T, bool> predicate, Zeros zeros = Zeros.AllowSkip)
		{
			return Storage.Find(predicate, zeros) != null;
		}

		public bool Exists2<TOther>(Func<T, TOther, bool> predicate, Matrix<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Find2(other.Storage, predicate, zeros) != null;
		}

		public bool ForAll(Func<T, bool> predicate, Zeros zeros = Zeros.AllowSkip)
		{
			return Storage.Find((T x) => !predicate(x), zeros) == null;
		}

		public bool ForAll2<TOther>(Func<T, TOther, bool> predicate, Matrix<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Find2(other.Storage, (T x, TOther y) => !predicate(x, y), zeros) == null;
		}

		public static Matrix<T>operator +(Matrix<T> rightSide)
		{
			return rightSide.Clone();
		}

		public static Matrix<T>operator -(Matrix<T> rightSide)
		{
			return rightSide.Negate();
		}

		public static Matrix<T>operator +(Matrix<T> leftSide, Matrix<T> rightSide)
		{
			return leftSide.Add(rightSide);
		}

		public static Matrix<T>operator +(Matrix<T> leftSide, T rightSide)
		{
			return leftSide.Add(rightSide);
		}

		public static Matrix<T>operator +(T leftSide, Matrix<T> rightSide)
		{
			return rightSide.Add(leftSide);
		}

		public static Matrix<T>operator -(Matrix<T> leftSide, Matrix<T> rightSide)
		{
			return leftSide.Subtract(rightSide);
		}

		public static Matrix<T>operator -(Matrix<T> leftSide, T rightSide)
		{
			return leftSide.Subtract(rightSide);
		}

		public static Matrix<T>operator -(T leftSide, Matrix<T> rightSide)
		{
			return rightSide.SubtractFrom(leftSide);
		}

		public static Matrix<T>operator *(Matrix<T> leftSide, T rightSide)
		{
			return leftSide.Multiply(rightSide);
		}

		public static Matrix<T>operator *(T leftSide, Matrix<T> rightSide)
		{
			return rightSide.Multiply(leftSide);
		}

		public static Matrix<T>operator *(Matrix<T> leftSide, Matrix<T> rightSide)
		{
			return leftSide.Multiply(rightSide);
		}

		public static Vector<T>operator *(Matrix<T> leftSide, Vector<T> rightSide)
		{
			return leftSide.Multiply(rightSide);
		}

		public static Vector<T>operator *(Vector<T> leftSide, Matrix<T> rightSide)
		{
			return rightSide.LeftMultiply(leftSide);
		}

		public static Matrix<T>operator /(T dividend, Matrix<T> divisor)
		{
			return divisor.DivideByThis(dividend);
		}

		public static Matrix<T>operator /(Matrix<T> dividend, T divisor)
		{
			return dividend.Divide(divisor);
		}

		public static Matrix<T>operator %(Matrix<T> dividend, T divisor)
		{
			return dividend.Remainder(divisor);
		}

		public static Matrix<T>operator %(T dividend, Matrix<T> divisor)
		{
			return divisor.RemainderByThis(dividend);
		}

		public static Matrix<T>operator %(Matrix<T> dividend, Matrix<T> divisor)
		{
			return dividend.PointwiseRemainder(divisor);
		}

		[SpecialName]
		public static Matrix<T> op_DotMultiply(Matrix<T> x, Matrix<T> y)
		{
			return x.PointwiseMultiply(y);
		}

		[SpecialName]
		public static Matrix<T> op_DotDivide(Matrix<T> dividend, Matrix<T> divisor)
		{
			return dividend.PointwiseDivide(divisor);
		}

		[SpecialName]
		public static Matrix<T> op_DotPercent(Matrix<T> dividend, Matrix<T> divisor)
		{
			return dividend.PointwiseRemainder(divisor);
		}

		[SpecialName]
		public static Matrix<T> op_DotHat(Matrix<T> matrix, Matrix<T> exponent)
		{
			return matrix.PointwisePower(exponent);
		}

		[SpecialName]
		public static Matrix<T> op_DotHat(Matrix<T> matrix, T exponent)
		{
			return matrix.PointwisePower(exponent);
		}

		public static Matrix<T> Sqrt(Matrix<T> x)
		{
			return x.PointwiseSqrt();
		}

		public static Matrix<T> Exp(Matrix<T> x)
		{
			return x.PointwiseExp();
		}

		public static Matrix<T> Log(Matrix<T> x)
		{
			return x.PointwiseLog();
		}

		public static Matrix<T> Log10(Matrix<T> x)
		{
			return x.PointwiseLog10();
		}

		public static Matrix<T> Sin(Matrix<T> x)
		{
			return x.PointwiseSin();
		}

		public static Matrix<T> Cos(Matrix<T> x)
		{
			return x.PointwiseCos();
		}

		public static Matrix<T> Tan(Matrix<T> x)
		{
			return x.PointwiseTan();
		}

		public static Matrix<T> Asin(Matrix<T> x)
		{
			return x.PointwiseAsin();
		}

		public static Matrix<T> Acos(Matrix<T> x)
		{
			return x.PointwiseAcos();
		}

		public static Matrix<T> Atan(Matrix<T> x)
		{
			return x.PointwiseAtan();
		}

		public static Matrix<T> Sinh(Matrix<T> x)
		{
			return x.PointwiseSinh();
		}

		public static Matrix<T> Cosh(Matrix<T> x)
		{
			return x.PointwiseCosh();
		}

		public static Matrix<T> Tanh(Matrix<T> x)
		{
			return x.PointwiseTanh();
		}

		public static Matrix<T> Abs(Matrix<T> x)
		{
			return x.PointwiseAbs();
		}

		public static Matrix<T> Floor(Matrix<T> x)
		{
			return x.PointwiseFloor();
		}

		public static Matrix<T> Ceiling(Matrix<T> x)
		{
			return x.PointwiseCeiling();
		}

		public static Matrix<T> Round(Matrix<T> x)
		{
			return x.PointwiseRound();
		}

		public abstract Cholesky<T> Cholesky();

		public abstract LU<T> LU();

		public abstract QR<T> QR(QRMethod method = QRMethod.Thin);

		public abstract GramSchmidt<T> GramSchmidt();

		public abstract Svd<T> Svd(bool computeVectors = true);

		public abstract Evd<T> Evd(Symmetricity symmetricity = Symmetricity.Unknown);

		public void Solve(Vector<T> input, Vector<T> result)
		{
			if (ColumnCount == RowCount)
			{
				LU().Solve(input, result);
			}
			else
			{
				QR().Solve(input, result);
			}
		}

		public void Solve(Matrix<T> input, Matrix<T> result)
		{
			if (ColumnCount == RowCount)
			{
				LU().Solve(input, result);
			}
			else
			{
				QR().Solve(input, result);
			}
		}

		public Matrix<T> Solve(Matrix<T> input)
		{
			Matrix<T> result = Build.SameAs(this, ColumnCount, input.ColumnCount, fullyMutable: true);
			Solve(input, result);
			return result;
		}

		public Vector<T> Solve(Vector<T> input)
		{
			Vector<T> result = Vector<T>.Build.SameAs(this, ColumnCount);
			Solve(input, result);
			return result;
		}

		public IterationStatus TrySolveIterative(Vector<T> input, Vector<T> result, IIterativeSolver<T> solver, Iterator<T> iterator = null, IPreconditioner<T> preconditioner = null)
		{
			if (iterator == null)
			{
				iterator = new Iterator<T>(Build.IterativeSolverStopCriteria());
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<T>();
			}
			solver.Solve(this, input, result, iterator, preconditioner);
			return iterator.Status;
		}

		public IterationStatus TrySolveIterative(Matrix<T> input, Matrix<T> result, IIterativeSolver<T> solver, Iterator<T> iterator = null, IPreconditioner<T> preconditioner = null)
		{
			if (RowCount != input.RowCount || input.RowCount != result.RowCount || input.ColumnCount != result.ColumnCount)
			{
				throw DimensionsDontMatch<ArgumentException>(this, input, result);
			}
			if (iterator == null)
			{
				iterator = new Iterator<T>(Build.IterativeSolverStopCriteria());
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<T>();
			}
			for (int i = 0; i < input.ColumnCount; i++)
			{
				Vector<T> vector = Vector<T>.Build.Dense(RowCount);
				solver.Solve(this, input.Column(i), vector, iterator, preconditioner);
				foreach (Tuple<int, T> item in vector.EnumerateIndexed(Zeros.AllowSkip))
				{
					result.At(item.Item1, i, item.Item2);
				}
			}
			return iterator.Status;
		}

		public IterationStatus TrySolveIterative(Vector<T> input, Vector<T> result, IIterativeSolver<T> solver, IPreconditioner<T> preconditioner, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Iterator<T> iterator = new Iterator<T>((stopCriteria.Length == 0) ? Build.IterativeSolverStopCriteria() : stopCriteria);
			return TrySolveIterative(input, result, solver, iterator, preconditioner);
		}

		public IterationStatus TrySolveIterative(Matrix<T> input, Matrix<T> result, IIterativeSolver<T> solver, IPreconditioner<T> preconditioner, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Iterator<T> iterator = new Iterator<T>((stopCriteria.Length == 0) ? Build.IterativeSolverStopCriteria() : stopCriteria);
			return TrySolveIterative(input, result, solver, iterator, preconditioner);
		}

		public IterationStatus TrySolveIterative(Vector<T> input, Vector<T> result, IIterativeSolver<T> solver, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Iterator<T> iterator = new Iterator<T>((stopCriteria.Length == 0) ? Build.IterativeSolverStopCriteria() : stopCriteria);
			return TrySolveIterative(input, result, solver, iterator);
		}

		public IterationStatus TrySolveIterative(Matrix<T> input, Matrix<T> result, IIterativeSolver<T> solver, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Iterator<T> iterator = new Iterator<T>((stopCriteria.Length == 0) ? Build.IterativeSolverStopCriteria() : stopCriteria);
			return TrySolveIterative(input, result, solver, iterator);
		}

		public Vector<T> SolveIterative(Vector<T> input, IIterativeSolver<T> solver, Iterator<T> iterator = null, IPreconditioner<T> preconditioner = null)
		{
			Vector<T> result = Vector<T>.Build.Dense(RowCount);
			TrySolveIterative(input, result, solver, iterator, preconditioner);
			return result;
		}

		public Matrix<T> SolveIterative(Matrix<T> input, IIterativeSolver<T> solver, Iterator<T> iterator = null, IPreconditioner<T> preconditioner = null)
		{
			Matrix<T> result = Build.Dense(input.RowCount, input.ColumnCount);
			TrySolveIterative(input, result, solver, iterator, preconditioner);
			return result;
		}

		public Vector<T> SolveIterative(Vector<T> input, IIterativeSolver<T> solver, IPreconditioner<T> preconditioner, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Vector<T> result = Vector<T>.Build.Dense(RowCount);
			TrySolveIterative(input, result, solver, preconditioner, stopCriteria);
			return result;
		}

		public Matrix<T> SolveIterative(Matrix<T> input, IIterativeSolver<T> solver, IPreconditioner<T> preconditioner, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Matrix<T> result = Build.Dense(input.RowCount, input.ColumnCount);
			TrySolveIterative(input, result, solver, preconditioner, stopCriteria);
			return result;
		}

		public Vector<T> SolveIterative(Vector<T> input, IIterativeSolver<T> solver, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Vector<T> result = Vector<T>.Build.Dense(RowCount);
			TrySolveIterative(input, result, solver, stopCriteria);
			return result;
		}

		public Matrix<T> SolveIterative(Matrix<T> input, IIterativeSolver<T> solver, params IIterationStopCriterion<T>[] stopCriteria)
		{
			Matrix<T> result = Build.Dense(input.RowCount, input.ColumnCount);
			TrySolveIterative(input, result, solver, stopCriteria);
			return result;
		}
	}
	public static class MatrixExtensions
	{
		public static Matrix<float> ToSingle(this Matrix<double> matrix)
		{
			return matrix.Map((double x) => (float)x);
		}

		public static Matrix<double> ToDouble(this Matrix<float> matrix)
		{
			return matrix.Map((Func<float, double>)((float x) => x), Zeros.AllowSkip);
		}

		public static Matrix<MathNet.Numerics.Complex32> ToComplex32(this Matrix<System.Numerics.Complex> matrix)
		{
			return matrix.Map((System.Numerics.Complex x) => new MathNet.Numerics.Complex32((float)x.Real, (float)x.Imaginary));
		}

		public static Matrix<System.Numerics.Complex> ToComplex(this Matrix<MathNet.Numerics.Complex32> matrix)
		{
			return matrix.Map((MathNet.Numerics.Complex32 x) => new System.Numerics.Complex(x.Real, x.Imaginary));
		}

		public static Matrix<MathNet.Numerics.Complex32> ToComplex32(this Matrix<float> matrix)
		{
			return matrix.Map((float x) => new MathNet.Numerics.Complex32(x, 0f));
		}

		public static Matrix<System.Numerics.Complex> ToComplex(this Matrix<double> matrix)
		{
			return matrix.Map((double x) => new System.Numerics.Complex(x, 0.0));
		}

		public static Matrix<double> Real(this Matrix<System.Numerics.Complex> matrix)
		{
			return matrix.Map((System.Numerics.Complex x) => x.Real);
		}

		public static Matrix<float> Real(this Matrix<MathNet.Numerics.Complex32> matrix)
		{
			return matrix.Map((MathNet.Numerics.Complex32 x) => x.Real);
		}

		public static Matrix<double> Imaginary(this Matrix<System.Numerics.Complex> matrix)
		{
			return matrix.Map((System.Numerics.Complex x) => x.Imaginary);
		}

		public static Matrix<float> Imaginary(this Matrix<MathNet.Numerics.Complex32> matrix)
		{
			return matrix.Map((MathNet.Numerics.Complex32 x) => x.Imaginary);
		}
	}
	public enum ExistingData
	{
		Clear,
		AssumeZeros
	}
	public enum Zeros
	{
		AllowSkip,
		Include
	}
	public enum Symmetricity
	{
		Unknown,
		Symmetric,
		Hermitian,
		Asymmetric
	}
	[Serializable]
	[DebuggerDisplay("Vector {Count}")]
	public abstract class Vector<T> : IFormattable, IEquatable<Vector<T>>, IList, ICollection, IEnumerable, IList<T>, ICollection<T>, IEnumerable<T>, ICloneable where T : struct, IEquatable<T>, IFormattable
	{
		public static readonly T Zero = BuilderInstance<T>.Vector.Zero;

		public static readonly T One = BuilderInstance<T>.Vector.One;

		public static readonly VectorBuilder<T> Build = BuilderInstance<T>.Vector;

		bool ICollection<T>.IsReadOnly => false;

		bool IList.IsReadOnly => false;

		bool IList.IsFixedSize => true;

		object IList.this[int index]
		{
			get
			{
				return Storage[index];
			}
			set
			{
				Storage[index] = (T)value;
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot => Storage;

		public VectorStorage<T> Storage { get; private set; }

		public int Count { get; private set; }

		public T this[int index]
		{
			[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
			get
			{
				return Storage[index];
			}
			[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
			set
			{
				Storage[index] = value;
			}
		}

		protected abstract void DoNegate(Vector<T> result);

		protected abstract void DoConjugate(Vector<T> result);

		protected abstract void DoAdd(T scalar, Vector<T> result);

		protected abstract void DoAdd(Vector<T> other, Vector<T> result);

		protected abstract void DoSubtract(T scalar, Vector<T> result);

		protected void DoSubtractFrom(T scalar, Vector<T> result)
		{
			DoNegate(result);
			result.DoAdd(scalar, result);
		}

		protected abstract void DoSubtract(Vector<T> other, Vector<T> result);

		protected abstract void DoMultiply(T scalar, Vector<T> result);

		protected abstract T DoDotProduct(Vector<T> other);

		protected abstract T DoConjugateDotProduct(Vector<T> other);

		protected void DoOuterProduct(Vector<T> other, Matrix<T> result)
		{
			Vector<T> vector = Build.Dense(Count);
			for (int i = 0; i < other.Count; i++)
			{
				DoMultiply(other.At(i), vector);
				result.SetColumn(i, vector);
			}
		}

		protected abstract void DoDivide(T divisor, Vector<T> result);

		protected abstract void DoDivideByThis(T dividend, Vector<T> result);

		protected abstract void DoModulus(T divisor, Vector<T> result);

		protected abstract void DoModulusByThis(T dividend, Vector<T> result);

		protected abstract void DoRemainder(T divisor, Vector<T> result);

		protected abstract void DoRemainderByThis(T dividend, Vector<T> result);

		protected abstract void DoPointwiseMultiply(Vector<T> other, Vector<T> result);

		protected abstract void DoPointwiseDivide(Vector<T> divisor, Vector<T> result);

		protected abstract void DoPointwisePower(T exponent, Vector<T> result);

		protected abstract void DoPointwisePower(Vector<T> exponent, Vector<T> result);

		protected abstract void DoPointwiseModulus(Vector<T> divisor, Vector<T> result);

		protected abstract void DoPointwiseRemainder(Vector<T> divisor, Vector<T> result);

		protected abstract void DoPointwiseExp(Vector<T> result);

		protected abstract void DoPointwiseLog(Vector<T> result);

		protected abstract void DoPointwiseAbs(Vector<T> result);

		protected abstract void DoPointwiseAcos(Vector<T> result);

		protected abstract void DoPointwiseAsin(Vector<T> result);

		protected abstract void DoPointwiseAtan(Vector<T> result);

		protected abstract void DoPointwiseCeiling(Vector<T> result);

		protected abstract void DoPointwiseCos(Vector<T> result);

		protected abstract void DoPointwiseCosh(Vector<T> result);

		protected abstract void DoPointwiseFloor(Vector<T> result);

		protected abstract void DoPointwiseLog10(Vector<T> result);

		protected abstract void DoPointwiseRound(Vector<T> result);

		protected abstract void DoPointwiseSign(Vector<T> result);

		protected abstract void DoPointwiseSin(Vector<T> result);

		protected abstract void DoPointwiseSinh(Vector<T> result);

		protected abstract void DoPointwiseSqrt(Vector<T> result);

		protected abstract void DoPointwiseTan(Vector<T> result);

		protected abstract void DoPointwiseTanh(Vector<T> result);

		protected abstract void DoPointwiseAtan2(Vector<T> other, Vector<T> result);

		protected abstract void DoPointwiseAtan2(T scalar, Vector<T> result);

		protected abstract void DoPointwiseMinimum(T scalar, Vector<T> result);

		protected abstract void DoPointwiseMinimum(Vector<T> other, Vector<T> result);

		protected abstract void DoPointwiseMaximum(T scalar, Vector<T> result);

		protected abstract void DoPointwiseMaximum(Vector<T> other, Vector<T> result);

		protected abstract void DoPointwiseAbsoluteMinimum(T scalar, Vector<T> result);

		protected abstract void DoPointwiseAbsoluteMinimum(Vector<T> other, Vector<T> result);

		protected abstract void DoPointwiseAbsoluteMaximum(T scalar, Vector<T> result);

		protected abstract void DoPointwiseAbsoluteMaximum(Vector<T> other, Vector<T> result);

		public Vector<T> Add(T scalar)
		{
			if (scalar.Equals(Zero))
			{
				return Clone();
			}
			Vector<T> result = Build.SameAs(this);
			DoAdd(scalar, result);
			return result;
		}

		public void Add(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			if (scalar.Equals(Zero))
			{
				CopyTo(result);
			}
			else
			{
				DoAdd(scalar, result);
			}
		}

		public Vector<T> Add(Vector<T> other)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			Vector<T> result = Build.SameAs(this, other);
			DoAdd(other, result);
			return result;
		}

		public void Add(Vector<T> other, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoAdd(other, result);
		}

		public Vector<T> Subtract(T scalar)
		{
			if (scalar.Equals(Zero))
			{
				return Clone();
			}
			Vector<T> result = Build.SameAs(this);
			DoSubtract(scalar, result);
			return result;
		}

		public void Subtract(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			if (scalar.Equals(Zero))
			{
				CopyTo(result);
			}
			else
			{
				DoSubtract(scalar, result);
			}
		}

		public Vector<T> SubtractFrom(T scalar)
		{
			Vector<T> result = Build.SameAs(this);
			DoSubtractFrom(scalar, result);
			return result;
		}

		public void SubtractFrom(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoSubtractFrom(scalar, result);
		}

		public Vector<T> Negate()
		{
			Vector<T> result = Build.SameAs(this);
			DoNegate(result);
			return result;
		}

		public void Negate(Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoNegate(result);
		}

		public Vector<T> Subtract(Vector<T> other)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			Vector<T> result = Build.SameAs(this, other);
			DoSubtract(other, result);
			return result;
		}

		public void Subtract(Vector<T> other, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoSubtract(other, result);
		}

		public Vector<T> Conjugate()
		{
			Vector<T> result = Build.SameAs(this);
			DoConjugate(result);
			return result;
		}

		public void Conjugate(Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoConjugate(result);
		}

		public Vector<T> Multiply(T scalar)
		{
			if (scalar.Equals(One))
			{
				return Clone();
			}
			if (scalar.Equals(Zero))
			{
				return Build.SameAs(this);
			}
			Vector<T> result = Build.SameAs(this);
			DoMultiply(scalar, result);
			return result;
		}

		public void Multiply(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			if (scalar.Equals(One))
			{
				CopyTo(result);
			}
			else if (scalar.Equals(Zero))
			{
				result.Clear();
			}
			else
			{
				DoMultiply(scalar, result);
			}
		}

		public T DotProduct(Vector<T> other)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			return DoDotProduct(other);
		}

		public T ConjugateDotProduct(Vector<T> other)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			return DoConjugateDotProduct(other);
		}

		public Vector<T> Divide(T scalar)
		{
			if (scalar.Equals(One))
			{
				return Clone();
			}
			Vector<T> result = Build.SameAs(this);
			DoDivide(scalar, result);
			return result;
		}

		public void Divide(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			if (scalar.Equals(One))
			{
				CopyTo(result);
			}
			else
			{
				DoDivide(scalar, result);
			}
		}

		public Vector<T> DivideByThis(T scalar)
		{
			Vector<T> result = Build.SameAs(this);
			DoDivideByThis(scalar, result);
			return result;
		}

		public void DivideByThis(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoDivideByThis(scalar, result);
		}

		public Vector<T> Modulus(T divisor)
		{
			Vector<T> result = Build.SameAs(this);
			DoModulus(divisor, result);
			return result;
		}

		public void Modulus(T divisor, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoModulus(divisor, result);
		}

		public Vector<T> ModulusByThis(T dividend)
		{
			Vector<T> result = Build.SameAs(this);
			DoModulusByThis(dividend, result);
			return result;
		}

		public void ModulusByThis(T dividend, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoModulusByThis(dividend, result);
		}

		public Vector<T> Remainder(T divisor)
		{
			Vector<T> result = Build.SameAs(this);
			DoRemainder(divisor, result);
			return result;
		}

		public void Remainder(T divisor, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoRemainder(divisor, result);
		}

		public Vector<T> RemainderByThis(T dividend)
		{
			Vector<T> result = Build.SameAs(this);
			DoRemainderByThis(dividend, result);
			return result;
		}

		public void RemainderByThis(T dividend, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoRemainderByThis(dividend, result);
		}

		public Vector<T> PointwiseMultiply(Vector<T> other)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			Vector<T> result = Build.SameAs(this, other);
			DoPointwiseMultiply(other, result);
			return result;
		}

		public void PointwiseMultiply(Vector<T> other, Vector<T> result)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseMultiply(other, result);
		}

		public Vector<T> PointwiseDivide(Vector<T> divisor)
		{
			if (Count != divisor.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "divisor");
			}
			Vector<T> result = Build.SameAs(this, divisor);
			DoPointwiseDivide(divisor, result);
			return result;
		}

		public void PointwiseDivide(Vector<T> divisor, Vector<T> result)
		{
			if (Count != divisor.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "divisor");
			}
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseDivide(divisor, result);
		}

		public Vector<T> PointwisePower(T exponent)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwisePower(exponent, result);
			return result;
		}

		public void PointwisePower(T exponent, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwisePower(exponent, result);
		}

		public Vector<T> PointwisePower(Vector<T> exponent)
		{
			if (Count != exponent.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "exponent");
			}
			Vector<T> result = Build.SameAs(this);
			DoPointwisePower(exponent, result);
			return result;
		}

		public void PointwisePower(Vector<T> exponent, Vector<T> result)
		{
			if (Count != exponent.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "exponent");
			}
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwisePower(exponent, result);
		}

		public Vector<T> PointwiseModulus(Vector<T> divisor)
		{
			if (Count != divisor.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "divisor");
			}
			Vector<T> result = Build.SameAs(this, divisor);
			DoPointwiseModulus(divisor, result);
			return result;
		}

		public void PointwiseModulus(Vector<T> divisor, Vector<T> result)
		{
			if (Count != divisor.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "divisor");
			}
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseModulus(divisor, result);
		}

		public Vector<T> PointwiseRemainder(Vector<T> divisor)
		{
			if (Count != divisor.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "divisor");
			}
			Vector<T> result = Build.SameAs(this, divisor);
			DoPointwiseRemainder(divisor, result);
			return result;
		}

		public void PointwiseRemainder(Vector<T> divisor, Vector<T> result)
		{
			if (Count != divisor.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "divisor");
			}
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseRemainder(divisor, result);
		}

		protected Vector<T> PointwiseUnary(Action<Vector<T>> f)
		{
			Vector<T> vector = Build.SameAs(this);
			f(vector);
			return vector;
		}

		protected void PointwiseUnary(Action<Vector<T>> f, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			f(result);
		}

		protected Vector<T> PointwiseBinary(Action<T, Vector<T>> f, T other)
		{
			Vector<T> vector = Build.SameAs(this);
			f(other, vector);
			return vector;
		}

		protected void PointwiseBinary(Action<T, Vector<T>> f, T x, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			f(x, result);
		}

		protected Vector<T> PointwiseBinary(Action<Vector<T>, Vector<T>> f, Vector<T> other)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			Vector<T> vector = Build.SameAs(this, other);
			f(other, vector);
			return vector;
		}

		protected void PointwiseBinary(Action<Vector<T>, Vector<T>> f, Vector<T> other, Vector<T> result)
		{
			if (Count != other.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			f(other, result);
		}

		public Vector<T> PointwiseExp()
		{
			return PointwiseUnary(DoPointwiseExp);
		}

		public void PointwiseExp(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseExp, result);
		}

		public Vector<T> PointwiseLog()
		{
			return PointwiseUnary(DoPointwiseLog);
		}

		public void PointwiseLog(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseLog, result);
		}

		public Vector<T> PointwiseAbs()
		{
			return PointwiseUnary(DoPointwiseAbs);
		}

		public void PointwiseAbs(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseAbs, result);
		}

		public Vector<T> PointwiseAcos()
		{
			return PointwiseUnary(DoPointwiseAcos);
		}

		public void PointwiseAcos(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseAcos, result);
		}

		public Vector<T> PointwiseAsin()
		{
			return PointwiseUnary(DoPointwiseAsin);
		}

		public void PointwiseAsin(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseAsin, result);
		}

		public Vector<T> PointwiseAtan()
		{
			return PointwiseUnary(DoPointwiseAtan);
		}

		public void PointwiseAtan(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseAtan, result);
		}

		public Vector<T> PointwiseAtan2(Vector<T> other)
		{
			return PointwiseBinary(DoPointwiseAtan2, other);
		}

		public void PointwiseAtan2(Vector<T> other, Vector<T> result)
		{
			PointwiseBinary(DoPointwiseAtan2, other, result);
		}

		public Vector<T> PointwiseCeiling()
		{
			return PointwiseUnary(DoPointwiseCeiling);
		}

		public void PointwiseCeiling(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseCeiling, result);
		}

		public Vector<T> PointwiseCos()
		{
			return PointwiseUnary(DoPointwiseCos);
		}

		public void PointwiseCos(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseCos, result);
		}

		public Vector<T> PointwiseCosh()
		{
			return PointwiseUnary(DoPointwiseCosh);
		}

		public void PointwiseCosh(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseCosh, result);
		}

		public Vector<T> PointwiseFloor()
		{
			return PointwiseUnary(DoPointwiseFloor);
		}

		public void PointwiseFloor(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseFloor, result);
		}

		public Vector<T> PointwiseLog10()
		{
			return PointwiseUnary(DoPointwiseLog10);
		}

		public void PointwiseLog10(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseLog10, result);
		}

		public Vector<T> PointwiseRound()
		{
			return PointwiseUnary(DoPointwiseRound);
		}

		public void PointwiseRound(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseRound, result);
		}

		public Vector<T> PointwiseSign()
		{
			return PointwiseUnary(DoPointwiseSign);
		}

		public void PointwiseSign(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseSign, result);
		}

		public Vector<T> PointwiseSin()
		{
			return PointwiseUnary(DoPointwiseSin);
		}

		public void PointwiseSin(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseSin, result);
		}

		public Vector<T> PointwiseSinh()
		{
			return PointwiseUnary(DoPointwiseSinh);
		}

		public void PointwiseSinh(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseSinh, result);
		}

		public Vector<T> PointwiseSqrt()
		{
			return PointwiseUnary(DoPointwiseSqrt);
		}

		public void PointwiseSqrt(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseSqrt, result);
		}

		public Vector<T> PointwiseTan()
		{
			return PointwiseUnary(DoPointwiseTan);
		}

		public void PointwiseTan(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseTan, result);
		}

		public Vector<T> PointwiseTanh()
		{
			return PointwiseUnary(DoPointwiseTanh);
		}

		public void PointwiseTanh(Vector<T> result)
		{
			PointwiseUnary(DoPointwiseTanh, result);
		}

		public Matrix<T> OuterProduct(Vector<T> other)
		{
			Matrix<T> result = Matrix<T>.Build.SameAs(this, Count, other.Count);
			DoOuterProduct(other, result);
			return result;
		}

		public void OuterProduct(Vector<T> other, Matrix<T> result)
		{
			if (Count != result.RowCount || other.Count != result.ColumnCount)
			{
				throw new ArgumentException("Matrix dimensions must agree.", "result");
			}
			DoOuterProduct(other, result);
		}

		public static Matrix<T> OuterProduct(Vector<T> u, Vector<T> v)
		{
			return u.OuterProduct(v);
		}

		public Vector<T> PointwiseMinimum(T scalar)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseMinimum(scalar, result);
			return result;
		}

		public void PointwiseMinimum(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseMinimum(scalar, result);
		}

		public Vector<T> PointwiseMaximum(T scalar)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseMaximum(scalar, result);
			return result;
		}

		public void PointwiseMaximum(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseMaximum(scalar, result);
		}

		public Vector<T> PointwiseAbsoluteMinimum(T scalar)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMinimum(scalar, result);
			return result;
		}

		public void PointwiseAbsoluteMinimum(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseAbsoluteMinimum(scalar, result);
		}

		public Vector<T> PointwiseAbsoluteMaximum(T scalar)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMaximum(scalar, result);
			return result;
		}

		public void PointwiseAbsoluteMaximum(T scalar, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseAbsoluteMaximum(scalar, result);
		}

		public Vector<T> PointwiseMinimum(Vector<T> other)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseMinimum(other, result);
			return result;
		}

		public void PointwiseMinimum(Vector<T> other, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseMinimum(other, result);
		}

		public Vector<T> PointwiseMaximum(Vector<T> other)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseMaximum(other, result);
			return result;
		}

		public void PointwiseMaximum(Vector<T> other, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseMaximum(other, result);
		}

		public Vector<T> PointwiseAbsoluteMinimum(Vector<T> other)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMinimum(other, result);
			return result;
		}

		public void PointwiseAbsoluteMinimum(Vector<T> other, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseAbsoluteMinimum(other, result);
		}

		public Vector<T> PointwiseAbsoluteMaximum(Vector<T> other)
		{
			Vector<T> result = Build.SameAs(this);
			DoPointwiseAbsoluteMaximum(other, result);
			return result;
		}

		public void PointwiseAbsoluteMaximum(Vector<T> other, Vector<T> result)
		{
			if (Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "result");
			}
			DoPointwiseAbsoluteMaximum(other, result);
		}

		public abstract double L1Norm();

		public abstract double L2Norm();

		public abstract double InfinityNorm();

		public abstract double Norm(double p);

		public abstract Vector<T> Normalize(double p);

		public abstract T AbsoluteMinimum();

		public abstract int AbsoluteMinimumIndex();

		public abstract T AbsoluteMaximum();

		public abstract int AbsoluteMaximumIndex();

		public T Maximum()
		{
			return At(MaximumIndex());
		}

		public abstract int MaximumIndex();

		public T Minimum()
		{
			return At(MinimumIndex());
		}

		public abstract int MinimumIndex();

		public abstract T Sum();

		public double SumMagnitudes()
		{
			return L1Norm();
		}

		public bool Equals(Vector<T> other)
		{
			if (other != null)
			{
				return Storage.Equals(other.Storage);
			}
			return false;
		}

		public sealed override bool Equals(object obj)
		{
			if (obj is Vector<T> vector)
			{
				return Storage.Equals(vector.Storage);
			}
			return false;
		}

		public sealed override int GetHashCode()
		{
			return Storage.GetHashCode();
		}

		object ICloneable.Clone()
		{
			return Clone();
		}

		int IList<T>.IndexOf(T item)
		{
			for (int i = 0; i < Count; i++)
			{
				if (At(i).Equals(item))
				{
					return i;
				}
			}
			return -1;
		}

		void IList<T>.Insert(int index, T item)
		{
			throw new NotSupportedException();
		}

		void IList<T>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		void ICollection<T>.Add(T item)
		{
			throw new NotSupportedException();
		}

		bool ICollection<T>.Remove(T item)
		{
			throw new NotSupportedException();
		}

		bool ICollection<T>.Contains(T item)
		{
			foreach (T item2 in (IEnumerable<T>)this)
			{
				if (item2.Equals(item))
				{
					return true;
				}
			}
			return false;
		}

		void ICollection<T>.CopyTo(T[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			Storage.CopySubVectorTo(new DenseVectorStorage<T>(array.Length, array), 0, arrayIndex, Count);
		}

		int IList.IndexOf(object value)
		{
			if (!(value is T))
			{
				return -1;
			}
			return ((IList<T>)this).IndexOf((T)value);
		}

		bool IList.Contains(object value)
		{
			if (!(value is T))
			{
				return false;
			}
			return ((ICollection<T>)this).Contains((T)value);
		}

		void IList.Insert(int index, object value)
		{
			throw new NotSupportedException();
		}

		int IList.Add(object value)
		{
			throw new NotSupportedException();
		}

		void IList.Remove(object value)
		{
			throw new NotSupportedException();
		}

		void IList.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (array.Rank != 1)
			{
				throw new ArgumentException("Array must have exactly one dimension (and not be null).", "array");
			}
			Storage.CopySubVectorTo(new DenseVectorStorage<T>(array.Length, (T[])array), 0, index, Count);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return Enumerate().GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return Enumerate().GetEnumerator();
		}

		public virtual string ToTypeString()
		{
			return FormattableString.Invariant($"{GetType().Name} {Count}-{typeof(T).Name}");
		}

		public string[,] ToVectorStringArray(int maxPerColumn, int maxCharactersWidth, int padding, string ellipsis, Func<T, string> formatValue)
		{
			maxPerColumn = Math.Max(maxPerColumn, 3);
			maxCharactersWidth = Math.Max(maxCharactersWidth, 16);
			List<Tuple<int, string[]>> list = new List<Tuple<int, string[]>>();
			int num = 0;
			int i;
			int num2;
			for (i = 0; i < Count; i += num2)
			{
				num2 = Math.Min(maxPerColumn, Count - i);
				Tuple<int, string[]> tuple = FormatCompleteColumn(i, num2, formatValue);
				num += tuple.Item1 + padding;
				if (num > maxCharactersWidth && i > 0)
				{
					break;
				}
				list.Add(tuple);
			}
			if (i < Count)
			{
				string[] item = list[list.Count - 1].Item2;
				item[item.Length - 2] = ellipsis;
				item[item.Length - 1] = formatValue(At(Count - 1));
			}
			int num3 = list[0].Item2.Length;
			int count = list.Count;
			string[,] array = new string[num3, count];
			int num4 = 0;
			foreach (Tuple<int, string[]> item2 in list)
			{
				for (int j = 0; j < item2.Item2.Length; j++)
				{
					array[j, num4] = item2.Item2[j];
				}
				for (int k = item2.Item2.Length; k < num3; k++)
				{
					array[k, num4] = "";
				}
				num4++;
			}
			return array;
		}

		private static string FormatStringArrayToString(string[,] array, string columnSeparator, string rowSeparator)
		{
			int length = array.GetLength(0);
			int length2 = array.GetLength(1);
			int[] array2 = new int[length2];
			for (int i = 0; i < length; i++)
			{
				for (int j = 0; j < length2; j++)
				{
					array2[j] = Math.Max(array2[j], array[i, j].Length);
				}
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int k = 0; k < length; k++)
			{
				stringBuilder.Append(array[k, 0].PadLeft(array2[0]));
				for (int l = 1; l < length2; l++)
				{
					stringBuilder.Append(columnSeparator);
					stringBuilder.Append(array[k, l].PadLeft(array2[l]));
				}
				stringBuilder.Append(rowSeparator);
			}
			return stringBuilder.ToString();
		}

		private Tuple<int, string[]> FormatCompleteColumn(int offset, int height, Func<T, string> formatValue)
		{
			string[] array = new string[height];
			int num = 0;
			for (int i = 0; i < height; i++)
			{
				array[num++] = formatValue(At(offset + i));
			}
			return new Tuple<int, string[]>(array.Max((string x) => x.Length), array);
		}

		public string ToVectorString(int maxPerColumn, int maxCharactersWidth, string ellipsis, string columnSeparator, string rowSeparator, Func<T, string> formatValue)
		{
			return FormatStringArrayToString(ToVectorStringArray(maxPerColumn, maxCharactersWidth, columnSeparator.Length, ellipsis, formatValue), columnSeparator, rowSeparator);
		}

		public string ToVectorString(int maxPerColumn, int maxCharactersWidth, string format = null, IFormatProvider provider = null)
		{
			if (format == null)
			{
				format = "G6";
			}
			return ToVectorString(maxPerColumn, maxCharactersWidth, "..", "  ", Environment.NewLine, (T x) => x.ToString(format, provider));
		}

		public string ToVectorString(string format = null, IFormatProvider provider = null)
		{
			if (format == null)
			{
				format = "G6";
			}
			return ToVectorString(12, 80, "..", "  ", Environment.NewLine, (T x) => x.ToString(format, provider));
		}

		public string ToString(int maxPerColumn, int maxCharactersWidth, string format = null, IFormatProvider provider = null)
		{
			return ToTypeString() + Environment.NewLine + ToVectorString(maxPerColumn, maxCharactersWidth, format, provider);
		}

		public sealed override string ToString()
		{
			return ToTypeString() + Environment.NewLine + ToVectorString();
		}

		public string ToString(string format = null, IFormatProvider formatProvider = null)
		{
			return ToTypeString() + Environment.NewLine + ToVectorString(format, formatProvider);
		}

		protected Vector(VectorStorage<T> storage)
		{
			Storage = storage;
			Count = storage.Length;
		}

		[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
		public T At(int index)
		{
			return Storage.At(index);
		}

		[TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]
		public void At(int index, T value)
		{
			Storage.At(index, value);
		}

		public void Clear()
		{
			Storage.Clear();
		}

		public void ClearSubVector(int index, int count)
		{
			if (count < 1)
			{
				throw new ArgumentOutOfRangeException("count", "Value must be positive.");
			}
			if (index + count > Count || index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			Storage.Clear(index, count);
		}

		public abstract void CoerceZero(double threshold);

		public void CoerceZero(Func<T, bool> zeroPredicate)
		{
			MapInplace((T x) => (!zeroPredicate(x)) ? x : Zero);
		}

		public Vector<T> Clone()
		{
			Vector<T> vector = Build.SameAs(this);
			Storage.CopyToUnchecked(vector.Storage, ExistingData.AssumeZeros);
			return vector;
		}

		public void SetValues(T[] values)
		{
			new DenseVectorStorage<T>(Count, values).CopyTo(Storage);
		}

		public void CopyTo(Vector<T> target)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			Storage.CopyTo(target.Storage);
		}

		public Vector<T> SubVector(int index, int count)
		{
			Vector<T> vector = Build.SameAs(this, count);
			Storage.CopySubVectorTo(vector.Storage, index, 0, count, ExistingData.AssumeZeros);
			return vector;
		}

		public void SetSubVector(int index, int count, Vector<T> subVector)
		{
			if (subVector == null)
			{
				throw new ArgumentNullException("subVector");
			}
			subVector.Storage.CopySubVectorTo(Storage, 0, index, count);
		}

		public void CopySubVectorTo(Vector<T> destination, int sourceIndex, int targetIndex, int count)
		{
			if (destination == null)
			{
				throw new ArgumentNullException("destination");
			}
			Storage.CopySubVectorTo(destination.Storage, sourceIndex, targetIndex, count);
		}

		public T[] ToArray()
		{
			return Storage.ToArray();
		}

		public T[] AsArray()
		{
			return Storage.AsArray();
		}

		public Matrix<T> ToColumnMatrix()
		{
			Matrix<T> matrix = Matrix<T>.Build.SameAs(this, Count, 1);
			Storage.CopyToColumnUnchecked(matrix.Storage, 0, ExistingData.AssumeZeros);
			return matrix;
		}

		public Matrix<T> ToRowMatrix()
		{
			Matrix<T> matrix = Matrix<T>.Build.SameAs(this, 1, Count);
			Storage.CopyToRowUnchecked(matrix.Storage, 0, ExistingData.AssumeZeros);
			return matrix;
		}

		public IEnumerable<T> Enumerate()
		{
			return Storage.Enumerate();
		}

		public IEnumerable<T> Enumerate(Zeros zeros = Zeros.Include)
		{
			if (zeros == Zeros.AllowSkip)
			{
				return Storage.EnumerateNonZero();
			}
			return Storage.Enumerate();
		}

		public IEnumerable<Tuple<int, T>> EnumerateIndexed()
		{
			return Storage.EnumerateIndexed();
		}

		public IEnumerable<Tuple<int, T>> EnumerateIndexed(Zeros zeros = Zeros.Include)
		{
			if (zeros == Zeros.AllowSkip)
			{
				return Storage.EnumerateNonZeroIndexed();
			}
			return Storage.EnumerateIndexed();
		}

		public void MapInplace(Func<T, T> f, Zeros zeros = Zeros.AllowSkip)
		{
			Storage.MapInplace(f, zeros);
		}

		public void MapIndexedInplace(Func<int, T, T> f, Zeros zeros = Zeros.AllowSkip)
		{
			Storage.MapIndexedInplace(f, zeros);
		}

		public void Map(Func<T, T> f, Vector<T> result, Zeros zeros = Zeros.AllowSkip)
		{
			if (this == result)
			{
				Storage.MapInplace(f, zeros);
			}
			else
			{
				Storage.MapTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
			}
		}

		public void MapIndexed(Func<int, T, T> f, Vector<T> result, Zeros zeros = Zeros.AllowSkip)
		{
			if (this == result)
			{
				Storage.MapIndexedInplace(f, zeros);
			}
			else
			{
				Storage.MapIndexedTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
			}
		}

		public void MapConvert<TU>(Func<T, TU> f, Vector<TU> result, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Storage.MapTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
		}

		public void MapIndexedConvert<TU>(Func<int, T, TU> f, Vector<TU> result, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Storage.MapIndexedTo(result.Storage, f, zeros, (zeros == Zeros.Include) ? ExistingData.AssumeZeros : ExistingData.Clear);
		}

		public Vector<TU> Map<TU>(Func<T, TU> f, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Vector<TU> vector = Vector<TU>.Build.SameAs(this);
			Storage.MapToUnchecked(vector.Storage, f, zeros, ExistingData.AssumeZeros);
			return vector;
		}

		public Vector<TU> MapIndexed<TU>(Func<int, T, TU> f, Zeros zeros = Zeros.AllowSkip) where TU : struct, IEquatable<TU>, IFormattable
		{
			Vector<TU> vector = Vector<TU>.Build.SameAs(this);
			Storage.MapIndexedToUnchecked(vector.Storage, f, zeros, ExistingData.AssumeZeros);
			return vector;
		}

		public void Map2(Func<T, T, T> f, Vector<T> other, Vector<T> result, Zeros zeros = Zeros.AllowSkip)
		{
			Storage.Map2To(result.Storage, other.Storage, f, zeros, ExistingData.Clear);
		}

		public Vector<T> Map2(Func<T, T, T> f, Vector<T> other, Zeros zeros = Zeros.AllowSkip)
		{
			Vector<T> vector = Build.SameAs(this);
			Storage.Map2To(vector.Storage, other.Storage, f, zeros, ExistingData.AssumeZeros);
			return vector;
		}

		public TState Fold2<TOther, TState>(Func<TState, T, TOther, TState> f, TState state, Vector<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Fold2(other.Storage, f, state, zeros);
		}

		public Tuple<int, T> Find(Func<T, bool> predicate, Zeros zeros = Zeros.AllowSkip)
		{
			return Storage.Find(predicate, zeros);
		}

		public Tuple<int, T, TOther> Find2<TOther>(Func<T, TOther, bool> predicate, Vector<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Find2(other.Storage, predicate, zeros);
		}

		public bool Exists(Func<T, bool> predicate, Zeros zeros = Zeros.AllowSkip)
		{
			return Storage.Find(predicate, zeros) != null;
		}

		public bool Exists2<TOther>(Func<T, TOther, bool> predicate, Vector<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Find2(other.Storage, predicate, zeros) != null;
		}

		public bool ForAll(Func<T, bool> predicate, Zeros zeros = Zeros.AllowSkip)
		{
			return Storage.Find((T x) => !predicate(x), zeros) == null;
		}

		public bool ForAll2<TOther>(Func<T, TOther, bool> predicate, Vector<TOther> other, Zeros zeros = Zeros.AllowSkip) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			return Storage.Find2(other.Storage, (T x, TOther y) => !predicate(x, y), zeros) == null;
		}

		public static Vector<T>operator +(Vector<T> rightSide)
		{
			return rightSide.Clone();
		}

		public static Vector<T>operator -(Vector<T> rightSide)
		{
			return rightSide.Negate();
		}

		public static Vector<T>operator +(Vector<T> leftSide, Vector<T> rightSide)
		{
			return leftSide.Add(rightSide);
		}

		public static Vector<T>operator +(Vector<T> leftSide, T rightSide)
		{
			return leftSide.Add(rightSide);
		}

		public static Vector<T>operator +(T leftSide, Vector<T> rightSide)
		{
			return rightSide.Add(leftSide);
		}

		public static Vector<T>operator -(Vector<T> leftSide, Vector<T> rightSide)
		{
			return leftSide.Subtract(rightSide);
		}

		public static Vector<T>operator -(Vector<T> leftSide, T rightSide)
		{
			return leftSide.Subtract(rightSide);
		}

		public static Vector<T>operator -(T leftSide, Vector<T> rightSide)
		{
			return rightSide.SubtractFrom(leftSide);
		}

		public static Vector<T>operator *(Vector<T> leftSide, T rightSide)
		{
			return leftSide.Multiply(rightSide);
		}

		public static Vector<T>operator *(T leftSide, Vector<T> rightSide)
		{
			return rightSide.Multiply(leftSide);
		}

		public static T operator *(Vector<T> leftSide, Vector<T> rightSide)
		{
			return leftSide.DotProduct(rightSide);
		}

		public static Vector<T>operator /(T dividend, Vector<T> divisor)
		{
			return divisor.DivideByThis(dividend);
		}

		public static Vector<T>operator /(Vector<T> dividend, T divisor)
		{
			return dividend.Divide(divisor);
		}

		public static Vector<T>operator /(Vector<T> dividend, Vector<T> divisor)
		{
			return dividend.PointwiseDivide(divisor);
		}

		public static Vector<T>operator %(Vector<T> dividend, T divisor)
		{
			return dividend.Remainder(divisor);
		}

		public static Vector<T>operator %(T dividend, Vector<T> divisor)
		{
			return divisor.RemainderByThis(dividend);
		}

		public static Vector<T>operator %(Vector<T> dividend, Vector<T> divisor)
		{
			return dividend.PointwiseRemainder(divisor);
		}

		[SpecialName]
		public static Vector<T> op_DotMultiply(Vector<T> x, Vector<T> y)
		{
			return x.PointwiseMultiply(y);
		}

		[SpecialName]
		public static Vector<T> op_DotDivide(Vector<T> dividend, Vector<T> divisor)
		{
			return dividend.PointwiseDivide(divisor);
		}

		[SpecialName]
		public static Vector<T> op_DotPercent(Vector<T> dividend, Vector<T> divisor)
		{
			return dividend.PointwiseRemainder(divisor);
		}

		[SpecialName]
		public static Vector<T> op_DotHat(Vector<T> vector, Vector<T> exponent)
		{
			return vector.PointwisePower(exponent);
		}

		[SpecialName]
		public static Vector<T> op_DotHat(Vector<T> vector, T exponent)
		{
			return vector.PointwisePower(exponent);
		}

		public static Vector<T> Sqrt(Vector<T> x)
		{
			return x.PointwiseSqrt();
		}

		public static Vector<T> Exp(Vector<T> x)
		{
			return x.PointwiseUnary(x.DoPointwiseExp);
		}

		public static Vector<T> Log(Vector<T> x)
		{
			return x.PointwiseUnary(x.PointwiseLog);
		}

		public static Vector<T> Log10(Vector<T> x)
		{
			return x.PointwiseLog10();
		}

		public static Vector<T> Sin(Vector<T> x)
		{
			return x.PointwiseSin();
		}

		public static Vector<T> Cos(Vector<T> x)
		{
			return x.PointwiseCos();
		}

		public static Vector<T> Tan(Vector<T> x)
		{
			return x.PointwiseTan();
		}

		public static Vector<T> Asin(Vector<T> x)
		{
			return x.PointwiseAsin();
		}

		public static Vector<T> Acos(Vector<T> x)
		{
			return x.PointwiseAcos();
		}

		public static Vector<T> Atan(Vector<T> x)
		{
			return x.PointwiseAtan();
		}

		public static Vector<T> Sinh(Vector<T> x)
		{
			return x.PointwiseSinh();
		}

		public static Vector<T> Cosh(Vector<T> x)
		{
			return x.PointwiseCosh();
		}

		public static Vector<T> Tanh(Vector<T> x)
		{
			return x.PointwiseTanh();
		}

		public static Vector<T> Abs(Vector<T> x)
		{
			return x.PointwiseAbs();
		}

		public static Vector<T> Floor(Vector<T> x)
		{
			return x.PointwiseFloor();
		}

		public static Vector<T> Ceiling(Vector<T> x)
		{
			return x.PointwiseCeiling();
		}

		public static Vector<T> Round(Vector<T> x)
		{
			return x.PointwiseRound();
		}
	}
	public static class VectorExtensions
	{
		public static Vector<float> ToSingle(this Vector<double> vector)
		{
			return vector.Map((double x) => (float)x);
		}

		public static Vector<double> ToDouble(this Vector<float> vector)
		{
			return vector.Map((Func<float, double>)((float x) => x), Zeros.AllowSkip);
		}

		public static Vector<MathNet.Numerics.Complex32> ToComplex32(this Vector<System.Numerics.Complex> vector)
		{
			return vector.Map((System.Numerics.Complex x) => new MathNet.Numerics.Complex32((float)x.Real, (float)x.Imaginary));
		}

		public static Vector<System.Numerics.Complex> ToComplex(this Vector<MathNet.Numerics.Complex32> vector)
		{
			return vector.Map((MathNet.Numerics.Complex32 x) => new System.Numerics.Complex(x.Real, x.Imaginary));
		}

		public static Vector<MathNet.Numerics.Complex32> ToComplex32(this Vector<float> vector)
		{
			return vector.Map((float x) => new MathNet.Numerics.Complex32(x, 0f));
		}

		public static Vector<System.Numerics.Complex> ToComplex(this Vector<double> vector)
		{
			return vector.Map((double x) => new System.Numerics.Complex(x, 0.0));
		}

		public static Vector<double> Real(this Vector<System.Numerics.Complex> vector)
		{
			return vector.Map((System.Numerics.Complex x) => x.Real);
		}

		public static Vector<float> Real(this Vector<MathNet.Numerics.Complex32> vector)
		{
			return vector.Map((MathNet.Numerics.Complex32 x) => x.Real);
		}

		public static Vector<double> Imaginary(this Vector<System.Numerics.Complex> vector)
		{
			return vector.Map((System.Numerics.Complex x) => x.Imaginary);
		}

		public static Vector<float> Imaginary(this Vector<MathNet.Numerics.Complex32> vector)
		{
			return vector.Map((MathNet.Numerics.Complex32 x) => x.Imaginary);
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Storage
{
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public class DenseColumnMajorMatrixStorage<T> : MatrixStorage<T> where T : struct, IEquatable<T>, IFormattable
	{
		[DataMember(Order = 1)]
		public readonly T[] Data;

		public override bool IsDense => true;

		public override bool IsFullyMutable => true;

		internal DenseColumnMajorMatrixStorage(int rows, int columns)
			: base(rows, columns)
		{
			Data = new T[rows * columns];
		}

		internal DenseColumnMajorMatrixStorage(int rows, int columns, T[] data)
			: base(rows, columns)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (data.Length != rows * columns)
			{
				throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows * columns}.");
			}
			Data = data;
		}

		public override bool IsMutableAt(int row, int column)
		{
			return true;
		}

		public override T At(int row, int column)
		{
			return Data[column * RowCount + row];
		}

		public override void At(int row, int column, T value)
		{
			Data[column * RowCount + row] = value;
		}

		private void RowColumnAtIndex(int index, out int row, out int column)
		{
			column = Math.DivRem(index, RowCount, out row);
		}

		public override void Clear()
		{
			Array.Clear(Data, 0, Data.Length);
		}

		internal override void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			if (rowIndex == 0 && columnIndex == 0 && rowCount == RowCount && columnCount == ColumnCount)
			{
				Array.Clear(Data, 0, Data.Length);
				return;
			}
			for (int i = columnIndex; i < columnIndex + columnCount; i++)
			{
				Array.Clear(Data, i * RowCount + rowIndex, rowCount);
			}
		}

		internal override void ClearRowsUnchecked(int[] rowIndices)
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				int num = i * RowCount;
				for (int j = 0; j < rowIndices.Length; j++)
				{
					Data[num + rowIndices[j]] = MatrixStorage<T>.Zero;
				}
			}
		}

		internal override void ClearColumnsUnchecked(int[] columnIndices)
		{
			for (int i = 0; i < columnIndices.Length; i++)
			{
				Array.Clear(Data, columnIndices[i] * RowCount, RowCount);
			}
		}

		public static DenseColumnMajorMatrixStorage<T> OfMatrix(MatrixStorage<T> matrix)
		{
			DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage = new DenseColumnMajorMatrixStorage<T>(matrix.RowCount, matrix.ColumnCount);
			matrix.CopyToUnchecked(denseColumnMajorMatrixStorage, ExistingData.AssumeZeros);
			return denseColumnMajorMatrixStorage;
		}

		public static DenseColumnMajorMatrixStorage<T> OfValue(int rows, int columns, T value)
		{
			DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage = new DenseColumnMajorMatrixStorage<T>(rows, columns);
			T[] data = denseColumnMajorMatrixStorage.Data;
			CommonParallel.For(0, data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					data[i] = value;
				}
			});
			return denseColumnMajorMatrixStorage;
		}

		public static DenseColumnMajorMatrixStorage<T> OfInit(int rows, int columns, Func<int, int, T> init)
		{
			DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage = new DenseColumnMajorMatrixStorage<T>(rows, columns);
			int num = 0;
			for (int i = 0; i < columns; i++)
			{
				for (int j = 0; j < rows; j++)
				{
					denseColumnMajorMatrixStorage.Data[num++] = init(j, i);
				}
			}
			return denseColumnMajorMatrixStorage;
		}

		public static DenseColumnMajorMatrixStorage<T> OfDiagonalInit(int rows, int columns, Func<int, T> init)
		{
			DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage = new DenseColumnMajorMatrixStorage<T>(rows, columns);
			int num = 0;
			int num2 = rows + 1;
			for (int i = 0; i < Math.Min(rows, columns); i++)
			{
				denseColumnMajorMatrixStorage.Data[num] = init(i);
				num += num2;
			}
			return denseColumnMajorMatrixStorage;
		}

		public static DenseColumnMajorMatrixStorage<T> OfArray(T[,] array)
		{
			DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage = new DenseColumnMajorMatrixStorage<T>(array.GetLength(0), array.GetLength(1));
			int num = 0;
			for (int i = 0; i < denseColumnMajorMatrixStorage.ColumnCount; i++)
			{
				for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
				{
					denseColumnMajorMatrixStorage.Data[num++] = array[j, i];
				}
			}
			return denseColumnMajorMatrixStorage;
		}

		public static DenseColumnMajorMatrixStorage<T> OfColumnArrays(T[][] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			int num = data.Length;
			int num2 = data[0].Length;
			T[] array = new T[num2 * num];
			for (int i = 0; i < data.Length; i++)
			{
				Array.Copy(data[i], 0, array, i * num2, num2);
			}
			return new DenseColumnMajorMatrixStorage<T>(num2, num, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfRowArrays(T[][] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			int num = data.Length;
			int num2 = data[0].Length;
			T[] array = new T[num * num2];
			for (int i = 0; i < num2; i++)
			{
				int num3 = i * num;
				for (int j = 0; j < num; j++)
				{
					array[num3 + j] = data[j][i];
				}
			}
			return new DenseColumnMajorMatrixStorage<T>(num, num2, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfColumnMajorArray(int rows, int columns, T[] data)
		{
			T[] array = new T[rows * columns];
			Array.Copy(data, 0, array, 0, Math.Min(array.Length, data.Length));
			return new DenseColumnMajorMatrixStorage<T>(rows, columns, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfRowMajorArray(int rows, int columns, T[] data)
		{
			T[] array = new T[rows * columns];
			for (int i = 0; i < rows; i++)
			{
				int num = i * columns;
				for (int j = 0; j < columns; j++)
				{
					array[j * rows + i] = data[num + j];
				}
			}
			return new DenseColumnMajorMatrixStorage<T>(rows, columns, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfColumnVectors(VectorStorage<T>[] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			int num = data.Length;
			int length = data[0].Length;
			T[] array = new T[length * num];
			for (int i = 0; i < data.Length; i++)
			{
				VectorStorage<T> vectorStorage = data[i];
				if (vectorStorage is DenseVectorStorage<T> denseVectorStorage)
				{
					Array.Copy(denseVectorStorage.Data, 0, array, i * length, length);
					continue;
				}
				int num2 = i * length;
				for (int j = 0; j < length; j++)
				{
					array[num2 + j] = vectorStorage.At(j);
				}
			}
			return new DenseColumnMajorMatrixStorage<T>(length, num, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfRowVectors(VectorStorage<T>[] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			int num = data.Length;
			int length = data[0].Length;
			T[] array = new T[num * length];
			for (int i = 0; i < length; i++)
			{
				int num2 = i * num;
				for (int j = 0; j < num; j++)
				{
					array[num2 + j] = data[j].At(i);
				}
			}
			return new DenseColumnMajorMatrixStorage<T>(num, length, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfIndexedEnumerable(int rows, int columns, IEnumerable<Tuple<int, int, T>> data)
		{
			T[] array = new T[rows * columns];
			foreach (Tuple<int, int, T> datum in data)
			{
				array[datum.Item2 * rows + datum.Item1] = datum.Item3;
			}
			return new DenseColumnMajorMatrixStorage<T>(rows, columns, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfColumnMajorEnumerable(int rows, int columns, IEnumerable<T> data)
		{
			if (data is T[] data2)
			{
				return OfColumnMajorArray(rows, columns, data2);
			}
			return new DenseColumnMajorMatrixStorage<T>(rows, columns, data.ToArray());
		}

		public static DenseColumnMajorMatrixStorage<T> OfRowMajorEnumerable(int rows, int columns, IEnumerable<T> data)
		{
			return OfRowMajorArray(rows, columns, (data as T[]) ?? data.ToArray());
		}

		public static DenseColumnMajorMatrixStorage<T> OfColumnEnumerables(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			T[] array = new T[rows * columns];
			using (IEnumerator<IEnumerable<T>> enumerator = data.GetEnumerator())
			{
				for (int i = 0; i < columns; i++)
				{
					if (!enumerator.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
					}
					if (enumerator.Current is T[] sourceArray)
					{
						Array.Copy(sourceArray, 0, array, i * rows, rows);
						continue;
					}
					using IEnumerator<T> enumerator2 = enumerator.Current.GetEnumerator();
					int num = (i + 1) * rows;
					for (int j = i * rows; j < num; j++)
					{
						if (!enumerator2.MoveNext())
						{
							throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
						}
						array[j] = enumerator2.Current;
					}
					if (enumerator2.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
					}
				}
				if (enumerator.MoveNext())
				{
					throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
				}
			}
			return new DenseColumnMajorMatrixStorage<T>(rows, columns, array);
		}

		public static DenseColumnMajorMatrixStorage<T> OfRowEnumerables(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			T[] array = new T[rows * columns];
			using (IEnumerator<IEnumerable<T>> enumerator = data.GetEnumerator())
			{
				for (int i = 0; i < rows; i++)
				{
					if (!enumerator.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
					}
					using IEnumerator<T> enumerator2 = enumerator.Current.GetEnumerator();
					for (int j = i; j < array.Length; j += rows)
					{
						if (!enumerator2.MoveNext())
						{
							throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
						}
						array[j] = enumerator2.Current;
					}
					if (enumerator2.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
					}
				}
				if (enumerator.MoveNext())
				{
					throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
				}
			}
			return new DenseColumnMajorMatrixStorage<T>(rows, columns, array);
		}

		internal override void CopyToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> target2)
			{
				CopyToUnchecked(target2);
				return;
			}
			int num = 0;
			int num2 = 0;
			while (num < ColumnCount)
			{
				for (int i = 0; i < RowCount; i++)
				{
					target.At(i, num, Data[i + num2]);
				}
				num++;
				num2 += RowCount;
			}
		}

		private void CopyToUnchecked(DenseColumnMajorMatrixStorage<T> target)
		{
			Array.Copy(Data, 0, target.Data, 0, Data.Length);
		}

		internal override void CopySubMatrixToUnchecked(MatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> target2)
			{
				CopySubMatrixToUnchecked(target2, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);
				return;
			}
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				int num3 = sourceRowIndex + num * RowCount;
				for (int i = targetRowIndex; i < targetRowIndex + rowCount; i++)
				{
					target.At(i, num2, Data[num3++]);
				}
				num++;
				num2++;
			}
		}

		private void CopySubMatrixToUnchecked(DenseColumnMajorMatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount)
		{
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				Array.Copy(Data, num * RowCount + sourceRowIndex, target.Data, num2 * target.RowCount + targetRowIndex, rowCount);
				num++;
				num2++;
			}
		}

		internal override void CopySubRowToUnchecked(VectorStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (target is DenseVectorStorage<T> denseVectorStorage)
			{
				for (int i = 0; i < columnCount; i++)
				{
					denseVectorStorage.Data[i + targetColumnIndex] = Data[(i + sourceColumnIndex) * RowCount + rowIndex];
				}
				return;
			}
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				target.At(num2, Data[num * RowCount + rowIndex]);
				num++;
				num2++;
			}
		}

		internal override void CopySubColumnToUnchecked(VectorStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData)
		{
			if (target is DenseVectorStorage<T> denseVectorStorage)
			{
				Array.Copy(Data, columnIndex * RowCount + sourceRowIndex, denseVectorStorage.Data, targetRowIndex, rowCount);
				return;
			}
			int num = columnIndex * RowCount;
			int num2 = sourceRowIndex;
			int num3 = targetRowIndex;
			while (num2 < sourceRowIndex + rowCount)
			{
				target.At(num3, Data[num + num2]);
				num2++;
				num3++;
			}
		}

		internal override void TransposeToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> target2)
			{
				TransposeToUnchecked(target2);
				return;
			}
			if (target is SparseCompressedRowMatrixStorage<T> target3)
			{
				TransposeToUnchecked(target3);
				return;
			}
			int num = 0;
			int num2 = 0;
			while (num < ColumnCount)
			{
				for (int i = 0; i < RowCount; i++)
				{
					target.At(num, i, Data[i + num2]);
				}
				num++;
				num2 += RowCount;
			}
		}

		private void TransposeToUnchecked(DenseColumnMajorMatrixStorage<T> target)
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				int num = i * RowCount;
				for (int j = 0; j < RowCount; j++)
				{
					target.Data[j * ColumnCount + i] = Data[num + j];
				}
			}
		}

		private void TransposeToUnchecked(SparseCompressedRowMatrixStorage<T> target)
		{
			int[] rowPointers = target.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < ColumnCount; i++)
			{
				rowPointers[i] = list2.Count;
				int num = i * RowCount;
				for (int j = 0; j < RowCount; j++)
				{
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(Data[num + j]))
					{
						list2.Add(Data[num + j]);
						list.Add(j);
					}
				}
			}
			rowPointers[ColumnCount] = list2.Count;
			target.ColumnIndices = list.ToArray();
			target.Values = list2.ToArray();
		}

		internal override void TransposeSquareInplaceUnchecked()
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				int num = i * RowCount;
				for (int j = 0; j < i; j++)
				{
					T val = Data[num + j];
					Data[num + j] = Data[j * ColumnCount + i];
					Data[j * ColumnCount + i] = val;
				}
			}
		}

		public override T[] ToRowMajorArray()
		{
			T[] array = new T[Data.Length];
			for (int i = 0; i < RowCount; i++)
			{
				int num = i * ColumnCount;
				for (int j = 0; j < ColumnCount; j++)
				{
					array[num + j] = Data[j * RowCount + i];
				}
			}
			return array;
		}

		public override T[] ToColumnMajorArray()
		{
			T[] array = new T[Data.Length];
			Array.Copy(Data, 0, array, 0, Data.Length);
			return array;
		}

		public override T[][] ToRowArrays()
		{
			T[][] ret = new T[RowCount][];
			CommonParallel.For(0, RowCount, Math.Max(4096 / ColumnCount, 32), delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					T[] array = new T[ColumnCount];
					for (int j = 0; j < ColumnCount; j++)
					{
						array[j] = Data[j * RowCount + i];
					}
					ret[i] = array;
				}
			});
			return ret;
		}

		public override T[][] ToColumnArrays()
		{
			T[][] ret = new T[ColumnCount][];
			CommonParallel.For(0, ColumnCount, Math.Max(4096 / RowCount, 32), delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					T[] array = new T[RowCount];
					Array.Copy(Data, i * RowCount, array, 0, RowCount);
					ret[i] = array;
				}
			});
			return ret;
		}

		public override T[,] ToArray()
		{
			T[,] array = new T[RowCount, ColumnCount];
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					array[i, j] = Data[j * RowCount + i];
				}
			}
			return array;
		}

		public override T[] AsColumnMajorArray()
		{
			return Data;
		}

		public override IEnumerable<T> Enumerate()
		{
			return Data;
		}

		public override IEnumerable<Tuple<int, int, T>> EnumerateIndexed()
		{
			int index = 0;
			for (int j = 0; j < ColumnCount; j++)
			{
				for (int i = 0; i < RowCount; i++)
				{
					yield return new Tuple<int, int, T>(i, j, Data[index]);
					index++;
				}
			}
		}

		public override IEnumerable<T> EnumerateNonZero()
		{
			return Data.Where(delegate(T x)
			{
				T zero = MatrixStorage<T>.Zero;
				return !zero.Equals(x);
			});
		}

		public override IEnumerable<Tuple<int, int, T>> EnumerateNonZeroIndexed()
		{
			int index = 0;
			for (int j = 0; j < ColumnCount; j++)
			{
				for (int i = 0; i < RowCount; i++)
				{
					T val = Data[index];
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						yield return new Tuple<int, int, T>(i, j, val);
					}
					index++;
				}
			}
		}

		public override Tuple<int, int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < Data.Length; i++)
			{
				if (predicate(Data[i]))
				{
					RowColumnAtIndex(i, out var row, out var column);
					return new Tuple<int, int, T>(row, column, Data[i]);
				}
			}
			return null;
		}

		internal override Tuple<int, int, T, TOther> Find2Unchecked<TOther>(MatrixStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros)
		{
			if (other is DenseColumnMajorMatrixStorage<TOther> denseColumnMajorMatrixStorage)
			{
				TOther[] data = denseColumnMajorMatrixStorage.Data;
				for (int i = 0; i < Data.Length; i++)
				{
					if (predicate(Data[i], data[i]))
					{
						RowColumnAtIndex(i, out var row, out var column);
						return new Tuple<int, int, T, TOther>(row, column, Data[i], data[i]);
					}
				}
				return null;
			}
			if (other is DiagonalMatrixStorage<TOther> diagonalMatrixStorage)
			{
				TOther[] data2 = diagonalMatrixStorage.Data;
				TOther zero = BuilderInstance<TOther>.Matrix.Zero;
				int num = 0;
				for (int j = 0; j < ColumnCount; j++)
				{
					for (int k = 0; k < RowCount; k++)
					{
						if (predicate(Data[num], (k == j) ? data2[k] : zero))
						{
							return new Tuple<int, int, T, TOther>(k, j, Data[num], (k == j) ? data2[k] : zero);
						}
						num++;
					}
				}
				return null;
			}
			if (other is SparseCompressedRowMatrixStorage<TOther> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
				TOther[] values = sparseCompressedRowMatrixStorage.Values;
				TOther zero2 = BuilderInstance<TOther>.Matrix.Zero;
				int num2 = 0;
				for (int l = 0; l < RowCount; l++)
				{
					for (int m = 0; m < ColumnCount; m++)
					{
						if (num2 < rowPointers[l + 1] && columnIndices[num2] == m)
						{
							if (predicate(Data[m * RowCount + l], values[num2]))
							{
								return new Tuple<int, int, T, TOther>(l, m, Data[m * RowCount + l], values[num2]);
							}
							num2++;
						}
						else if (predicate(Data[m * RowCount + l], zero2))
						{
							return new Tuple<int, int, T, TOther>(l, m, Data[m * RowCount + l], values[num2]);
						}
					}
				}
				return null;
			}
			return base.Find2Unchecked(other, predicate, zeros);
		}

		public override void MapInplace(Func<T, T> f, Zeros zeros)
		{
			CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					Data[i] = f(Data[i]);
				}
			});
		}

		public override void MapIndexedInplace(Func<int, int, T, T> f, Zeros zeros)
		{
			CommonParallel.For(0, ColumnCount, Math.Max(4096 / RowCount, 32), delegate(int a, int b)
			{
				int num = a * RowCount;
				for (int i = a; i < b; i++)
				{
					for (int j = 0; j < RowCount; j++)
					{
						Data[num] = f(j, i, Data[num]);
						num++;
					}
				}
			});
		}

		internal override void MapToUnchecked<TU>(MatrixStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData)
		{
			DenseColumnMajorMatrixStorage<TU> denseTarget = target as DenseColumnMajorMatrixStorage<TU>;
			if (denseTarget != null)
			{
				CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
				{
					for (int k = a; k < b; k++)
					{
						denseTarget.Data[k] = f(Data[k]);
					}
				});
				return;
			}
			int num = 0;
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < RowCount; j++)
				{
					target.At(j, i, f(Data[num++]));
				}
			}
		}

		internal override void MapIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, Zeros zeros, ExistingData existingData)
		{
			DenseColumnMajorMatrixStorage<TU> denseTarget = target as DenseColumnMajorMatrixStorage<TU>;
			if (denseTarget != null)
			{
				CommonParallel.For(0, ColumnCount, Math.Max(4096 / RowCount, 32), delegate(int a, int b)
				{
					int num2 = a * RowCount;
					for (int k = a; k < b; k++)
					{
						for (int l = 0; l < RowCount; l++)
						{
							denseTarget.Data[num2] = f(l, k, Data[num2]);
							num2++;
						}
					}
				});
				return;
			}
			int num = 0;
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < RowCount; j++)
				{
					target.At(j, i, f(j, i, Data[num++]));
				}
			}
		}

		internal override void MapSubMatrixIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData)
		{
			DenseColumnMajorMatrixStorage<TU> denseTarget = target as DenseColumnMajorMatrixStorage<TU>;
			if (denseTarget != null)
			{
				CommonParallel.For(0, columnCount, Math.Max(4096 / rowCount, 32), delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						int num4 = sourceRowIndex + (j + sourceColumnIndex) * RowCount;
						int num5 = targetRowIndex + (j + targetColumnIndex) * target.RowCount;
						for (int k = 0; k < rowCount; k++)
						{
							denseTarget.Data[num5++] = f(targetRowIndex + k, targetColumnIndex + j, Data[num4++]);
						}
					}
				});
				return;
			}
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				int num3 = sourceRowIndex + num * RowCount;
				for (int i = targetRowIndex; i < targetRowIndex + rowCount; i++)
				{
					target.At(i, num2, f(i, num2, Data[num3++]));
				}
				num++;
				num2++;
			}
		}

		internal override void FoldByRowUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			for (int i = 0; i < RowCount; i++)
			{
				TU arg = state[i];
				for (int j = 0; j < ColumnCount; j++)
				{
					arg = f(arg, Data[j * RowCount + i]);
				}
				target[i] = finalize(arg, ColumnCount);
			}
		}

		internal override void FoldByColumnUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				int num = i * RowCount;
				TU arg = state[i];
				for (int j = 0; j < RowCount; j++)
				{
					arg = f(arg, Data[num + j]);
				}
				target[i] = finalize(arg, RowCount);
			}
		}

		internal override TState Fold2Unchecked<TOther, TState>(MatrixStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros)
		{
			if (other is DenseColumnMajorMatrixStorage<TOther> denseColumnMajorMatrixStorage)
			{
				TOther[] data = denseColumnMajorMatrixStorage.Data;
				for (int i = 0; i < Data.Length; i++)
				{
					state = f(state, Data[i], data[i]);
				}
				return state;
			}
			if (other is DiagonalMatrixStorage<TOther> diagonalMatrixStorage)
			{
				TOther[] data2 = diagonalMatrixStorage.Data;
				TOther zero = BuilderInstance<TOther>.Matrix.Zero;
				int num = 0;
				for (int j = 0; j < ColumnCount; j++)
				{
					for (int k = 0; k < RowCount; k++)
					{
						state = f(state, Data[num], (k == j) ? data2[k] : zero);
						num++;
					}
				}
				return state;
			}
			if (other is SparseCompressedRowMatrixStorage<TOther> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
				TOther[] values = sparseCompressedRowMatrixStorage.Values;
				TOther zero2 = BuilderInstance<TOther>.Matrix.Zero;
				int num2 = 0;
				for (int l = 0; l < RowCount; l++)
				{
					for (int m = 0; m < ColumnCount; m++)
					{
						state = ((num2 >= rowPointers[l + 1] || columnIndices[num2] != m) ? f(state, Data[m * RowCount + l], zero2) : f(state, Data[m * RowCount + l], values[num2++]));
					}
				}
				return state;
			}
			return base.Fold2Unchecked(other, f, state, zeros);
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public class DenseVectorStorage<T> : VectorStorage<T> where T : struct, IEquatable<T>, IFormattable
	{
		[DataMember(Order = 1)]
		public readonly T[] Data;

		public override bool IsDense => true;

		internal DenseVectorStorage(int length)
			: base(length)
		{
			Data = new T[length];
		}

		internal DenseVectorStorage(int length, T[] data)
			: base(length)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (data.Length != length)
			{
				throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {length}.");
			}
			Data = data;
		}

		public override T At(int index)
		{
			return Data[index];
		}

		public override void At(int index, T value)
		{
			Data[index] = value;
		}

		public override void Clear()
		{
			Array.Clear(Data, 0, Data.Length);
		}

		public override void Clear(int index, int count)
		{
			Array.Clear(Data, index, count);
		}

		public static DenseVectorStorage<T> OfVector(VectorStorage<T> vector)
		{
			DenseVectorStorage<T> denseVectorStorage = new DenseVectorStorage<T>(vector.Length);
			vector.CopyToUnchecked(denseVectorStorage, ExistingData.AssumeZeros);
			return denseVectorStorage;
		}

		public static DenseVectorStorage<T> OfValue(int length, T value)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Value must not be negative (zero is ok).");
			}
			T[] data = new T[length];
			CommonParallel.For(0, data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					data[i] = value;
				}
			});
			return new DenseVectorStorage<T>(length, data);
		}

		public static DenseVectorStorage<T> OfInit(int length, Func<int, T> init)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Value must not be negative (zero is ok).");
			}
			T[] data = new T[length];
			CommonParallel.For(0, data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					data[i] = init(i);
				}
			});
			return new DenseVectorStorage<T>(length, data);
		}

		public static DenseVectorStorage<T> OfEnumerable(IEnumerable<T> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (data is T[] array)
			{
				T[] array2 = new T[array.Length];
				Array.Copy(array, 0, array2, 0, array.Length);
				return new DenseVectorStorage<T>(array2.Length, array2);
			}
			T[] array3 = data.ToArray();
			return new DenseVectorStorage<T>(array3.Length, array3);
		}

		public static DenseVectorStorage<T> OfIndexedEnumerable(int length, IEnumerable<Tuple<int, T>> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			T[] array = new T[length];
			foreach (Tuple<int, T> datum in data)
			{
				array[datum.Item1] = datum.Item2;
			}
			return new DenseVectorStorage<T>(array.Length, array);
		}

		internal override void CopyToUnchecked(VectorStorage<T> target, ExistingData existingData)
		{
			if (target is DenseVectorStorage<T> denseVectorStorage)
			{
				if (this != denseVectorStorage)
				{
					Array.Copy(Data, 0, denseVectorStorage.Data, 0, Data.Length);
				}
			}
			else if (target is SparseVectorStorage<T> sparseVectorStorage)
			{
				List<int> list = new List<int>();
				List<T> list2 = new List<T>();
				for (int i = 0; i < Data.Length; i++)
				{
					T val = Data[i];
					T zero = VectorStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(i);
					}
				}
				sparseVectorStorage.Indices = list.ToArray();
				sparseVectorStorage.Values = list2.ToArray();
				sparseVectorStorage.ValueCount = list2.Count;
			}
			else
			{
				for (int j = 0; j < Data.Length; j++)
				{
					target.At(j, Data[j]);
				}
			}
		}

		internal override void CopyToRowUnchecked(MatrixStorage<T> target, int rowIndex, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage)
			{
				for (int i = 0; i < Data.Length; i++)
				{
					denseColumnMajorMatrixStorage.Data[i * target.RowCount + rowIndex] = Data[i];
				}
			}
			else
			{
				for (int j = 0; j < Length; j++)
				{
					target.At(rowIndex, j, Data[j]);
				}
			}
		}

		internal override void CopyToColumnUnchecked(MatrixStorage<T> target, int columnIndex, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage)
			{
				Array.Copy(Data, 0, denseColumnMajorMatrixStorage.Data, columnIndex * denseColumnMajorMatrixStorage.RowCount, Data.Length);
				return;
			}
			for (int i = 0; i < Length; i++)
			{
				target.At(i, columnIndex, Data[i]);
			}
		}

		internal override void CopySubVectorToUnchecked(VectorStorage<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData)
		{
			if (target is DenseVectorStorage<T> denseVectorStorage)
			{
				Array.Copy(Data, sourceIndex, denseVectorStorage.Data, targetIndex, count);
			}
			else
			{
				base.CopySubVectorToUnchecked(target, sourceIndex, targetIndex, count, existingData);
			}
		}

		internal override void CopyToSubRowUnchecked(MatrixStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage)
			{
				for (int i = 0; i < Data.Length; i++)
				{
					denseColumnMajorMatrixStorage.Data[(i + targetColumnIndex) * target.RowCount + rowIndex] = Data[i + sourceColumnIndex];
				}
				return;
			}
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				target.At(rowIndex, num2, Data[num]);
				num++;
				num2++;
			}
		}

		internal override void CopyToSubColumnUnchecked(MatrixStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> denseColumnMajorMatrixStorage)
			{
				Array.Copy(Data, sourceRowIndex, denseColumnMajorMatrixStorage.Data, columnIndex * denseColumnMajorMatrixStorage.RowCount + targetRowIndex, rowCount);
				return;
			}
			int num = sourceRowIndex;
			int num2 = targetRowIndex;
			while (num < sourceRowIndex + rowCount)
			{
				target.At(num2, columnIndex, Data[num]);
				num++;
				num2++;
			}
		}

		public override T[] ToArray()
		{
			T[] array = new T[Data.Length];
			Array.Copy(Data, 0, array, 0, Data.Length);
			return array;
		}

		public override T[] AsArray()
		{
			return Data;
		}

		public override IEnumerable<T> Enumerate()
		{
			return Data;
		}

		public override IEnumerable<Tuple<int, T>> EnumerateIndexed()
		{
			return Data.Select((T t, int i) => new Tuple<int, T>(i, t));
		}

		public override IEnumerable<T> EnumerateNonZero()
		{
			return Data.Where(delegate(T x)
			{
				T zero = VectorStorage<T>.Zero;
				return !zero.Equals(x);
			});
		}

		public override IEnumerable<Tuple<int, T>> EnumerateNonZeroIndexed()
		{
			for (int i = 0; i < Data.Length; i++)
			{
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(Data[i]))
				{
					yield return new Tuple<int, T>(i, Data[i]);
				}
			}
		}

		public override Tuple<int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < Data.Length; i++)
			{
				if (predicate(Data[i]))
				{
					return new Tuple<int, T>(i, Data[i]);
				}
			}
			return null;
		}

		internal override Tuple<int, T, TOther> Find2Unchecked<TOther>(VectorStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros)
		{
			if (other is DenseVectorStorage<TOther> denseVectorStorage)
			{
				TOther[] data = denseVectorStorage.Data;
				for (int i = 0; i < Data.Length; i++)
				{
					if (predicate(Data[i], data[i]))
					{
						return new Tuple<int, T, TOther>(i, Data[i], data[i]);
					}
				}
				return null;
			}
			if (other is SparseVectorStorage<TOther> sparseVectorStorage)
			{
				int[] indices = sparseVectorStorage.Indices;
				TOther[] values = sparseVectorStorage.Values;
				int valueCount = sparseVectorStorage.ValueCount;
				TOther zero = BuilderInstance<TOther>.Matrix.Zero;
				int num = 0;
				for (int j = 0; j < Data.Length; j++)
				{
					if (num < valueCount && indices[num] == j)
					{
						if (predicate(Data[j], values[num]))
						{
							return new Tuple<int, T, TOther>(j, Data[j], values[num]);
						}
						num++;
					}
					else if (predicate(Data[j], zero))
					{
						return new Tuple<int, T, TOther>(j, Data[j], zero);
					}
				}
				return null;
			}
			return base.Find2Unchecked(other, predicate, zeros);
		}

		public override void MapInplace(Func<T, T> f, Zeros zeros)
		{
			CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					Data[i] = f(Data[i]);
				}
			});
		}

		public override void MapIndexedInplace(Func<int, T, T> f, Zeros zeros)
		{
			CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					Data[i] = f(i, Data[i]);
				}
			});
		}

		internal override void MapToUnchecked<TU>(VectorStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData)
		{
			DenseVectorStorage<TU> denseTarget = target as DenseVectorStorage<TU>;
			if (denseTarget != null)
			{
				CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						denseTarget.Data[j] = f(Data[j]);
					}
				});
			}
			else
			{
				for (int i = 0; i < Length; i++)
				{
					target.At(i, f(Data[i]));
				}
			}
		}

		internal override void MapIndexedToUnchecked<TU>(VectorStorage<TU> target, Func<int, T, TU> f, Zeros zeros, ExistingData existingData)
		{
			DenseVectorStorage<TU> denseTarget = target as DenseVectorStorage<TU>;
			if (denseTarget != null)
			{
				CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						denseTarget.Data[j] = f(j, Data[j]);
					}
				});
			}
			else
			{
				for (int i = 0; i < Length; i++)
				{
					target.At(i, f(i, Data[i]));
				}
			}
		}

		internal override void Map2ToUnchecked(VectorStorage<T> target, VectorStorage<T> other, Func<T, T, T> f, Zeros zeros, ExistingData existingData)
		{
			if (target is SparseVectorStorage<T>)
			{
				DenseVectorStorage<T> denseVectorStorage = new DenseVectorStorage<T>(target.Length);
				Map2ToUnchecked(denseVectorStorage, other, f, zeros, ExistingData.AssumeZeros);
				denseVectorStorage.CopyTo(target, existingData);
				return;
			}
			DenseVectorStorage<T> denseTarget = target as DenseVectorStorage<T>;
			if (denseTarget != null)
			{
				DenseVectorStorage<T> denseOther = other as DenseVectorStorage<T>;
				if (denseOther != null)
				{
					CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
					{
						for (int j = a; j < b; j++)
						{
							denseTarget.Data[j] = f(Data[j], denseOther.Data[j]);
						}
					});
					return;
				}
			}
			if (denseTarget != null && other is SparseVectorStorage<T> sparseVectorStorage)
			{
				T[] data = denseTarget.Data;
				int[] indices = sparseVectorStorage.Indices;
				T[] values = sparseVectorStorage.Values;
				int valueCount = sparseVectorStorage.ValueCount;
				int num = 0;
				for (int i = 0; i < Data.Length; i++)
				{
					if (num < valueCount && indices[num] == i)
					{
						data[i] = f(Data[i], values[num]);
						num++;
					}
					else
					{
						data[i] = f(Data[i], VectorStorage<T>.Zero);
					}
				}
			}
			else
			{
				base.Map2ToUnchecked(target, other, f, zeros, existingData);
			}
		}

		internal override TState Fold2Unchecked<TOther, TState>(VectorStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros)
		{
			if (other is DenseVectorStorage<TOther> denseVectorStorage)
			{
				TOther[] data = denseVectorStorage.Data;
				for (int i = 0; i < Data.Length; i++)
				{
					state = f(state, Data[i], data[i]);
				}
				return state;
			}
			if (other is SparseVectorStorage<TOther> sparseVectorStorage)
			{
				int[] indices = sparseVectorStorage.Indices;
				TOther[] values = sparseVectorStorage.Values;
				int valueCount = sparseVectorStorage.ValueCount;
				TOther zero = BuilderInstance<TOther>.Vector.Zero;
				int num = 0;
				for (int j = 0; j < Data.Length; j++)
				{
					if (num < valueCount && indices[num] == j)
					{
						state = f(state, Data[j], values[num]);
						num++;
					}
					else
					{
						state = f(state, Data[j], zero);
					}
				}
				return state;
			}
			return base.Fold2Unchecked(other, f, state, zeros);
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public class DiagonalMatrixStorage<T> : MatrixStorage<T> where T : struct, IEquatable<T>, IFormattable
	{
		[DataMember(Order = 1)]
		public readonly T[] Data;

		public override bool IsDense => false;

		public override bool IsFullyMutable => false;

		internal DiagonalMatrixStorage(int rows, int columns)
			: base(rows, columns)
		{
			Data = new T[Math.Min(rows, columns)];
		}

		internal DiagonalMatrixStorage(int rows, int columns, T[] data)
			: base(rows, columns)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (data.Length != Math.Min(rows, columns))
			{
				throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {Math.Min(rows, columns)}.");
			}
			Data = data;
		}

		public override bool IsMutableAt(int row, int column)
		{
			return row == column;
		}

		public override T At(int row, int column)
		{
			if (row != column)
			{
				return MatrixStorage<T>.Zero;
			}
			return Data[row];
		}

		public override void At(int row, int column, T value)
		{
			if (row == column)
			{
				Data[row] = value;
				return;
			}
			T zero = MatrixStorage<T>.Zero;
			if (zero.Equals(value))
			{
				return;
			}
			throw new IndexOutOfRangeException("Cannot set an off-diagonal element in a diagonal matrix.");
		}

		public override int GetHashCode()
		{
			int num = Math.Min(Data.Length, 25);
			int num2 = 17;
			for (int i = 0; i < num; i++)
			{
				num2 = num2 * 31 + Data[i].GetHashCode();
			}
			return num2;
		}

		public override void Clear()
		{
			Array.Clear(Data, 0, Data.Length);
		}

		internal override void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			int num = Math.Max(rowIndex, columnIndex);
			int num2 = Math.Min(rowIndex + rowCount, columnIndex + columnCount);
			if (num2 > num)
			{
				Array.Clear(Data, num, num2 - num);
			}
		}

		internal override void ClearRowsUnchecked(int[] rowIndices)
		{
			for (int i = 0; i < rowIndices.Length; i++)
			{
				Data[rowIndices[i]] = MatrixStorage<T>.Zero;
			}
		}

		internal override void ClearColumnsUnchecked(int[] columnIndices)
		{
			for (int i = 0; i < columnIndices.Length; i++)
			{
				Data[columnIndices[i]] = MatrixStorage<T>.Zero;
			}
		}

		public static DiagonalMatrixStorage<T> OfMatrix(MatrixStorage<T> matrix)
		{
			DiagonalMatrixStorage<T> diagonalMatrixStorage = new DiagonalMatrixStorage<T>(matrix.RowCount, matrix.ColumnCount);
			matrix.CopyToUnchecked(diagonalMatrixStorage, ExistingData.AssumeZeros);
			return diagonalMatrixStorage;
		}

		public static DiagonalMatrixStorage<T> OfArray(T[,] array)
		{
			DiagonalMatrixStorage<T> diagonalMatrixStorage = new DiagonalMatrixStorage<T>(array.GetLength(0), array.GetLength(1));
			for (int i = 0; i < diagonalMatrixStorage.RowCount; i++)
			{
				for (int j = 0; j < diagonalMatrixStorage.ColumnCount; j++)
				{
					if (i == j)
					{
						diagonalMatrixStorage.Data[i] = array[i, j];
						continue;
					}
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(array[i, j]))
					{
						throw new ArgumentException("Cannot set an off-diagonal element in a diagonal matrix.");
					}
				}
			}
			return diagonalMatrixStorage;
		}

		public static DiagonalMatrixStorage<T> OfValue(int rows, int columns, T diagonalValue)
		{
			DiagonalMatrixStorage<T> diagonalMatrixStorage = new DiagonalMatrixStorage<T>(rows, columns);
			for (int i = 0; i < diagonalMatrixStorage.Data.Length; i++)
			{
				diagonalMatrixStorage.Data[i] = diagonalValue;
			}
			return diagonalMatrixStorage;
		}

		public static DiagonalMatrixStorage<T> OfInit(int rows, int columns, Func<int, T> init)
		{
			DiagonalMatrixStorage<T> diagonalMatrixStorage = new DiagonalMatrixStorage<T>(rows, columns);
			for (int i = 0; i < diagonalMatrixStorage.Data.Length; i++)
			{
				diagonalMatrixStorage.Data[i] = init(i);
			}
			return diagonalMatrixStorage;
		}

		public static DiagonalMatrixStorage<T> OfEnumerable(int rows, int columns, IEnumerable<T> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (data is T[] array)
			{
				T[] array2 = new T[array.Length];
				Array.Copy(array, 0, array2, 0, array.Length);
				return new DiagonalMatrixStorage<T>(rows, columns, array2);
			}
			return new DiagonalMatrixStorage<T>(rows, columns, data.ToArray());
		}

		public static DiagonalMatrixStorage<T> OfIndexedEnumerable(int rows, int columns, IEnumerable<Tuple<int, T>> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			DiagonalMatrixStorage<T> diagonalMatrixStorage = new DiagonalMatrixStorage<T>(rows, columns);
			foreach (Tuple<int, T> datum in data)
			{
				diagonalMatrixStorage.Data[datum.Item1] = datum.Item2;
			}
			return diagonalMatrixStorage;
		}

		internal override void CopyToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			if (target is DiagonalMatrixStorage<T> target2)
			{
				CopyToUnchecked(target2);
				return;
			}
			if (target is DenseColumnMajorMatrixStorage<T> target3)
			{
				CopyToUnchecked(target3, existingData);
				return;
			}
			if (target is SparseCompressedRowMatrixStorage<T> target4)
			{
				CopyToUnchecked(target4, existingData);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			for (int i = 0; i < Data.Length; i++)
			{
				target.At(i, i, Data[i]);
			}
		}

		private void CopyToUnchecked(DiagonalMatrixStorage<T> target)
		{
			Array.Copy(Data, 0, target.Data, 0, Data.Length);
		}

		private void CopyToUnchecked(SparseCompressedRowMatrixStorage<T> target, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			for (int i = 0; i < Data.Length; i++)
			{
				target.At(i, i, Data[i]);
			}
		}

		private void CopyToUnchecked(DenseColumnMajorMatrixStorage<T> target, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			for (int i = 0; i < Data.Length; i++)
			{
				target.Data[i * (target.RowCount + 1)] = Data[i];
			}
		}

		internal override void CopySubMatrixToUnchecked(MatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (target is DenseColumnMajorMatrixStorage<T> target2)
			{
				CopySubMatrixToUnchecked(target2, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
				return;
			}
			if (target is DiagonalMatrixStorage<T> target3)
			{
				CopySubMatrixToUnchecked(target3, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			if (sourceRowIndex == sourceColumnIndex)
			{
				for (int i = 0; i < Math.Min(columnCount, rowCount); i++)
				{
					target.At(targetRowIndex + i, targetColumnIndex + i, Data[sourceRowIndex + i]);
				}
			}
			else if (sourceRowIndex > sourceColumnIndex && sourceColumnIndex + columnCount > sourceRowIndex)
			{
				int num = sourceRowIndex - sourceColumnIndex;
				for (int j = 0; j < Math.Min(columnCount - num, rowCount); j++)
				{
					target.At(targetRowIndex + j, num + targetColumnIndex + j, Data[sourceRowIndex + j]);
				}
			}
			else if (sourceRowIndex < sourceColumnIndex && sourceRowIndex + rowCount > sourceColumnIndex)
			{
				int num2 = sourceColumnIndex - sourceRowIndex;
				for (int k = 0; k < Math.Min(columnCount, rowCount - num2); k++)
				{
					target.At(num2 + targetRowIndex + k, targetColumnIndex + k, Data[sourceColumnIndex + k]);
				}
			}
		}

		private void CopySubMatrixToUnchecked(DiagonalMatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount)
		{
			if (sourceRowIndex - sourceColumnIndex != targetRowIndex - targetColumnIndex)
			{
				if (Data.Any(delegate(T x)
				{
					T zero = MatrixStorage<T>.Zero;
					return !zero.Equals(x);
				}))
				{
					throw new NotSupportedException();
				}
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
				return;
			}
			int num = Math.Max(sourceRowIndex, sourceColumnIndex);
			int num2 = Math.Min(sourceRowIndex + rowCount, sourceColumnIndex + columnCount);
			if (num2 > num)
			{
				int destinationIndex = Math.Max(targetRowIndex, targetColumnIndex);
				Array.Copy(Data, num, target.Data, destinationIndex, num2 - num);
			}
		}

		private void CopySubMatrixToUnchecked(DenseColumnMajorMatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			if (sourceRowIndex > sourceColumnIndex && sourceColumnIndex + columnCount > sourceRowIndex)
			{
				int num = sourceRowIndex - sourceColumnIndex;
				int num2 = (num + targetColumnIndex) * target.RowCount + targetRowIndex;
				int num3 = target.RowCount + 1;
				int num4 = Math.Min(columnCount - num, rowCount) + sourceRowIndex;
				int num5 = sourceRowIndex;
				int num6 = num2;
				while (num5 < num4)
				{
					target.Data[num6] = Data[num5];
					num5++;
					num6 += num3;
				}
			}
			else if (sourceRowIndex < sourceColumnIndex && sourceRowIndex + rowCount > sourceColumnIndex)
			{
				int num7 = sourceColumnIndex - sourceRowIndex;
				int num8 = targetColumnIndex * target.RowCount + num7 + targetRowIndex;
				int num9 = target.RowCount + 1;
				int num10 = Math.Min(columnCount, rowCount - num7) + sourceColumnIndex;
				int num11 = sourceColumnIndex;
				int num12 = num8;
				while (num11 < num10)
				{
					target.Data[num12] = Data[num11];
					num11++;
					num12 += num9;
				}
			}
			else
			{
				int num13 = targetColumnIndex * target.RowCount + targetRowIndex;
				int num14 = target.RowCount + 1;
				int num15 = Math.Min(columnCount, rowCount) + sourceRowIndex;
				int num16 = sourceRowIndex;
				int num17 = num13;
				while (num16 < num15)
				{
					target.Data[num17] = Data[num16];
					num16++;
					num17 += num14;
				}
			}
		}

		internal override void CopySubRowToUnchecked(VectorStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.Clear(targetColumnIndex, columnCount);
			}
			if (rowIndex >= sourceColumnIndex && rowIndex < sourceColumnIndex + columnCount && rowIndex < Data.Length)
			{
				target.At(rowIndex - sourceColumnIndex + targetColumnIndex, Data[rowIndex]);
			}
		}

		internal override void CopySubColumnToUnchecked(VectorStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.Clear(targetRowIndex, rowCount);
			}
			if (columnIndex >= sourceRowIndex && columnIndex < sourceRowIndex + rowCount && columnIndex < Data.Length)
			{
				target.At(columnIndex - sourceRowIndex + targetRowIndex, Data[columnIndex]);
			}
		}

		internal override void TransposeToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			CopyToUnchecked(target, existingData);
		}

		internal override void TransposeSquareInplaceUnchecked()
		{
		}

		public override T[] ToRowMajorArray()
		{
			T[] array = new T[RowCount * ColumnCount];
			int num = ColumnCount + 1;
			for (int i = 0; i < Data.Length; i++)
			{
				array[i * num] = Data[i];
			}
			return array;
		}

		public override T[] ToColumnMajorArray()
		{
			T[] array = new T[RowCount * ColumnCount];
			int num = RowCount + 1;
			for (int i = 0; i < Data.Length; i++)
			{
				array[i * num] = Data[i];
			}
			return array;
		}

		public override T[][] ToRowArrays()
		{
			T[][] array = new T[RowCount][];
			for (int i = 0; i < RowCount; i++)
			{
				array[i] = new T[ColumnCount];
			}
			for (int j = 0; j < Data.Length; j++)
			{
				array[j][j] = Data[j];
			}
			return array;
		}

		public override T[][] ToColumnArrays()
		{
			T[][] array = new T[ColumnCount][];
			for (int i = 0; i < ColumnCount; i++)
			{
				array[i] = new T[RowCount];
			}
			for (int j = 0; j < Data.Length; j++)
			{
				array[j][j] = Data[j];
			}
			return array;
		}

		public override T[,] ToArray()
		{
			T[,] array = new T[RowCount, ColumnCount];
			for (int i = 0; i < Data.Length; i++)
			{
				array[i, i] = Data[i];
			}
			return array;
		}

		public override IEnumerable<T> Enumerate()
		{
			for (int j = 0; j < ColumnCount; j++)
			{
				for (int i = 0; i < RowCount; i++)
				{
					yield return (i == j) ? Data[i] : MatrixStorage<T>.Zero;
				}
			}
		}

		public override IEnumerable<Tuple<int, int, T>> EnumerateIndexed()
		{
			for (int j = 0; j < ColumnCount; j++)
			{
				for (int i = 0; i < RowCount; i++)
				{
					yield return (i == j) ? new Tuple<int, int, T>(i, i, Data[i]) : new Tuple<int, int, T>(i, j, MatrixStorage<T>.Zero);
				}
			}
		}

		public override IEnumerable<T> EnumerateNonZero()
		{
			return Data.Where(delegate(T x)
			{
				T zero = MatrixStorage<T>.Zero;
				return !zero.Equals(x);
			});
		}

		public override IEnumerable<Tuple<int, int, T>> EnumerateNonZeroIndexed()
		{
			for (int i = 0; i < Data.Length; i++)
			{
				T zero = MatrixStorage<T>.Zero;
				if (!zero.Equals(Data[i]))
				{
					yield return new Tuple<int, int, T>(i, i, Data[i]);
				}
			}
		}

		public override Tuple<int, int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < Data.Length; i++)
			{
				if (predicate(Data[i]))
				{
					return new Tuple<int, int, T>(i, i, Data[i]);
				}
			}
			if (zeros == Zeros.Include && (RowCount > 1 || ColumnCount > 1) && predicate(MatrixStorage<T>.Zero))
			{
				return new Tuple<int, int, T>((RowCount > 1) ? 1 : 0, (RowCount <= 1) ? 1 : 0, MatrixStorage<T>.Zero);
			}
			return null;
		}

		internal override Tuple<int, int, T, TOther> Find2Unchecked<TOther>(MatrixStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros)
		{
			if (other is DenseColumnMajorMatrixStorage<TOther> denseColumnMajorMatrixStorage)
			{
				TOther[] data = denseColumnMajorMatrixStorage.Data;
				int num = 0;
				for (int i = 0; i < ColumnCount; i++)
				{
					for (int j = 0; j < RowCount; j++)
					{
						if (predicate((j == i) ? Data[j] : MatrixStorage<T>.Zero, data[num]))
						{
							return new Tuple<int, int, T, TOther>(j, i, (j == i) ? Data[j] : MatrixStorage<T>.Zero, data[num]);
						}
						num++;
					}
				}
				return null;
			}
			if (other is DiagonalMatrixStorage<TOther> diagonalMatrixStorage)
			{
				TOther[] data2 = diagonalMatrixStorage.Data;
				for (int k = 0; k < Data.Length; k++)
				{
					if (predicate(Data[k], data2[k]))
					{
						return new Tuple<int, int, T, TOther>(k, k, Data[k], data2[k]);
					}
				}
				if (zeros == Zeros.Include && (RowCount > 1 || ColumnCount > 1))
				{
					TOther zero = BuilderInstance<TOther>.Matrix.Zero;
					if (predicate(MatrixStorage<T>.Zero, zero))
					{
						return new Tuple<int, int, T, TOther>((RowCount > 1) ? 1 : 0, (RowCount <= 1) ? 1 : 0, MatrixStorage<T>.Zero, zero);
					}
				}
				return null;
			}
			if (other is SparseCompressedRowMatrixStorage<TOther> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
				TOther[] values = sparseCompressedRowMatrixStorage.Values;
				TOther zero2 = BuilderInstance<TOther>.Matrix.Zero;
				for (int l = 0; l < RowCount; l++)
				{
					bool flag = false;
					int num2 = rowPointers[l];
					int num3 = rowPointers[l + 1];
					for (int m = num2; m < num3; m++)
					{
						if (columnIndices[m] == l)
						{
							flag = true;
							if (predicate(Data[l], values[m]))
							{
								return new Tuple<int, int, T, TOther>(l, l, Data[l], values[m]);
							}
						}
						else if (predicate(MatrixStorage<T>.Zero, values[m]))
						{
							return new Tuple<int, int, T, TOther>(l, columnIndices[m], MatrixStorage<T>.Zero, values[m]);
						}
					}
					if (!flag && l < ColumnCount && predicate(Data[l], zero2))
					{
						return new Tuple<int, int, T, TOther>(l, l, Data[l], zero2);
					}
				}
				if (zeros == Zeros.Include && sparseCompressedRowMatrixStorage.ValueCount < RowCount * ColumnCount && predicate(MatrixStorage<T>.Zero, zero2))
				{
					int num4 = 0;
					for (int n = 0; n < RowCount; n++)
					{
						for (int num5 = 0; num5 < ColumnCount; num5++)
						{
							if (num4 < rowPointers[n + 1] && columnIndices[num4] == num5)
							{
								num4++;
							}
							else if (n != num5)
							{
								return new Tuple<int, int, T, TOther>(n, num5, MatrixStorage<T>.Zero, zero2);
							}
						}
					}
				}
				return null;
			}
			return base.Find2Unchecked(other, predicate, zeros);
		}

		public override void MapInplace(Func<T, T> f, Zeros zeros)
		{
			if (zeros == Zeros.Include)
			{
				throw new NotSupportedException("Cannot map non-zero off-diagonal values into a diagonal matrix");
			}
			CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					Data[i] = f(Data[i]);
				}
			});
		}

		public override void MapIndexedInplace(Func<int, int, T, T> f, Zeros zeros)
		{
			if (zeros == Zeros.Include)
			{
				throw new NotSupportedException("Cannot map non-zero off-diagonal values into a diagonal matrix");
			}
			CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					Data[i] = f(i, i, Data[i]);
				}
			});
		}

		internal override void MapToUnchecked<TU>(MatrixStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData)
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			DiagonalMatrixStorage<TU> diagonalTarget = target as DiagonalMatrixStorage<TU>;
			if (diagonalTarget != null)
			{
				if (flag)
				{
					throw new NotSupportedException("Cannot map non-zero off-diagonal values into a diagonal matrix");
				}
				CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
				{
					for (int l = a; l < b; l++)
					{
						diagonalTarget.Data[l] = f(Data[l]);
					}
				});
				return;
			}
			if (existingData == ExistingData.Clear && !flag)
			{
				target.Clear();
			}
			if (flag)
			{
				for (int i = 0; i < ColumnCount; i++)
				{
					for (int j = 0; j < RowCount; j++)
					{
						target.At(j, i, f((j == i) ? Data[j] : MatrixStorage<T>.Zero));
					}
				}
			}
			else
			{
				for (int k = 0; k < Data.Length; k++)
				{
					target.At(k, k, f(Data[k]));
				}
			}
		}

		internal override void MapIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, Zeros zeros, ExistingData existingData)
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(0, 1, MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			DiagonalMatrixStorage<TU> diagonalTarget = target as DiagonalMatrixStorage<TU>;
			if (diagonalTarget != null)
			{
				if (flag)
				{
					throw new NotSupportedException("Cannot map non-zero off-diagonal values into a diagonal matrix");
				}
				CommonParallel.For(0, Data.Length, 4096, delegate(int a, int b)
				{
					for (int l = a; l < b; l++)
					{
						diagonalTarget.Data[l] = f(l, l, Data[l]);
					}
				});
				return;
			}
			if (existingData == ExistingData.Clear && !flag)
			{
				target.Clear();
			}
			if (flag)
			{
				for (int i = 0; i < ColumnCount; i++)
				{
					for (int j = 0; j < RowCount; j++)
					{
						target.At(j, i, f(j, i, (j == i) ? Data[j] : MatrixStorage<T>.Zero));
					}
				}
			}
			else
			{
				for (int k = 0; k < Data.Length; k++)
				{
					target.At(k, k, f(k, k, Data[k]));
				}
			}
		}

		internal override void MapSubMatrixIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData)
		{
			if (target is DiagonalMatrixStorage<TU> target2)
			{
				MapSubMatrixIndexedToUnchecked(target2, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros);
				return;
			}
			if (target is DenseColumnMajorMatrixStorage<TU> target3)
			{
				MapSubMatrixIndexedToUnchecked(target3, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			if (sourceRowIndex == sourceColumnIndex)
			{
				int num = targetRowIndex;
				int num2 = targetColumnIndex;
				for (int i = 0; i < Math.Min(columnCount, rowCount); i++)
				{
					target.At(num, num2, f(num, num2, Data[sourceRowIndex + i]));
					num++;
					num2++;
				}
			}
			else if (sourceRowIndex > sourceColumnIndex && sourceColumnIndex + columnCount > sourceRowIndex)
			{
				int num3 = sourceRowIndex - sourceColumnIndex;
				int num4 = targetRowIndex;
				int num5 = targetColumnIndex + num3;
				for (int j = 0; j < Math.Min(columnCount - num3, rowCount); j++)
				{
					target.At(num4, num5, f(num4, num5, Data[sourceRowIndex + j]));
					num4++;
					num5++;
				}
			}
			else if (sourceRowIndex < sourceColumnIndex && sourceRowIndex + rowCount > sourceColumnIndex)
			{
				int num6 = sourceColumnIndex - sourceRowIndex;
				int num7 = targetRowIndex + num6;
				int num8 = targetColumnIndex;
				for (int k = 0; k < Math.Min(columnCount, rowCount - num6); k++)
				{
					target.At(num7, num8, f(num7, num8, Data[sourceColumnIndex + k]));
					num7++;
					num8++;
				}
			}
		}

		private void MapSubMatrixIndexedToUnchecked<TU>(DiagonalMatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				if (zero.Equals(f(0, 1, MatrixStorage<T>.Zero)) && sourceRowIndex - sourceColumnIndex == targetRowIndex - targetColumnIndex)
				{
					int beginInclusive = Math.Max(sourceRowIndex, sourceColumnIndex);
					int num = Math.Min(sourceRowIndex + rowCount, sourceColumnIndex + columnCount) - beginInclusive;
					if (num <= 0)
					{
						return;
					}
					int beginTarget = Math.Max(targetRowIndex, targetColumnIndex);
					CommonParallel.For(0, num, 4096, delegate(int a, int b)
					{
						int num2 = beginTarget + a;
						for (int i = a; i < b; i++)
						{
							target.Data[num2] = f(num2, num2, Data[beginInclusive + i]);
							num2++;
						}
					});
					return;
				}
			}
			throw new NotSupportedException("Cannot map non-zero off-diagonal values into a diagonal matrix");
		}

		private void MapSubMatrixIndexedToUnchecked<TU>(DenseColumnMajorMatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(0, 1, MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			if (existingData == ExistingData.Clear && !flag)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			if (flag)
			{
				CommonParallel.For(0, columnCount, Math.Max(4096 / rowCount, 32), delegate(int a, int b)
				{
					int num16 = sourceColumnIndex + a;
					int num17 = targetColumnIndex + a;
					for (int l = a; l < b; l++)
					{
						int num18 = targetRowIndex + (l + targetColumnIndex) * target.RowCount;
						int num19 = sourceRowIndex;
						int num20 = targetRowIndex;
						for (int m = 0; m < rowCount; m++)
						{
							target.Data[num18++] = f(num20++, num17, (num19++ == num16) ? Data[num16] : MatrixStorage<T>.Zero);
						}
						num16++;
						num17++;
					}
				});
			}
			else if (sourceRowIndex > sourceColumnIndex && sourceColumnIndex + columnCount > sourceRowIndex)
			{
				int num2 = sourceRowIndex - sourceColumnIndex;
				int num3 = (num2 + targetColumnIndex) * target.RowCount + targetRowIndex;
				int num4 = target.RowCount + 1;
				int num5 = Math.Min(columnCount - num2, rowCount);
				int i = 0;
				int num6 = num3;
				for (; i < num5; i++)
				{
					target.Data[num6] = f(targetRowIndex + i, targetColumnIndex + num2 + i, Data[sourceRowIndex + i]);
					num6 += num4;
				}
			}
			else if (sourceRowIndex < sourceColumnIndex && sourceRowIndex + rowCount > sourceColumnIndex)
			{
				int num7 = sourceColumnIndex - sourceRowIndex;
				int num8 = targetColumnIndex * target.RowCount + num7 + targetRowIndex;
				int num9 = target.RowCount + 1;
				int num10 = Math.Min(columnCount, rowCount - num7);
				int j = 0;
				int num11 = num8;
				for (; j < num10; j++)
				{
					target.Data[num11] = f(targetRowIndex + num7 + j, targetColumnIndex + j, Data[sourceColumnIndex + j]);
					num11 += num9;
				}
			}
			else
			{
				int num12 = targetColumnIndex * target.RowCount + targetRowIndex;
				int num13 = target.RowCount + 1;
				int num14 = Math.Min(columnCount, rowCount);
				int k = 0;
				int num15 = num12;
				for (; k < num14; k++)
				{
					target.Data[num15] = f(targetRowIndex + k, targetColumnIndex + k, Data[sourceRowIndex + k]);
					num15 += num13;
				}
			}
		}

		internal override void FoldByRowUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			if (zeros == Zeros.AllowSkip)
			{
				for (int i = 0; i < Data.Length; i++)
				{
					target[i] = finalize(f(state[i], Data[i]), 1);
				}
				for (int j = Data.Length; j < RowCount; j++)
				{
					target[j] = finalize(state[j], 0);
				}
				return;
			}
			for (int k = 0; k < RowCount; k++)
			{
				TU arg = state[k];
				for (int l = 0; l < ColumnCount; l++)
				{
					arg = f(arg, (k == l) ? Data[k] : MatrixStorage<T>.Zero);
				}
				target[k] = finalize(arg, ColumnCount);
			}
		}

		internal override void FoldByColumnUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			if (zeros == Zeros.AllowSkip)
			{
				for (int i = 0; i < Data.Length; i++)
				{
					target[i] = finalize(f(state[i], Data[i]), 1);
				}
				for (int j = Data.Length; j < ColumnCount; j++)
				{
					target[j] = finalize(state[j], 0);
				}
				return;
			}
			for (int k = 0; k < ColumnCount; k++)
			{
				TU arg = state[k];
				for (int l = 0; l < RowCount; l++)
				{
					arg = f(arg, (l == k) ? Data[l] : MatrixStorage<T>.Zero);
				}
				target[k] = finalize(arg, RowCount);
			}
		}

		internal override TState Fold2Unchecked<TOther, TState>(MatrixStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros)
		{
			if (other is DenseColumnMajorMatrixStorage<TOther> denseColumnMajorMatrixStorage)
			{
				TOther[] data = denseColumnMajorMatrixStorage.Data;
				int num = 0;
				for (int i = 0; i < ColumnCount; i++)
				{
					for (int j = 0; j < RowCount; j++)
					{
						state = f(state, (j == i) ? Data[j] : MatrixStorage<T>.Zero, data[num]);
						num++;
					}
				}
				return state;
			}
			if (other is DiagonalMatrixStorage<TOther> diagonalMatrixStorage)
			{
				TOther[] data2 = diagonalMatrixStorage.Data;
				for (int k = 0; k < Data.Length; k++)
				{
					state = f(state, Data[k], data2[k]);
				}
				if (zeros == Zeros.Include)
				{
					TOther zero = BuilderInstance<TOther>.Matrix.Zero;
					int num2 = RowCount * ColumnCount - Data.Length;
					for (int l = 0; l < num2; l++)
					{
						state = f(state, MatrixStorage<T>.Zero, zero);
					}
				}
				return state;
			}
			if (other is SparseCompressedRowMatrixStorage<TOther> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
				TOther[] values = sparseCompressedRowMatrixStorage.Values;
				TOther zero2 = BuilderInstance<TOther>.Matrix.Zero;
				if (zeros == Zeros.Include)
				{
					int num3 = 0;
					for (int m = 0; m < RowCount; m++)
					{
						for (int n = 0; n < ColumnCount; n++)
						{
							state = ((num3 >= rowPointers[m + 1] || columnIndices[num3] != n) ? f(state, (m == n) ? Data[m] : MatrixStorage<T>.Zero, zero2) : f(state, (m == n) ? Data[m] : MatrixStorage<T>.Zero, values[num3++]));
						}
					}
					return state;
				}
				for (int num4 = 0; num4 < RowCount; num4++)
				{
					bool flag = false;
					int num5 = rowPointers[num4];
					int num6 = rowPointers[num4 + 1];
					for (int num7 = num5; num7 < num6; num7++)
					{
						if (columnIndices[num7] == num4)
						{
							flag = true;
							state = f(state, Data[num4], values[num7]);
						}
						else
						{
							state = f(state, MatrixStorage<T>.Zero, values[num7]);
						}
					}
					if (!flag && num4 < ColumnCount)
					{
						state = f(state, Data[num4], zero2);
					}
				}
				return state;
			}
			return base.Fold2Unchecked(other, f, state, zeros);
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public abstract class MatrixStorage<T> : IEquatable<MatrixStorage<T>> where T : struct, IEquatable<T>, IFormattable
	{
		protected static readonly T Zero = BuilderInstance<T>.Matrix.Zero;

		[DataMember(Order = 1)]
		public readonly int RowCount;

		[DataMember(Order = 2)]
		public readonly int ColumnCount;

		public abstract bool IsDense { get; }

		public abstract bool IsFullyMutable { get; }

		public T this[int row, int column]
		{
			get
			{
				ValidateRange(row, column);
				return At(row, column);
			}
			set
			{
				ValidateRange(row, column);
				At(row, column, value);
			}
		}

		protected MatrixStorage(int rowCount, int columnCount)
		{
			if (rowCount < 0)
			{
				throw new ArgumentOutOfRangeException("rowCount", "The number of rows of a matrix must be non-negative.");
			}
			if (columnCount < 0)
			{
				throw new ArgumentOutOfRangeException("columnCount", "The number of columns of a matrix must be non-negative.");
			}
			RowCount = rowCount;
			ColumnCount = columnCount;
		}

		public abstract bool IsMutableAt(int row, int column);

		public abstract T At(int row, int column);

		public abstract void At(int row, int column, T value);

		public bool Equals(MatrixStorage<T> other)
		{
			if (other == null)
			{
				return false;
			}
			if (ColumnCount != other.ColumnCount || RowCount != other.RowCount)
			{
				return false;
			}
			if (this == other)
			{
				return true;
			}
			return Find2Unchecked(other, (T a, T b) => !a.Equals(b), Zeros.AllowSkip) == null;
		}

		public sealed override bool Equals(object obj)
		{
			return Equals(obj as MatrixStorage<T>);
		}

		public override int GetHashCode()
		{
			int num = Math.Min(RowCount * ColumnCount, 25);
			int num2 = 17;
			for (int i = 0; i < num; i++)
			{
				int result;
				int row = Math.DivRem(i, ColumnCount, out result);
				num2 = num2 * 31 + At(row, result).GetHashCode();
			}
			return num2;
		}

		public virtual void Clear()
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					At(i, j, Zero);
				}
			}
		}

		public void Clear(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			if (rowCount >= 1 && columnCount >= 1)
			{
				if (rowIndex + rowCount > RowCount || rowIndex < 0)
				{
					throw new ArgumentOutOfRangeException("rowIndex");
				}
				if (columnIndex + columnCount > ColumnCount || columnIndex < 0)
				{
					throw new ArgumentOutOfRangeException("columnIndex");
				}
				ClearUnchecked(rowIndex, rowCount, columnIndex, columnCount);
			}
		}

		internal virtual void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			for (int i = rowIndex; i < rowIndex + rowCount; i++)
			{
				for (int j = columnIndex; j < columnIndex + columnCount; j++)
				{
					At(i, j, Zero);
				}
			}
		}

		public void ClearRows(int[] rowIndices)
		{
			if (rowIndices.Length == 0)
			{
				return;
			}
			for (int i = 0; i < rowIndices.Length; i++)
			{
				if (rowIndices[i] < 0 || rowIndices[i] >= RowCount)
				{
					throw new ArgumentOutOfRangeException("rowIndices");
				}
			}
			ClearRowsUnchecked(rowIndices);
		}

		public void ClearColumns(int[] columnIndices)
		{
			if (columnIndices.Length == 0)
			{
				return;
			}
			for (int i = 0; i < columnIndices.Length; i++)
			{
				if ((uint)columnIndices[i] >= (uint)ColumnCount)
				{
					throw new ArgumentOutOfRangeException("columnIndices");
				}
			}
			ClearColumnsUnchecked(columnIndices);
		}

		internal virtual void ClearRowsUnchecked(int[] rowIndices)
		{
			foreach (int row in rowIndices)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					At(row, j, Zero);
				}
			}
		}

		internal virtual void ClearColumnsUnchecked(int[] columnIndices)
		{
			foreach (int column in columnIndices)
			{
				for (int j = 0; j < RowCount; j++)
				{
					At(j, column, Zero);
				}
			}
		}

		public void CopyTo(MatrixStorage<T> target, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (this != target)
			{
				if (RowCount != target.RowCount || ColumnCount != target.ColumnCount)
				{
					throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {target.RowCount}x{target.ColumnCount}.", "target");
				}
				CopyToUnchecked(target, existingData);
			}
		}

		internal virtual void CopyToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < RowCount; j++)
				{
					target.At(j, i, At(j, i));
				}
			}
		}

		public void CopySubMatrixTo(MatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (rowCount == 0 || columnCount == 0)
			{
				return;
			}
			if (sourceRowIndex == 0 && targetRowIndex == 0 && rowCount == RowCount && rowCount == target.RowCount && sourceColumnIndex == 0 && targetColumnIndex == 0 && columnCount == ColumnCount && columnCount == target.ColumnCount)
			{
				CopyTo(target);
				return;
			}
			if (this == target)
			{
				throw new NotSupportedException();
			}
			ValidateSubMatrixRange(target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);
			CopySubMatrixToUnchecked(target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
		}

		internal virtual void CopySubMatrixToUnchecked(MatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				int num3 = sourceRowIndex;
				int num4 = targetRowIndex;
				while (num3 < sourceRowIndex + rowCount)
				{
					target.At(num4, num2, At(num3, num));
					num3++;
					num4++;
				}
				num++;
				num2++;
			}
		}

		public void CopyRowTo(VectorStorage<T> target, int rowIndex, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			ValidateRowRange(target, rowIndex);
			CopySubRowToUnchecked(target, rowIndex, 0, 0, ColumnCount, existingData);
		}

		public void CopySubRowTo(VectorStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (columnCount != 0)
			{
				ValidateSubRowRange(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount);
				CopySubRowToUnchecked(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
			}
		}

		internal virtual void CopySubRowToUnchecked(VectorStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				target.At(num2, At(rowIndex, num));
				num++;
				num2++;
			}
		}

		public void CopyColumnTo(VectorStorage<T> target, int columnIndex, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			ValidateColumnRange(target, columnIndex);
			CopySubColumnToUnchecked(target, columnIndex, 0, 0, RowCount, existingData);
		}

		public void CopySubColumnTo(VectorStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (rowCount != 0)
			{
				ValidateSubColumnRange(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount);
				CopySubColumnToUnchecked(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData);
			}
		}

		internal virtual void CopySubColumnToUnchecked(VectorStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData)
		{
			int num = sourceRowIndex;
			int num2 = targetRowIndex;
			while (num < sourceRowIndex + rowCount)
			{
				target.At(num2, At(num, columnIndex));
				num++;
				num2++;
			}
		}

		public void TransposeTo(MatrixStorage<T> target, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (RowCount != target.ColumnCount || ColumnCount != target.RowCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {target.RowCount}x{target.ColumnCount}.", "target");
			}
			if (this == target)
			{
				TransposeSquareInplaceUnchecked();
			}
			else
			{
				TransposeToUnchecked(target, existingData);
			}
		}

		internal virtual void TransposeToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < RowCount; j++)
				{
					target.At(i, j, At(j, i));
				}
			}
		}

		internal virtual void TransposeSquareInplaceUnchecked()
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < i; j++)
				{
					T value = At(j, i);
					At(j, i, At(i, j));
					At(i, j, value);
				}
			}
		}

		public virtual T[] ToRowMajorArray()
		{
			T[] array = new T[RowCount * ColumnCount];
			for (int i = 0; i < RowCount; i++)
			{
				int num = i * ColumnCount;
				for (int j = 0; j < ColumnCount; j++)
				{
					array[num + j] = At(i, j);
				}
			}
			return array;
		}

		public virtual T[] ToColumnMajorArray()
		{
			T[] array = new T[RowCount * ColumnCount];
			for (int i = 0; i < ColumnCount; i++)
			{
				int num = i * RowCount;
				for (int j = 0; j < RowCount; j++)
				{
					array[num + j] = At(j, i);
				}
			}
			return array;
		}

		public virtual T[][] ToRowArrays()
		{
			T[][] array = new T[RowCount][];
			for (int i = 0; i < RowCount; i++)
			{
				T[] array2 = new T[ColumnCount];
				for (int j = 0; j < ColumnCount; j++)
				{
					array2[j] = At(i, j);
				}
				array[i] = array2;
			}
			return array;
		}

		public virtual T[][] ToColumnArrays()
		{
			T[][] array = new T[ColumnCount][];
			for (int i = 0; i < ColumnCount; i++)
			{
				T[] array2 = new T[RowCount];
				for (int j = 0; j < RowCount; j++)
				{
					array2[j] = At(j, i);
				}
				array[i] = array2;
			}
			return array;
		}

		public virtual T[,] ToArray()
		{
			T[,] array = new T[RowCount, ColumnCount];
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					array[i, j] = At(i, j);
				}
			}
			return array;
		}

		public virtual T[] AsRowMajorArray()
		{
			return null;
		}

		public virtual T[] AsColumnMajorArray()
		{
			return null;
		}

		public virtual T[][] AsRowArrays()
		{
			return null;
		}

		public virtual T[][] AsColumnArrays()
		{
			return null;
		}

		public virtual T[,] AsArray()
		{
			return null;
		}

		public virtual IEnumerable<T> Enumerate()
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					yield return At(i, j);
				}
			}
		}

		public virtual IEnumerable<Tuple<int, int, T>> EnumerateIndexed()
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					yield return new Tuple<int, int, T>(i, j, At(i, j));
				}
			}
		}

		public virtual IEnumerable<T> EnumerateNonZero()
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					T val = At(i, j);
					T zero = Zero;
					if (!zero.Equals(val))
					{
						yield return val;
					}
				}
			}
		}

		public virtual IEnumerable<Tuple<int, int, T>> EnumerateNonZeroIndexed()
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					T val = At(i, j);
					T zero = Zero;
					if (!zero.Equals(val))
					{
						yield return new Tuple<int, int, T>(i, j, val);
					}
				}
			}
		}

		public virtual Tuple<int, int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					T val = At(i, j);
					if (predicate(val))
					{
						return new Tuple<int, int, T>(i, j, val);
					}
				}
			}
			return null;
		}

		public Tuple<int, int, T, TOther> Find2<TOther>(MatrixStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (RowCount != other.RowCount || ColumnCount != other.ColumnCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {other.RowCount}x{other.ColumnCount}.", "other");
			}
			return Find2Unchecked(other, predicate, zeros);
		}

		internal virtual Tuple<int, int, T, TOther> Find2Unchecked<TOther>(MatrixStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					T val = At(i, j);
					TOther val2 = other.At(i, j);
					if (predicate(val, val2))
					{
						return new Tuple<int, int, T, TOther>(i, j, val, val2);
					}
				}
			}
			return null;
		}

		public virtual void MapInplace(Func<T, T> f, Zeros zeros)
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					At(i, j, f(At(i, j)));
				}
			}
		}

		public virtual void MapIndexedInplace(Func<int, int, T, T> f, Zeros zeros)
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					At(i, j, f(i, j, At(i, j)));
				}
			}
		}

		public void MapTo<TU>(MatrixStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (RowCount != target.RowCount || ColumnCount != target.ColumnCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {target.RowCount}x{target.ColumnCount}.", "target");
			}
			MapToUnchecked(target, f, zeros, existingData);
		}

		internal virtual void MapToUnchecked<TU>(MatrixStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					target.At(i, j, f(At(i, j)));
				}
			}
		}

		public void MapIndexedTo<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (RowCount != target.RowCount || ColumnCount != target.ColumnCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {target.RowCount}x{target.ColumnCount}.", "target");
			}
			MapIndexedToUnchecked(target, f, zeros, existingData);
		}

		internal virtual void MapIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				for (int j = 0; j < RowCount; j++)
				{
					target.At(j, i, f(j, i, At(j, i)));
				}
			}
		}

		public void MapSubMatrixIndexedTo<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (rowCount != 0 && columnCount != 0)
			{
				if (this == target)
				{
					throw new NotSupportedException();
				}
				ValidateSubMatrixRange(target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);
				MapSubMatrixIndexedToUnchecked(target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData);
			}
		}

		internal virtual void MapSubMatrixIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				int num3 = sourceRowIndex;
				int num4 = targetRowIndex;
				while (num3 < sourceRowIndex + rowCount)
				{
					target.At(num4, num2, f(num4, num2, At(num3, num)));
					num3++;
					num4++;
				}
				num++;
				num2++;
			}
		}

		public void Map2To(MatrixStorage<T> target, MatrixStorage<T> other, Func<T, T, T> f, Zeros zeros, ExistingData existingData)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (RowCount != target.RowCount || ColumnCount != target.ColumnCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {target.RowCount}x{target.ColumnCount}.", "target");
			}
			if (RowCount != other.RowCount || ColumnCount != other.ColumnCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {other.RowCount}x{other.ColumnCount}.", "other");
			}
			Map2ToUnchecked(target, other, f, zeros, existingData);
		}

		internal virtual void Map2ToUnchecked(MatrixStorage<T> target, MatrixStorage<T> other, Func<T, T, T> f, Zeros zeros, ExistingData existingData)
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					target.At(i, j, f(At(i, j), other.At(i, j)));
				}
			}
		}

		public void FoldByRow<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (target.Length != RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			if (state == null)
			{
				throw new ArgumentNullException("state");
			}
			if (state.Length != RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "state");
			}
			FoldByRowUnchecked(target, f, finalize, state, zeros);
		}

		internal virtual void FoldByRowUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			for (int i = 0; i < RowCount; i++)
			{
				TU arg = state[i];
				for (int j = 0; j < ColumnCount; j++)
				{
					arg = f(arg, At(i, j));
				}
				target[i] = finalize(arg, ColumnCount);
			}
		}

		public void FoldByColumn<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (target.Length != ColumnCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			if (state == null)
			{
				throw new ArgumentNullException("state");
			}
			if (state.Length != ColumnCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "state");
			}
			FoldByColumnUnchecked(target, f, finalize, state, zeros);
		}

		internal virtual void FoldByColumnUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			for (int i = 0; i < ColumnCount; i++)
			{
				TU arg = state[i];
				for (int j = 0; j < RowCount; j++)
				{
					arg = f(arg, At(j, i));
				}
				target[i] = finalize(arg, RowCount);
			}
		}

		public TState Fold2<TOther, TState>(MatrixStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (RowCount != other.RowCount || ColumnCount != other.ColumnCount)
			{
				throw new ArgumentException($"Matrix dimensions must agree: op1 is {RowCount}x{ColumnCount}, op2 is {other.RowCount}x{other.ColumnCount}.", "other");
			}
			return Fold2Unchecked(other, f, state, zeros);
		}

		internal virtual TState Fold2Unchecked<TOther, TState>(MatrixStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			for (int i = 0; i < RowCount; i++)
			{
				for (int j = 0; j < ColumnCount; j++)
				{
					state = f(state, At(i, j), other.At(i, j));
				}
			}
			return state;
		}

		private void ValidateRange(int row, int column)
		{
			if ((uint)row >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("row");
			}
			if ((uint)column >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("column");
			}
		}

		private void ValidateSubMatrixRange<TU>(MatrixStorage<TU> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (rowCount < 1)
			{
				throw new ArgumentOutOfRangeException("rowCount", "Value must be positive.");
			}
			if (columnCount < 1)
			{
				throw new ArgumentOutOfRangeException("columnCount", "Value must be positive.");
			}
			if ((uint)sourceRowIndex >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("sourceRowIndex");
			}
			if ((uint)sourceColumnIndex >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("sourceColumnIndex");
			}
			int num = sourceRowIndex + rowCount;
			int num2 = sourceColumnIndex + columnCount;
			if (num > RowCount)
			{
				throw new ArgumentOutOfRangeException("rowCount");
			}
			if (num2 > ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnCount");
			}
			if ((uint)targetRowIndex >= (uint)target.RowCount)
			{
				throw new ArgumentOutOfRangeException("targetRowIndex");
			}
			if ((uint)targetColumnIndex >= (uint)target.ColumnCount)
			{
				throw new ArgumentOutOfRangeException("targetColumnIndex");
			}
			int num3 = targetRowIndex + rowCount;
			int num4 = targetColumnIndex + columnCount;
			if (num3 > target.RowCount)
			{
				throw new ArgumentOutOfRangeException("rowCount");
			}
			if (num4 > target.ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnCount");
			}
		}

		private void ValidateRowRange<TU>(VectorStorage<TU> target, int rowIndex) where TU : struct, IEquatable<TU>, IFormattable
		{
			if ((uint)rowIndex >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			if (ColumnCount != target.Length)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "target");
			}
		}

		private void ValidateColumnRange<TU>(VectorStorage<TU> target, int columnIndex) where TU : struct, IEquatable<TU>, IFormattable
		{
			if ((uint)columnIndex >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			if (RowCount != target.Length)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "target");
			}
		}

		private void ValidateSubRowRange<TU>(VectorStorage<TU> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (columnCount < 1)
			{
				throw new ArgumentOutOfRangeException("columnCount", "Value must be positive.");
			}
			if ((uint)rowIndex >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			if ((uint)sourceColumnIndex >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("sourceColumnIndex");
			}
			if (sourceColumnIndex + columnCount > ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnCount");
			}
			if ((uint)targetColumnIndex >= (uint)target.Length)
			{
				throw new ArgumentOutOfRangeException("targetColumnIndex");
			}
			if (targetColumnIndex + columnCount > target.Length)
			{
				throw new ArgumentOutOfRangeException("columnCount");
			}
		}

		private void ValidateSubColumnRange<TU>(VectorStorage<TU> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (rowCount < 1)
			{
				throw new ArgumentOutOfRangeException("rowCount", "Value must be positive.");
			}
			if ((uint)columnIndex >= (uint)ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			if ((uint)sourceRowIndex >= (uint)RowCount)
			{
				throw new ArgumentOutOfRangeException("sourceRowIndex");
			}
			if (sourceRowIndex + rowCount > RowCount)
			{
				throw new ArgumentOutOfRangeException("rowCount");
			}
			if ((uint)targetRowIndex >= (uint)target.Length)
			{
				throw new ArgumentOutOfRangeException("targetRowIndex");
			}
			if (targetRowIndex + rowCount > target.Length)
			{
				throw new ArgumentOutOfRangeException("rowCount");
			}
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public class SparseCompressedRowMatrixStorage<T> : MatrixStorage<T> where T : struct, IEquatable<T>, IFormattable
	{
		[DataMember(Order = 1)]
		public readonly int[] RowPointers;

		[DataMember(Order = 2)]
		public int[] ColumnIndices;

		[DataMember(Order = 3)]
		public T[] Values;

		public int ValueCount => RowPointers[RowCount];

		public override bool IsDense => false;

		public override bool IsFullyMutable => true;

		internal SparseCompressedRowMatrixStorage(int rows, int columns)
			: base(rows, columns)
		{
			RowPointers = new int[rows + 1];
			ColumnIndices = new int[0];
			Values = new T[0];
		}

		internal SparseCompressedRowMatrixStorage(int rows, int columns, int[] rowPointers, int[] columnIndices, T[] values)
			: base(rows, columns)
		{
			RowPointers = rowPointers;
			ColumnIndices = columnIndices;
			Values = values;
			NormalizeOrdering();
			NormalizeDuplicates();
		}

		public override bool IsMutableAt(int row, int column)
		{
			return true;
		}

		public override T At(int row, int column)
		{
			int num = FindItem(row, column);
			if (num < 0)
			{
				return MatrixStorage<T>.Zero;
			}
			return Values[num];
		}

		public override void At(int row, int column, T value)
		{
			int num = FindItem(row, column);
			T zero;
			if (num >= 0)
			{
				zero = MatrixStorage<T>.Zero;
				if (zero.Equals(value))
				{
					RemoveAtIndexUnchecked(num, row);
				}
				else
				{
					Values[num] = value;
				}
				return;
			}
			zero = MatrixStorage<T>.Zero;
			if (zero.Equals(value))
			{
				return;
			}
			num = ~num;
			int num2 = RowPointers[RowPointers.Length - 1];
			if (num2 == Values.Length && num2 < (long)RowCount * (long)ColumnCount)
			{
				long num3 = Math.Min(Values.Length + GrowthSize(), (long)RowCount * (long)ColumnCount);
				if (num3 > int.MaxValue)
				{
					throw new NotSupportedException("We only support sparse matrix with less than int.MaxValue elements.");
				}
				Array.Resize(ref Values, (int)num3);
				Array.Resize(ref ColumnIndices, (int)num3);
			}
			Array.Copy(Values, num, Values, num + 1, num2 - num);
			Array.Copy(ColumnIndices, num, ColumnIndices, num + 1, num2 - num);
			Values[num] = value;
			ColumnIndices[num] = column;
			for (int i = row + 1; i < RowPointers.Length; i++)
			{
				RowPointers[i]++;
			}
		}

		private void RemoveAtIndexUnchecked(int itemIndex, int row)
		{
			int num = RowPointers[RowPointers.Length - 1];
			Array.Copy(Values, itemIndex + 1, Values, itemIndex, num - itemIndex - 1);
			Array.Copy(ColumnIndices, itemIndex + 1, ColumnIndices, itemIndex, num - itemIndex - 1);
			for (int i = row + 1; i < RowPointers.Length; i++)
			{
				RowPointers[i]--;
			}
			num--;
			if (num > 1024 && num < Values.Length / 2)
			{
				Array.Resize(ref Values, num);
				Array.Resize(ref ColumnIndices, num);
			}
		}

		public int FindItem(int row, int column)
		{
			return Array.BinarySearch(ColumnIndices, RowPointers[row], RowPointers[row + 1] - RowPointers[row], column);
		}

		private int GrowthSize()
		{
			if (Values.Length > 1024)
			{
				return Values.Length / 4;
			}
			if (Values.Length > 256)
			{
				return 512;
			}
			return (Values.Length > 64) ? 128 : 32;
		}

		public void Normalize()
		{
			NormalizeOrdering();
			NormalizeZeros();
		}

		public void NormalizeOrdering()
		{
			for (int i = 0; i < RowCount; i++)
			{
				int num = RowPointers[i];
				int num2 = RowPointers[i + 1] - num;
				if (num2 > 1)
				{
					Sorting.Sort(ColumnIndices, Values, num, num2);
				}
			}
		}

		public void NormalizeZeros()
		{
			MapInplace((T x) => x, Zeros.AllowSkip);
		}

		public void NormalizeDuplicates()
		{
			MatrixBuilder<T> matrix = BuilderInstance<T>.Matrix;
			int num = 0;
			for (int i = 0; i < RowCount; i++)
			{
				int j = RowPointers[i];
				int num2 = RowPointers[i + 1];
				while (j < num2)
				{
					int num3 = ColumnIndices[j];
					T val = Values[j];
					for (j++; j < num2 && ColumnIndices[j] == num3; j++)
					{
						val = matrix.Add(val, Values[j]);
					}
					ColumnIndices[num] = num3;
					Values[num] = val;
					num++;
				}
				RowPointers[i + 1] = num;
			}
			Array.Resize(ref Values, num);
			Array.Resize(ref ColumnIndices, num);
		}

		public void PopulateExplicitZerosOnDiagonal()
		{
			int num = 0;
			for (int i = 0; i < RowCount; i++)
			{
				bool flag = false;
				for (int j = RowPointers[i]; j < RowPointers[i + 1]; j++)
				{
					if (ColumnIndices[j] == i)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					num++;
				}
			}
			if (num <= 0)
			{
				return;
			}
			int num2 = Values.Length + num;
			if (num2 > int.MaxValue)
			{
				throw new NotSupportedException("We only support sparse matrix with less than int.MaxValue elements.");
			}
			int[] array = new int[RowCount + 1];
			int[] array2 = new int[num2];
			T[] array3 = new T[num2];
			num = 0;
			for (int k = 0; k < RowCount; k++)
			{
				bool flag2 = false;
				for (int l = RowPointers[k]; l < RowPointers[k + 1]; l++)
				{
					array2[l + num] = ColumnIndices[l];
					array3[l + num] = Values[l];
					if (ColumnIndices[l] == k)
					{
						flag2 = true;
					}
				}
				if (!flag2)
				{
					int num3 = RowPointers[k] + num;
					int num4 = RowPointers[k + 1] + num;
					int count = num4 - num3 + 1;
					array2[num4] = k;
					array3[num4] = MatrixStorage<T>.Zero;
					Sorting.Sort(array2, array3, num3, count);
					num++;
				}
				array[k + 1] = RowPointers[k + 1] + num;
			}
			Array.Copy(array, RowPointers, RowCount + 1);
			ColumnIndices = array2;
			Values = array3;
		}

		public override int GetHashCode()
		{
			T[] values = Values;
			int num = Math.Min(ValueCount, 25);
			int num2 = 17;
			for (int i = 0; i < num; i++)
			{
				num2 = num2 * 31 + values[i].GetHashCode();
			}
			return num2;
		}

		public override void Clear()
		{
			Array.Clear(RowPointers, 0, RowPointers.Length);
		}

		internal override void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			if (rowIndex == 0 && columnIndex == 0 && rowCount == RowCount && columnCount == ColumnCount)
			{
				Clear();
				return;
			}
			int num = RowPointers[RowPointers.Length - 1];
			for (int num2 = rowIndex + rowCount - 1; num2 >= rowIndex; num2--)
			{
				int num3 = RowPointers[num2];
				int num4 = RowPointers[num2 + 1];
				if (num3 != num4)
				{
					int num5 = Array.BinarySearch(ColumnIndices, num3, num4 - num3, columnIndex);
					int num6 = Array.BinarySearch(ColumnIndices, num3, num4 - num3, columnIndex + columnCount - 1);
					if (num5 < 0)
					{
						num5 = ~num5;
					}
					if (num6 < 0)
					{
						num6 = ~num6 - 1;
					}
					int num7 = num6 - num5 + 1;
					if (num7 > 0)
					{
						Array.Copy(Values, num5 + num7, Values, num5, num - num5 - num7);
						Array.Copy(ColumnIndices, num5 + num7, ColumnIndices, num5, num - num5 - num7);
						for (int i = num2 + 1; i < RowPointers.Length; i++)
						{
							RowPointers[i] -= num7;
						}
						num -= num7;
					}
				}
			}
			if (num > 1024 && num < Values.Length / 2)
			{
				Array.Resize(ref Values, num);
				Array.Resize(ref ColumnIndices, num);
			}
		}

		internal override void ClearRowsUnchecked(int[] rowIndices)
		{
			bool[] rows = new bool[RowCount];
			for (int k = 0; k < rowIndices.Length; k++)
			{
				rows[rowIndices[k]] = true;
			}
			MapIndexedInplace((int i, int j, T x) => (!rows[i]) ? x : MatrixStorage<T>.Zero, Zeros.AllowSkip);
		}

		internal override void ClearColumnsUnchecked(int[] columnIndices)
		{
			bool[] columns = new bool[ColumnCount];
			for (int k = 0; k < columnIndices.Length; k++)
			{
				columns[columnIndices[k]] = true;
			}
			MapIndexedInplace((int i, int j, T x) => (!columns[j]) ? x : MatrixStorage<T>.Zero, Zeros.AllowSkip);
		}

		public static SparseCompressedRowMatrixStorage<T> OfMatrix(MatrixStorage<T> matrix)
		{
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(matrix.RowCount, matrix.ColumnCount);
			matrix.CopyToUnchecked(sparseCompressedRowMatrixStorage, ExistingData.AssumeZeros);
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfValue(int rows, int columns, T value)
		{
			T zero = MatrixStorage<T>.Zero;
			if (zero.Equals(value))
			{
				return new SparseCompressedRowMatrixStorage<T>(rows, columns);
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			T[] array = new T[rows * columns];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = value;
			}
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			for (int j = 0; j <= rows; j++)
			{
				rowPointers[j] = j * columns;
			}
			int[] array2 = new int[array.Length];
			for (int k = 0; k < rows; k++)
			{
				int num = k * columns;
				for (int l = 0; l < columns; l++)
				{
					array2[num + l] = l;
				}
			}
			rowPointers[rows] = array.Length;
			sparseCompressedRowMatrixStorage.ColumnIndices = array2;
			sparseCompressedRowMatrixStorage.Values = array;
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfInit(int rows, int columns, Func<int, int, T> init)
		{
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < rows; i++)
			{
				rowPointers[i] = list2.Count;
				for (int j = 0; j < columns; j++)
				{
					T val = init(i, j);
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(j);
					}
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfDiagonalInit(int rows, int columns, Func<int, T> init)
		{
			int num = Math.Min(rows, columns);
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>(num);
			List<T> list2 = new List<T>(num);
			for (int i = 0; i < num; i++)
			{
				rowPointers[i] = list2.Count;
				T val = init(i);
				T zero = MatrixStorage<T>.Zero;
				if (!zero.Equals(val))
				{
					list2.Add(val);
					list.Add(i);
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfArray(T[,] array)
		{
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(array.GetLength(0), array.GetLength(1));
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				rowPointers[i] = list2.Count;
				for (int j = 0; j < sparseCompressedRowMatrixStorage.ColumnCount; j++)
				{
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(array[i, j]))
					{
						list2.Add(array[i, j]);
						list.Add(j);
					}
				}
			}
			rowPointers[sparseCompressedRowMatrixStorage.RowCount] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfRowArrays(T[][] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(data.Length, data[0].Length);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				rowPointers[i] = list2.Count;
				for (int j = 0; j < sparseCompressedRowMatrixStorage.ColumnCount; j++)
				{
					T val = data[i][j];
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(j);
					}
				}
			}
			rowPointers[sparseCompressedRowMatrixStorage.RowCount] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfColumnArrays(T[][] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(data[0].Length, data.Length);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				rowPointers[i] = list2.Count;
				for (int j = 0; j < sparseCompressedRowMatrixStorage.ColumnCount; j++)
				{
					T val = data[j][i];
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(j);
					}
				}
			}
			rowPointers[sparseCompressedRowMatrixStorage.RowCount] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfRowVectors(VectorStorage<T>[] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(data.Length, data[0].Length);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				VectorStorage<T> vectorStorage = data[i];
				rowPointers[i] = list2.Count;
				for (int j = 0; j < sparseCompressedRowMatrixStorage.ColumnCount; j++)
				{
					T val = vectorStorage.At(j);
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(j);
					}
				}
			}
			rowPointers[sparseCompressedRowMatrixStorage.RowCount] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfColumnVectors(VectorStorage<T>[] data)
		{
			if (data.Length == 0)
			{
				throw new ArgumentOutOfRangeException("data", "Matrices can not be empty and must have at least one row and column.");
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(data[0].Length, data.Length);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				rowPointers[i] = list2.Count;
				for (int j = 0; j < sparseCompressedRowMatrixStorage.ColumnCount; j++)
				{
					T val = data[j].At(i);
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(j);
					}
				}
			}
			rowPointers[sparseCompressedRowMatrixStorage.RowCount] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfIndexedEnumerable(int rows, int columns, IEnumerable<Tuple<int, int, T>> data)
		{
			List<Tuple<int, T>>[] array = new List<Tuple<int, T>>[rows];
			foreach (Tuple<int, int, T> datum in data)
			{
				T zero = MatrixStorage<T>.Zero;
				if (!zero.Equals(datum.Item3))
				{
					(array[datum.Item1] ?? (array[datum.Item1] = new List<Tuple<int, T>>())).Add(new Tuple<int, T>(datum.Item2, datum.Item3));
				}
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			int num = 0;
			for (int i = 0; i < rows; i++)
			{
				rowPointers[i] = num;
				List<Tuple<int, T>> list3 = array[i];
				if (list3 == null)
				{
					continue;
				}
				list3.Sort();
				foreach (Tuple<int, T> item in list3)
				{
					list2.Add(item.Item2);
					list.Add(item.Item1);
					num++;
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfRowEnumerables(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			using (IEnumerator<IEnumerable<T>> enumerator = data.GetEnumerator())
			{
				for (int i = 0; i < rows; i++)
				{
					if (!enumerator.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
					}
					rowPointers[i] = list2.Count;
					using IEnumerator<T> enumerator2 = enumerator.Current.GetEnumerator();
					for (int j = 0; j < columns; j++)
					{
						if (!enumerator2.MoveNext())
						{
							throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
						}
						T zero = MatrixStorage<T>.Zero;
						if (!zero.Equals(enumerator2.Current))
						{
							list2.Add(enumerator2.Current);
							list.Add(j);
						}
					}
					if (enumerator2.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
					}
				}
				if (enumerator.MoveNext())
				{
					throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfColumnEnumerables(int rows, int columns, IEnumerable<IEnumerable<T>> data)
		{
			List<Tuple<int, T>>[] array = new List<Tuple<int, T>>[rows];
			using (IEnumerator<IEnumerable<T>> enumerator = data.GetEnumerator())
			{
				for (int i = 0; i < columns; i++)
				{
					if (!enumerator.MoveNext())
					{
						throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {columns}.");
					}
					using IEnumerator<T> enumerator2 = enumerator.Current.GetEnumerator();
					for (int j = 0; j < rows; j++)
					{
						if (!enumerator2.MoveNext())
						{
							throw new ArgumentOutOfRangeException("data", $"The given array has the wrong length. Should be {rows}.");
						}
						T zero = MatrixStorage<T>.Zero;
						if (!zero.Equals(enumerator2.Current))
						{
							(array[j] ?? (array[j] = new List<Tuple<int, T>>())).Add(new Tuple<int, T>(i, enumerator2.Current));
						}
					}
				}
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			int num = 0;
			for (int k = 0; k < rows; k++)
			{
				rowPointers[k] = num;
				List<Tuple<int, T>> list3 = array[k];
				if (list3 == null)
				{
					continue;
				}
				list3.Sort();
				foreach (Tuple<int, T> item in list3)
				{
					list2.Add(item.Item2);
					list.Add(item.Item1);
					num++;
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfRowMajorEnumerable(int rows, int columns, IEnumerable<T> data)
		{
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			using (IEnumerator<T> enumerator = data.GetEnumerator())
			{
				for (int i = 0; i < rows; i++)
				{
					rowPointers[i] = list2.Count;
					for (int j = 0; j < columns; j++)
					{
						enumerator.MoveNext();
						T zero = MatrixStorage<T>.Zero;
						if (!zero.Equals(enumerator.Current))
						{
							list2.Add(enumerator.Current);
							list.Add(j);
						}
					}
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfColumnMajorList(int rows, int columns, IList<T> data)
		{
			if (rows * columns != data.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < rows; i++)
			{
				rowPointers[i] = list2.Count;
				for (int j = 0; j < columns; j++)
				{
					T val = data[i + j * rows];
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(j);
					}
				}
			}
			rowPointers[rows] = list2.Count;
			sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
			sparseCompressedRowMatrixStorage.Values = list2.ToArray();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfCompressedSparseRowFormat(int rows, int columns, int valueCount, int[] rowPointers, int[] columnIndices, T[] values)
		{
			if (values == null)
			{
				throw new NullReferenceException("values");
			}
			if (columnIndices == null)
			{
				throw new NullReferenceException("columnIndices");
			}
			if (rowPointers == null)
			{
				throw new NullReferenceException("rowPointers");
			}
			if (rowPointers.Length < rows)
			{
				throw new Exception($"The given array has the wrong length. Should be {rows + 1}.");
			}
			if (valueCount != rowPointers[rows])
			{
				throw new Exception(string.Format("{0} should be same to {1}", "valueCount", rowPointers[rows]));
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			T[] array = new T[valueCount];
			Array.Copy(values, array, valueCount);
			int[] array2 = new int[valueCount];
			Array.Copy(columnIndices, array2, valueCount);
			Array.Copy(rowPointers, sparseCompressedRowMatrixStorage.RowPointers, rows + 1);
			sparseCompressedRowMatrixStorage.ColumnIndices = array2;
			sparseCompressedRowMatrixStorage.Values = array;
			sparseCompressedRowMatrixStorage.NormalizeOrdering();
			sparseCompressedRowMatrixStorage.NormalizeDuplicates();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfCompressedSparseColumnFormat(int rows, int columns, int valueCount, int[] rowIndices, int[] columnPointers, T[] values)
		{
			if (values == null)
			{
				throw new NullReferenceException("values");
			}
			if (rowIndices == null)
			{
				throw new NullReferenceException("rowIndices");
			}
			if (columnPointers == null)
			{
				throw new NullReferenceException("columnPointers");
			}
			if (columnPointers.Length < columns)
			{
				throw new Exception($"The given array has the wrong length. Should be {columns + 1}.");
			}
			if (valueCount != columnPointers[columns])
			{
				throw new Exception(string.Format("{0} should be same to {1}", "valueCount", columnPointers[columns]));
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			T[] array = new T[valueCount];
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			int[] array2 = new int[valueCount];
			for (int i = 0; i < columns; i++)
			{
				for (int j = columnPointers[i]; j < columnPointers[i + 1]; j++)
				{
					rowPointers[rowIndices[j] + 1]++;
				}
			}
			for (int k = 1; k < rows + 1; k++)
			{
				rowPointers[k] += rowPointers[k - 1];
			}
			int[] array3 = new int[rows];
			for (int l = 0; l < columns; l++)
			{
				for (int m = columnPointers[l]; m < columnPointers[l + 1]; m++)
				{
					int num = rowPointers[rowIndices[m]] + array3[rowIndices[m]];
					array3[rowIndices[m]]++;
					array2[num] = l;
					array[num] = values[m];
				}
			}
			sparseCompressedRowMatrixStorage.ColumnIndices = array2;
			sparseCompressedRowMatrixStorage.Values = array;
			sparseCompressedRowMatrixStorage.NormalizeOrdering();
			sparseCompressedRowMatrixStorage.NormalizeDuplicates();
			return sparseCompressedRowMatrixStorage;
		}

		public static SparseCompressedRowMatrixStorage<T> OfCoordinateFormat(int rows, int columns, int valueCount, int[] rowIndices, int[] columnIndices, T[] values)
		{
			if (values == null)
			{
				throw new NullReferenceException("values");
			}
			if (rowIndices == null)
			{
				throw new NullReferenceException("rowIndices");
			}
			if (columnIndices == null)
			{
				throw new NullReferenceException("columnIndices");
			}
			if (rowIndices.Length < valueCount || columnIndices.Length < valueCount || values.Length < valueCount)
			{
				throw new Exception($"The given array has the wrong length. Should be {valueCount}.");
			}
			SparseCompressedRowMatrixStorage<T> sparseCompressedRowMatrixStorage = new SparseCompressedRowMatrixStorage<T>(rows, columns);
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			int[] array = new int[valueCount];
			T[] array2 = new T[valueCount];
			for (int i = 0; i < valueCount; i++)
			{
				rowPointers[rowIndices[i]]++;
			}
			int j = 0;
			int num = 0;
			for (; j < rows; j++)
			{
				int num2 = rowPointers[j];
				rowPointers[j] = num;
				num += num2;
			}
			rowPointers[rows] = valueCount;
			for (int k = 0; k < valueCount; k++)
			{
				int num3 = rowIndices[k];
				int num4 = rowPointers[num3];
				array[num4] = columnIndices[k];
				array2[num4] = values[k];
				rowPointers[num3]++;
			}
			int l = 0;
			int num5 = 0;
			for (; l <= rows; l++)
			{
				int num6 = rowPointers[l];
				rowPointers[l] = num5;
				num5 = num6;
			}
			sparseCompressedRowMatrixStorage.ColumnIndices = array;
			sparseCompressedRowMatrixStorage.Values = array2;
			sparseCompressedRowMatrixStorage.NormalizeOrdering();
			sparseCompressedRowMatrixStorage.NormalizeDuplicates();
			return sparseCompressedRowMatrixStorage;
		}

		internal override void CopyToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			if (target is SparseCompressedRowMatrixStorage<T> target2)
			{
				CopyToUnchecked(target2);
				return;
			}
			if (target is DenseColumnMajorMatrixStorage<T> target3)
			{
				CopyToUnchecked(target3, existingData);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			if (ValueCount == 0)
			{
				return;
			}
			for (int i = 0; i < RowCount; i++)
			{
				int num = RowPointers[i];
				int num2 = RowPointers[i + 1];
				for (int j = num; j < num2; j++)
				{
					target.At(i, ColumnIndices[j], Values[j]);
				}
			}
		}

		private void CopyToUnchecked(SparseCompressedRowMatrixStorage<T> target)
		{
			target.Values = new T[ValueCount];
			target.ColumnIndices = new int[ValueCount];
			if (ValueCount != 0)
			{
				Array.Copy(Values, 0, target.Values, 0, ValueCount);
				Buffer.BlockCopy(ColumnIndices, 0, target.ColumnIndices, 0, ValueCount * 4);
				Buffer.BlockCopy(RowPointers, 0, target.RowPointers, 0, (RowCount + 1) * 4);
			}
		}

		private void CopyToUnchecked(DenseColumnMajorMatrixStorage<T> target, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			if (ValueCount == 0)
			{
				return;
			}
			for (int i = 0; i < RowCount; i++)
			{
				int num = RowPointers[i];
				int num2 = RowPointers[i + 1];
				for (int j = num; j < num2; j++)
				{
					target.At(i, ColumnIndices[j], Values[j]);
				}
			}
		}

		internal override void CopySubMatrixToUnchecked(MatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (target is SparseCompressedRowMatrixStorage<T> target2)
			{
				CopySubMatrixToUnchecked(target2, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			int num = sourceRowIndex;
			int num2 = 0;
			while (num < sourceRowIndex + rowCount)
			{
				int num3 = RowPointers[num];
				int num4 = RowPointers[num + 1];
				for (int i = num3; i < num4; i++)
				{
					if (ColumnIndices[i] >= sourceColumnIndex && ColumnIndices[i] < sourceColumnIndex + columnCount)
					{
						int num5 = ColumnIndices[i] - sourceColumnIndex;
						target.At(targetRowIndex + num2, targetColumnIndex + num5, Values[i]);
					}
				}
				num++;
				num2++;
			}
		}

		private void CopySubMatrixToUnchecked(SparseCompressedRowMatrixStorage<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			int num = targetRowIndex - sourceRowIndex;
			int num2 = targetColumnIndex - sourceColumnIndex;
			if (target.ValueCount == 0)
			{
				List<T> list = new List<T>(ValueCount);
				List<int> list2 = new List<int>(ValueCount);
				int[] rowPointers = target.RowPointers;
				for (int i = sourceRowIndex; i < sourceRowIndex + rowCount; i++)
				{
					rowPointers[i + num] = list.Count;
					int num3 = RowPointers[i];
					int num4 = RowPointers[i + 1];
					for (int j = num3; j < num4; j++)
					{
						if (ColumnIndices[j] >= sourceColumnIndex && ColumnIndices[j] < sourceColumnIndex + columnCount)
						{
							list.Add(Values[j]);
							list2.Add(ColumnIndices[j] + num2);
						}
					}
				}
				for (int k = targetRowIndex + rowCount; k < rowPointers.Length; k++)
				{
					rowPointers[k] = list.Count;
				}
				target.RowPointers[target.RowCount] = list.Count;
				target.Values = list.ToArray();
				target.ColumnIndices = list2.ToArray();
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			int num5 = sourceRowIndex;
			for (int l = 0; l < rowCount; l++)
			{
				int num6 = RowPointers[num5];
				int num7 = RowPointers[num5 + 1];
				for (int m = num6; m < num7; m++)
				{
					if (ColumnIndices[m] >= sourceColumnIndex && ColumnIndices[m] < sourceColumnIndex + columnCount)
					{
						int num8 = ColumnIndices[m] - sourceColumnIndex;
						target.At(targetRowIndex + l, targetColumnIndex + num8, Values[m]);
					}
				}
				num5++;
			}
		}

		internal override void CopySubRowToUnchecked(VectorStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			int num = RowPointers[rowIndex];
			int num2 = RowPointers[rowIndex + 1];
			if (num == num2)
			{
				if (existingData == ExistingData.Clear)
				{
					target.Clear(targetColumnIndex, columnCount);
				}
			}
			else if (target is SparseVectorStorage<T> sparseVectorStorage)
			{
				if (sourceColumnIndex == 0 && targetColumnIndex == 0 && columnCount == ColumnCount && ColumnCount == sparseVectorStorage.Length)
				{
					sparseVectorStorage.ValueCount = num2 - num;
					sparseVectorStorage.Values = new T[sparseVectorStorage.ValueCount];
					sparseVectorStorage.Indices = new int[sparseVectorStorage.ValueCount];
					Array.Copy(ColumnIndices, num, sparseVectorStorage.Indices, 0, sparseVectorStorage.ValueCount);
					Array.Copy(Values, num, sparseVectorStorage.Values, 0, sparseVectorStorage.ValueCount);
					return;
				}
				int num3 = Array.BinarySearch(ColumnIndices, num, num2 - num, sourceColumnIndex);
				if (num3 < 0)
				{
					num3 = ~num3;
				}
				int num4 = Array.BinarySearch(ColumnIndices, num, num2 - num, sourceColumnIndex + columnCount);
				if (num4 < 0)
				{
					num4 = ~num4;
				}
				int num5 = num4 - num3;
				if (num5 > 0)
				{
					int num6 = Array.BinarySearch(sparseVectorStorage.Indices, 0, sparseVectorStorage.ValueCount, targetColumnIndex);
					if (num6 < 0)
					{
						num6 = ~num6;
					}
					int num7 = Array.BinarySearch(sparseVectorStorage.Indices, 0, sparseVectorStorage.ValueCount, targetColumnIndex + columnCount);
					if (num7 < 0)
					{
						num7 = Math.Max(~num7, num6);
					}
					int num8 = sparseVectorStorage.ValueCount - (num7 - num6) + num5;
					T[] array = new T[num8];
					int[] array2 = new int[num8];
					Array.Copy(sparseVectorStorage.Indices, 0, array2, 0, num6);
					Array.Copy(sparseVectorStorage.Values, 0, array, 0, num6);
					int num9 = targetColumnIndex - sourceColumnIndex;
					for (int i = 0; i < num5; i++)
					{
						array2[num6 + i] = ColumnIndices[num3 + i] + num9;
					}
					Array.Copy(Values, num3, array, num6, num5);
					Array.Copy(sparseVectorStorage.Indices, num7, array2, num5 + num6, sparseVectorStorage.ValueCount - num7);
					Array.Copy(sparseVectorStorage.Values, num7, array, num5 + num6, sparseVectorStorage.ValueCount - num7);
					sparseVectorStorage.Values = array;
					sparseVectorStorage.Indices = array2;
					sparseVectorStorage.ValueCount = num8;
				}
				else if (existingData == ExistingData.Clear)
				{
					target.Clear(targetColumnIndex, columnCount);
				}
			}
			else
			{
				if (existingData == ExistingData.Clear)
				{
					target.Clear(targetColumnIndex, columnCount);
				}
				int num10 = sourceColumnIndex;
				int num11 = 0;
				while (num10 < sourceColumnIndex + columnCount)
				{
					int num12 = FindItem(rowIndex, num10);
					target.At(num11, (num12 >= 0) ? Values[num12] : MatrixStorage<T>.Zero);
					num10++;
					num11++;
				}
			}
		}

		internal override void TransposeToUnchecked(MatrixStorage<T> target, ExistingData existingData)
		{
			if (target is SparseCompressedRowMatrixStorage<T> target2)
			{
				TransposeToUnchecked(target2);
				return;
			}
			if (target is DenseColumnMajorMatrixStorage<T> target3)
			{
				TransposeToUnchecked(target3, existingData);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			if (ValueCount == 0)
			{
				return;
			}
			for (int i = 0; i < RowCount; i++)
			{
				int num = RowPointers[i];
				int num2 = RowPointers[i + 1];
				for (int j = num; j < num2; j++)
				{
					target.At(ColumnIndices[j], i, Values[j]);
				}
			}
		}

		private void TransposeToUnchecked(SparseCompressedRowMatrixStorage<T> target)
		{
			target.Values = new T[ValueCount];
			target.ColumnIndices = new int[ValueCount];
			T[] values = target.Values;
			int[] rowPointers = target.RowPointers;
			int[] columnIndices = target.ColumnIndices;
			int[] array = new int[ColumnCount];
			for (int i = 0; i < RowPointers[RowCount]; i++)
			{
				array[ColumnIndices[i]]++;
			}
			int num = 0;
			for (int j = 0; j < ColumnCount; j++)
			{
				rowPointers[j] = num;
				num += array[j];
				array[j] = rowPointers[j];
			}
			rowPointers[ColumnCount] = num;
			for (int k = 0; k < RowCount; k++)
			{
				for (int l = RowPointers[k]; l < RowPointers[k + 1]; l++)
				{
					int num2 = array[ColumnIndices[l]]++;
					columnIndices[num2] = k;
					values[num2] = Values[l];
				}
			}
		}

		private void TransposeToUnchecked(DenseColumnMajorMatrixStorage<T> target, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			if (ValueCount == 0)
			{
				return;
			}
			for (int i = 0; i < RowCount; i++)
			{
				int num = i * ColumnCount;
				int num2 = RowPointers[i];
				int num3 = RowPointers[i + 1];
				for (int j = num2; j < num3; j++)
				{
					target.Data[num + ColumnIndices[j]] = Values[j];
				}
			}
		}

		internal override void TransposeSquareInplaceUnchecked()
		{
			T[] array = new T[ValueCount];
			int[] array2 = new int[RowCount + 1];
			int[] array3 = new int[ValueCount];
			int[] array4 = new int[ColumnCount];
			for (int i = 0; i < RowPointers[RowCount]; i++)
			{
				array4[ColumnIndices[i]]++;
			}
			int num = 0;
			for (int j = 0; j < ColumnCount; j++)
			{
				array2[j] = num;
				num += array4[j];
				array4[j] = array2[j];
			}
			array2[ColumnCount] = num;
			for (int k = 0; k < RowCount; k++)
			{
				for (int l = RowPointers[k]; l < RowPointers[k + 1]; l++)
				{
					int num2 = array4[ColumnIndices[l]]++;
					array3[num2] = k;
					array[num2] = Values[l];
				}
			}
			Array.Copy(array, 0, Values, 0, ValueCount);
			Buffer.BlockCopy(array3, 0, ColumnIndices, 0, ValueCount * 4);
			Buffer.BlockCopy(array2, 0, RowPointers, 0, (RowCount + 1) * 4);
		}

		public override T[] ToRowMajorArray()
		{
			T[] array = new T[RowCount * ColumnCount];
			if (ValueCount != 0)
			{
				for (int i = 0; i < RowCount; i++)
				{
					int num = i * ColumnCount;
					int num2 = RowPointers[i];
					int num3 = RowPointers[i + 1];
					for (int j = num2; j < num3; j++)
					{
						array[num + ColumnIndices[j]] = Values[j];
					}
				}
			}
			return array;
		}

		public override T[] ToColumnMajorArray()
		{
			T[] array = new T[RowCount * ColumnCount];
			if (ValueCount != 0)
			{
				for (int i = 0; i < RowCount; i++)
				{
					int num = RowPointers[i];
					int num2 = RowPointers[i + 1];
					for (int j = num; j < num2; j++)
					{
						array[ColumnIndices[j] * RowCount + i] = Values[j];
					}
				}
			}
			return array;
		}

		public override T[][] ToRowArrays()
		{
			T[][] array = new T[RowCount][];
			if (ValueCount != 0)
			{
				for (int i = 0; i < RowCount; i++)
				{
					T[] array2 = new T[ColumnCount];
					int num = RowPointers[i];
					int num2 = RowPointers[i + 1];
					for (int j = num; j < num2; j++)
					{
						array2[ColumnIndices[j]] = Values[j];
					}
					array[i] = array2;
				}
			}
			return array;
		}

		public override T[][] ToColumnArrays()
		{
			T[][] array = new T[ColumnCount][];
			for (int i = 0; i < ColumnCount; i++)
			{
				array[i] = new T[RowCount];
			}
			if (ValueCount != 0)
			{
				for (int j = 0; j < RowCount; j++)
				{
					int num = RowPointers[j];
					int num2 = RowPointers[j + 1];
					for (int k = num; k < num2; k++)
					{
						array[ColumnIndices[k]][j] = Values[k];
					}
				}
			}
			return array;
		}

		public override T[,] ToArray()
		{
			T[,] array = new T[RowCount, ColumnCount];
			if (ValueCount != 0)
			{
				for (int i = 0; i < RowCount; i++)
				{
					int num = RowPointers[i];
					int num2 = RowPointers[i + 1];
					for (int j = num; j < num2; j++)
					{
						array[i, ColumnIndices[j]] = Values[j];
					}
				}
			}
			return array;
		}

		public override IEnumerable<T> Enumerate()
		{
			int i = 0;
			for (int row = 0; row < RowCount; row++)
			{
				for (int col = 0; col < ColumnCount; col++)
				{
					yield return (i < RowPointers[row + 1] && ColumnIndices[i] == col) ? Values[i++] : MatrixStorage<T>.Zero;
				}
			}
		}

		public override IEnumerable<Tuple<int, int, T>> EnumerateIndexed()
		{
			int i = 0;
			for (int row = 0; row < RowCount; row++)
			{
				for (int col = 0; col < ColumnCount; col++)
				{
					yield return (i < RowPointers[row + 1] && ColumnIndices[i] == col) ? new Tuple<int, int, T>(row, col, Values[i++]) : new Tuple<int, int, T>(row, col, MatrixStorage<T>.Zero);
				}
			}
		}

		public override IEnumerable<T> EnumerateNonZero()
		{
			return Values.Take(ValueCount).Where(delegate(T x)
			{
				T zero = MatrixStorage<T>.Zero;
				return !zero.Equals(x);
			});
		}

		public override IEnumerable<Tuple<int, int, T>> EnumerateNonZeroIndexed()
		{
			for (int row = 0; row < RowCount; row++)
			{
				int num = RowPointers[row];
				int endIndex = RowPointers[row + 1];
				for (int i = num; i < endIndex; i++)
				{
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(Values[i]))
					{
						yield return new Tuple<int, int, T>(row, ColumnIndices[i], Values[i]);
					}
				}
			}
		}

		public override Tuple<int, int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < RowCount; i++)
			{
				int num = RowPointers[i];
				int num2 = RowPointers[i + 1];
				for (int j = num; j < num2; j++)
				{
					if (predicate(Values[j]))
					{
						return new Tuple<int, int, T>(i, ColumnIndices[j], Values[j]);
					}
				}
			}
			if (zeros == Zeros.Include && ValueCount < RowCount * ColumnCount && predicate(MatrixStorage<T>.Zero))
			{
				int num3 = 0;
				for (int k = 0; k < RowCount; k++)
				{
					for (int l = 0; l < ColumnCount; l++)
					{
						if (num3 < RowPointers[k + 1] && ColumnIndices[num3] == l)
						{
							num3++;
							continue;
						}
						return new Tuple<int, int, T>(k, l, MatrixStorage<T>.Zero);
					}
				}
			}
			return null;
		}

		internal override Tuple<int, int, T, TOther> Find2Unchecked<TOther>(MatrixStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros)
		{
			if (other is DenseColumnMajorMatrixStorage<TOther> denseColumnMajorMatrixStorage)
			{
				TOther[] data = denseColumnMajorMatrixStorage.Data;
				int num = 0;
				for (int i = 0; i < RowCount; i++)
				{
					for (int j = 0; j < ColumnCount; j++)
					{
						bool flag = num < RowPointers[i + 1] && ColumnIndices[num] == j;
						if (predicate(flag ? Values[num++] : MatrixStorage<T>.Zero, data[j * RowCount + i]))
						{
							return new Tuple<int, int, T, TOther>(i, j, flag ? Values[num - 1] : MatrixStorage<T>.Zero, data[j * RowCount + i]);
						}
					}
				}
				return null;
			}
			if (other is DiagonalMatrixStorage<TOther> diagonalMatrixStorage)
			{
				TOther[] data2 = diagonalMatrixStorage.Data;
				TOther zero = BuilderInstance<TOther>.Matrix.Zero;
				if (zeros == Zeros.Include && predicate(MatrixStorage<T>.Zero, zero))
				{
					int num2 = 0;
					for (int k = 0; k < RowCount; k++)
					{
						for (int l = 0; l < ColumnCount; l++)
						{
							bool flag2 = num2 < RowPointers[k + 1] && ColumnIndices[num2] == l;
							if (predicate(flag2 ? Values[num2++] : MatrixStorage<T>.Zero, (k == l) ? data2[k] : zero))
							{
								return new Tuple<int, int, T, TOther>(k, l, flag2 ? Values[num2 - 1] : MatrixStorage<T>.Zero, (k == l) ? data2[k] : zero);
							}
						}
					}
					return null;
				}
				for (int m = 0; m < RowCount; m++)
				{
					bool flag3 = false;
					int num3 = RowPointers[m];
					int num4 = RowPointers[m + 1];
					for (int n = num3; n < num4; n++)
					{
						if (ColumnIndices[n] == m)
						{
							flag3 = true;
							if (predicate(Values[n], data2[m]))
							{
								return new Tuple<int, int, T, TOther>(m, m, Values[n], data2[m]);
							}
						}
						else if (predicate(Values[n], zero))
						{
							return new Tuple<int, int, T, TOther>(m, ColumnIndices[n], Values[n], zero);
						}
					}
					if (!flag3 && m < ColumnCount && predicate(MatrixStorage<T>.Zero, data2[m]))
					{
						return new Tuple<int, int, T, TOther>(m, m, MatrixStorage<T>.Zero, data2[m]);
					}
				}
				return null;
			}
			if (other is SparseCompressedRowMatrixStorage<TOther> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
				TOther[] values = sparseCompressedRowMatrixStorage.Values;
				TOther zero2 = BuilderInstance<TOther>.Matrix.Zero;
				if (zeros == Zeros.Include)
				{
					int num5 = 0;
					int num6 = 0;
					for (int num7 = 0; num7 < RowCount; num7++)
					{
						for (int num8 = 0; num8 < ColumnCount; num8++)
						{
							bool flag4 = num5 < RowPointers[num7 + 1] && ColumnIndices[num5] == num8;
							bool flag5 = num6 < rowPointers[num7 + 1] && columnIndices[num6] == num8;
							if (predicate(flag4 ? Values[num5++] : MatrixStorage<T>.Zero, flag5 ? values[num6++] : zero2))
							{
								return new Tuple<int, int, T, TOther>(num7, num8, flag4 ? Values[num5 - 1] : MatrixStorage<T>.Zero, flag5 ? values[num6 - 1] : zero2);
							}
						}
					}
					return null;
				}
				for (int num9 = 0; num9 < RowCount; num9++)
				{
					int num10 = RowPointers[num9 + 1];
					int num11 = rowPointers[num9 + 1];
					int num12 = RowPointers[num9];
					int num13 = rowPointers[num9];
					while (num12 < num10 || num13 < num11)
					{
						if (num12 == num10 || (num13 < num11 && ColumnIndices[num12] > columnIndices[num13]))
						{
							if (predicate(MatrixStorage<T>.Zero, values[num13++]))
							{
								return new Tuple<int, int, T, TOther>(num9, columnIndices[num13 - 1], MatrixStorage<T>.Zero, values[num13 - 1]);
							}
						}
						else if (num13 == num11 || ColumnIndices[num12] < columnIndices[num13])
						{
							if (predicate(Values[num12++], zero2))
							{
								return new Tuple<int, int, T, TOther>(num9, ColumnIndices[num12 - 1], Values[num12 - 1], zero2);
							}
						}
						else if (predicate(Values[num12++], values[num13++]))
						{
							return new Tuple<int, int, T, TOther>(num9, ColumnIndices[num12 - 1], Values[num12 - 1], values[num13 - 1]);
						}
					}
				}
				return null;
			}
			return base.Find2Unchecked(other, predicate, zeros);
		}

		public override void MapInplace(Func<T, T> f, Zeros zeros)
		{
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				if (zero.Equals(f(MatrixStorage<T>.Zero)))
				{
					int num = 0;
					for (int i = 0; i < RowCount; i++)
					{
						int num2 = RowPointers[i];
						int num3 = RowPointers[i + 1];
						RowPointers[i] = num;
						for (int j = num2; j < num3; j++)
						{
							T val = f(Values[j]);
							zero = MatrixStorage<T>.Zero;
							if (!zero.Equals(val))
							{
								Values[num] = val;
								ColumnIndices[num] = ColumnIndices[j];
								num++;
							}
						}
					}
					Array.Resize(ref ColumnIndices, num);
					Array.Resize(ref Values, num);
					RowPointers[RowCount] = num;
					return;
				}
			}
			int[] rowPointers = RowPointers;
			List<int> list = new List<int>(ColumnIndices.Length);
			List<T> list2 = new List<T>(Values.Length);
			int num4 = 0;
			for (int k = 0; k < RowCount; k++)
			{
				rowPointers[k] = list2.Count;
				for (int l = 0; l < ColumnCount; l++)
				{
					T val2 = ((num4 < RowPointers[k + 1] && ColumnIndices[num4] == l) ? f(Values[num4++]) : f(MatrixStorage<T>.Zero));
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val2))
					{
						list2.Add(val2);
						list.Add(l);
					}
				}
			}
			ColumnIndices = list.ToArray();
			Values = list2.ToArray();
			rowPointers[RowCount] = list2.Count;
		}

		public override void MapIndexedInplace(Func<int, int, T, T> f, Zeros zeros)
		{
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				if (zero.Equals(f(0, 1, MatrixStorage<T>.Zero)))
				{
					int num = 0;
					for (int i = 0; i < RowCount; i++)
					{
						int num2 = RowPointers[i];
						int num3 = RowPointers[i + 1];
						RowPointers[i] = num;
						for (int j = num2; j < num3; j++)
						{
							T val = f(i, ColumnIndices[j], Values[j]);
							zero = MatrixStorage<T>.Zero;
							if (!zero.Equals(val))
							{
								Values[num] = val;
								ColumnIndices[num] = ColumnIndices[j];
								num++;
							}
						}
					}
					Array.Resize(ref ColumnIndices, num);
					Array.Resize(ref Values, num);
					RowPointers[RowCount] = num;
					return;
				}
			}
			int[] rowPointers = RowPointers;
			List<int> list = new List<int>(ColumnIndices.Length);
			List<T> list2 = new List<T>(Values.Length);
			int num4 = 0;
			for (int k = 0; k < RowCount; k++)
			{
				rowPointers[k] = list2.Count;
				for (int l = 0; l < ColumnCount; l++)
				{
					T val2 = ((num4 < RowPointers[k + 1] && ColumnIndices[num4] == l) ? f(k, l, Values[num4++]) : f(k, l, MatrixStorage<T>.Zero));
					T zero = MatrixStorage<T>.Zero;
					if (!zero.Equals(val2))
					{
						list2.Add(val2);
						list.Add(l);
					}
				}
			}
			ColumnIndices = list.ToArray();
			Values = list2.ToArray();
			rowPointers[RowCount] = list2.Count;
		}

		internal override void MapToUnchecked<TU>(MatrixStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData)
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			if (target is SparseCompressedRowMatrixStorage<TU> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				List<int> list = new List<int>(ColumnIndices.Length);
				List<TU> list2 = new List<TU>(Values.Length);
				if (flag)
				{
					int num2 = 0;
					for (int i = 0; i < RowCount; i++)
					{
						rowPointers[i] = list2.Count;
						for (int j = 0; j < ColumnCount; j++)
						{
							TU val = ((num2 < RowPointers[i + 1] && ColumnIndices[num2] == j) ? f(Values[num2++]) : f(MatrixStorage<T>.Zero));
							T zero = MatrixStorage<T>.Zero;
							if (!zero.Equals(val))
							{
								list2.Add(val);
								list.Add(j);
							}
						}
					}
				}
				else
				{
					for (int k = 0; k < RowCount; k++)
					{
						rowPointers[k] = list2.Count;
						int num3 = RowPointers[k];
						int num4 = RowPointers[k + 1];
						for (int l = num3; l < num4; l++)
						{
							TU val2 = f(Values[l]);
							T zero = MatrixStorage<T>.Zero;
							if (!zero.Equals(val2))
							{
								list2.Add(val2);
								list.Add(ColumnIndices[l]);
							}
						}
					}
				}
				sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
				sparseCompressedRowMatrixStorage.Values = list2.ToArray();
				rowPointers[RowCount] = list2.Count;
				return;
			}
			if (existingData == ExistingData.Clear && !flag)
			{
				target.Clear();
			}
			if (flag)
			{
				for (int m = 0; m < RowCount; m++)
				{
					int num5 = RowPointers[m];
					int num6 = RowPointers[m + 1];
					for (int n = 0; n < ColumnCount; n++)
					{
						if (num5 < num6 && n == ColumnIndices[num5])
						{
							target.At(m, n, f(Values[num5]));
							num5 = Math.Min(num5 + 1, num6);
						}
						else
						{
							target.At(m, n, f(MatrixStorage<T>.Zero));
						}
					}
				}
				return;
			}
			for (int num7 = 0; num7 < RowCount; num7++)
			{
				int num8 = RowPointers[num7];
				int num9 = RowPointers[num7 + 1];
				for (int num10 = num8; num10 < num9; num10++)
				{
					target.At(num7, ColumnIndices[num10], f(Values[num10]));
				}
			}
		}

		internal override void MapIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, Zeros zeros, ExistingData existingData)
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(0, 1, MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			if (target is SparseCompressedRowMatrixStorage<TU> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				List<int> list = new List<int>(ColumnIndices.Length);
				List<TU> list2 = new List<TU>(Values.Length);
				if (flag)
				{
					int num2 = 0;
					for (int i = 0; i < RowCount; i++)
					{
						rowPointers[i] = list2.Count;
						for (int j = 0; j < ColumnCount; j++)
						{
							TU val = ((num2 < RowPointers[i + 1] && ColumnIndices[num2] == j) ? f(i, j, Values[num2++]) : f(i, j, MatrixStorage<T>.Zero));
							T zero = MatrixStorage<T>.Zero;
							if (!zero.Equals(val))
							{
								list2.Add(val);
								list.Add(j);
							}
						}
					}
				}
				else
				{
					for (int k = 0; k < RowCount; k++)
					{
						rowPointers[k] = list2.Count;
						int num3 = RowPointers[k];
						int num4 = RowPointers[k + 1];
						for (int l = num3; l < num4; l++)
						{
							TU val2 = f(k, ColumnIndices[l], Values[l]);
							T zero = MatrixStorage<T>.Zero;
							if (!zero.Equals(val2))
							{
								list2.Add(val2);
								list.Add(ColumnIndices[l]);
							}
						}
					}
				}
				sparseCompressedRowMatrixStorage.ColumnIndices = list.ToArray();
				sparseCompressedRowMatrixStorage.Values = list2.ToArray();
				rowPointers[RowCount] = list2.Count;
				return;
			}
			if (existingData == ExistingData.Clear && !flag)
			{
				target.Clear();
			}
			if (flag)
			{
				for (int m = 0; m < RowCount; m++)
				{
					int num5 = RowPointers[m];
					int num6 = RowPointers[m + 1];
					for (int n = 0; n < ColumnCount; n++)
					{
						if (num5 < num6 && n == ColumnIndices[num5])
						{
							target.At(m, n, f(m, n, Values[num5]));
							num5 = Math.Min(num5 + 1, num6);
						}
						else
						{
							target.At(m, n, f(m, n, MatrixStorage<T>.Zero));
						}
					}
				}
				return;
			}
			for (int num7 = 0; num7 < RowCount; num7++)
			{
				int num8 = RowPointers[num7];
				int num9 = RowPointers[num7 + 1];
				for (int num10 = num8; num10 < num9; num10++)
				{
					target.At(num7, ColumnIndices[num10], f(num7, ColumnIndices[num10], Values[num10]));
				}
			}
		}

		internal override void MapSubMatrixIndexedToUnchecked<TU>(MatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData)
		{
			if (target is SparseCompressedRowMatrixStorage<TU> target2)
			{
				MapSubMatrixIndexedToUnchecked(target2, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData);
				return;
			}
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(0, 1, MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			if (existingData == ExistingData.Clear && !flag)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			if (flag)
			{
				int num2 = sourceRowIndex;
				int num3 = targetRowIndex;
				while (num2 < sourceRowIndex + rowCount)
				{
					int i = RowPointers[num2];
					int num4;
					for (num4 = RowPointers[num2 + 1]; ColumnIndices[i] < sourceColumnIndex && i < num4; i++)
					{
					}
					int num5 = sourceColumnIndex;
					int num6 = targetColumnIndex;
					while (num5 < sourceColumnIndex + columnCount)
					{
						if (i < num4 && num5 == ColumnIndices[i])
						{
							target.At(num3, num6, f(num3, num6, Values[i]));
							i = Math.Min(i + 1, num4);
						}
						else
						{
							target.At(num3, num6, f(num3, num6, MatrixStorage<T>.Zero));
						}
						num5++;
						num6++;
					}
					num2++;
					num3++;
				}
				return;
			}
			int num7 = targetColumnIndex - sourceColumnIndex;
			int num8 = sourceRowIndex;
			int num9 = targetRowIndex;
			while (num8 < sourceRowIndex + rowCount)
			{
				int num10 = RowPointers[num8];
				int num11 = RowPointers[num8 + 1];
				for (int j = num10; j < num11; j++)
				{
					if (ColumnIndices[j] >= sourceColumnIndex && ColumnIndices[j] < sourceColumnIndex + columnCount)
					{
						int num12 = ColumnIndices[j] + num7;
						target.At(num9, num12, f(num9, num12, Values[j]));
					}
				}
				num8++;
				num9++;
			}
		}

		private void MapSubMatrixIndexedToUnchecked<TU>(SparseCompressedRowMatrixStorage<TU> target, Func<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = MatrixStorage<T>.Zero;
				num = ((!zero.Equals(f(0, 1, MatrixStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			if (existingData == ExistingData.Clear && !flag)
			{
				target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
			}
			int num2 = targetRowIndex - sourceRowIndex;
			int num3 = targetColumnIndex - sourceColumnIndex;
			TU zero2 = Matrix<TU>.Zero;
			if (target.ValueCount == 0)
			{
				List<TU> list = new List<TU>(ValueCount);
				List<int> list2 = new List<int>(ValueCount);
				int[] rowPointers = target.RowPointers;
				if (flag)
				{
					for (int i = sourceRowIndex; i < sourceRowIndex + rowCount; i++)
					{
						int num4 = i + num2;
						rowPointers[num4] = list.Count;
						int j = RowPointers[i];
						int num5;
						for (num5 = RowPointers[i + 1]; ColumnIndices[j] < sourceColumnIndex && j < num5; j++)
						{
						}
						int num6 = sourceColumnIndex;
						int num7 = targetColumnIndex;
						while (num6 < sourceColumnIndex + columnCount)
						{
							if (j < num5 && num6 == ColumnIndices[j])
							{
								TU val = f(num4, num7, Values[j]);
								if (!zero2.Equals(val))
								{
									list.Add(val);
									list2.Add(num7);
								}
								j = Math.Min(j + 1, num5);
							}
							else
							{
								TU val2 = f(num4, num7, MatrixStorage<T>.Zero);
								if (!zero2.Equals(val2))
								{
									list.Add(val2);
									list2.Add(num7);
								}
							}
							num6++;
							num7++;
						}
					}
				}
				else
				{
					for (int k = sourceRowIndex; k < sourceRowIndex + rowCount; k++)
					{
						int num8 = k + num2;
						rowPointers[num8] = list.Count;
						int num9 = RowPointers[k];
						int num10 = RowPointers[k + 1];
						for (int l = num9; l < num10; l++)
						{
							if (ColumnIndices[l] >= sourceColumnIndex && ColumnIndices[l] < sourceColumnIndex + columnCount)
							{
								int num11 = ColumnIndices[l] + num3;
								TU val3 = f(num8, num11, Values[l]);
								if (!zero2.Equals(val3))
								{
									list.Add(val3);
									list2.Add(num11);
								}
							}
						}
					}
				}
				for (int m = targetRowIndex + rowCount; m < rowPointers.Length; m++)
				{
					rowPointers[m] = list.Count;
				}
				target.RowPointers[target.RowCount] = list.Count;
				target.Values = list.ToArray();
				target.ColumnIndices = list2.ToArray();
				return;
			}
			if (flag)
			{
				int num12 = sourceRowIndex;
				int num13 = targetRowIndex;
				while (num12 < sourceRowIndex + rowCount)
				{
					int n = RowPointers[num12];
					int num14;
					for (num14 = RowPointers[num12 + 1]; ColumnIndices[n] < sourceColumnIndex && n < num14; n++)
					{
					}
					int num15 = sourceColumnIndex;
					int num16 = targetColumnIndex;
					while (num15 < sourceColumnIndex + columnCount)
					{
						if (n < num14 && num15 == ColumnIndices[n])
						{
							target.At(num13, num16, f(num13, num16, Values[n]));
							n = Math.Min(n + 1, num14);
						}
						else
						{
							target.At(num13, num16, f(num13, num16, MatrixStorage<T>.Zero));
						}
						num15++;
						num16++;
					}
					num12++;
					num13++;
				}
				return;
			}
			int num17 = sourceRowIndex;
			int num18 = targetRowIndex;
			while (num17 < sourceRowIndex + rowCount)
			{
				int num19 = RowPointers[num17];
				int num20 = RowPointers[num17 + 1];
				for (int num21 = num19; num21 < num20; num21++)
				{
					if (ColumnIndices[num21] >= sourceColumnIndex && ColumnIndices[num21] < sourceColumnIndex + columnCount)
					{
						int num22 = ColumnIndices[num21] + num3;
						target.At(num18, num22, f(num18, num22, Values[num21]));
					}
				}
				num17++;
				num18++;
			}
		}

		internal override void FoldByRowUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			if (zeros == Zeros.AllowSkip)
			{
				for (int i = 0; i < RowCount; i++)
				{
					int num = RowPointers[i];
					int num2 = RowPointers[i + 1];
					TU arg = state[i];
					for (int j = num; j < num2; j++)
					{
						arg = f(arg, Values[j]);
					}
					target[i] = finalize(arg, num2 - num);
				}
				return;
			}
			for (int k = 0; k < RowCount; k++)
			{
				int num3 = RowPointers[k];
				int num4 = RowPointers[k + 1];
				TU arg2 = state[k];
				for (int l = 0; l < ColumnCount; l++)
				{
					if (num3 < num4 && l == ColumnIndices[num3])
					{
						arg2 = f(arg2, Values[num3]);
						num3 = Math.Min(num3 + 1, num4);
					}
					else
					{
						arg2 = f(arg2, MatrixStorage<T>.Zero);
					}
				}
				target[k] = finalize(arg2, ColumnCount);
			}
		}

		internal override void FoldByColumnUnchecked<TU>(TU[] target, Func<TU, T, TU> f, Func<TU, int, TU> finalize, TU[] state, Zeros zeros)
		{
			if (state != target)
			{
				Array.Copy(state, 0, target, 0, state.Length);
			}
			if (zeros == Zeros.AllowSkip)
			{
				int[] array = new int[ColumnCount];
				for (int i = 0; i < RowCount; i++)
				{
					int num = RowPointers[i];
					int num2 = RowPointers[i + 1];
					for (int j = num; j < num2; j++)
					{
						int num3 = ColumnIndices[j];
						target[num3] = f(target[num3], Values[j]);
						array[num3]++;
					}
				}
				for (int k = 0; k < ColumnCount; k++)
				{
					target[k] = finalize(target[k], array[k]);
				}
				return;
			}
			for (int l = 0; l < RowCount; l++)
			{
				int num4 = RowPointers[l];
				int num5 = RowPointers[l + 1];
				for (int m = 0; m < ColumnCount; m++)
				{
					if (num4 < num5 && m == ColumnIndices[num4])
					{
						target[m] = f(target[m], Values[num4]);
						num4 = Math.Min(num4 + 1, num5);
					}
					else
					{
						target[m] = f(target[m], MatrixStorage<T>.Zero);
					}
				}
			}
			for (int n = 0; n < ColumnCount; n++)
			{
				target[n] = finalize(target[n], RowCount);
			}
		}

		internal override TState Fold2Unchecked<TOther, TState>(MatrixStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros)
		{
			if (other is DenseColumnMajorMatrixStorage<TOther> denseColumnMajorMatrixStorage)
			{
				TOther[] data = denseColumnMajorMatrixStorage.Data;
				int num = 0;
				for (int i = 0; i < RowCount; i++)
				{
					for (int j = 0; j < ColumnCount; j++)
					{
						bool flag = num < RowPointers[i + 1] && ColumnIndices[num] == j;
						state = f(state, flag ? Values[num++] : MatrixStorage<T>.Zero, data[j * RowCount + i]);
					}
				}
				return state;
			}
			if (other is DiagonalMatrixStorage<TOther> diagonalMatrixStorage)
			{
				TOther[] data2 = diagonalMatrixStorage.Data;
				TOther zero = BuilderInstance<TOther>.Matrix.Zero;
				if (zeros == Zeros.Include)
				{
					int num2 = 0;
					for (int k = 0; k < RowCount; k++)
					{
						for (int l = 0; l < ColumnCount; l++)
						{
							bool flag2 = num2 < RowPointers[k + 1] && ColumnIndices[num2] == l;
							state = f(state, flag2 ? Values[num2++] : MatrixStorage<T>.Zero, (k == l) ? data2[k] : zero);
						}
					}
					return state;
				}
				for (int m = 0; m < RowCount; m++)
				{
					bool flag3 = false;
					int num3 = RowPointers[m];
					int num4 = RowPointers[m + 1];
					for (int n = num3; n < num4; n++)
					{
						if (ColumnIndices[n] == m)
						{
							flag3 = true;
							state = f(state, Values[n], data2[m]);
						}
						else
						{
							state = f(state, Values[n], zero);
						}
					}
					if (!flag3 && m < ColumnCount)
					{
						state = f(state, MatrixStorage<T>.Zero, data2[m]);
					}
				}
				return state;
			}
			if (other is SparseCompressedRowMatrixStorage<TOther> sparseCompressedRowMatrixStorage)
			{
				int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
				int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
				TOther[] values = sparseCompressedRowMatrixStorage.Values;
				TOther zero2 = BuilderInstance<TOther>.Matrix.Zero;
				if (zeros == Zeros.Include)
				{
					int num5 = 0;
					int num6 = 0;
					for (int num7 = 0; num7 < RowCount; num7++)
					{
						for (int num8 = 0; num8 < ColumnCount; num8++)
						{
							bool flag4 = num5 < RowPointers[num7 + 1] && ColumnIndices[num5] == num8;
							bool flag5 = num6 < rowPointers[num7 + 1] && columnIndices[num6] == num8;
							state = f(state, flag4 ? Values[num5++] : MatrixStorage<T>.Zero, flag5 ? values[num6++] : zero2);
						}
					}
					return state;
				}
				for (int num9 = 0; num9 < RowCount; num9++)
				{
					int num10 = RowPointers[num9];
					int num11 = RowPointers[num9 + 1];
					int num12 = rowPointers[num9];
					int num13 = rowPointers[num9 + 1];
					int num14 = num10;
					int num15 = num12;
					while (num14 < num11 || num15 < num13)
					{
						state = ((num14 != num11 && (num15 >= num13 || ColumnIndices[num14] <= columnIndices[num15])) ? ((num15 != num13 && ColumnIndices[num14] >= columnIndices[num15]) ? f(state, Values[num14++], values[num15++]) : f(state, Values[num14++], zero2)) : f(state, MatrixStorage<T>.Zero, values[num15++]));
					}
				}
				return state;
			}
			return base.Fold2Unchecked(other, f, state, zeros);
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public class SparseVectorStorage<T> : VectorStorage<T> where T : struct, IEquatable<T>, IFormattable
	{
		[DataMember(Order = 1)]
		public int[] Indices;

		[DataMember(Order = 2)]
		public T[] Values;

		[DataMember(Order = 3)]
		public int ValueCount;

		public override bool IsDense => false;

		internal SparseVectorStorage(int length)
			: base(length)
		{
			Indices = new int[0];
			Values = new T[0];
			ValueCount = 0;
		}

		public override T At(int index)
		{
			int num = Array.BinarySearch(Indices, 0, ValueCount, index);
			if (num < 0)
			{
				return VectorStorage<T>.Zero;
			}
			return Values[num];
		}

		public override void At(int index, T value)
		{
			int num = Array.BinarySearch(Indices, 0, ValueCount, index);
			if (num >= 0)
			{
				T zero = VectorStorage<T>.Zero;
				if (zero.Equals(value))
				{
					RemoveAtIndexUnchecked(num);
				}
				else
				{
					Values[num] = value;
				}
			}
			else
			{
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(value))
				{
					InsertAtIndexUnchecked(~num, index, value);
				}
			}
		}

		internal void InsertAtIndexUnchecked(int itemIndex, int index, T value)
		{
			if (ValueCount == Values.Length && ValueCount < Length)
			{
				int newSize = Math.Min(Values.Length + GrowthSize(), Length);
				Array.Resize(ref Values, newSize);
				Array.Resize(ref Indices, newSize);
			}
			Array.Copy(Values, itemIndex, Values, itemIndex + 1, ValueCount - itemIndex);
			Array.Copy(Indices, itemIndex, Indices, itemIndex + 1, ValueCount - itemIndex);
			Values[itemIndex] = value;
			Indices[itemIndex] = index;
			ValueCount++;
		}

		internal void RemoveAtIndexUnchecked(int itemIndex)
		{
			Array.Copy(Values, itemIndex + 1, Values, itemIndex, ValueCount - itemIndex - 1);
			Array.Copy(Indices, itemIndex + 1, Indices, itemIndex, ValueCount - itemIndex - 1);
			ValueCount--;
			if (ValueCount > 1024 && ValueCount < Indices.Length / 2)
			{
				Array.Resize(ref Values, ValueCount);
				Array.Resize(ref Indices, ValueCount);
			}
		}

		private int GrowthSize()
		{
			if (Values.Length > 1024)
			{
				return Values.Length / 4;
			}
			if (Values.Length > 256)
			{
				return 512;
			}
			return (Values.Length > 64) ? 128 : 32;
		}

		public override bool Equals(VectorStorage<T> other)
		{
			if (other == null || Length != other.Length)
			{
				return false;
			}
			if (this == other)
			{
				return true;
			}
			if (other is SparseVectorStorage<T> sparseVectorStorage)
			{
				int num = 0;
				int num2 = 0;
				while (num < ValueCount || num2 < sparseVectorStorage.ValueCount)
				{
					if (num2 >= sparseVectorStorage.ValueCount || (num < ValueCount && Indices[num] < sparseVectorStorage.Indices[num2]))
					{
						T zero = VectorStorage<T>.Zero;
						if (!zero.Equals(Values[num++]))
						{
							return false;
						}
						continue;
					}
					if (num >= ValueCount || (num2 < sparseVectorStorage.ValueCount && sparseVectorStorage.Indices[num2] < Indices[num]))
					{
						T zero = VectorStorage<T>.Zero;
						if (!zero.Equals(sparseVectorStorage.Values[num2++]))
						{
							return false;
						}
						continue;
					}
					if (!Values[num].Equals(sparseVectorStorage.Values[num2]))
					{
						return false;
					}
					num++;
					num2++;
				}
				return true;
			}
			return base.Equals(other);
		}

		public override int GetHashCode()
		{
			T[] values = Values;
			int num = Math.Min(ValueCount, 25);
			int num2 = 17;
			for (int i = 0; i < num; i++)
			{
				num2 = num2 * 31 + values[i].GetHashCode();
			}
			return num2;
		}

		public override void Clear()
		{
			ValueCount = 0;
		}

		public override void Clear(int index, int count)
		{
			if (index == 0 && count == Length)
			{
				Clear();
				return;
			}
			int num = Array.BinarySearch(Indices, 0, ValueCount, index);
			int num2 = Array.BinarySearch(Indices, 0, ValueCount, index + count - 1);
			if (num < 0)
			{
				num = ~num;
			}
			if (num2 < 0)
			{
				num2 = ~num2 - 1;
			}
			int num3 = num2 - num + 1;
			if (num3 > 0)
			{
				Array.Copy(Values, num + num3, Values, num, ValueCount - num - num3);
				Array.Copy(Indices, num + num3, Indices, num, ValueCount - num - num3);
				ValueCount -= num3;
			}
			if (ValueCount > 1024 && ValueCount < Indices.Length / 2)
			{
				Array.Resize(ref Values, ValueCount);
				Array.Resize(ref Indices, ValueCount);
			}
		}

		public static SparseVectorStorage<T> OfVector(VectorStorage<T> vector)
		{
			SparseVectorStorage<T> sparseVectorStorage = new SparseVectorStorage<T>(vector.Length);
			vector.CopyToUnchecked(sparseVectorStorage, ExistingData.AssumeZeros);
			return sparseVectorStorage;
		}

		public static SparseVectorStorage<T> OfValue(int length, T value)
		{
			T zero = VectorStorage<T>.Zero;
			if (zero.Equals(value))
			{
				return new SparseVectorStorage<T>(length);
			}
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Value must not be negative (zero is ok).");
			}
			int[] array = new int[length];
			T[] array2 = new T[length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = i;
				array2[i] = value;
			}
			return new SparseVectorStorage<T>(length)
			{
				Indices = array,
				Values = array2,
				ValueCount = length
			};
		}

		public static SparseVectorStorage<T> OfInit(int length, Func<int, T> init)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Value must not be negative (zero is ok).");
			}
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			for (int i = 0; i < length; i++)
			{
				T val = init(i);
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(val))
				{
					list2.Add(val);
					list.Add(i);
				}
			}
			return new SparseVectorStorage<T>(length)
			{
				Indices = list.ToArray(),
				Values = list2.ToArray(),
				ValueCount = list2.Count
			};
		}

		public static SparseVectorStorage<T> OfEnumerable(IEnumerable<T> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			int num = 0;
			foreach (T datum in data)
			{
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(datum))
				{
					list2.Add(datum);
					list.Add(num);
				}
				num++;
			}
			return new SparseVectorStorage<T>(num)
			{
				Indices = list.ToArray(),
				Values = list2.ToArray(),
				ValueCount = list2.Count
			};
		}

		public static SparseVectorStorage<T> OfIndexedEnumerable(int length, IEnumerable<Tuple<int, T>> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			List<int> list = new List<int>();
			List<T> list2 = new List<T>();
			foreach (Tuple<int, T> datum in data)
			{
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(datum.Item2))
				{
					list2.Add(datum.Item2);
					list.Add(datum.Item1);
				}
			}
			int[] array = list.ToArray();
			T[] array2 = list2.ToArray();
			Sorting.Sort(array, array2);
			return new SparseVectorStorage<T>(length)
			{
				Indices = array,
				Values = array2,
				ValueCount = list2.Count
			};
		}

		internal override void CopyToUnchecked(VectorStorage<T> target, ExistingData existingData)
		{
			if (target is SparseVectorStorage<T> target2)
			{
				CopyToUnchecked(target2);
				return;
			}
			if (existingData == ExistingData.Clear)
			{
				target.Clear();
			}
			if (ValueCount != 0)
			{
				for (int i = 0; i < ValueCount; i++)
				{
					target.At(Indices[i], Values[i]);
				}
			}
		}

		private void CopyToUnchecked(SparseVectorStorage<T> target)
		{
			if (this != target)
			{
				if (Length != target.Length)
				{
					throw new ArgumentException($"Matrix dimensions must agree: op1 is {Length}, op2 is {target.Length}.", "target");
				}
				target.ValueCount = ValueCount;
				target.Values = new T[ValueCount];
				target.Indices = new int[ValueCount];
				if (ValueCount != 0)
				{
					Array.Copy(Values, 0, target.Values, 0, ValueCount);
					Buffer.BlockCopy(Indices, 0, target.Indices, 0, ValueCount * 4);
				}
			}
		}

		internal override void CopyToRowUnchecked(MatrixStorage<T> target, int rowIndex, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(rowIndex, 1, 0, Length);
			}
			if (ValueCount != 0)
			{
				for (int i = 0; i < ValueCount; i++)
				{
					target.At(rowIndex, Indices[i], Values[i]);
				}
			}
		}

		internal override void CopyToColumnUnchecked(MatrixStorage<T> target, int columnIndex, ExistingData existingData)
		{
			if (existingData == ExistingData.Clear)
			{
				target.ClearUnchecked(0, Length, columnIndex, 1);
			}
			if (ValueCount != 0)
			{
				for (int i = 0; i < ValueCount; i++)
				{
					target.At(Indices[i], columnIndex, Values[i]);
				}
			}
		}

		internal override void CopySubVectorToUnchecked(VectorStorage<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData)
		{
			if (target is SparseVectorStorage<T> target2)
			{
				CopySubVectorToUnchecked(target2, sourceIndex, targetIndex, count, existingData);
				return;
			}
			int num = targetIndex - sourceIndex;
			int num2 = Array.BinarySearch(Indices, 0, ValueCount, sourceIndex);
			int num3 = Array.BinarySearch(Indices, 0, ValueCount, sourceIndex + count - 1);
			if (num2 < 0)
			{
				num2 = ~num2;
			}
			if (num3 < 0)
			{
				num3 = ~num3 - 1;
			}
			if (existingData == ExistingData.Clear)
			{
				target.Clear(targetIndex, count);
			}
			for (int i = num2; i <= num3; i++)
			{
				target.At(Indices[i] + num, Values[i]);
			}
		}

		private void CopySubVectorToUnchecked(SparseVectorStorage<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData)
		{
			int num = targetIndex - sourceIndex;
			int num2 = Array.BinarySearch(Indices, 0, ValueCount, sourceIndex);
			int num3 = Array.BinarySearch(Indices, 0, ValueCount, sourceIndex + count - 1);
			if (num2 < 0)
			{
				num2 = ~num2;
			}
			if (num3 < 0)
			{
				num3 = ~num3 - 1;
			}
			int num4 = num3 - num2 + 1;
			if (this == target)
			{
				T[] array = new T[num4];
				int[] array2 = new int[num4];
				Array.Copy(Values, num2, array, 0, num4);
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = Indices[i + num2];
				}
				if (existingData == ExistingData.Clear)
				{
					Clear(targetIndex, count);
				}
				for (int j = num2; j <= num3; j++)
				{
					At(array2[j] + num, array[j]);
				}
			}
			else if (target.ValueCount == 0)
			{
				T[] array3 = new T[num4];
				int[] array4 = new int[num4];
				Array.Copy(Values, num2, array3, 0, num4);
				for (int k = 0; k < array4.Length; k++)
				{
					array4[k] = Indices[k + num2] + num;
				}
				target.ValueCount = num4;
				target.Values = array3;
				target.Indices = array4;
			}
			else
			{
				if (existingData == ExistingData.Clear)
				{
					target.Clear(targetIndex, count);
				}
				for (int l = num2; l <= num3; l++)
				{
					target.At(Indices[l] + num, Values[l]);
				}
			}
		}

		public override T[] ToArray()
		{
			T[] array = new T[Length];
			for (int i = 0; i < ValueCount; i++)
			{
				array[Indices[i]] = Values[i];
			}
			return array;
		}

		public override IEnumerable<T> Enumerate()
		{
			int j = 0;
			for (int i = 0; i < Length; i++)
			{
				yield return (j < ValueCount && Indices[j] == i) ? Values[j++] : VectorStorage<T>.Zero;
			}
		}

		public override IEnumerable<Tuple<int, T>> EnumerateIndexed()
		{
			int j = 0;
			for (int i = 0; i < Length; i++)
			{
				yield return (j < ValueCount && Indices[j] == i) ? new Tuple<int, T>(i, Values[j++]) : new Tuple<int, T>(i, VectorStorage<T>.Zero);
			}
		}

		public override IEnumerable<T> EnumerateNonZero()
		{
			return Values.Take(ValueCount).Where(delegate(T x)
			{
				T zero = VectorStorage<T>.Zero;
				return !zero.Equals(x);
			});
		}

		public override IEnumerable<Tuple<int, T>> EnumerateNonZeroIndexed()
		{
			for (int i = 0; i < ValueCount; i++)
			{
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(Values[i]))
				{
					yield return new Tuple<int, T>(Indices[i], Values[i]);
				}
			}
		}

		public override Tuple<int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < ValueCount; i++)
			{
				if (predicate(Values[i]))
				{
					return new Tuple<int, T>(Indices[i], Values[i]);
				}
			}
			if (zeros == Zeros.Include && ValueCount < Length && predicate(VectorStorage<T>.Zero))
			{
				for (int j = 0; j < Length; j++)
				{
					if (j >= ValueCount || Indices[j] != j)
					{
						return new Tuple<int, T>(j, VectorStorage<T>.Zero);
					}
				}
			}
			return null;
		}

		internal override Tuple<int, T, TOther> Find2Unchecked<TOther>(VectorStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros)
		{
			if (other is DenseVectorStorage<TOther> denseVectorStorage)
			{
				TOther[] data = denseVectorStorage.Data;
				int num = 0;
				for (int i = 0; i < data.Length; i++)
				{
					if (num < ValueCount && Indices[num] == i)
					{
						if (predicate(Values[num], data[i]))
						{
							return new Tuple<int, T, TOther>(i, Values[num], data[i]);
						}
						num++;
					}
					else if (predicate(VectorStorage<T>.Zero, data[i]))
					{
						return new Tuple<int, T, TOther>(i, VectorStorage<T>.Zero, data[i]);
					}
				}
				return null;
			}
			if (other is SparseVectorStorage<TOther> sparseVectorStorage)
			{
				int[] indices = sparseVectorStorage.Indices;
				TOther[] values = sparseVectorStorage.Values;
				int valueCount = sparseVectorStorage.ValueCount;
				TOther zero = BuilderInstance<TOther>.Matrix.Zero;
				int num2 = 0;
				int num3 = 0;
				if (zeros == Zeros.Include && ValueCount < Length && sparseVectorStorage.ValueCount < Length && predicate(VectorStorage<T>.Zero, zero))
				{
					for (int j = 0; j < Length; j++)
					{
						T val = ((num2 < ValueCount && Indices[num2] == j) ? Values[num2++] : VectorStorage<T>.Zero);
						TOther val2 = ((num3 < valueCount && indices[num3] == j) ? values[num3++] : zero);
						if (predicate(val, val2))
						{
							return new Tuple<int, T, TOther>(j, val, val2);
						}
					}
					return null;
				}
				num2 = 0;
				num3 = 0;
				while (num2 < ValueCount || num3 < valueCount)
				{
					if (num2 == ValueCount || (num3 < valueCount && Indices[num2] > indices[num3]))
					{
						if (predicate(VectorStorage<T>.Zero, values[num3++]))
						{
							return new Tuple<int, T, TOther>(indices[num3 - 1], VectorStorage<T>.Zero, values[num3 - 1]);
						}
					}
					else if (num3 == valueCount || Indices[num2] < indices[num3])
					{
						if (predicate(Values[num2++], zero))
						{
							return new Tuple<int, T, TOther>(Indices[num2 - 1], Values[num2 - 1], zero);
						}
					}
					else if (predicate(Values[num2++], values[num3++]))
					{
						return new Tuple<int, T, TOther>(Indices[num2 - 1], Values[num2 - 1], values[num3 - 1]);
					}
				}
				return null;
			}
			return base.Find2Unchecked(other, predicate, zeros);
		}

		public override void MapInplace(Func<T, T> f, Zeros zeros)
		{
			List<int> list = new List<int>();
			List<T> list2 = new List<T>(ValueCount);
			if (zeros != Zeros.Include)
			{
				T zero = VectorStorage<T>.Zero;
				if (zero.Equals(f(VectorStorage<T>.Zero)))
				{
					for (int i = 0; i < ValueCount; i++)
					{
						T val = f(Values[i]);
						zero = VectorStorage<T>.Zero;
						if (!zero.Equals(val))
						{
							list2.Add(val);
							list.Add(Indices[i]);
						}
					}
					goto IL_0108;
				}
			}
			int num = 0;
			for (int j = 0; j < Length; j++)
			{
				T val2 = ((num < ValueCount && Indices[num] == j) ? f(Values[num++]) : f(VectorStorage<T>.Zero));
				T zero = VectorStorage<T>.Zero;
				if (!zero.Equals(val2))
				{
					list2.Add(val2);
					list.Add(j);
				}
			}
			goto IL_0108;
			IL_0108:
			Indices = list.ToArray();
			Values = list2.ToArray();
			ValueCount = list2.Count;
		}

		public override void MapIndexedInplace(Func<int, T, T> f, Zeros zeros)
		{
			List<int> list = new List<int>();
			List<T> list2 = new List<T>(ValueCount);
			if (zeros == Zeros.Include)
			{
				int num = 0;
				for (int i = 0; i < Length; i++)
				{
					T val = ((num < ValueCount && Indices[num] == i) ? f(i, Values[num++]) : f(i, VectorStorage<T>.Zero));
					T zero = VectorStorage<T>.Zero;
					if (!zero.Equals(val))
					{
						list2.Add(val);
						list.Add(i);
					}
				}
			}
			else
			{
				for (int j = 0; j < ValueCount; j++)
				{
					T val2 = f(Indices[j], Values[j]);
					T zero = VectorStorage<T>.Zero;
					if (!zero.Equals(val2))
					{
						list2.Add(val2);
						list.Add(Indices[j]);
					}
				}
			}
			Indices = list.ToArray();
			Values = list2.ToArray();
			ValueCount = list2.Count;
		}

		internal override void MapToUnchecked<TU>(VectorStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData)
		{
			List<int> list;
			List<TU> list2;
			if (target is SparseVectorStorage<TU> sparseVectorStorage)
			{
				list = new List<int>();
				list2 = new List<TU>();
				if (zeros != Zeros.Include)
				{
					T zero = VectorStorage<T>.Zero;
					if (zero.Equals(f(VectorStorage<T>.Zero)))
					{
						for (int i = 0; i < ValueCount; i++)
						{
							TU val = f(Values[i]);
							zero = VectorStorage<T>.Zero;
							if (!zero.Equals(val))
							{
								list2.Add(val);
								list.Add(Indices[i]);
							}
						}
						goto IL_0154;
					}
				}
				int num = 0;
				for (int j = 0; j < Length; j++)
				{
					TU val2 = ((num < ValueCount && Indices[num] == j) ? f(Values[num++]) : f(VectorStorage<T>.Zero));
					T zero = VectorStorage<T>.Zero;
					if (!zero.Equals(val2))
					{
						list2.Add(val2);
						list.Add(j);
					}
				}
				goto IL_0154;
			}
			DenseVectorStorage<TU> denseTarget = target as DenseVectorStorage<TU>;
			if (denseTarget != null)
			{
				if (existingData == ExistingData.Clear)
				{
					denseTarget.Clear();
				}
				if (zeros != Zeros.Include)
				{
					T zero = VectorStorage<T>.Zero;
					if (zero.Equals(f(VectorStorage<T>.Zero)))
					{
						CommonParallel.For(0, ValueCount, 4096, delegate(int a, int b)
						{
							for (int l = a; l < b; l++)
							{
								denseTarget.Data[Indices[l]] = f(Values[l]);
							}
						});
						return;
					}
				}
				int num2 = 0;
				for (int k = 0; k < Length; k++)
				{
					denseTarget.Data[k] = ((num2 < ValueCount && Indices[num2] == k) ? f(Values[num2++]) : f(VectorStorage<T>.Zero));
				}
			}
			else
			{
				base.MapToUnchecked(target, f, zeros, existingData);
			}
			return;
			IL_0154:
			sparseVectorStorage.Indices = list.ToArray();
			sparseVectorStorage.Values = list2.ToArray();
			sparseVectorStorage.ValueCount = list2.Count;
		}

		internal override void MapIndexedToUnchecked<TU>(VectorStorage<TU> target, Func<int, T, TU> f, Zeros zeros, ExistingData existingData)
		{
			List<int> list;
			List<TU> list2;
			if (target is SparseVectorStorage<TU> sparseVectorStorage)
			{
				list = new List<int>();
				list2 = new List<TU>();
				if (zeros != Zeros.Include)
				{
					T zero = VectorStorage<T>.Zero;
					if (zero.Equals(f(0, VectorStorage<T>.Zero)))
					{
						for (int i = 0; i < ValueCount; i++)
						{
							TU val = f(Indices[i], Values[i]);
							zero = VectorStorage<T>.Zero;
							if (!zero.Equals(val))
							{
								list2.Add(val);
								list.Add(Indices[i]);
							}
						}
						goto IL_0162;
					}
				}
				int num = 0;
				for (int j = 0; j < Length; j++)
				{
					TU val2 = ((num < ValueCount && Indices[num] == j) ? f(j, Values[num++]) : f(j, VectorStorage<T>.Zero));
					T zero = VectorStorage<T>.Zero;
					if (!zero.Equals(val2))
					{
						list2.Add(val2);
						list.Add(j);
					}
				}
				goto IL_0162;
			}
			DenseVectorStorage<TU> denseTarget = target as DenseVectorStorage<TU>;
			if (denseTarget != null)
			{
				if (existingData == ExistingData.Clear)
				{
					denseTarget.Clear();
				}
				if (zeros != Zeros.Include)
				{
					T zero = VectorStorage<T>.Zero;
					if (zero.Equals(f(0, VectorStorage<T>.Zero)))
					{
						CommonParallel.For(0, ValueCount, 4096, delegate(int a, int b)
						{
							for (int l = a; l < b; l++)
							{
								denseTarget.Data[Indices[l]] = f(Indices[l], Values[l]);
							}
						});
						return;
					}
				}
				int num2 = 0;
				for (int k = 0; k < Length; k++)
				{
					denseTarget.Data[k] = ((num2 < ValueCount && Indices[num2] == k) ? f(k, Values[num2++]) : f(k, VectorStorage<T>.Zero));
				}
			}
			else
			{
				base.MapIndexedToUnchecked(target, f, zeros, existingData);
			}
			return;
			IL_0162:
			sparseVectorStorage.Indices = list.ToArray();
			sparseVectorStorage.Values = list2.ToArray();
			sparseVectorStorage.ValueCount = list2.Count;
		}

		internal override void Map2ToUnchecked(VectorStorage<T> target, VectorStorage<T> other, Func<T, T, T> f, Zeros zeros, ExistingData existingData)
		{
			int num;
			if (zeros != Zeros.Include)
			{
				T zero = VectorStorage<T>.Zero;
				num = ((!zero.Equals(f(VectorStorage<T>.Zero, VectorStorage<T>.Zero))) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool flag = (byte)num != 0;
			DenseVectorStorage<T> denseVectorStorage = target as DenseVectorStorage<T>;
			DenseVectorStorage<T> denseVectorStorage2 = other as DenseVectorStorage<T>;
			if (denseVectorStorage == null && (denseVectorStorage2 != null || flag))
			{
				DenseVectorStorage<T> denseVectorStorage3 = new DenseVectorStorage<T>(target.Length);
				Map2ToUnchecked(denseVectorStorage3, other, f, zeros, ExistingData.AssumeZeros);
				denseVectorStorage3.CopyTo(target, existingData);
				return;
			}
			if (denseVectorStorage2 != null)
			{
				T[] data = denseVectorStorage.Data;
				T[] data2 = denseVectorStorage2.Data;
				int num2 = 0;
				for (int i = 0; i < data2.Length; i++)
				{
					if (num2 < ValueCount && Indices[num2] == i)
					{
						data[i] = f(Values[num2], data2[i]);
						num2++;
					}
					else
					{
						data[i] = f(VectorStorage<T>.Zero, data2[i]);
					}
				}
				return;
			}
			SparseVectorStorage<T> sparseVectorStorage = other as SparseVectorStorage<T>;
			if (sparseVectorStorage != null && denseVectorStorage != null)
			{
				T[] data3 = denseVectorStorage.Data;
				int[] indices = sparseVectorStorage.Indices;
				T[] values = sparseVectorStorage.Values;
				int valueCount = sparseVectorStorage.ValueCount;
				if (flag)
				{
					int num3 = 0;
					int num4 = 0;
					for (int j = 0; j < data3.Length; j++)
					{
						T arg = ((num3 < ValueCount && Indices[num3] == j) ? Values[num3++] : VectorStorage<T>.Zero);
						T arg2 = ((num4 < valueCount && indices[num4] == j) ? values[num4++] : VectorStorage<T>.Zero);
						data3[j] = f(arg, arg2);
					}
					return;
				}
				if (existingData == ExistingData.Clear)
				{
					denseVectorStorage.Clear();
				}
				int num5 = 0;
				int num6 = 0;
				while (num5 < ValueCount || num6 < valueCount)
				{
					if (num6 >= valueCount || (num5 < ValueCount && Indices[num5] < indices[num6]))
					{
						data3[Indices[num5]] = f(Values[num5], VectorStorage<T>.Zero);
						num5++;
					}
					else if (num5 >= ValueCount || (num6 < valueCount && Indices[num5] > indices[num6]))
					{
						data3[indices[num6]] = f(VectorStorage<T>.Zero, values[num6]);
						num6++;
					}
					else
					{
						data3[Indices[num5]] = f(Values[num5], values[num6]);
						num5++;
						num6++;
					}
				}
			}
			else if (sparseVectorStorage != null && target is SparseVectorStorage<T> sparseVectorStorage2)
			{
				List<int> list = new List<int>();
				List<T> list2 = new List<T>();
				int[] indices2 = sparseVectorStorage.Indices;
				T[] values2 = sparseVectorStorage.Values;
				int valueCount2 = sparseVectorStorage.ValueCount;
				int num7 = 0;
				int num8 = 0;
				while (num7 < ValueCount || num8 < valueCount2)
				{
					T zero;
					if (num8 >= valueCount2 || (num7 < ValueCount && Indices[num7] < indices2[num8]))
					{
						T val = f(Values[num7], VectorStorage<T>.Zero);
						zero = VectorStorage<T>.Zero;
						if (!zero.Equals(val))
						{
							list.Add(Indices[num7]);
							list2.Add(val);
						}
						num7++;
						continue;
					}
					if (num7 >= ValueCount || (num8 < valueCount2 && Indices[num7] > indices2[num8]))
					{
						T val2 = f(VectorStorage<T>.Zero, values2[num8]);
						zero = VectorStorage<T>.Zero;
						if (!zero.Equals(val2))
						{
							list.Add(indices2[num8]);
							list2.Add(val2);
						}
						num8++;
						continue;
					}
					T val3 = f(Values[num7], values2[num8]);
					zero = VectorStorage<T>.Zero;
					if (!zero.Equals(val3))
					{
						list.Add(Indices[num7]);
						list2.Add(val3);
					}
					num7++;
					num8++;
				}
				sparseVectorStorage2.Indices = list.ToArray();
				sparseVectorStorage2.Values = list2.ToArray();
				sparseVectorStorage2.ValueCount = list2.Count;
			}
			else
			{
				base.Map2ToUnchecked(target, other, f, zeros, existingData);
			}
		}

		internal override TState Fold2Unchecked<TOther, TState>(VectorStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros)
		{
			if (other is SparseVectorStorage<TOther> sparseVectorStorage)
			{
				int[] indices = sparseVectorStorage.Indices;
				TOther[] values = sparseVectorStorage.Values;
				int valueCount = sparseVectorStorage.ValueCount;
				TOther zero = BuilderInstance<TOther>.Vector.Zero;
				if (zeros == Zeros.Include)
				{
					int num = 0;
					int num2 = 0;
					for (int i = 0; i < Length; i++)
					{
						T arg = ((num < ValueCount && Indices[num] == i) ? Values[num++] : VectorStorage<T>.Zero);
						TOther arg2 = ((num2 < valueCount && indices[num2] == i) ? values[num2++] : zero);
						state = f(state, arg, arg2);
					}
				}
				else
				{
					int num3 = 0;
					int num4 = 0;
					while (num3 < ValueCount || num4 < valueCount)
					{
						if (num4 >= valueCount || (num3 < ValueCount && Indices[num3] < indices[num4]))
						{
							state = f(state, Values[num3], zero);
							num3++;
						}
						else if (num3 >= ValueCount || (num4 < valueCount && Indices[num3] > indices[num4]))
						{
							state = f(state, VectorStorage<T>.Zero, values[num4]);
							num4++;
						}
						else
						{
							state = f(state, Values[num3], values[num4]);
							num3++;
							num4++;
						}
					}
				}
				return state;
			}
			if (other is DenseVectorStorage<TOther> denseVectorStorage)
			{
				TOther[] data = denseVectorStorage.Data;
				int num5 = 0;
				for (int j = 0; j < data.Length; j++)
				{
					if (num5 < ValueCount && Indices[num5] == j)
					{
						state = f(state, Values[num5], data[j]);
						num5++;
					}
					else
					{
						state = f(state, VectorStorage<T>.Zero, data[j]);
					}
				}
				return state;
			}
			return base.Fold2Unchecked(other, f, state, zeros);
		}
	}
	[Serializable]
	[DataContract(Namespace = "urn:MathNet/Numerics/LinearAlgebra")]
	public abstract class VectorStorage<T> : IEquatable<VectorStorage<T>> where T : struct, IEquatable<T>, IFormattable
	{
		protected static readonly T Zero = BuilderInstance<T>.Vector.Zero;

		[DataMember(Order = 1)]
		public readonly int Length;

		public abstract bool IsDense { get; }

		public T this[int index]
		{
			get
			{
				ValidateRange(index);
				return At(index);
			}
			set
			{
				ValidateRange(index);
				At(index, value);
			}
		}

		protected VectorStorage(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Value must not be negative (zero is ok).");
			}
			Length = length;
		}

		public abstract T At(int index);

		public abstract void At(int index, T value);

		public virtual bool Equals(VectorStorage<T> other)
		{
			if (other == null)
			{
				return false;
			}
			if (Length != other.Length)
			{
				return false;
			}
			if (this == other)
			{
				return true;
			}
			for (int i = 0; i < Length; i++)
			{
				if (!At(i).Equals(other.At(i)))
				{
					return false;
				}
			}
			return true;
		}

		public sealed override bool Equals(object obj)
		{
			return Equals(obj as VectorStorage<T>);
		}

		public override int GetHashCode()
		{
			int num = Math.Min(Length, 25);
			int num2 = 17;
			for (int i = 0; i < num; i++)
			{
				num2 = num2 * 31 + At(i).GetHashCode();
			}
			return num2;
		}

		public virtual void Clear()
		{
			for (int i = 0; i < Length; i++)
			{
				At(i, Zero);
			}
		}

		public virtual void Clear(int index, int count)
		{
			for (int i = index; i < index + count; i++)
			{
				At(i, Zero);
			}
		}

		public void CopyTo(VectorStorage<T> target, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (this != target)
			{
				if (Length != target.Length)
				{
					throw new ArgumentException("All vectors must have the same dimensionality.", "target");
				}
				CopyToUnchecked(target, existingData);
			}
		}

		internal virtual void CopyToUnchecked(VectorStorage<T> target, ExistingData existingData)
		{
			for (int i = 0; i < Length; i++)
			{
				target.At(i, At(i));
			}
		}

		public void CopyToRow(MatrixStorage<T> target, int rowIndex, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (Length != target.ColumnCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			ValidateRowRange(target, rowIndex);
			CopyToRowUnchecked(target, rowIndex, existingData);
		}

		internal virtual void CopyToRowUnchecked(MatrixStorage<T> target, int rowIndex, ExistingData existingData)
		{
			for (int i = 0; i < Length; i++)
			{
				target.At(rowIndex, i, At(i));
			}
		}

		public void CopyToColumn(MatrixStorage<T> target, int columnIndex, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (Length != target.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			ValidateColumnRange(target, columnIndex);
			CopyToColumnUnchecked(target, columnIndex, existingData);
		}

		internal virtual void CopyToColumnUnchecked(MatrixStorage<T> target, int columnIndex, ExistingData existingData)
		{
			for (int i = 0; i < Length; i++)
			{
				target.At(i, columnIndex, At(i));
			}
		}

		public void CopySubVectorTo(VectorStorage<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (count != 0)
			{
				ValidateSubVectorRange(target, sourceIndex, targetIndex, count);
				CopySubVectorToUnchecked(target, sourceIndex, targetIndex, count, existingData);
			}
		}

		internal virtual void CopySubVectorToUnchecked(VectorStorage<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData)
		{
			if (this == target)
			{
				T[] array = new T[count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = At(i + sourceIndex);
				}
				for (int j = 0; j < array.Length; j++)
				{
					At(j + targetIndex, array[j]);
				}
			}
			else
			{
				int num = sourceIndex;
				int num2 = targetIndex;
				while (num < sourceIndex + count)
				{
					target.At(num2, At(num));
					num++;
					num2++;
				}
			}
		}

		public void CopyToSubRow(MatrixStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (columnCount != 0)
			{
				ValidateSubRowRange(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount);
				CopyToSubRowUnchecked(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
			}
		}

		internal virtual void CopyToSubRowUnchecked(MatrixStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData)
		{
			int num = sourceColumnIndex;
			int num2 = targetColumnIndex;
			while (num < sourceColumnIndex + columnCount)
			{
				target.At(rowIndex, num2, At(num));
				num++;
				num2++;
			}
		}

		public void CopyToSubColumn(MatrixStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData = ExistingData.Clear)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (rowCount != 0)
			{
				ValidateSubColumnRange(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount);
				CopyToSubColumnUnchecked(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData);
			}
		}

		internal virtual void CopyToSubColumnUnchecked(MatrixStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData)
		{
			int num = sourceRowIndex;
			int num2 = targetRowIndex;
			while (num < sourceRowIndex + rowCount)
			{
				target.At(num2, columnIndex, At(num));
				num++;
				num2++;
			}
		}

		public virtual T[] ToArray()
		{
			T[] array = new T[Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = At(i);
			}
			return array;
		}

		public virtual T[] AsArray()
		{
			return null;
		}

		public virtual IEnumerable<T> Enumerate()
		{
			for (int i = 0; i < Length; i++)
			{
				yield return At(i);
			}
		}

		public virtual IEnumerable<Tuple<int, T>> EnumerateIndexed()
		{
			for (int i = 0; i < Length; i++)
			{
				yield return new Tuple<int, T>(i, At(i));
			}
		}

		public virtual IEnumerable<T> EnumerateNonZero()
		{
			for (int i = 0; i < Length; i++)
			{
				T val = At(i);
				T zero = Zero;
				if (!zero.Equals(val))
				{
					yield return val;
				}
			}
		}

		public virtual IEnumerable<Tuple<int, T>> EnumerateNonZeroIndexed()
		{
			for (int i = 0; i < Length; i++)
			{
				T val = At(i);
				T zero = Zero;
				if (!zero.Equals(val))
				{
					yield return new Tuple<int, T>(i, val);
				}
			}
		}

		public virtual Tuple<int, T> Find(Func<T, bool> predicate, Zeros zeros)
		{
			for (int i = 0; i < Length; i++)
			{
				T val = At(i);
				if (predicate(val))
				{
					return new Tuple<int, T>(i, val);
				}
			}
			return null;
		}

		public Tuple<int, T, TOther> Find2<TOther>(VectorStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (Length != other.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			return Find2Unchecked(other, predicate, zeros);
		}

		internal virtual Tuple<int, T, TOther> Find2Unchecked<TOther>(VectorStorage<TOther> other, Func<T, TOther, bool> predicate, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			for (int i = 0; i < Length; i++)
			{
				T val = At(i);
				TOther val2 = other.At(i);
				if (predicate(val, val2))
				{
					return new Tuple<int, T, TOther>(i, val, val2);
				}
			}
			return null;
		}

		public virtual void MapInplace(Func<T, T> f, Zeros zeros)
		{
			for (int i = 0; i < Length; i++)
			{
				At(i, f(At(i)));
			}
		}

		public virtual void MapIndexedInplace(Func<int, T, T> f, Zeros zeros)
		{
			for (int i = 0; i < Length; i++)
			{
				At(i, f(i, At(i)));
			}
		}

		public void MapTo<TU>(VectorStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (Length != target.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			MapToUnchecked(target, f, zeros, existingData);
		}

		internal virtual void MapToUnchecked<TU>(VectorStorage<TU> target, Func<T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			for (int i = 0; i < Length; i++)
			{
				target.At(i, f(At(i)));
			}
		}

		public void MapIndexedTo<TU>(VectorStorage<TU> target, Func<int, T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (Length != target.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			MapIndexedToUnchecked(target, f, zeros, existingData);
		}

		internal virtual void MapIndexedToUnchecked<TU>(VectorStorage<TU> target, Func<int, T, TU> f, Zeros zeros, ExistingData existingData) where TU : struct, IEquatable<TU>, IFormattable
		{
			for (int i = 0; i < Length; i++)
			{
				target.At(i, f(i, At(i)));
			}
		}

		public void Map2To(VectorStorage<T> target, VectorStorage<T> other, Func<T, T, T> f, Zeros zeros, ExistingData existingData)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (Length != target.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "target");
			}
			if (Length != other.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			Map2ToUnchecked(target, other, f, zeros, existingData);
		}

		internal virtual void Map2ToUnchecked(VectorStorage<T> target, VectorStorage<T> other, Func<T, T, T> f, Zeros zeros, ExistingData existingData)
		{
			for (int i = 0; i < Length; i++)
			{
				target.At(i, f(At(i), other.At(i)));
			}
		}

		public TState Fold2<TOther, TState>(VectorStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (Length != other.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "other");
			}
			return Fold2Unchecked(other, f, state, zeros);
		}

		internal virtual TState Fold2Unchecked<TOther, TState>(VectorStorage<TOther> other, Func<TState, T, TOther, TState> f, TState state, Zeros zeros) where TOther : struct, IEquatable<TOther>, IFormattable
		{
			for (int i = 0; i < Length; i++)
			{
				state = f(state, At(i), other.At(i));
			}
			return state;
		}

		private void ValidateRange(int index)
		{
			if ((uint)index >= (uint)Length)
			{
				throw new ArgumentOutOfRangeException("index");
			}
		}

		private void ValidateSubVectorRange(VectorStorage<T> target, int sourceIndex, int targetIndex, int count)
		{
			if (count < 1)
			{
				throw new ArgumentOutOfRangeException("count", "Value must be positive.");
			}
			if ((uint)sourceIndex >= (uint)Length)
			{
				throw new ArgumentOutOfRangeException("sourceIndex");
			}
			if (sourceIndex + count > Length)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if ((uint)targetIndex >= (uint)target.Length)
			{
				throw new ArgumentOutOfRangeException("targetIndex");
			}
			if (targetIndex + count > target.Length)
			{
				throw new ArgumentOutOfRangeException("count");
			}
		}

		private void ValidateRowRange(MatrixStorage<T> target, int rowIndex)
		{
			if ((uint)rowIndex >= (uint)target.RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			if (target.ColumnCount != Length)
			{
				throw new ArgumentException("Matrix row dimensions must agree.", "target");
			}
		}

		private void ValidateColumnRange(MatrixStorage<T> target, int columnIndex)
		{
			if ((uint)columnIndex >= (uint)target.ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			if (target.RowCount != Length)
			{
				throw new ArgumentException("Matrix column dimensions must agree.", "target");
			}
		}

		private void ValidateSubRowRange(MatrixStorage<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount)
		{
			if (columnCount < 1)
			{
				throw new ArgumentOutOfRangeException("columnCount", "Value must be positive.");
			}
			if ((uint)sourceColumnIndex >= (uint)Length)
			{
				throw new ArgumentOutOfRangeException("sourceColumnIndex");
			}
			if (sourceColumnIndex + columnCount > Length)
			{
				throw new ArgumentOutOfRangeException("columnCount");
			}
			if ((uint)rowIndex >= (uint)target.RowCount)
			{
				throw new ArgumentOutOfRangeException("rowIndex");
			}
			if ((uint)targetColumnIndex >= (uint)target.ColumnCount)
			{
				throw new ArgumentOutOfRangeException("targetColumnIndex");
			}
			if (targetColumnIndex + columnCount > target.ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnCount");
			}
		}

		private void ValidateSubColumnRange(MatrixStorage<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount)
		{
			if (rowCount < 1)
			{
				throw new ArgumentOutOfRangeException("rowCount", "Value must be positive.");
			}
			if ((uint)sourceRowIndex >= (uint)Length)
			{
				throw new ArgumentOutOfRangeException("sourceRowIndex");
			}
			if (sourceRowIndex + rowCount > Length)
			{
				throw new ArgumentOutOfRangeException("rowCount");
			}
			if ((uint)columnIndex >= (uint)target.ColumnCount)
			{
				throw new ArgumentOutOfRangeException("columnIndex");
			}
			if ((uint)targetRowIndex >= (uint)target.RowCount)
			{
				throw new ArgumentOutOfRangeException("targetRowIndex");
			}
			if (targetRowIndex + rowCount > target.RowCount)
			{
				throw new ArgumentOutOfRangeException("rowCount");
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Solvers
{
	public sealed class CancellationStopCriterion<T> : IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		private readonly CancellationToken _masterToken;

		private CancellationTokenSource _currentTcs;

		public IterationStatus Status
		{
			[DebuggerStepThrough]
			get
			{
				if (!_currentTcs.Token.IsCancellationRequested)
				{
					return IterationStatus.Continue;
				}
				return IterationStatus.Cancelled;
			}
		}

		public CancellationStopCriterion()
		{
			_masterToken = CancellationToken.None;
			_currentTcs = CancellationTokenSource.CreateLinkedTokenSource(CancellationToken.None);
		}

		public CancellationStopCriterion(CancellationToken masterToken)
		{
			_masterToken = masterToken;
			_currentTcs = CancellationTokenSource.CreateLinkedTokenSource(masterToken);
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			if (!_currentTcs.Token.IsCancellationRequested)
			{
				return IterationStatus.Continue;
			}
			return IterationStatus.Cancelled;
		}

		public void Cancel()
		{
			_currentTcs.Cancel();
		}

		public void Reset()
		{
			_currentTcs = CancellationTokenSource.CreateLinkedTokenSource(_masterToken);
		}

		public IIterationStopCriterion<T> Clone()
		{
			return new CancellationStopCriterion<T>(_masterToken);
		}
	}
	public class DelegateStopCriterion<T> : IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		private readonly Func<int, Vector<T>, Vector<T>, Vector<T>, IterationStatus> _determine;

		private IterationStatus _status;

		public IterationStatus Status => _status;

		public DelegateStopCriterion(Func<int, Vector<T>, Vector<T>, Vector<T>, IterationStatus> determine)
		{
			_determine = determine;
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			return _status = _determine(iterationNumber, solutionVector, sourceVector, residualVector);
		}

		public void Reset()
		{
			_status = IterationStatus.Continue;
		}

		public IIterationStopCriterion<T> Clone()
		{
			return new DelegateStopCriterion<T>(_determine);
		}
	}
	public sealed class DivergenceStopCriterion<T> : IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		private double _maximumRelativeIncrease;

		private int _minimumNumberOfIterations;

		private IterationStatus _status;

		private double[] _residualHistory;

		private int _lastIteration = -1;

		public double MaximumRelativeIncrease
		{
			[DebuggerStepThrough]
			get
			{
				return _maximumRelativeIncrease;
			}
			[DebuggerStepThrough]
			set
			{
				if (value <= 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_maximumRelativeIncrease = value;
			}
		}

		public int MinimumNumberOfIterations
		{
			[DebuggerStepThrough]
			get
			{
				return _minimumNumberOfIterations;
			}
			[DebuggerStepThrough]
			set
			{
				if (value < 3)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_minimumNumberOfIterations = value;
			}
		}

		private int RequiredHistoryLength
		{
			[DebuggerStepThrough]
			get
			{
				return _minimumNumberOfIterations + 1;
			}
		}

		public IterationStatus Status
		{
			[DebuggerStepThrough]
			get
			{
				return _status;
			}
		}

		public DivergenceStopCriterion(double maximumRelativeIncrease = 0.08, int minimumIterations = 10)
		{
			if (maximumRelativeIncrease <= 0.0)
			{
				throw new ArgumentOutOfRangeException("maximumRelativeIncrease");
			}
			if (minimumIterations < 3)
			{
				throw new ArgumentOutOfRangeException("minimumIterations");
			}
			_maximumRelativeIncrease = maximumRelativeIncrease;
			_minimumNumberOfIterations = minimumIterations;
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			if (iterationNumber < 0)
			{
				throw new ArgumentOutOfRangeException("iterationNumber");
			}
			if (_lastIteration >= iterationNumber)
			{
				return _status;
			}
			if (_residualHistory == null || _residualHistory.Length != RequiredHistoryLength)
			{
				_residualHistory = new double[RequiredHistoryLength];
			}
			for (int i = 1; i < _residualHistory.Length; i++)
			{
				_residualHistory[i - 1] = _residualHistory[i];
			}
			_residualHistory[_residualHistory.Length - 1] = residualVector.InfinityNorm();
			if (double.IsNaN(_residualHistory[_residualHistory.Length - 1]))
			{
				_status = IterationStatus.Diverged;
				return _status;
			}
			_status = (IsDiverging() ? IterationStatus.Diverged : IterationStatus.Continue);
			_lastIteration = iterationNumber;
			return _status;
		}

		private bool IsDiverging()
		{
			for (int i = 1; i < _residualHistory.Length; i++)
			{
				if (_residualHistory[i] - _residualHistory[i - 1] < 0.0 || _residualHistory[i - 1] * (1.0 + _maximumRelativeIncrease) >= _residualHistory[i])
				{
					return false;
				}
			}
			return true;
		}

		public void Reset()
		{
			_status = IterationStatus.Continue;
			_lastIteration = -1;
			_residualHistory = null;
		}

		public IIterationStopCriterion<T> Clone()
		{
			return new DivergenceStopCriterion<T>(_maximumRelativeIncrease, _minimumNumberOfIterations);
		}
	}
	public sealed class FailureStopCriterion<T> : IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		private IterationStatus _status;

		private int _lastIteration = -1;

		public IterationStatus Status
		{
			[DebuggerStepThrough]
			get
			{
				return _status;
			}
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			if (iterationNumber < 0)
			{
				throw new ArgumentOutOfRangeException("iterationNumber");
			}
			if (solutionVector.Count != residualVector.Count)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			if (_lastIteration >= iterationNumber)
			{
				return _status;
			}
			double d = residualVector.InfinityNorm();
			double d2 = solutionVector.InfinityNorm();
			_status = ((double.IsNaN(d2) || double.IsNaN(d)) ? IterationStatus.Failure : IterationStatus.Continue);
			_lastIteration = iterationNumber;
			return _status;
		}

		public void Reset()
		{
			_status = IterationStatus.Continue;
			_lastIteration = -1;
		}

		public IIterationStopCriterion<T> Clone()
		{
			return new FailureStopCriterion<T>();
		}
	}
	public interface IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		IterationStatus Status { get; }

		IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector);

		void Reset();

		IIterationStopCriterion<T> Clone();
	}
	public interface IIterativeSolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		void Solve(Matrix<T> matrix, Vector<T> input, Vector<T> result, Iterator<T> iterator, IPreconditioner<T> preconditioner);
	}
	public interface IIterativeSolverSetup<T> where T : struct, IEquatable<T>, IFormattable
	{
		Type SolverType { get; }

		Type PreconditionerType { get; }

		double SolutionSpeed { get; }

		double Reliability { get; }

		IIterativeSolver<T> CreateSolver();

		IPreconditioner<T> CreatePreconditioner();
	}
	public interface IPreconditioner<T> where T : struct, IEquatable<T>, IFormattable
	{
		void Initialize(Matrix<T> matrix);

		void Approximate(Vector<T> rhs, Vector<T> lhs);
	}
	public sealed class IterationCountStopCriterion<T> : IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		public const int DefaultMaximumNumberOfIterations = 1000;

		private int _maximumNumberOfIterations;

		private IterationStatus _status;

		public int MaximumNumberOfIterations
		{
			[DebuggerStepThrough]
			get
			{
				return _maximumNumberOfIterations;
			}
			[DebuggerStepThrough]
			set
			{
				if (value < 1)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_maximumNumberOfIterations = value;
			}
		}

		public IterationStatus Status
		{
			[DebuggerStepThrough]
			get
			{
				return _status;
			}
		}

		public IterationCountStopCriterion()
			: this(1000)
		{
		}

		public IterationCountStopCriterion(int maximumNumberOfIterations)
		{
			if (maximumNumberOfIterations < 1)
			{
				throw new ArgumentOutOfRangeException("maximumNumberOfIterations");
			}
			_maximumNumberOfIterations = maximumNumberOfIterations;
		}

		public void ResetMaximumNumberOfIterationsToDefault()
		{
			_maximumNumberOfIterations = 1000;
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			if (iterationNumber < 0)
			{
				throw new ArgumentOutOfRangeException("iterationNumber");
			}
			_status = ((iterationNumber >= _maximumNumberOfIterations) ? IterationStatus.StoppedWithoutConvergence : IterationStatus.Continue);
			return _status;
		}

		public void Reset()
		{
			_status = IterationStatus.Continue;
		}

		public IIterationStopCriterion<T> Clone()
		{
			return new IterationCountStopCriterion<T>(_maximumNumberOfIterations);
		}
	}
	public enum IterationStatus
	{
		Continue,
		Converged,
		Diverged,
		StoppedWithoutConvergence,
		Cancelled,
		Failure
	}
	public sealed class Iterator<T> where T : struct, IEquatable<T>, IFormattable
	{
		private readonly List<IIterationStopCriterion<T>> _stopCriteria;

		private IterationStatus _status;

		public IterationStatus Status => _status;

		public Iterator()
		{
			_stopCriteria = new List<IIterationStopCriterion<T>>(Matrix<T>.Build.IterativeSolverStopCriteria());
		}

		public Iterator(params IIterationStopCriterion<T>[] stopCriteria)
		{
			_stopCriteria = new List<IIterationStopCriterion<T>>(stopCriteria);
		}

		public Iterator(IEnumerable<IIterationStopCriterion<T>> stopCriteria)
		{
			_stopCriteria = new List<IIterationStopCriterion<T>>(stopCriteria);
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			if (_stopCriteria.Count == 0)
			{
				throw new ArgumentException("There is no stop criterion in the collection.");
			}
			if (iterationNumber < 0)
			{
				throw new ArgumentOutOfRangeException("iterationNumber");
			}
			if (_status == IterationStatus.Cancelled)
			{
				return _status;
			}
			foreach (IIterationStopCriterion<T> stopCriterion in _stopCriteria)
			{
				IterationStatus iterationStatus = stopCriterion.DetermineStatus(iterationNumber, solutionVector, sourceVector, residualVector);
				if (iterationStatus != 0)
				{
					_status = iterationStatus;
					return _status;
				}
			}
			_status = IterationStatus.Continue;
			return _status;
		}

		public void Cancel()
		{
			_status = IterationStatus.Cancelled;
		}

		public void Reset()
		{
			_status = IterationStatus.Continue;
			foreach (IIterationStopCriterion<T> stopCriterion in _stopCriteria)
			{
				stopCriterion.Reset();
			}
		}

		public Iterator<T> Clone()
		{
			return new Iterator<T>(_stopCriteria.Select((IIterationStopCriterion<T> sc) => sc.Clone()));
		}
	}
	public sealed class ResidualStopCriterion<T> : IIterationStopCriterion<T> where T : struct, IEquatable<T>, IFormattable
	{
		private double _maximum;

		private int _minimumIterationsBelowMaximum;

		private IterationStatus _status;

		private int _iterationCount;

		private int _lastIteration = -1;

		public double Maximum
		{
			[DebuggerStepThrough]
			get
			{
				return _maximum;
			}
			[DebuggerStepThrough]
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_maximum = value;
			}
		}

		public int MinimumIterationsBelowMaximum
		{
			[DebuggerStepThrough]
			get
			{
				return _minimumIterationsBelowMaximum;
			}
			[DebuggerStepThrough]
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_minimumIterationsBelowMaximum = value;
			}
		}

		public IterationStatus Status
		{
			[DebuggerStepThrough]
			get
			{
				return _status;
			}
		}

		public ResidualStopCriterion(double maximum, int minimumIterationsBelowMaximum = 0)
		{
			if (maximum < 0.0)
			{
				throw new ArgumentOutOfRangeException("maximum");
			}
			if (minimumIterationsBelowMaximum < 0)
			{
				throw new ArgumentOutOfRangeException("minimumIterationsBelowMaximum");
			}
			_maximum = maximum;
			_minimumIterationsBelowMaximum = minimumIterationsBelowMaximum;
		}

		public IterationStatus DetermineStatus(int iterationNumber, Vector<T> solutionVector, Vector<T> sourceVector, Vector<T> residualVector)
		{
			if (iterationNumber < 0)
			{
				throw new ArgumentOutOfRangeException("iterationNumber");
			}
			if (solutionVector.Count != sourceVector.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "sourceVector");
			}
			if (solutionVector.Count != residualVector.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "residualVector");
			}
			double num = residualVector.InfinityNorm();
			double num2 = _maximum * sourceVector.InfinityNorm();
			if (double.IsNaN(num2) || double.IsNaN(num))
			{
				_iterationCount = 0;
				_status = IterationStatus.Diverged;
				return _status;
			}
			if (num < num2)
			{
				if (_lastIteration <= iterationNumber)
				{
					_iterationCount = iterationNumber - _lastIteration;
					_status = ((_iterationCount >= _minimumIterationsBelowMaximum) ? IterationStatus.Converged : IterationStatus.Continue);
				}
			}
			else
			{
				_iterationCount = 0;
				_status = IterationStatus.Continue;
			}
			_lastIteration = iterationNumber;
			return _status;
		}

		public void Reset()
		{
			_status = IterationStatus.Continue;
			_iterationCount = 0;
			_lastIteration = -1;
		}

		public IIterationStopCriterion<T> Clone()
		{
			return new ResidualStopCriterion<T>(_maximum, _minimumIterationsBelowMaximum);
		}
	}
	public static class SolverSetup<T> where T : struct, IEquatable<T>, IFormattable
	{
		public static IEnumerable<IIterativeSolverSetup<T>> LoadFromAssembly(Assembly assembly, bool ignoreFailed = true, params Type[] typesToExclude)
		{
			Type setupInterfaceType = typeof(IIterativeSolverSetup<T>);
			IEnumerable<Type> enumerable = from type in assembly.GetTypes()
				where !type.IsAbstract && !type.IsEnum && !type.IsInterface && type.IsVisible
				where type.GetInterfaces().Any(setupInterfaceType.IsAssignableFrom)
				select type;
			List<IIterativeSolverSetup<T>> list = new List<IIterativeSolverSetup<T>>();
			foreach (Type item in enumerable)
			{
				try
				{
					list.Add((IIterativeSolverSetup<T>)Activator.CreateInstance(item));
				}
				catch
				{
					if (!ignoreFailed)
					{
						throw;
					}
				}
			}
			List<Type> excludedTypes = new List<Type>(typesToExclude);
			return from s in list
				where !excludedTypes.Any((Type t) => t.IsAssignableFrom(s.SolverType) || t.IsAssignableFrom(s.PreconditionerType))
				orderby s.SolutionSpeed / s.Reliability
				select s;
		}

		public static IEnumerable<IIterativeSolverSetup<T>> LoadFromAssembly(Type typeInAssembly, bool ignoreFailed = true, params Type[] typesToExclude)
		{
			return LoadFromAssembly(typeInAssembly.Assembly, ignoreFailed, typesToExclude);
		}

		public static IEnumerable<IIterativeSolverSetup<T>> LoadFromAssembly(AssemblyName assemblyName, bool ignoreFailed = true, params Type[] typesToExclude)
		{
			return LoadFromAssembly(Assembly.Load(assemblyName.FullName), ignoreFailed, typesToExclude);
		}

		public static IEnumerable<IIterativeSolverSetup<T>> Load(Type[] typesToExclude)
		{
			return LoadFromAssembly(typeof(SolverSetup<T>), ignoreFailed: false, typesToExclude);
		}

		public static IEnumerable<IIterativeSolverSetup<T>> Load()
		{
			return LoadFromAssembly(typeof(SolverSetup<T>), false);
		}
	}
	public sealed class UnitPreconditioner<T> : IPreconditioner<T> where T : struct, IEquatable<T>, IFormattable
	{
		private int _size;

		public void Initialize(Matrix<T> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_size = matrix.RowCount;
		}

		public void Approximate(Vector<T> rhs, Vector<T> lhs)
		{
			if (lhs.Count != rhs.Count || lhs.Count != _size)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			rhs.CopyTo(lhs);
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Factorization
{
	public abstract class Cholesky<T> : ISolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		public Matrix<T> Factor { get; private set; }

		public abstract T Determinant { get; }

		public abstract T DeterminantLn { get; }

		protected Cholesky(Matrix<T> factor)
		{
			Factor = factor;
		}

		public abstract void Factorize(Matrix<T> matrix);

		public virtual Matrix<T> Solve(Matrix<T> input)
		{
			Matrix<T> result = Matrix<T>.Build.SameAs(input, input.RowCount, input.ColumnCount, fullyMutable: true);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Matrix<T> input, Matrix<T> result);

		public virtual Vector<T> Solve(Vector<T> input)
		{
			Vector<T> result = Vector<T>.Build.SameAs(input, input.Count);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Vector<T> input, Vector<T> result);
	}
	public abstract class Evd<T> : ISolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		public bool IsSymmetric { get; private set; }

		public abstract T Determinant { get; }

		public abstract int Rank { get; }

		public abstract bool IsFullRank { get; }

		public Vector<System.Numerics.Complex> EigenValues { get; private set; }

		public Matrix<T> EigenVectors { get; private set; }

		public Matrix<T> D { get; private set; }

		protected Evd(Matrix<T> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<T> blockDiagonal, bool isSymmetric)
		{
			EigenVectors = eigenVectors;
			EigenValues = eigenValues;
			D = blockDiagonal;
			IsSymmetric = isSymmetric;
		}

		public virtual Matrix<T> Solve(Matrix<T> input)
		{
			Matrix<T> result = Matrix<T>.Build.SameAs(EigenVectors, EigenVectors.ColumnCount, input.ColumnCount, fullyMutable: true);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Matrix<T> input, Matrix<T> result);

		public virtual Vector<T> Solve(Vector<T> input)
		{
			Vector<T> result = Vector<T>.Build.SameAs(EigenVectors, EigenVectors.ColumnCount);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Vector<T> input, Vector<T> result);
	}
	public abstract class GramSchmidt<T> : QR<T> where T : struct, IEquatable<T>, IFormattable
	{
		protected GramSchmidt(Matrix<T> q, Matrix<T> rFull)
			: base(q, rFull, QRMethod.Full)
		{
		}
	}
	public interface ISolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		Matrix<T> Solve(Matrix<T> input);

		void Solve(Matrix<T> input, Matrix<T> result);

		Vector<T> Solve(Vector<T> input);

		void Solve(Vector<T> input, Vector<T> result);
	}
	public abstract class LU<T> : ISolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		private static readonly T One = BuilderInstance<T>.Matrix.One;

		private readonly Lazy<Matrix<T>> _lazyL;

		private readonly Lazy<Matrix<T>> _lazyU;

		private readonly Lazy<Permutation> _lazyP;

		protected readonly Matrix<T> Factors;

		protected readonly int[] Pivots;

		public Matrix<T> L => _lazyL.Value;

		public Matrix<T> U => _lazyU.Value;

		public Permutation P => _lazyP.Value;

		public abstract T Determinant { get; }

		protected LU(Matrix<T> factors, int[] pivots)
		{
			Factors = factors;
			Pivots = pivots;
			_lazyL = new Lazy<Matrix<T>>(ComputeL);
			_lazyU = new Lazy<Matrix<T>>(Factors.UpperTriangle);
			_lazyP = new Lazy<Permutation>(() => Permutation.FromInversions(Pivots));
		}

		private Matrix<T> ComputeL()
		{
			Matrix<T> matrix = Factors.LowerTriangle();
			for (int i = 0; i < matrix.RowCount; i++)
			{
				matrix.At(i, i, One);
			}
			return matrix;
		}

		public virtual Matrix<T> Solve(Matrix<T> input)
		{
			Matrix<T> result = Matrix<T>.Build.SameAs(input, input.RowCount, input.ColumnCount, fullyMutable: true);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Matrix<T> input, Matrix<T> result);

		public virtual Vector<T> Solve(Vector<T> input)
		{
			Vector<T> result = Vector<T>.Build.SameAs(input, input.Count);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Vector<T> input, Vector<T> result);

		public abstract Matrix<T> Inverse();
	}
	public enum QRMethod
	{
		Full,
		Thin
	}
	public abstract class QR<T> : ISolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		private readonly Lazy<Matrix<T>> _lazyR;

		protected readonly Matrix<T> FullR;

		protected readonly QRMethod Method;

		public Matrix<T> Q { get; }

		public Matrix<T> R => _lazyR.Value;

		public abstract T Determinant { get; }

		public abstract bool IsFullRank { get; }

		protected QR(Matrix<T> q, Matrix<T> rFull, QRMethod method)
		{
			Q = q;
			FullR = rFull;
			Method = method;
			_lazyR = new Lazy<Matrix<T>>(FullR.UpperTriangle);
		}

		public virtual Matrix<T> Solve(Matrix<T> input)
		{
			Matrix<T> result = Matrix<T>.Build.SameAs(input, FullR.ColumnCount, input.ColumnCount, fullyMutable: true);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Matrix<T> input, Matrix<T> result);

		public virtual Vector<T> Solve(Vector<T> input)
		{
			Vector<T> result = Vector<T>.Build.SameAs(input, FullR.ColumnCount);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Vector<T> input, Vector<T> result);
	}
	public abstract class Svd<T> : ISolver<T> where T : struct, IEquatable<T>, IFormattable
	{
		private readonly Lazy<Matrix<T>> _lazyW;

		protected readonly bool VectorsComputed;

		public Vector<T> S { get; }

		public Matrix<T> U { get; }

		public Matrix<T> VT { get; }

		public Matrix<T> W => _lazyW.Value;

		public abstract int Rank { get; }

		public abstract double L2Norm { get; }

		public abstract T ConditionNumber { get; }

		public abstract T Determinant { get; }

		protected Svd(Vector<T> s, Matrix<T> u, Matrix<T> vt, bool vectorsComputed)
		{
			S = s;
			U = u;
			VT = vt;
			VectorsComputed = vectorsComputed;
			_lazyW = new Lazy<Matrix<T>>(ComputeW);
		}

		private Matrix<T> ComputeW()
		{
			int rowCount = U.RowCount;
			int columnCount = VT.ColumnCount;
			Matrix<T> matrix = Matrix<T>.Build.SameAs(U, rowCount, columnCount);
			for (int i = 0; i < rowCount; i++)
			{
				for (int j = 0; j < columnCount; j++)
				{
					if (i == j)
					{
						matrix.At(i, i, S[i]);
					}
				}
			}
			return matrix;
		}

		public virtual Matrix<T> Solve(Matrix<T> input)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			Matrix<T> result = Matrix<T>.Build.SameAs(U, VT.ColumnCount, input.ColumnCount, fullyMutable: true);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Matrix<T> input, Matrix<T> result);

		public virtual Vector<T> Solve(Vector<T> input)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			Vector<T> result = Vector<T>.Build.SameAs(U, VT.ColumnCount);
			Solve(input, result);
			return result;
		}

		public abstract void Solve(Vector<T> input, Vector<T> result);
	}
}
namespace MathNet.Numerics.LinearAlgebra.Complex32
{
	internal class MatrixBuilder : MatrixBuilder<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Zero => MathNet.Numerics.Complex32.Zero;

		public override MathNet.Numerics.Complex32 One => MathNet.Numerics.Complex32.One;

		public override Matrix<MathNet.Numerics.Complex32> Dense(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> storage)
		{
			return new DenseMatrix(storage);
		}

		public override Matrix<MathNet.Numerics.Complex32> Sparse(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> storage)
		{
			return new SparseMatrix(storage);
		}

		public override Matrix<MathNet.Numerics.Complex32> Diagonal(DiagonalMatrixStorage<MathNet.Numerics.Complex32> storage)
		{
			return new DiagonalMatrix(storage);
		}

		public override Matrix<MathNet.Numerics.Complex32> Random(int rows, int columns, IContinuousDistribution distribution)
		{
			return Dense(rows, columns, Generate.RandomComplex32(rows * columns, distribution));
		}

		public override IIterationStopCriterion<MathNet.Numerics.Complex32>[] IterativeSolverStopCriteria(int maxIterations = 1000)
		{
			return new IIterationStopCriterion<MathNet.Numerics.Complex32>[4]
			{
				new FailureStopCriterion<MathNet.Numerics.Complex32>(),
				new DivergenceStopCriterion<MathNet.Numerics.Complex32>(),
				new IterationCountStopCriterion<MathNet.Numerics.Complex32>(maxIterations),
				new ResidualStopCriterion<MathNet.Numerics.Complex32>(1E-06)
			};
		}

		internal override MathNet.Numerics.Complex32 Add(MathNet.Numerics.Complex32 x, MathNet.Numerics.Complex32 y)
		{
			return x + y;
		}
	}
	internal class VectorBuilder : VectorBuilder<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Zero => MathNet.Numerics.Complex32.Zero;

		public override MathNet.Numerics.Complex32 One => MathNet.Numerics.Complex32.One;

		public override Vector<MathNet.Numerics.Complex32> Dense(DenseVectorStorage<MathNet.Numerics.Complex32> storage)
		{
			return new DenseVector(storage);
		}

		public override Vector<MathNet.Numerics.Complex32> Sparse(SparseVectorStorage<MathNet.Numerics.Complex32> storage)
		{
			return new SparseVector(storage);
		}

		public override Vector<MathNet.Numerics.Complex32> Random(int length, IContinuousDistribution distribution)
		{
			return Dense(Generate.RandomComplex32(length, distribution));
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseMatrix {RowCount}x{ColumnCount}-Complex32")]
	public class DenseMatrix : Matrix
	{
		private readonly int _rowCount;

		private readonly int _columnCount;

		private readonly MathNet.Numerics.Complex32[] _values;

		public MathNet.Numerics.Complex32[] Values => _values;

		public DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
			_rowCount = storage.RowCount;
			_columnCount = storage.ColumnCount;
			_values = storage.Data;
		}

		public DenseMatrix(int order)
			: this(new DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>(order, order))
		{
		}

		public DenseMatrix(int rows, int columns)
			: this(new DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>(rows, columns))
		{
		}

		public DenseMatrix(int rows, int columns, MathNet.Numerics.Complex32[] storage)
			: this(new DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>(rows, columns, storage))
		{
		}

		public static DenseMatrix OfMatrix(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfMatrix(matrix.Storage));
		}

		public static DenseMatrix OfArray(MathNet.Numerics.Complex32[,] array)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfArray(array));
		}

		public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, MathNet.Numerics.Complex32>> enumerable)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable<MathNet.Numerics.Complex32> columnMajor)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfColumnMajorEnumerable(rows, columns, columnMajor));
		}

		public static DenseMatrix OfColumns(IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<MathNet.Numerics.Complex32> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfColumnEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfColumnArrays(params MathNet.Numerics.Complex32[][] columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfColumnArrays(columns));
		}

		public static DenseMatrix OfColumnArrays(IEnumerable<MathNet.Numerics.Complex32[]> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfColumnArrays((columns as MathNet.Numerics.Complex32[][]) ?? columns.ToArray()));
		}

		public static DenseMatrix OfColumnVectors(params Vector<MathNet.Numerics.Complex32>[] columns)
		{
			VectorStorage<MathNet.Numerics.Complex32>[] array = new VectorStorage<MathNet.Numerics.Complex32>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfColumnVectors(array));
		}

		public static DenseMatrix OfColumnVectors(IEnumerable<Vector<MathNet.Numerics.Complex32>> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfColumnVectors(columns.Select((Vector<MathNet.Numerics.Complex32> c) => c.Storage).ToArray()));
		}

		public static DenseMatrix OfRows(IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<MathNet.Numerics.Complex32> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfRowEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfRowArrays(params MathNet.Numerics.Complex32[][] rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfRowArrays(rows));
		}

		public static DenseMatrix OfRowArrays(IEnumerable<MathNet.Numerics.Complex32[]> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfRowArrays((rows as MathNet.Numerics.Complex32[][]) ?? rows.ToArray()));
		}

		public static DenseMatrix OfRowVectors(params Vector<MathNet.Numerics.Complex32>[] rows)
		{
			VectorStorage<MathNet.Numerics.Complex32>[] array = new VectorStorage<MathNet.Numerics.Complex32>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfRowVectors(array));
		}

		public static DenseMatrix OfRowVectors(IEnumerable<Vector<MathNet.Numerics.Complex32>> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfRowVectors(rows.Select((Vector<MathNet.Numerics.Complex32> r) => r.Storage).ToArray()));
		}

		public static DenseMatrix OfDiagonalVector(Vector<MathNet.Numerics.Complex32> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Count, diagonal.Count);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector<MathNet.Numerics.Complex32> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(MathNet.Numerics.Complex32[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Length, diagonal.Length);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(int rows, int columns, MathNet.Numerics.Complex32[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix Create(int rows, int columns, MathNet.Numerics.Complex32 value)
		{
			if (value == MathNet.Numerics.Complex32.Zero)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfValue(rows, columns, value));
		}

		public static DenseMatrix Create(int rows, int columns, Func<int, int, MathNet.Numerics.Complex32> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfInit(rows, columns, init));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, MathNet.Numerics.Complex32 value)
		{
			if (value == MathNet.Numerics.Complex32.Zero)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, Func<int, MathNet.Numerics.Complex32> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfDiagonalInit(rows, columns, init));
		}

		public static DenseMatrix CreateIdentity(int order)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>.OfDiagonalInit(order, order, (int i) => Matrix<MathNet.Numerics.Complex32>.One));
		}

		public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DenseMatrix(new DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32>(rows, columns, Generate.RandomComplex32(rows * columns, distribution)));
		}

		public override double L1Norm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.OneNorm, _rowCount, _columnCount, _values);
		}

		public override double InfinityNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.InfinityNorm, _rowCount, _columnCount, _values);
		}

		public override double FrobeniusNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.FrobeniusNorm, _rowCount, _columnCount, _values);
		}

		protected override void DoNegate(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1, _values, denseMatrix._values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoConjugate(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_values, denseMatrix._values);
			}
			else
			{
				base.DoConjugate(result);
			}
		}

		protected override void DoAdd(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					MathNet.Numerics.Complex32[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				base.Storage.CopyToUnchecked(result.Storage, ExistingData.Clear);
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) + data[i]);
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					MathNet.Numerics.Complex32[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				CopyTo(result);
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) - data[i]);
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseMatrix._values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, denseVector2.Values);
			}
			else
			{
				base.DoMultiply(rightSide, result);
			}
		}

		protected override void DoMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.ColumnCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoMultiply(other, result);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, 1f, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0f, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.RowCount);
				if (num < other.RowCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.RowCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoConjugateTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.ConjugateTranspose, 1f, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0f, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[data.Length];
				for (int i = 0; i < data.Length; i++)
				{
					array[i] = data[i].Conjugate();
				}
				int num = Math.Min(base.ColumnCount, other.RowCount);
				if (num < other.RowCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.RowCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < base.RowCount; k++)
					{
						result.At(k, j, _values[num2] * array[j]);
						num2++;
					}
				}
			}
			else
			{
				base.DoConjugateTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1f, _values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, 0f, denseVector2.Values);
			}
			else
			{
				base.DoTransposeThisAndMultiply(rightSide, result);
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.ConjugateTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1f, _values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, 0f, denseVector2.Values);
			}
			else
			{
				base.DoConjugateTransposeThisAndMultiply(rightSide, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1f, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0f, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.RowCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.ColumnCount, base.RowCount, other.ColumnCount - base.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < base.ColumnCount; i++)
				{
					for (int j = 0; j < num; j++)
					{
						result.At(i, j, _values[num2] * data[j]);
						num2++;
					}
					num2 += base.RowCount - num;
				}
			}
			else
			{
				base.DoTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.ConjugateTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1f, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0f, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.RowCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.ColumnCount, base.RowCount, other.ColumnCount - base.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < base.ColumnCount; i++)
				{
					for (int j = 0; j < num; j++)
					{
						result.At(i, j, _values[num2].Conjugate() * data[j]);
						num2++;
					}
					num2 += base.RowCount - num;
				}
			}
			else
			{
				base.DoConjugateTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoDivide(MathNet.Numerics.Complex32 divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1f / divisor, _values, denseMatrix._values);
			}
			else
			{
				base.DoDivide(divisor, result);
			}
		}

		protected override void DoPointwiseMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Matrix<MathNet.Numerics.Complex32> divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (divisor is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Matrix<MathNet.Numerics.Complex32> exponent, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (exponent is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		public override MathNet.Numerics.Complex32 Trace()
		{
			if (_rowCount != _columnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < _rowCount; i++)
			{
				zero += _values[i * _rowCount + i];
			}
			return zero;
		}

		public static DenseMatrix operator +(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Add(rightSide);
		}

		public static DenseMatrix operator +(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Clone();
		}

		public static DenseMatrix operator -(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Subtract(rightSide);
		}

		public static DenseMatrix operator -(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Negate();
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseMatrix operator *(MathNet.Numerics.Complex32 leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Multiply(leftSide);
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide._columnCount != rightSide._rowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseMatrix leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseVector leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.LeftMultiply(leftSide);
		}

		public static DenseMatrix operator %(DenseMatrix leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Remainder(rightSide);
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < base.ColumnCount; i++)
			{
				int num = i * base.RowCount;
				for (int j = i + 1; j < base.RowCount; j++)
				{
					if (_values[j * base.ColumnCount + i] != _values[num + j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public override bool IsHermitian()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int num = base.RowCount + 1;
			for (int i = 0; i < _values.Length; i += num)
			{
				if (!_values[i].IsReal())
				{
					return false;
				}
			}
			for (int j = 0; j < base.ColumnCount; j++)
			{
				int num2 = j * base.RowCount;
				for (int k = j + 1; k < base.RowCount; k++)
				{
					if (_values[k * base.ColumnCount + j] != _values[num2 + k].Conjugate())
					{
						return false;
					}
				}
			}
			return true;
		}

		public override Cholesky<MathNet.Numerics.Complex32> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseCholesky.Create(this);
		}

		public override LU<MathNet.Numerics.Complex32> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseLU.Create(this);
		}

		public override QR<MathNet.Numerics.Complex32> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseQR.Create(this, method);
		}

		public override GramSchmidt<MathNet.Numerics.Complex32> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseGramSchmidt.Create(this);
		}

		public override Svd<MathNet.Numerics.Complex32> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseSvd.Create(this, computeVectors);
		}

		public override Evd<MathNet.Numerics.Complex32> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseVector {Count}-Complex32")]
	public class DenseVector : Vector
	{
		private readonly int _length;

		private readonly MathNet.Numerics.Complex32[] _values;

		public MathNet.Numerics.Complex32[] Values => _values;

		public DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
			_length = storage.Length;
			_values = storage.Data;
		}

		public DenseVector(int length)
			: this(new DenseVectorStorage<MathNet.Numerics.Complex32>(length))
		{
		}

		public DenseVector(MathNet.Numerics.Complex32[] storage)
			: this(new DenseVectorStorage<MathNet.Numerics.Complex32>(storage.Length, storage))
		{
		}

		public static DenseVector OfVector(Vector<MathNet.Numerics.Complex32> vector)
		{
			return new DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32>.OfVector(vector.Storage));
		}

		public static DenseVector OfArray(MathNet.Numerics.Complex32[] array)
		{
			return new DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32>.OfVector(new DenseVectorStorage<MathNet.Numerics.Complex32>(array.Length, array)));
		}

		public static DenseVector OfEnumerable(IEnumerable<MathNet.Numerics.Complex32> enumerable)
		{
			return new DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32>.OfEnumerable(enumerable));
		}

		public static DenseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, MathNet.Numerics.Complex32>> enumerable)
		{
			return new DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32>.OfIndexedEnumerable(length, enumerable));
		}

		public static DenseVector Create(int length, MathNet.Numerics.Complex32 value)
		{
			if (value == MathNet.Numerics.Complex32.Zero)
			{
				return new DenseVector(length);
			}
			return new DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32>.OfValue(length, value));
		}

		public static DenseVector Create(int length, Func<int, MathNet.Numerics.Complex32> init)
		{
			return new DenseVector(DenseVectorStorage<MathNet.Numerics.Complex32>.OfInit(length, init));
		}

		public static DenseVector CreateRandom(int length, IContinuousDistribution distribution)
		{
			MathNet.Numerics.Complex32[] data = Generate.RandomComplex32(length, distribution);
			return new DenseVector(new DenseVectorStorage<MathNet.Numerics.Complex32>(length, data));
		}

		public static explicit operator MathNet.Numerics.Complex32[](DenseVector vector)
		{
			if (vector == null)
			{
				throw new ArgumentNullException("vector");
			}
			return vector.Values;
		}

		public static implicit operator DenseVector(MathNet.Numerics.Complex32[] array)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			return new DenseVector(array);
		}

		protected override void DoAdd(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		public static DenseVector operator +(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Add(rightSide);
		}

		protected override void DoSubtract(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		public static DenseVector operator -(DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Negate();
		}

		public static DenseVector operator -(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Subtract(rightSide);
		}

		protected override void DoNegate(Vector<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(-MathNet.Numerics.Complex32.One, _values, denseVector.Values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoConjugate(Vector<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_values, denseVector._values);
			}
			else
			{
				base.DoConjugate(result);
			}
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseVector.Values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override MathNet.Numerics.Complex32 DoDotProduct(Vector<MathNet.Numerics.Complex32> other)
		{
			if (!(other is DenseVector denseVector))
			{
				return base.DoDotProduct(other);
			}
			return LinearAlgebraControl.Provider.DotProduct(_values, denseVector.Values);
		}

		protected override MathNet.Numerics.Complex32 DoConjugateDotProduct(Vector<MathNet.Numerics.Complex32> other)
		{
			if (other is DenseVector denseVector)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int i = 0; i < _values.Length; i++)
				{
					zero += _values[i].Conjugate() * denseVector._values[i];
				}
				return zero;
			}
			return base.DoConjugateDotProduct(other);
		}

		public static DenseVector operator *(DenseVector leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(MathNet.Numerics.Complex32 leftSide, DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Multiply(leftSide);
		}

		public static MathNet.Numerics.Complex32 operator *(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static DenseVector operator /(DenseVector leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Divide(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			float num2 = _values[num].Magnitude;
			for (int i = 1; i < _length; i++)
			{
				float magnitude = _values[i].Magnitude;
				if (magnitude < num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			float num2 = _values[num].Magnitude;
			for (int i = 1; i < _length; i++)
			{
				float magnitude = _values[i].Magnitude;
				if (magnitude > num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override MathNet.Numerics.Complex32 Sum()
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < _length; i++)
			{
				zero += _values[i];
			}
			return zero;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += (double)_values[i].Magnitude;
			}
			return num;
		}

		public override double L2Norm()
		{
			return _values.Aggregate(MathNet.Numerics.Complex32.Zero, SpecialFunctions.Hypotenuse).Magnitude;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(_values, (int i, MathNet.Numerics.Complex32 v) => v.Magnitude, Math.Max, 0f);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += Math.Pow(_values[i].Magnitude, p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Vector<MathNet.Numerics.Complex32> divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			if (divisor is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Vector<MathNet.Numerics.Complex32> exponent, Vector<MathNet.Numerics.Complex32> result)
		{
			if (exponent is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		public static DenseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			string[] array = value.Split(new string[1] { formatProvider.GetTextInfo().ListSeparator }, StringSplitOptions.RemoveEmptyEntries);
			List<MathNet.Numerics.Complex32> list = new List<MathNet.Numerics.Complex32>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				string[] array3 = array2[i].Split(new string[2] { " ", "\t" }, StringSplitOptions.RemoveEmptyEntries);
				string text = string.Empty;
				for (int j = 0; j < array3.Length; j++)
				{
					text += array3[j];
					if (!text.EndsWith("+") && !text.EndsWith("-") && (!text.StartsWith("(") || text.EndsWith(")")))
					{
						string text2 = ((j < array3.Length - 1) ? array3[j + 1] : string.Empty);
						if (!text2.StartsWith("+") && !text2.StartsWith("-"))
						{
							list.Add(text.ToComplex32(formatProvider));
							text = string.Empty;
						}
					}
				}
				if (text != string.Empty)
				{
					throw new FormatException();
				}
			}
			if (list.Count == 0)
			{
				throw new FormatException();
			}
			return new DenseVector(list.ToArray());
		}

		public static bool TryParse(string value, out DenseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out DenseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}
	}
	[Serializable]
	[DebuggerDisplay("DiagonalMatrix {RowCount}x{ColumnCount}-Complex32")]
	public class DiagonalMatrix : Matrix
	{
		private readonly MathNet.Numerics.Complex32[] _data;

		public DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
			_data = storage.Data;
		}

		public DiagonalMatrix(int order)
			: this(new DiagonalMatrixStorage<MathNet.Numerics.Complex32>(order, order))
		{
		}

		public DiagonalMatrix(int rows, int columns)
			: this(new DiagonalMatrixStorage<MathNet.Numerics.Complex32>(rows, columns))
		{
		}

		public DiagonalMatrix(int rows, int columns, MathNet.Numerics.Complex32 diagonalValue)
			: this(rows, columns)
		{
			for (int i = 0; i < _data.Length; i++)
			{
				_data[i] = diagonalValue;
			}
		}

		public DiagonalMatrix(int rows, int columns, MathNet.Numerics.Complex32[] diagonalStorage)
			: this(new DiagonalMatrixStorage<MathNet.Numerics.Complex32>(rows, columns, diagonalStorage))
		{
		}

		public static DiagonalMatrix OfMatrix(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32>.OfMatrix(matrix.Storage));
		}

		public static DiagonalMatrix OfArray(MathNet.Numerics.Complex32[,] array)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32>.OfArray(array));
		}

		public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable<Tuple<int, MathNet.Numerics.Complex32>> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32>.OfIndexedEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable<MathNet.Numerics.Complex32> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32>.OfEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix Create(int rows, int columns, Func<int, MathNet.Numerics.Complex32> init)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32>.OfInit(rows, columns, init));
		}

		public static DiagonalMatrix CreateIdentity(int order)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<MathNet.Numerics.Complex32>.OfValue(order, order, Matrix<MathNet.Numerics.Complex32>.One));
		}

		public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DiagonalMatrix(new DiagonalMatrixStorage<MathNet.Numerics.Complex32>(rows, columns, Generate.RandomComplex32(Math.Min(rows, columns), distribution)));
		}

		protected override void DoNegate(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, -_data[i]);
			}
		}

		protected override void DoConjugate(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i].Conjugate());
			}
		}

		protected override void DoAdd(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.AddArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.CopyTo(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoSubtract(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.Negate(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (scalar.IsZero())
			{
				result.Clear();
			}
			else if (scalar.IsOne())
			{
				CopyTo(result);
			}
			else if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _data, diagonalMatrix._data);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.RowCount)
			{
				result.ClearSubVector(base.ColumnCount, base.RowCount - base.ColumnCount);
			}
			if (num == base.ColumnCount && rightSide.Storage is DenseVectorStorage<MathNet.Numerics.Complex32> denseVectorStorage && result.Storage is DenseVectorStorage<MathNet.Numerics.Complex32> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = denseColumnMajorMatrixStorage.Data;
				MathNet.Numerics.Complex32[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.RowCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => x * _data[i], 0, 0, Math.Min(base.RowCount, other.RowCount), 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = denseColumnMajorMatrixStorage.Data;
				MathNet.Numerics.Complex32[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount - denseColumnMajorMatrixStorage.ColumnCount, 0, denseColumnMajorMatrixStorage.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
					{
						result.At(i, j, data[num2] * data2[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoConjugateTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.ConjugateArray(array2, array2);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = denseColumnMajorMatrixStorage.Data;
				MathNet.Numerics.Complex32[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount - denseColumnMajorMatrixStorage.ColumnCount, 0, denseColumnMajorMatrixStorage.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
					{
						result.At(i, j, data[num2].Conjugate() * data2[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoConjugateTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = denseColumnMajorMatrixStorage.Data;
				MathNet.Numerics.Complex32[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount);
				if (num < base.ColumnCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => x * _data[i], 0, 0, other.RowCount, 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.ConjugateArray(array, array);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage)
			{
				MathNet.Numerics.Complex32[] data = denseColumnMajorMatrixStorage.Data;
				MathNet.Numerics.Complex32[] array3 = new MathNet.Numerics.Complex32[_data.Length];
				for (int i = 0; i < _data.Length; i++)
				{
					array3[i] = _data[i].Conjugate();
				}
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount);
				if (num < base.ColumnCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int j = 0; j < denseColumnMajorMatrixStorage.ColumnCount; j++)
				{
					for (int k = 0; k < num; k++)
					{
						result.At(k, j, data[num2] * array3[k]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else
			{
				base.DoConjugateTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.ColumnCount)
			{
				result.ClearSubVector(base.RowCount, base.ColumnCount - base.RowCount);
			}
			if (num == base.RowCount && rightSide.Storage is DenseVectorStorage<MathNet.Numerics.Complex32> denseVectorStorage && result.Storage is DenseVectorStorage<MathNet.Numerics.Complex32> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.ColumnCount)
			{
				result.ClearSubVector(base.RowCount, base.ColumnCount - base.RowCount);
			}
			if (num == base.RowCount && rightSide.Storage is DenseVectorStorage<MathNet.Numerics.Complex32> denseVectorStorage && result.Storage is DenseVectorStorage<MathNet.Numerics.Complex32> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_data, denseVectorStorage2.Data);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(denseVectorStorage2.Data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i].Conjugate() * rightSide.At(i));
			}
		}

		protected override void DoDivide(MathNet.Numerics.Complex32 divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (divisor == MathNet.Numerics.Complex32.One)
			{
				CopyTo(result);
				return;
			}
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1f / divisor, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i] / divisor);
			}
		}

		protected override void DoDivideByThis(MathNet.Numerics.Complex32 dividend, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				MathNet.Numerics.Complex32[] resultData = diagonalMatrix._data;
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						resultData[j] = dividend / _data[j];
					}
				});
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, dividend / _data[i]);
				}
			}
		}

		public override MathNet.Numerics.Complex32 Determinant()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			return _data.Aggregate(MathNet.Numerics.Complex32.One, (MathNet.Numerics.Complex32 current, MathNet.Numerics.Complex32 t) => current * t);
		}

		public override Vector<MathNet.Numerics.Complex32> Diagonal()
		{
			return new DenseVector(_data).Clone();
		}

		public override void SetDiagonal(MathNet.Numerics.Complex32[] source)
		{
			if (source.Length != _data.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "source");
			}
			Array.Copy(source, 0, _data, 0, source.Length);
		}

		public override void SetDiagonal(Vector<MathNet.Numerics.Complex32> source)
		{
			if (source is DenseVector denseVector)
			{
				if (_data.Length != denseVector.Values.Length)
				{
					throw new ArgumentException("All vectors must have the same dimensionality.", "source");
				}
				Array.Copy(denseVector.Values, 0, _data, 0, denseVector.Values.Length);
			}
			else
			{
				base.SetDiagonal(source);
			}
		}

		public override double L1Norm()
		{
			return _data.Aggregate(0f, (float current, MathNet.Numerics.Complex32 t) => Math.Max(current, t.Magnitude));
		}

		public override double L2Norm()
		{
			return _data.Aggregate(0f, (float current, MathNet.Numerics.Complex32 t) => Math.Max(current, t.Magnitude));
		}

		public override double InfinityNorm()
		{
			return L1Norm();
		}

		public override double FrobeniusNorm()
		{
			return Math.Sqrt(_data.Sum((MathNet.Numerics.Complex32 t) => t.Magnitude * t.Magnitude));
		}

		public override MathNet.Numerics.Complex32 ConditionNumber()
		{
			float num = float.NegativeInfinity;
			float num2 = float.PositiveInfinity;
			MathNet.Numerics.Complex32[] data = _data;
			for (int i = 0; i < data.Length; i++)
			{
				MathNet.Numerics.Complex32 complex = data[i];
				num = Math.Max(num, complex.Magnitude);
				num2 = Math.Min(num2, complex.Magnitude);
			}
			return num / num2;
		}

		public override Matrix<MathNet.Numerics.Complex32> Inverse()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DiagonalMatrix diagonalMatrix = (DiagonalMatrix)Clone();
			for (int i = 0; i < _data.Length; i++)
			{
				if (_data[i] != 0f)
				{
					diagonalMatrix._data[i] = 1f / _data[i];
					continue;
				}
				throw new ArgumentException("Matrix must not be singular.");
			}
			return diagonalMatrix;
		}

		public override Matrix<MathNet.Numerics.Complex32> LowerTriangle()
		{
			return Clone();
		}

		public override void LowerTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this != result)
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, _data[i]);
				}
			}
		}

		public override Matrix<MathNet.Numerics.Complex32> StrictlyLowerTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyLowerTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<MathNet.Numerics.Complex32> UpperTriangle()
		{
			return Clone();
		}

		public override void UpperTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i]);
			}
		}

		public override Matrix<MathNet.Numerics.Complex32> StrictlyUpperTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyUpperTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<MathNet.Numerics.Complex32> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			Matrix<MathNet.Numerics.Complex32> matrix = ((rowIndex == columnIndex) ? ((Matrix)new DiagonalMatrix(rowCount, columnCount)) : ((Matrix)new SparseMatrix(rowCount, columnCount)));
			base.Storage.CopySubMatrixTo(matrix.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public override void PermuteColumns(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public override void PermuteRows(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public sealed override bool IsSymmetric()
		{
			return true;
		}

		public sealed override bool IsHermitian()
		{
			for (int i = 0; i < _data.Length; i++)
			{
				if (!_data[i].IsReal())
				{
					return false;
				}
			}
			return true;
		}
	}
	[Serializable]
	public abstract class Matrix : Matrix<MathNet.Numerics.Complex32>
	{
		protected Matrix(MatrixStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((MathNet.Numerics.Complex32 x) => (!((double)x.Magnitude < threshold)) ? x : MathNet.Numerics.Complex32.Zero);
		}

		public sealed override Matrix<MathNet.Numerics.Complex32> ConjugateTranspose()
		{
			Matrix<MathNet.Numerics.Complex32> matrix = Transpose();
			matrix.MapInplace((MathNet.Numerics.Complex32 c) => c.Conjugate());
			return matrix;
		}

		public sealed override void ConjugateTranspose(Matrix<MathNet.Numerics.Complex32> result)
		{
			Transpose(result);
			result.MapInplace((MathNet.Numerics.Complex32 c) => c.Conjugate());
		}

		protected override void DoConjugate(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Conjugate, result);
		}

		protected override void DoNegate(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Negate, result);
		}

		protected override void DoAdd(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Add, other, result);
		}

		protected override void DoSubtract(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Subtract, other, result);
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x * scalar, result);
		}

		protected override void DoMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					zero += At(i, j) * rightSide[j];
				}
				result[i] = zero;
			}
		}

		protected override void DoDivide(MathNet.Numerics.Complex32 divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x / divisor, result, divisor.IsZero() ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(MathNet.Numerics.Complex32 dividend, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				for (int j = 0; j != other.ColumnCount; j++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						zero += At(i, k) * other.At(k, j);
					}
					result.At(i, j, zero);
				}
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < other.RowCount; i++)
			{
				for (int j = 0; j < base.RowCount; j++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						zero += At(j, k) * other.At(i, k);
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoConjugateTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < other.RowCount; i++)
			{
				for (int j = 0; j < base.RowCount; j++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						zero += At(j, k) * other.At(i, k).Conjugate();
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < other.ColumnCount; i++)
			{
				for (int j = 0; j < base.ColumnCount; j++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int k = 0; k < base.RowCount; k++)
					{
						zero += At(k, j) * other.At(k, i);
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < other.ColumnCount; i++)
			{
				for (int j = 0; j < base.ColumnCount; j++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int k = 0; k < base.RowCount; k++)
					{
						zero += At(k, j).Conjugate() * other.At(k, i);
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < base.ColumnCount; i++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = 0; j < base.RowCount; j++)
				{
					zero += At(j, i) * rightSide[j];
				}
				result[i] = zero;
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < base.ColumnCount; i++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = 0; j < base.RowCount; j++)
				{
					zero += At(j, i).Conjugate() * rightSide[j];
				}
				result[i] = zero;
			}
		}

		protected override void DoPointwiseMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Multiply, other, result);
		}

		protected override void DoPointwiseDivide(Matrix<MathNet.Numerics.Complex32> divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Divide, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(MathNet.Numerics.Complex32 exponent, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x.Power(exponent), result, Zeros.Include);
		}

		protected override void DoPointwisePower(Matrix<MathNet.Numerics.Complex32> exponent, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Pow, result, Zeros.Include);
		}

		protected sealed override void DoPointwiseModulus(Matrix<MathNet.Numerics.Complex32> divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoPointwiseRemainder(Matrix<MathNet.Numerics.Complex32> divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoModulus(MathNet.Numerics.Complex32 divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoModulusByThis(MathNet.Numerics.Complex32 dividend, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainder(MathNet.Numerics.Complex32 divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainderByThis(MathNet.Numerics.Complex32 dividend, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseExp(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Exp, result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Log, result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => (MathNet.Numerics.Complex32)MathNet.Numerics.Complex32.Abs(x), result);
		}

		protected override void DoPointwiseAcos(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Acos, result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Asin, result);
		}

		protected override void DoPointwiseAtan(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Atan, result);
		}

		protected override void DoPointwiseAtan2(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCeiling(Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCos(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Cos, result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Cosh, result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseLog10(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Log10, result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSign(Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSin(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Sin, result);
		}

		protected override void DoPointwiseSinh(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Sinh, result);
		}

		protected override void DoPointwiseSqrt(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Sqrt, result);
		}

		protected override void DoPointwiseTan(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Tan, result);
		}

		protected override void DoPointwiseTanh(Matrix<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Tanh, result);
		}

		public override Matrix<MathNet.Numerics.Complex32> PseudoInverse()
		{
			Svd<MathNet.Numerics.Complex32> svd = Svd();
			Matrix<MathNet.Numerics.Complex32> w = svd.W;
			Vector<MathNet.Numerics.Complex32> s = svd.S;
			float num = (float)((double)Math.Max(base.RowCount, base.ColumnCount) * svd.L2Norm * Precision.SinglePrecision);
			for (int i = 0; i < s.Count; i++)
			{
				s[i] = ((s[i].Magnitude < num) ? ((MathNet.Numerics.Complex32)0) : (1f / s[i]));
			}
			w.SetDiagonal(s);
			return (svd.U * (w * svd.VT)).ConjugateTranspose();
		}

		public override MathNet.Numerics.Complex32 Trace()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < base.RowCount; i++)
			{
				zero += At(i, i);
			}
			return zero;
		}

		protected override void DoPointwiseMinimum(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			float absolute = scalar.Magnitude;
			Map((MathNet.Numerics.Complex32 x) => Math.Min(absolute, x.Magnitude), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			float absolute = scalar.Magnitude;
			Map((MathNet.Numerics.Complex32 x) => Math.Max(absolute, x.Magnitude), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2((MathNet.Numerics.Complex32 x, MathNet.Numerics.Complex32 y) => Math.Min(x.Magnitude, y.Magnitude), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			Map2((MathNet.Numerics.Complex32 x, MathNet.Numerics.Complex32 y) => Math.Max(x.Magnitude, y.Magnitude), other, result);
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.ColumnCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.RowCount; j++)
				{
					num2 += (double)At(j, i).Magnitude;
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double InfinityNorm()
		{
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					num2 += (double)At(i, j).Magnitude;
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			Matrix<MathNet.Numerics.Complex32> matrix = ConjugateTranspose();
			Matrix<MathNet.Numerics.Complex32> matrix2 = this * matrix;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				num += (double)matrix2.At(i, i).Magnitude;
			}
			return Math.Sqrt(num);
		}

		public override Vector<double> RowNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.RowCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => s + (double)x.MagnitudeSquared, (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => s + (double)x.Magnitude, (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByRowUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => Math.Max(s, x.Magnitude), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByRowUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => s + Math.Pow(x.Magnitude, norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> ColumnNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.ColumnCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => s + (double)x.MagnitudeSquared, (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => s + (double)x.Magnitude, (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => Math.Max(s, x.Magnitude), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByColumnUnchecked(array, (double s, MathNet.Numerics.Complex32 x) => s + Math.Pow(x.Magnitude, norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public sealed override Matrix<MathNet.Numerics.Complex32> NormalizeRows(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)RowNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => (float)norminv[i] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public sealed override Matrix<MathNet.Numerics.Complex32> NormalizeColumns(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)ColumnNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => (float)norminv[j] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public override Vector<MathNet.Numerics.Complex32> RowSums()
		{
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (MathNet.Numerics.Complex32 s, MathNet.Numerics.Complex32 x) => s + x, (MathNet.Numerics.Complex32 x, int c) => x, array, Zeros.AllowSkip);
			return Vector<MathNet.Numerics.Complex32>.Build.Dense(array);
		}

		public override Vector<MathNet.Numerics.Complex32> RowAbsoluteSums()
		{
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (MathNet.Numerics.Complex32 s, MathNet.Numerics.Complex32 x) => s + x.Magnitude, (MathNet.Numerics.Complex32 x, int c) => x, array, Zeros.AllowSkip);
			return Vector<MathNet.Numerics.Complex32>.Build.Dense(array);
		}

		public override Vector<MathNet.Numerics.Complex32> ColumnSums()
		{
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (MathNet.Numerics.Complex32 s, MathNet.Numerics.Complex32 x) => s + x, (MathNet.Numerics.Complex32 x, int c) => x, array, Zeros.AllowSkip);
			return Vector<MathNet.Numerics.Complex32>.Build.Dense(array);
		}

		public override Vector<MathNet.Numerics.Complex32> ColumnAbsoluteSums()
		{
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (MathNet.Numerics.Complex32 s, MathNet.Numerics.Complex32 x) => s + x.Magnitude, (MathNet.Numerics.Complex32 x, int c) => x, array, Zeros.AllowSkip);
			return Vector<MathNet.Numerics.Complex32>.Build.Dense(array);
		}

		public override bool IsHermitian()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < base.RowCount; i++)
			{
				if (!At(i, i).IsReal())
				{
					return false;
				}
			}
			for (int j = 0; j < base.RowCount; j++)
			{
				for (int k = j + 1; k < base.ColumnCount; k++)
				{
					if (!At(j, k).Equals(At(k, j).Conjugate()))
					{
						return false;
					}
				}
			}
			return true;
		}

		public override Cholesky<MathNet.Numerics.Complex32> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserCholesky.Create(this);
		}

		public override LU<MathNet.Numerics.Complex32> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserLU.Create(this);
		}

		public override QR<MathNet.Numerics.Complex32> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserQR.Create(this, method);
		}

		public override GramSchmidt<MathNet.Numerics.Complex32> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserGramSchmidt.Create(this);
		}

		public override Svd<MathNet.Numerics.Complex32> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserSvd.Create(this, computeVectors);
		}

		public override Evd<MathNet.Numerics.Complex32> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseMatrix {RowCount}x{ColumnCount}-Complex32 {NonZerosCount}-NonZero")]
	public class SparseMatrix : Matrix
	{
		private readonly SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseMatrix(int order)
			: this(order, order)
		{
		}

		public SparseMatrix(int rows, int columns)
			: this(new SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>(rows, columns))
		{
		}

		public static SparseMatrix OfMatrix(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfMatrix(matrix.Storage));
		}

		public static SparseMatrix OfArray(MathNet.Numerics.Complex32[,] array)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfArray(array));
		}

		public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, MathNet.Numerics.Complex32>> enumerable)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable<MathNet.Numerics.Complex32> rowMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfRowMajorEnumerable(rows, columns, rowMajor));
		}

		public static SparseMatrix OfColumnMajor(int rows, int columns, IList<MathNet.Numerics.Complex32> columnMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfColumnMajorList(rows, columns, columnMajor));
		}

		public static SparseMatrix OfColumns(IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<MathNet.Numerics.Complex32> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfColumnEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfColumnArrays(params MathNet.Numerics.Complex32[][] columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfColumnArrays(columns));
		}

		public static SparseMatrix OfColumnArrays(IEnumerable<MathNet.Numerics.Complex32[]> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfColumnArrays((columns as MathNet.Numerics.Complex32[][]) ?? columns.ToArray()));
		}

		public static SparseMatrix OfColumnVectors(params Vector<MathNet.Numerics.Complex32>[] columns)
		{
			VectorStorage<MathNet.Numerics.Complex32>[] array = new VectorStorage<MathNet.Numerics.Complex32>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfColumnVectors(array));
		}

		public static SparseMatrix OfColumnVectors(IEnumerable<Vector<MathNet.Numerics.Complex32>> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfColumnVectors(columns.Select((Vector<MathNet.Numerics.Complex32> c) => c.Storage).ToArray()));
		}

		public static SparseMatrix OfRows(IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<MathNet.Numerics.Complex32> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<MathNet.Numerics.Complex32>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfRowEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfRowArrays(params MathNet.Numerics.Complex32[][] rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfRowArrays(rows));
		}

		public static SparseMatrix OfRowArrays(IEnumerable<MathNet.Numerics.Complex32[]> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfRowArrays((rows as MathNet.Numerics.Complex32[][]) ?? rows.ToArray()));
		}

		public static SparseMatrix OfRowVectors(params Vector<MathNet.Numerics.Complex32>[] rows)
		{
			VectorStorage<MathNet.Numerics.Complex32>[] array = new VectorStorage<MathNet.Numerics.Complex32>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfRowVectors(array));
		}

		public static SparseMatrix OfRowVectors(IEnumerable<Vector<MathNet.Numerics.Complex32>> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfRowVectors(rows.Select((Vector<MathNet.Numerics.Complex32> r) => r.Storage).ToArray()));
		}

		public static SparseMatrix OfDiagonalVector(Vector<MathNet.Numerics.Complex32> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Count, diagonal.Count);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector<MathNet.Numerics.Complex32> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(MathNet.Numerics.Complex32[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Length, diagonal.Length);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(int rows, int columns, MathNet.Numerics.Complex32[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix Create(int rows, int columns, MathNet.Numerics.Complex32 value)
		{
			if (value == MathNet.Numerics.Complex32.Zero)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfValue(rows, columns, value));
		}

		public static SparseMatrix Create(int rows, int columns, Func<int, int, MathNet.Numerics.Complex32> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfInit(rows, columns, init));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, MathNet.Numerics.Complex32 value)
		{
			if (value == MathNet.Numerics.Complex32.Zero)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, Func<int, MathNet.Numerics.Complex32> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfDiagonalInit(rows, columns, init));
		}

		public static SparseMatrix CreateIdentity(int order)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>.OfDiagonalInit(order, order, (int i) => Matrix<MathNet.Numerics.Complex32>.One));
		}

		public override Matrix<MathNet.Numerics.Complex32> LowerTriangle()
		{
			Matrix<MathNet.Numerics.Complex32> result = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(this);
			LowerTriangleImpl(result);
			return result;
		}

		public override void LowerTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(result);
				LowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				LowerTriangleImpl(result);
			}
		}

		private void LowerTriangleImpl(Matrix<MathNet.Numerics.Complex32> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i >= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<MathNet.Numerics.Complex32> UpperTriangle()
		{
			Matrix<MathNet.Numerics.Complex32> result = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(this);
			UpperTriangleImpl(result);
			return result;
		}

		public override void UpperTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(result);
				UpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				UpperTriangleImpl(result);
			}
		}

		private void UpperTriangleImpl(Matrix<MathNet.Numerics.Complex32> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i <= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<MathNet.Numerics.Complex32> StrictlyLowerTriangle()
		{
			Matrix<MathNet.Numerics.Complex32> result = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(this);
			StrictlyLowerTriangleImpl(result);
			return result;
		}

		public override void StrictlyLowerTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(result);
				StrictlyLowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyLowerTriangleImpl(result);
			}
		}

		private void StrictlyLowerTriangleImpl(Matrix<MathNet.Numerics.Complex32> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i > columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<MathNet.Numerics.Complex32> StrictlyUpperTriangle()
		{
			Matrix<MathNet.Numerics.Complex32> result = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(this);
			StrictlyUpperTriangleImpl(result);
			return result;
		}

		public override void StrictlyUpperTriangle(Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(result);
				StrictlyUpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyUpperTriangleImpl(result);
			}
		}

		private void StrictlyUpperTriangleImpl(Matrix<MathNet.Numerics.Complex32> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i < columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		protected override void DoNegate(Matrix<MathNet.Numerics.Complex32> result)
		{
			CopyTo(result);
			DoMultiply(-1, result);
		}

		public override double InfinityNorm()
		{
			int[] rowPointers = _storage.RowPointers;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num2 = rowPointers[i];
				int num3 = rowPointers[i + 1];
				if (num2 != num3)
				{
					double num4 = 0.0;
					for (int j = num2; j < num3; j++)
					{
						num4 += (double)values[j].Magnitude;
					}
					num = Math.Max(num, num4);
				}
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> sparseCompressedRowMatrixStorage = (SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32>)(this * ConjugateTranspose()).Storage;
			double num = 0.0;
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				int num2 = sparseCompressedRowMatrixStorage.RowPointers[i];
				int num3 = sparseCompressedRowMatrixStorage.RowPointers[i + 1];
				if (num2 == num3)
				{
					continue;
				}
				for (int j = num2; j < num3; j++)
				{
					if (i == sparseCompressedRowMatrixStorage.ColumnIndices[j])
					{
						num += (double)sparseCompressedRowMatrixStorage.Values[j].Magnitude;
					}
				}
			}
			return Math.Sqrt(num);
		}

		protected override void DoAdd(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					if (this != result)
					{
						CopyTo(result);
					}
					LinearAlgebraControl.Provider.ScaleArray(2f, sparseMatrix2._storage.Values, sparseMatrix2._storage.Values);
					return;
				}
				SparseMatrix sparseMatrix3;
				if (sparseMatrix == sparseMatrix2)
				{
					sparseMatrix3 = this;
				}
				else if (this == sparseMatrix2)
				{
					sparseMatrix3 = sparseMatrix;
				}
				else
				{
					CopyTo(sparseMatrix2);
					sparseMatrix3 = sparseMatrix;
				}
				SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> storage = sparseMatrix3._storage;
				for (int i = 0; i < storage.RowCount; i++)
				{
					int num = storage.RowPointers[i + 1];
					for (int j = storage.RowPointers[i]; j < num; j++)
					{
						int column = storage.ColumnIndices[j];
						MathNet.Numerics.Complex32 value = storage.Values[j] + result.At(i, column);
						result.At(i, column, value);
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					result.Clear();
					return;
				}
				SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> storage = sparseMatrix._storage;
				if (this == sparseMatrix2)
				{
					for (int i = 0; i < storage.RowCount; i++)
					{
						int num = storage.RowPointers[i + 1];
						for (int j = storage.RowPointers[i]; j < num; j++)
						{
							int column = storage.ColumnIndices[j];
							MathNet.Numerics.Complex32 value = sparseMatrix2.At(i, column) - storage.Values[j];
							result.At(i, column, value);
						}
					}
					return;
				}
				if (sparseMatrix != sparseMatrix2)
				{
					sparseMatrix.CopyTo(sparseMatrix2);
				}
				sparseMatrix2.Negate(sparseMatrix2);
				int[] rowPointers = _storage.RowPointers;
				int[] columnIndices = _storage.ColumnIndices;
				MathNet.Numerics.Complex32[] values = _storage.Values;
				for (int k = 0; k < base.RowCount; k++)
				{
					int num2 = rowPointers[k + 1];
					for (int l = rowPointers[k]; l < num2; l++)
					{
						int column2 = columnIndices[l];
						MathNet.Numerics.Complex32 value2 = sparseMatrix2.At(k, column2) + values[l];
						result.At(k, column2, value2);
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (scalar == 1f)
			{
				CopyTo(result);
				return;
			}
			if (scalar == 0f || NonZerosCount == 0)
			{
				result.Clear();
				return;
			}
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(sparseMatrix);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseMatrix._storage.Values, sparseMatrix._storage.Values);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					for (int j = num; j < num2; j++)
					{
						int column = columnIndices[j];
						result.At(i, column, values[j] * scalar);
					}
				}
			}
		}

		protected override void DoMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			SparseMatrix sparseMatrix = other as SparseMatrix;
			SparseMatrix sparseMatrix2 = result as SparseMatrix;
			if (sparseMatrix != null && sparseMatrix2 != null)
			{
				DoMultiplySparse(sparseMatrix, sparseMatrix2);
				return;
			}
			if (other.Storage is DiagonalMatrixStorage<MathNet.Numerics.Complex32> diagonalMatrixStorage && sparseMatrix2 != null)
			{
				MathNet.Numerics.Complex32[] diagonal = diagonalMatrixStorage.Data;
				if (other.ColumnCount == other.RowCount)
				{
					base.Storage.MapIndexedTo(result.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => x * diagonal[j], Zeros.AllowSkip, ExistingData.Clear);
					return;
				}
				result.Storage.Clear();
				base.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, MathNet.Numerics.Complex32 x) => x * diagonal[j], 0, 0, base.RowCount, 0, 0, Math.Min(base.ColumnCount, other.ColumnCount), Zeros.AllowSkip, ExistingData.AssumeZeros);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			if (other.Storage is DenseColumnMajorMatrixStorage<MathNet.Numerics.Complex32> denseColumnMajorMatrixStorage)
			{
				for (int k = 0; k < base.RowCount; k++)
				{
					int num = rowPointers[k];
					int num2 = rowPointers[k + 1];
					if (num == num2)
					{
						continue;
					}
					for (int l = 0; l < other.ColumnCount; l++)
					{
						int num3 = l * other.RowCount;
						MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
						for (int m = num; m < num2; m++)
						{
							zero += values[m] * denseColumnMajorMatrixStorage.Data[num3 + columnIndices[m]];
						}
						result.At(k, l, zero);
					}
				}
				return;
			}
			DenseVector denseVector = new DenseVector(other.RowCount);
			for (int n = 0; n < base.RowCount; n++)
			{
				int num4 = rowPointers[n];
				int num5 = rowPointers[n + 1];
				if (num4 == num5)
				{
					continue;
				}
				for (int num6 = 0; num6 < other.ColumnCount; num6++)
				{
					other.Column(num6, denseVector);
					MathNet.Numerics.Complex32 zero2 = MathNet.Numerics.Complex32.Zero;
					for (int num7 = num4; num7 < num5; num7++)
					{
						zero2 += values[num7] * denseVector[columnIndices[num7]];
					}
					result.At(n, num6, zero2);
				}
			}
		}

		private void DoMultiplySparse(SparseMatrix other, SparseMatrix result)
		{
			result.Clear();
			MathNet.Numerics.Complex32[] values = _storage.Values;
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values2 = other._storage.Values;
			int[] rowPointers2 = other._storage.RowPointers;
			int[] columnIndices2 = other._storage.ColumnIndices;
			int rowCount = base.RowCount;
			int columnCount = other.ColumnCount;
			int[] rowPointers3 = result._storage.RowPointers;
			int[] array = new int[columnCount];
			for (int i = 0; i < columnCount; i++)
			{
				array[i] = -1;
			}
			int num = 0;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = rowPointers[j]; k < rowPointers[j + 1]; k++)
				{
					int num2 = columnIndices[k];
					for (int l = rowPointers2[num2]; l < rowPointers2[num2 + 1]; l++)
					{
						int num3 = columnIndices2[l];
						if (array[num3] != j)
						{
							array[num3] = j;
							num++;
						}
					}
				}
				rowPointers3[j + 1] = num;
			}
			int[] array2 = new int[num];
			MathNet.Numerics.Complex32[] array3 = new MathNet.Numerics.Complex32[num];
			for (int m = 0; m < columnCount; m++)
			{
				array[m] = -1;
			}
			num = 0;
			for (int n = 0; n < rowCount; n++)
			{
				int num4 = rowPointers3[n];
				for (int num5 = rowPointers[n]; num5 < rowPointers[n + 1]; num5++)
				{
					int num6 = columnIndices[num5];
					MathNet.Numerics.Complex32 complex = values[num5];
					for (int num7 = rowPointers2[num6]; num7 < rowPointers2[num6 + 1]; num7++)
					{
						int num8 = columnIndices2[num7];
						MathNet.Numerics.Complex32 complex2 = values2[num7];
						if (array[num8] < num4)
						{
							array[num8] = num;
							array2[array[num8]] = num8;
							array3[array[num8]] = complex * complex2;
							num++;
						}
						else
						{
							array3[array[num8]] += complex * complex2;
						}
					}
				}
			}
			result._storage.Values = array3;
			result._storage.ColumnIndices = array2;
			result._storage.Normalize();
		}

		protected override void DoMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int j = num; j < num2; j++)
					{
						zero += values[j] * rightSide[columnIndices[j]];
					}
					result[i] = zero;
				}
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				sparseMatrix2.Clear();
				int[] rowPointers = _storage.RowPointers;
				MathNet.Numerics.Complex32[] values = _storage.Values;
				SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> storage = sparseMatrix._storage;
				for (int i = 0; i < base.RowCount; i++)
				{
					int num = storage.RowPointers[i];
					int num2 = storage.RowPointers[i + 1];
					if (num == num2)
					{
						continue;
					}
					for (int j = 0; j < base.RowCount; j++)
					{
						int num3 = rowPointers[j];
						int num4 = rowPointers[j + 1];
						if (num3 == num4)
						{
							continue;
						}
						MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
						for (int k = num; k < num2; k++)
						{
							int num5 = _storage.FindItem(j, storage.ColumnIndices[k]);
							if (num5 >= 0)
							{
								zero += storage.Values[k] * values[num5];
							}
						}
						sparseMatrix2._storage.At(j, i, zero + result.At(j, i));
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<MathNet.Numerics.Complex32> rightSide, Vector<MathNet.Numerics.Complex32> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					MathNet.Numerics.Complex32 complex = rightSide[i];
					for (int j = num; j < num2; j++)
					{
						result[columnIndices[j]] += values[j] * complex;
					}
				}
			}
		}

		protected override void DoPointwiseMultiply(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					MathNet.Numerics.Complex32 value = values[j] * other.At(i, columnIndices[j]);
					if (!value.IsZero())
					{
						result.At(i, columnIndices[j], value);
					}
				}
			}
		}

		protected override void DoPointwiseDivide(Matrix<MathNet.Numerics.Complex32> divisor, Matrix<MathNet.Numerics.Complex32> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (!values[j].IsZero())
					{
						result.At(i, columnIndices[j], values[j] / divisor.At(i, columnIndices[j]));
					}
				}
			}
		}

		public override void KroneckerProduct(Matrix<MathNet.Numerics.Complex32> other, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount * other.RowCount || result.ColumnCount != base.ColumnCount * other.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, result);
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (!values[j].IsZero())
					{
						result.SetSubMatrix(i * other.RowCount, other.RowCount, columnIndices[j] * other.ColumnCount, other.ColumnCount, values[j] * other);
					}
				}
			}
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num == num2)
				{
					continue;
				}
				for (int j = num; j < num2; j++)
				{
					int row = columnIndices[j];
					if (!values[j].Equals(At(row, i)))
					{
						return false;
					}
				}
			}
			return true;
		}

		public override bool IsHermitian()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			MathNet.Numerics.Complex32[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num == num2)
				{
					continue;
				}
				for (int j = num; j < num2; j++)
				{
					int row = columnIndices[j];
					if (!values[j].Equals(At(row, i).Conjugate()))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static SparseMatrix operator +(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Add(rightSide);
		}

		public static SparseMatrix operator +(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Clone();
		}

		public static SparseMatrix operator -(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Subtract(rightSide);
		}

		public static SparseMatrix operator -(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Negate();
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseMatrix operator *(MathNet.Numerics.Complex32 leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Multiply(leftSide);
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide.ColumnCount != rightSide.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseMatrix leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.LeftMultiply(leftSide);
		}

		public static SparseMatrix operator %(SparseMatrix leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Remainder(rightSide);
		}

		public override string ToTypeString()
		{
			return $"SparseMatrix {base.RowCount}x{base.ColumnCount}-Complex32 {(double)NonZerosCount / ((double)base.RowCount * (double)base.ColumnCount):P2} Filled";
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseVector {Count}-Complex32 {NonZerosCount}-NonZero")]
	public class SparseVector : Vector
	{
		private readonly SparseVectorStorage<MathNet.Numerics.Complex32> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseVector(SparseVectorStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseVector(int length)
			: this(new SparseVectorStorage<MathNet.Numerics.Complex32>(length))
		{
		}

		public static SparseVector OfVector(Vector<MathNet.Numerics.Complex32> vector)
		{
			return new SparseVector(SparseVectorStorage<MathNet.Numerics.Complex32>.OfVector(vector.Storage));
		}

		public static SparseVector OfEnumerable(IEnumerable<MathNet.Numerics.Complex32> enumerable)
		{
			return new SparseVector(SparseVectorStorage<MathNet.Numerics.Complex32>.OfEnumerable(enumerable));
		}

		public static SparseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, MathNet.Numerics.Complex32>> enumerable)
		{
			return new SparseVector(SparseVectorStorage<MathNet.Numerics.Complex32>.OfIndexedEnumerable(length, enumerable));
		}

		public static SparseVector Create(int length, MathNet.Numerics.Complex32 value)
		{
			return new SparseVector(SparseVectorStorage<MathNet.Numerics.Complex32>.OfValue(length, value));
		}

		public static SparseVector Create(int length, Func<int, MathNet.Numerics.Complex32> init)
		{
			return new SparseVector(SparseVectorStorage<MathNet.Numerics.Complex32>.OfInit(length, init));
		}

		protected override void DoAdd(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			if (scalar == MathNet.Numerics.Complex32.Zero)
			{
				if (this != result)
				{
					CopyTo(result);
				}
			}
			else if (this == result)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.Count];
				int[] array2 = new int[base.Count];
				for (int i = 0; i < base.Count; i++)
				{
					array2[i] = i;
					array[i] = scalar;
				}
				int[] indices = _storage.Indices;
				MathNet.Numerics.Complex32[] values = _storage.Values;
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					array[indices[j]] = values[j] + scalar;
				}
				_storage.Values = array;
				_storage.Indices = array2;
				_storage.ValueCount = base.Count;
			}
			else
			{
				for (int k = 0; k < base.Count; k++)
				{
					result.At(k, At(k) + scalar);
				}
			}
		}

		protected override void DoAdd(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<MathNet.Numerics.Complex32> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							MathNet.Numerics.Complex32 complex = storage.Values[num2];
							if (!MathNet.Numerics.Complex32.Zero.Equals(complex))
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], complex);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] += storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num3 = 0;
				int num4 = 0;
				int num5 = -1;
				while (num3 < _storage.ValueCount || num4 < storage.ValueCount)
				{
					if (num4 >= storage.ValueCount || (num3 < _storage.ValueCount && _storage.Indices[num3] <= storage.Indices[num4]))
					{
						int num6 = _storage.Indices[num3];
						if (num6 != num5)
						{
							num5 = num6;
							result.At(num6, _storage.Values[num3] + sparseVector.At(num6));
						}
						num3++;
					}
					else
					{
						int num7 = storage.Indices[num4];
						if (num7 != num5)
						{
							num5 = num7;
							result.At(num7, At(num7) + storage.Values[num4]);
						}
						num4++;
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			DoAdd(-scalar, result);
		}

		protected override void DoSubtract(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			if (this == other)
			{
				result.Clear();
			}
			else if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<MathNet.Numerics.Complex32> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							MathNet.Numerics.Complex32 complex = storage.Values[num2];
							if (!MathNet.Numerics.Complex32.Zero.Equals(complex))
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], -complex);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] -= storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num3 = 0;
				int num4 = 0;
				int num5 = -1;
				while (num3 < _storage.ValueCount || num4 < storage.ValueCount)
				{
					if (num4 >= storage.ValueCount || (num3 < _storage.ValueCount && _storage.Indices[num3] <= storage.Indices[num4]))
					{
						int num6 = _storage.Indices[num3];
						if (num6 != num5)
						{
							num5 = num6;
							result.At(num6, _storage.Values[num3] - sparseVector.At(num6));
						}
						num3++;
					}
					else
					{
						int num7 = storage.Indices[num4];
						if (num7 != num5)
						{
							num5 = num7;
							result.At(num7, At(num7) - storage.Values[num4]);
						}
						num4++;
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoNegate(Vector<MathNet.Numerics.Complex32> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new MathNet.Numerics.Complex32[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(-MathNet.Numerics.Complex32.One, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], -_storage.Values[i]);
				}
			}
		}

		protected override void DoConjugate(Vector<MathNet.Numerics.Complex32> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new MathNet.Numerics.Complex32[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ConjugateArray(sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], _storage.Values[i].Conjugate());
				}
			}
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new MathNet.Numerics.Complex32[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], scalar * _storage.Values[i]);
				}
			}
		}

		protected override MathNet.Numerics.Complex32 DoDotProduct(Vector<MathNet.Numerics.Complex32> other)
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			if (this == other)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					zero += _storage.Values[i] * _storage.Values[i];
				}
			}
			else
			{
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					zero += _storage.Values[j] * other.At(_storage.Indices[j]);
				}
			}
			return zero;
		}

		protected override MathNet.Numerics.Complex32 DoConjugateDotProduct(Vector<MathNet.Numerics.Complex32> other)
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			if (this == other)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					zero += _storage.Values[i].Conjugate() * _storage.Values[i];
				}
			}
			else
			{
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					zero += _storage.Values[j].Conjugate() * other.At(_storage.Indices[j]);
				}
			}
			return zero;
		}

		public static SparseVector operator +(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Add(rightSide);
		}

		public static SparseVector operator -(SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Negate();
		}

		public static SparseVector operator -(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Subtract(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(MathNet.Numerics.Complex32 leftSide, SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Multiply(leftSide);
		}

		public static MathNet.Numerics.Complex32 operator *(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static SparseVector operator /(SparseVector leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Divide(rightSide);
		}

		public static SparseVector operator %(SparseVector leftSide, MathNet.Numerics.Complex32 rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Modulus(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			float num2 = _storage.Values[num].Magnitude;
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				float magnitude = _storage.Values[i].Magnitude;
				if (magnitude < num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return _storage.Indices[num];
		}

		public override int AbsoluteMaximumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			float num2 = _storage.Values[num].Magnitude;
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				float magnitude = _storage.Values[i].Magnitude;
				if (magnitude > num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return _storage.Indices[num];
		}

		public override MathNet.Numerics.Complex32 Sum()
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				zero += _storage.Values[i];
			}
			return zero;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += (double)_storage.Values[i].Magnitude;
			}
			return num;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, _storage.ValueCount, (int i) => _storage.Values[i].Magnitude, Math.Max, 0f);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (_storage.ValueCount == 0)
			{
				return 0.0;
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += Math.Pow(_storage.Values[i].Magnitude, p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			if (this == other && this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] *= _storage.Values[i];
				}
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		public static SparseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			string[] array = value.Split(new string[1] { formatProvider.GetTextInfo().ListSeparator }, StringSplitOptions.RemoveEmptyEntries);
			List<MathNet.Numerics.Complex32> list = new List<MathNet.Numerics.Complex32>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				string[] array3 = array2[i].Split(new string[2] { " ", "\t" }, StringSplitOptions.RemoveEmptyEntries);
				string text = string.Empty;
				for (int j = 0; j < array3.Length; j++)
				{
					text += array3[j];
					if (!text.EndsWith("+") && !text.EndsWith("-") && (!text.StartsWith("(") || text.EndsWith(")")))
					{
						string text2 = ((j < array3.Length - 1) ? array3[j + 1] : string.Empty);
						if (!text2.StartsWith("+") && !text2.StartsWith("-"))
						{
							list.Add(text.ToComplex32(formatProvider));
							text = string.Empty;
						}
					}
				}
				if (text != string.Empty)
				{
					throw new FormatException();
				}
			}
			if (list.Count == 0)
			{
				throw new FormatException();
			}
			return OfEnumerable(list);
		}

		public static bool TryParse(string value, out SparseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out SparseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseVector {base.Count}-Complex32 {(double)NonZerosCount / (double)base.Count:P2} Filled");
		}
	}
	[Serializable]
	public abstract class Vector : Vector<MathNet.Numerics.Complex32>
	{
		protected Vector(VectorStorage<MathNet.Numerics.Complex32> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((MathNet.Numerics.Complex32 x) => (!((double)x.Magnitude < threshold)) ? x : MathNet.Numerics.Complex32.Zero);
		}

		protected override void DoConjugate(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Conjugate, result);
		}

		protected override void DoNegate(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Negate, result);
		}

		protected override void DoAdd(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Add, other, result);
		}

		protected override void DoSubtract(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Subtract, other, result);
		}

		protected override void DoMultiply(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x * scalar, result);
		}

		protected override void DoDivide(MathNet.Numerics.Complex32 divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x / divisor, result, divisor.IsZero() ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(MathNet.Numerics.Complex32 dividend, Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoPointwiseMultiply(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Multiply, other, result);
		}

		protected override void DoPointwiseDivide(Vector<MathNet.Numerics.Complex32> divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Divide, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(MathNet.Numerics.Complex32 exponent, Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => x.Power(exponent), result, Zeros.Include);
		}

		protected override void DoPointwisePower(Vector<MathNet.Numerics.Complex32> exponent, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2(MathNet.Numerics.Complex32.Pow, exponent, result, Zeros.Include);
		}

		protected sealed override void DoPointwiseModulus(Vector<MathNet.Numerics.Complex32> divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoPointwiseRemainder(Vector<MathNet.Numerics.Complex32> divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseExp(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Exp, result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Log, result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Vector<MathNet.Numerics.Complex32> result)
		{
			Map((MathNet.Numerics.Complex32 x) => (MathNet.Numerics.Complex32)MathNet.Numerics.Complex32.Abs(x), result);
		}

		protected override void DoPointwiseAcos(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Acos, result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Asin, result);
		}

		protected override void DoPointwiseAtan(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Atan, result);
		}

		protected override void DoPointwiseAtan2(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAtan2(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCeiling(Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCos(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Cos, result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Cosh, result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseLog10(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Log10, result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSign(Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSin(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Sin, result);
		}

		protected override void DoPointwiseSinh(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Sinh, result);
		}

		protected override void DoPointwiseSqrt(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Sqrt, result);
		}

		protected override void DoPointwiseTan(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Tan, result);
		}

		protected override void DoPointwiseTanh(Vector<MathNet.Numerics.Complex32> result)
		{
			Map(MathNet.Numerics.Complex32.Tanh, result);
		}

		protected override MathNet.Numerics.Complex32 DoDotProduct(Vector<MathNet.Numerics.Complex32> other)
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < base.Count; i++)
			{
				zero += At(i) * other.At(i);
			}
			return zero;
		}

		protected override MathNet.Numerics.Complex32 DoConjugateDotProduct(Vector<MathNet.Numerics.Complex32> other)
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < base.Count; i++)
			{
				zero += At(i).Conjugate() * other.At(i);
			}
			return zero;
		}

		protected sealed override void DoModulus(MathNet.Numerics.Complex32 divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoModulusByThis(MathNet.Numerics.Complex32 dividend, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainder(MathNet.Numerics.Complex32 divisor, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainderByThis(MathNet.Numerics.Complex32 dividend, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMinimum(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			float absolute = scalar.Magnitude;
			Map((MathNet.Numerics.Complex32 x) => Math.Min(absolute, x.Magnitude), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(MathNet.Numerics.Complex32 scalar, Vector<MathNet.Numerics.Complex32> result)
		{
			float absolute = scalar.Magnitude;
			Map((MathNet.Numerics.Complex32 x) => Math.Max(absolute, x.Magnitude), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2((MathNet.Numerics.Complex32 x, MathNet.Numerics.Complex32 y) => Math.Min(x.Magnitude, y.Magnitude), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Vector<MathNet.Numerics.Complex32> other, Vector<MathNet.Numerics.Complex32> result)
		{
			Map2((MathNet.Numerics.Complex32 x, MathNet.Numerics.Complex32 y) => Math.Max(x.Magnitude, y.Magnitude), other, result);
		}

		public sealed override MathNet.Numerics.Complex32 AbsoluteMinimum()
		{
			return At(AbsoluteMinimumIndex()).Magnitude;
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			float num2 = At(num).Magnitude;
			for (int i = 1; i < base.Count; i++)
			{
				float magnitude = At(i).Magnitude;
				if (magnitude < num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override MathNet.Numerics.Complex32 AbsoluteMaximum()
		{
			return At(AbsoluteMaximumIndex()).Magnitude;
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			float num2 = At(num).Magnitude;
			for (int i = 1; i < base.Count; i++)
			{
				float magnitude = At(i).Magnitude;
				if (magnitude > num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override MathNet.Numerics.Complex32 Sum()
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = 0; i < base.Count; i++)
			{
				zero += At(i);
			}
			return zero;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += (double)At(i).Magnitude;
			}
			return num;
		}

		public override double L2Norm()
		{
			return DoConjugateDotProduct(this).SquareRoot().Real;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, base.Count, (int i) => At(i).Magnitude, Math.Max, 0f);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += Math.Pow(At(i).Magnitude, p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		public override int MaximumIndex()
		{
			throw new NotSupportedException();
		}

		public override int MinimumIndex()
		{
			throw new NotSupportedException();
		}

		public override Vector<MathNet.Numerics.Complex32> Normalize(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			double num = Norm(p);
			Vector<MathNet.Numerics.Complex32> vector = Clone();
			if (num == 0.0)
			{
				return vector;
			}
			vector.Multiply((float)(1.0 / num), vector);
			return vector;
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Complex32.Solvers
{
	public sealed class BiCgStab : IIterativeSolver<MathNet.Numerics.Complex32>
	{
		private static void CalculateTrueResidual(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> residual, Vector<MathNet.Numerics.Complex32> x, Vector<MathNet.Numerics.Complex32> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result, Iterator<MathNet.Numerics.Complex32> iterator, IPreconditioner<MathNet.Numerics.Complex32> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<MathNet.Numerics.Complex32>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<MathNet.Numerics.Complex32>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector, result, input);
			Vector<MathNet.Numerics.Complex32> vector = denseVector.Clone();
			DenseVector denseVector2 = new DenseVector(denseVector.Count);
			DenseVector denseVector3 = new DenseVector(denseVector.Count);
			DenseVector denseVector4 = new DenseVector(denseVector.Count);
			DenseVector denseVector5 = new DenseVector(denseVector.Count);
			DenseVector denseVector6 = new DenseVector(denseVector.Count);
			DenseVector denseVector7 = new DenseVector(denseVector.Count);
			DenseVector denseVector8 = new DenseVector(denseVector.Count);
			MathNet.Numerics.Complex32 complex = 0;
			MathNet.Numerics.Complex32 complex2 = 0;
			MathNet.Numerics.Complex32 complex3 = 0;
			int num = 0;
			while (iterator.DetermineStatus(num, result, input, denseVector) == IterationStatus.Continue)
			{
				MathNet.Numerics.Complex32 complex4 = complex;
				complex = vector.ConjugateDotProduct(denseVector);
				if (complex.Real.AlmostEqualNumbersBetween(0f, 1) && complex.Imaginary.AlmostEqualNumbersBetween(0f, 1))
				{
					throw new NumericalBreakdownException();
				}
				if (num != 0)
				{
					MathNet.Numerics.Complex32 scalar = complex / complex4 * (complex2 / complex3);
					denseVector4.Multiply(-complex3, denseVector7);
					denseVector2.Add(denseVector7, denseVector8);
					denseVector8.CopyTo(denseVector2);
					denseVector2.Multiply(scalar, denseVector2);
					denseVector2.Add(denseVector, denseVector8);
					denseVector8.CopyTo(denseVector2);
				}
				else
				{
					denseVector.CopyTo(denseVector2);
				}
				preconditioner.Approximate(denseVector2, denseVector3);
				matrix.Multiply(denseVector3, denseVector4);
				complex2 = complex * 1f / vector.ConjugateDotProduct(denseVector4);
				denseVector4.Multiply(-complex2, denseVector7);
				denseVector.Add(denseVector7, denseVector5);
				denseVector3.Multiply(complex2, denseVector7);
				denseVector7.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector7);
				denseVector7.Add(result, denseVector8);
				denseVector8.CopyTo(denseVector7);
				if (iterator.DetermineStatus(num, denseVector7, input, denseVector5) != 0)
				{
					denseVector7.CopyTo(result);
					CalculateTrueResidual(matrix, denseVector, result, input);
					if (iterator.DetermineStatus(num, result, input, denseVector) != 0)
					{
						break;
					}
					num++;
					continue;
				}
				preconditioner.Approximate(denseVector5, denseVector6);
				matrix.Multiply(denseVector6, denseVector7);
				complex3 = denseVector7.ConjugateDotProduct(denseVector5) / denseVector7.ConjugateDotProduct(denseVector7);
				denseVector7.Multiply(-complex3, denseVector);
				denseVector.Add(denseVector5, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector6.Multiply(complex3, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				denseVector3.Multiply(complex2, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				if (complex3.Real.AlmostEqualNumbersBetween(0f, 1) && complex3.Imaginary.AlmostEqualNumbersBetween(0f, 1))
				{
					throw new NumericalBreakdownException();
				}
				if (iterator.DetermineStatus(num, result, input, denseVector) != 0)
				{
					CalculateTrueResidual(matrix, denseVector, result, input);
				}
				num++;
			}
		}
	}
	public sealed class CompositeSolver : IIterativeSolver<MathNet.Numerics.Complex32>
	{
		private readonly List<Tuple<IIterativeSolver<MathNet.Numerics.Complex32>, IPreconditioner<MathNet.Numerics.Complex32>>> _solvers;

		public CompositeSolver(IEnumerable<IIterativeSolverSetup<MathNet.Numerics.Complex32>> solvers)
		{
			_solvers = solvers.Select((IIterativeSolverSetup<MathNet.Numerics.Complex32> setup) => new Tuple<IIterativeSolver<MathNet.Numerics.Complex32>, IPreconditioner<MathNet.Numerics.Complex32>>(setup.CreateSolver(), setup.CreatePreconditioner() ?? new UnitPreconditioner<MathNet.Numerics.Complex32>())).ToList();
		}

		public void Solve(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result, Iterator<MathNet.Numerics.Complex32> iterator, IPreconditioner<MathNet.Numerics.Complex32> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (iterator == null)
			{
				iterator = new Iterator<MathNet.Numerics.Complex32>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<MathNet.Numerics.Complex32>();
			}
			Vector<MathNet.Numerics.Complex32> vector = input.Clone();
			Vector<MathNet.Numerics.Complex32> vector2 = result.Clone();
			foreach (Tuple<IIterativeSolver<MathNet.Numerics.Complex32>, IPreconditioner<MathNet.Numerics.Complex32>> solver in _solvers)
			{
				IterationStatus status;
				try
				{
					iterator.Reset();
					solver.Item1.Solve(matrix, vector, vector2, iterator, solver.Item2 ?? preconditioner);
					status = iterator.Status;
				}
				catch (Exception)
				{
					input.CopyTo(vector);
					continue;
				}
				switch (status)
				{
				case IterationStatus.Converged:
					vector2.CopyTo(result);
					return;
				case IterationStatus.StoppedWithoutConvergence:
					vector2.CopyTo(result);
					break;
				default:
					input.CopyTo(vector);
					break;
				}
			}
		}
	}
	public sealed class DiagonalPreconditioner : IPreconditioner<MathNet.Numerics.Complex32>
	{
		private MathNet.Numerics.Complex32[] _inverseDiagonals;

		internal DiagonalMatrix DiagonalEntries()
		{
			DiagonalMatrix diagonalMatrix = new DiagonalMatrix(_inverseDiagonals.Length);
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				diagonalMatrix[i, i] = 1f / _inverseDiagonals[i];
			}
			return diagonalMatrix;
		}

		public void Initialize(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_inverseDiagonals = new MathNet.Numerics.Complex32[matrix.RowCount];
			for (int i = 0; i < matrix.RowCount; i++)
			{
				_inverseDiagonals[i] = 1f / matrix[i, i];
			}
		}

		public void Approximate(Vector<MathNet.Numerics.Complex32> rhs, Vector<MathNet.Numerics.Complex32> lhs)
		{
			if (_inverseDiagonals == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _inverseDiagonals.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				lhs[i] = rhs[i] * _inverseDiagonals[i];
			}
		}
	}
	public sealed class GpBiCg : IIterativeSolver<MathNet.Numerics.Complex32>
	{
		private int _numberOfBiCgStabSteps = 1;

		private int _numberOfGpbiCgSteps = 4;

		public int NumberOfBiCgStabSteps
		{
			get
			{
				return _numberOfBiCgStabSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfBiCgStabSteps = value;
			}
		}

		public int NumberOfGpBiCgSteps
		{
			get
			{
				return _numberOfGpbiCgSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfGpbiCgSteps = value;
			}
		}

		private static void CalculateTrueResidual(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> residual, Vector<MathNet.Numerics.Complex32> x, Vector<MathNet.Numerics.Complex32> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		private bool ShouldRunBiCgStabSteps(int iterationNumber)
		{
			int num = iterationNumber % (_numberOfBiCgStabSteps + _numberOfGpbiCgSteps);
			if (num >= 0)
			{
				return num < _numberOfBiCgStabSteps;
			}
			return false;
		}

		public void Solve(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result, Iterator<MathNet.Numerics.Complex32> iterator, IPreconditioner<MathNet.Numerics.Complex32> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<MathNet.Numerics.Complex32>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<MathNet.Numerics.Complex32>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			MathNet.Numerics.Complex32 scalar = 0;
			DenseVector denseVector3 = DenseVector.OfVector(denseVector2);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			DenseVector denseVector12 = new DenseVector(denseVector2.Count);
			DenseVector denseVector13 = new DenseVector(denseVector2.Count);
			DenseVector denseVector14 = new DenseVector(denseVector2.Count);
			DenseVector denseVector15 = new DenseVector(denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				denseVector8.Subtract(denseVector10, denseVector13);
				denseVector13.Multiply(scalar, denseVector14);
				denseVector2.Add(denseVector14, denseVector8);
				preconditioner.Approximate(denseVector8, denseVector13);
				matrix.Multiply(denseVector13, denseVector9);
				MathNet.Numerics.Complex32 complex = denseVector3.ConjugateDotProduct(denseVector2) / denseVector3.ConjugateDotProduct(denseVector9);
				denseVector9.Subtract(denseVector6, denseVector13);
				denseVector4.Subtract(denseVector2, denseVector11);
				denseVector13.Multiply(complex, denseVector14);
				denseVector11.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector11);
				denseVector4.CopyTo(denseVector5);
				denseVector9.Multiply(-complex, denseVector14);
				denseVector2.Add(denseVector14, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector13);
				matrix.Multiply(denseVector13, denseVector7);
				MathNet.Numerics.Complex32 complex2 = denseVector7.ConjugateDotProduct(denseVector7);
				if (complex2.Real.AlmostEqualNumbersBetween(0f, 1) && complex2.Imaginary.AlmostEqualNumbersBetween(0f, 1))
				{
					complex2 = 1f;
				}
				MathNet.Numerics.Complex32 complex3 = denseVector7.ConjugateDotProduct(denseVector4);
				MathNet.Numerics.Complex32 complex4;
				MathNet.Numerics.Complex32 complex5;
				if ((_numberOfBiCgStabSteps == 0 && i == 0) || ShouldRunBiCgStabSteps(i))
				{
					complex4 = complex3 / complex2;
					complex5 = 0;
				}
				else
				{
					MathNet.Numerics.Complex32 complex6 = denseVector11.ConjugateDotProduct(denseVector11);
					if (complex6.Real.AlmostEqualNumbersBetween(0f, 1) && complex6.Imaginary.AlmostEqualNumbersBetween(0f, 1))
					{
						complex6 = 1f;
					}
					MathNet.Numerics.Complex32 complex7 = denseVector11.ConjugateDotProduct(denseVector4);
					MathNet.Numerics.Complex32 complex8 = denseVector7.ConjugateDotProduct(denseVector11);
					MathNet.Numerics.Complex32 complex9 = complex2 * complex6 - complex8 * complex8;
					complex4 = (complex6 * complex3 - complex7 * complex8) / complex9;
					complex5 = (complex2 * complex7 - complex8 * complex3) / complex9;
				}
				denseVector10.Multiply(scalar, denseVector14);
				denseVector5.Add(denseVector14, denseVector13);
				denseVector13.Subtract(denseVector2, denseVector15);
				denseVector15.CopyTo(denseVector13);
				denseVector13.Multiply(complex5, denseVector13);
				denseVector9.Multiply(complex4, denseVector14);
				denseVector13.Add(denseVector14, denseVector10);
				denseVector12.Multiply(complex5, denseVector12);
				denseVector10.Multiply(-complex, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector2.Multiply(complex4, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector8.Multiply(complex, denseVector14);
				denseVector.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector.Add(denseVector12, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector2.CopyTo(denseVector5);
				denseVector11.Multiply(-complex5, denseVector14);
				denseVector4.Add(denseVector14, denseVector2);
				denseVector7.Multiply(-complex4, denseVector14);
				denseVector2.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector2);
				scalar = ((!complex4.Real.AlmostEqualNumbersBetween(0f, 1) || !complex4.Imaginary.AlmostEqualNumbersBetween(0f, 1)) ? (complex / complex4 * denseVector3.ConjugateDotProduct(denseVector2) / denseVector3.ConjugateDotProduct(denseVector5)) : ((MathNet.Numerics.Complex32)0));
				denseVector9.Multiply(scalar, denseVector14);
				denseVector7.Add(denseVector14, denseVector6);
				preconditioner.Approximate(denseVector, result);
				if (iterator.DetermineStatus(i, result, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, result, input);
				}
			}
		}
	}
	public sealed class ILU0Preconditioner : IPreconditioner<MathNet.Numerics.Complex32>
	{
		private SparseMatrix _decompositionLU;

		internal Matrix<MathNet.Numerics.Complex32> UpperTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = i; j < _decompositionLU.ColumnCount; j++)
				{
					sparseMatrix[i, j] = _decompositionLU[i, j];
				}
			}
			return sparseMatrix;
		}

		internal Matrix<MathNet.Numerics.Complex32> LowerTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j <= i; j++)
				{
					if (i == j)
					{
						sparseMatrix[i, j] = 1f;
					}
					else
					{
						sparseMatrix[i, j] = _decompositionLU[i, j];
					}
				}
			}
			return sparseMatrix;
		}

		public void Initialize(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_decompositionLU = SparseMatrix.OfMatrix(matrix);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j < i; j++)
				{
					if (!(_decompositionLU[i, j] != 0f))
					{
						continue;
					}
					MathNet.Numerics.Complex32 complex = _decompositionLU[i, j] / _decompositionLU[j, j];
					_decompositionLU[i, j] = complex;
					if (_decompositionLU[j, i] != 0f)
					{
						_decompositionLU[i, i] -= complex * _decompositionLU[j, i];
					}
					for (int k = j + 1; k < _decompositionLU.RowCount; k++)
					{
						if (k != i && _decompositionLU[i, k] != 0f)
						{
							_decompositionLU[i, k] -= complex * _decompositionLU[j, k];
						}
					}
				}
			}
		}

		public void Approximate(Vector<MathNet.Numerics.Complex32> rhs, Vector<MathNet.Numerics.Complex32> lhs)
		{
			if (_decompositionLU == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _decompositionLU.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			DenseVector denseVector = new DenseVector(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				denseVector.Clear();
				_decompositionLU.Row(i, denseVector);
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = 0; j < i; j++)
				{
					zero += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - zero;
			}
			for (int num = _decompositionLU.RowCount - 1; num > -1; num--)
			{
				_decompositionLU.Row(num, denseVector);
				MathNet.Numerics.Complex32 zero2 = MathNet.Numerics.Complex32.Zero;
				for (int num2 = _decompositionLU.RowCount - 1; num2 > num; num2--)
				{
					zero2 += denseVector[num2] * lhs[num2];
				}
				lhs[num] = 1f / denseVector[num] * (lhs[num] - zero2);
			}
		}
	}
	public sealed class ILUTPPreconditioner : IPreconditioner<MathNet.Numerics.Complex32>
	{
		public const double DefaultFillLevel = 200.0;

		public const double DefaultDropTolerance = 0.0001;

		private SparseMatrix _upper;

		private SparseMatrix _lower;

		private int[] _pivots;

		private double _fillLevel = 200.0;

		private double _dropTolerance = 0.0001;

		private double _pivotTolerance;

		public double FillLevel
		{
			get
			{
				return _fillLevel;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_fillLevel = value;
			}
		}

		public double DropTolerance
		{
			get
			{
				return _dropTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dropTolerance = value;
			}
		}

		public double PivotTolerance
		{
			get
			{
				return _pivotTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_pivotTolerance = value;
			}
		}

		public ILUTPPreconditioner()
		{
		}

		public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance)
		{
			if (fillLevel < 0.0)
			{
				throw new ArgumentOutOfRangeException("fillLevel");
			}
			if (dropTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("dropTolerance");
			}
			if (pivotTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("pivotTolerance");
			}
			_fillLevel = fillLevel;
			_dropTolerance = dropTolerance;
			_pivotTolerance = pivotTolerance;
		}

		internal Matrix<MathNet.Numerics.Complex32> UpperTriangle()
		{
			return _upper.Clone();
		}

		internal Matrix<MathNet.Numerics.Complex32> LowerTriangle()
		{
			return _lower.Clone();
		}

		internal int[] Pivots()
		{
			int[] array = new int[_pivots.Length];
			for (int i = 0; i < _pivots.Length; i++)
			{
				array[i] = _pivots[i];
			}
			return array;
		}

		public void Initialize(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			SparseMatrix sparseMatrix = (matrix as SparseMatrix) ?? SparseMatrix.OfMatrix(matrix);
			_lower = new SparseMatrix(sparseMatrix.RowCount);
			_upper = new SparseMatrix(sparseMatrix.RowCount);
			_pivots = new int[sparseMatrix.RowCount];
			for (int i = 0; i < _pivots.Length; i++)
			{
				_pivots[i] = i;
			}
			DenseVector denseVector = new DenseVector(sparseMatrix.RowCount);
			DenseVector denseVector2 = new DenseVector(sparseMatrix.ColumnCount);
			int[] array = new int[sparseMatrix.RowCount];
			int num = (int)_fillLevel * sparseMatrix.NonZerosCount;
			for (int j = 0; j < sparseMatrix.RowCount; j++)
			{
				sparseMatrix.Row(j, denseVector);
				PivotRow(denseVector);
				double num2 = denseVector.InfinityNorm();
				for (int k = 0; k < j; k++)
				{
					if (!(denseVector[k] != 0f))
					{
						continue;
					}
					denseVector[k] /= _upper[k, k];
					if ((double)denseVector[k].Magnitude < _dropTolerance)
					{
						denseVector[k] = 0f;
					}
					if (denseVector[k] != 0f)
					{
						_upper.Row(k, denseVector2);
						for (int l = 0; l <= k; l++)
						{
							denseVector2[l] = 0f;
						}
						denseVector2.Multiply(denseVector[k], denseVector2);
						denseVector.Subtract(denseVector2, denseVector);
					}
				}
				for (int m = j; m < sparseMatrix.RowCount; m++)
				{
					if ((double)denseVector[m].Magnitude <= _dropTolerance * num2)
					{
						denseVector[m] = 0f;
					}
				}
				int num3 = num / (sparseMatrix.RowCount - j + 1);
				int num4 = num3 / 2;
				FindLargestItems(0, j - 1, array, denseVector);
				int num5 = 0;
				int num6 = 0;
				for (int n = 0; n < j; n++)
				{
					if (num6 > num4)
					{
						break;
					}
					if (array[n] == -1)
					{
						break;
					}
					_lower[j, array[n]] = denseVector[array[n]];
					num6++;
					num5++;
				}
				FindLargestItems(j + 1, sparseMatrix.RowCount - 1, array, denseVector);
				num4 = num3 - num5;
				int num7 = 0;
				num6 = 0;
				for (int num8 = 0; num8 < sparseMatrix.RowCount - j; num8++)
				{
					if (num6 > num4 - 1)
					{
						break;
					}
					if (array[num8] == -1)
					{
						break;
					}
					_upper[j, array[num8]] = denseVector[array[num8]];
					num6++;
					num7++;
				}
				_upper[j, j] = denseVector[j];
				if (j + 1 < sparseMatrix.RowCount - 1 && (double)denseVector[j].Magnitude < _pivotTolerance * (double)denseVector[array[0]].Magnitude)
				{
					SwapColumns(_upper, j, array[0]);
					int num9 = _pivots[j];
					_pivots[j] = _pivots[array[0]];
					_pivots[array[0]] = num9;
				}
				num -= num5 + num7;
			}
			for (int num10 = 0; num10 < _lower.RowCount; num10++)
			{
				_lower[num10, num10] = 1f;
			}
		}

		private void PivotRow(Vector<MathNet.Numerics.Complex32> row)
		{
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			for (int i = 0; i < row.Count; i++)
			{
				if (_pivots[i] != i && !PivotMapFound(dictionary, i))
				{
					dictionary.Add(_pivots[i], i);
					MathNet.Numerics.Complex32 value = row[i];
					row[i] = row[_pivots[i]];
					row[_pivots[i]] = value;
				}
			}
		}

		private bool PivotMapFound(Dictionary<int, int> knownPivots, int currentItem)
		{
			if (knownPivots.ContainsKey(_pivots[currentItem]) && knownPivots[_pivots[currentItem]].Equals(currentItem))
			{
				return true;
			}
			if (knownPivots.ContainsKey(currentItem) && knownPivots[currentItem].Equals(_pivots[currentItem]))
			{
				return true;
			}
			return false;
		}

		private static void SwapColumns(Matrix<MathNet.Numerics.Complex32> matrix, int firstColumn, int secondColumn)
		{
			for (int i = 0; i < matrix.RowCount; i++)
			{
				MathNet.Numerics.Complex32 value = matrix[i, firstColumn];
				matrix[i, firstColumn] = matrix[i, secondColumn];
				matrix[i, secondColumn] = value;
			}
		}

		private static void FindLargestItems(int lowerBound, int upperBound, int[] sortedIndices, Vector<MathNet.Numerics.Complex32> values)
		{
			for (int i = 0; i < upperBound + 1 - lowerBound; i++)
			{
				sortedIndices[i] = lowerBound + i;
			}
			for (int j = upperBound + 1 - lowerBound; j < sortedIndices.Length; j++)
			{
				sortedIndices[j] = -1;
			}
			ILUTPElementSorter.SortDoubleIndicesDecreasing(0, upperBound - lowerBound, sortedIndices, values);
		}

		public void Approximate(Vector<MathNet.Numerics.Complex32> rhs, Vector<MathNet.Numerics.Complex32> lhs)
		{
			if (_upper == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _upper.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			DenseVector denseVector = new DenseVector(_lower.RowCount);
			for (int i = 0; i < _lower.RowCount; i++)
			{
				_lower.Row(i, denseVector);
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = 0; j < i; j++)
				{
					zero += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - zero;
			}
			for (int num = _upper.RowCount - 1; num > -1; num--)
			{
				_upper.Row(num, denseVector);
				MathNet.Numerics.Complex32 zero2 = MathNet.Numerics.Complex32.Zero;
				for (int num2 = _upper.RowCount - 1; num2 > num; num2--)
				{
					zero2 += denseVector[num2] * lhs[num2];
				}
				lhs[num] = 1f / denseVector[num] * (lhs[num] - zero2);
			}
			Vector<MathNet.Numerics.Complex32> vector = lhs.Clone();
			Pivot(vector, lhs);
		}

		private void Pivot(Vector<MathNet.Numerics.Complex32> vector, Vector<MathNet.Numerics.Complex32> result)
		{
			for (int i = 0; i < _pivots.Length; i++)
			{
				result[i] = vector[_pivots[i]];
			}
		}
	}
	internal static class ILUTPElementSorter
	{
		public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, int[] sortedIndices, Vector<MathNet.Numerics.Complex32> values)
		{
			if (lowerBound > 0)
			{
				for (int i = 0; i < upperBound - lowerBound + 1; i++)
				{
					Exchange(sortedIndices, i, i + lowerBound);
				}
				upperBound -= lowerBound;
				lowerBound = 0;
			}
			HeapSortDoublesIndices(lowerBound, upperBound, sortedIndices, values);
		}

		private static void HeapSortDoublesIndices(int lowerBound, int upperBound, int[] sortedIndices, Vector<MathNet.Numerics.Complex32> values)
		{
			int start = (upperBound - lowerBound + 1) / 2 - 1 + lowerBound;
			int num = upperBound - lowerBound + 1 - 1 + lowerBound;
			BuildDoubleIndexHeap(start, upperBound - lowerBound + 1, sortedIndices, values);
			while (num >= lowerBound)
			{
				Exchange(sortedIndices, num, lowerBound);
				SiftDoubleIndices(sortedIndices, values, lowerBound, num);
				num--;
			}
		}

		private static void BuildDoubleIndexHeap(int start, int count, int[] sortedIndices, Vector<MathNet.Numerics.Complex32> values)
		{
			while (start >= 0)
			{
				SiftDoubleIndices(sortedIndices, values, start, count);
				start--;
			}
		}

		private static void SiftDoubleIndices(int[] sortedIndices, Vector<MathNet.Numerics.Complex32> values, int begin, int count)
		{
			int num = begin;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[sortedIndices[num2]].Magnitude > values[sortedIndices[num2 + 1]].Magnitude)
				{
					num2++;
				}
				if (values[sortedIndices[num]].Magnitude <= values[sortedIndices[num2]].Magnitude)
				{
					break;
				}
				Exchange(sortedIndices, num, num2);
				num = num2;
			}
		}

		public static void SortIntegersDecreasing(int[] values)
		{
			HeapSortIntegers(values, values.Length);
		}

		private static void HeapSortIntegers(int[] values, int count)
		{
			int start = count / 2 - 1;
			int num = count - 1;
			BuildHeap(values, start, count);
			while (num >= 0)
			{
				Exchange(values, num, 0);
				Sift(values, 0, num);
				num--;
			}
		}

		private static void BuildHeap(int[] values, int start, int count)
		{
			while (start >= 0)
			{
				Sift(values, start, count);
				start--;
			}
		}

		private static void Sift(int[] values, int start, int count)
		{
			int num = start;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[num2] > values[num2 + 1])
				{
					num2++;
				}
				if (values[num] > values[num2])
				{
					Exchange(values, num, num2);
					num = num2;
					continue;
				}
				break;
			}
		}

		private static void Exchange(int[] values, int first, int second)
		{
			int num = values[first];
			values[first] = values[second];
			values[second] = num;
		}
	}
	public sealed class MILU0Preconditioner : IPreconditioner<MathNet.Numerics.Complex32>
	{
		private MathNet.Numerics.Complex32[] _alu;

		private int[] _jlu;

		private int[] _diag;

		public bool UseModified { get; set; }

		public bool IsInitialized { get; private set; }

		public MILU0Preconditioner(bool modified = true)
		{
			UseModified = modified;
		}

		public void Initialize(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (!(matrix.Storage is SparseCompressedRowMatrixStorage<MathNet.Numerics.Complex32> sparseCompressedRowMatrixStorage))
			{
				throw new ArgumentException("Matrix must be in sparse storage format", "matrix");
			}
			int rowCount = sparseCompressedRowMatrixStorage.RowCount;
			if (rowCount != sparseCompressedRowMatrixStorage.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			MathNet.Numerics.Complex32[] values = sparseCompressedRowMatrixStorage.Values;
			int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			_alu = new MathNet.Numerics.Complex32[rowPointers[rowCount] + 1];
			_jlu = new int[rowPointers[rowCount] + 1];
			_diag = new int[rowCount];
			int num = Compute(rowCount, values, columnIndices, rowPointers, _alu, _jlu, _diag, UseModified);
			if (num > -1)
			{
				throw new NumericalBreakdownException("Zero pivot encountered on row " + num + " during ILU process");
			}
			IsInitialized = true;
		}

		public void Approximate(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (_alu == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (result.Count != input.Count || result.Count != _diag.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			int num = _diag.Length;
			for (int i = 0; i < num; i++)
			{
				result[i] = input[i];
				for (int j = _jlu[i]; j < _diag[i]; j++)
				{
					result[i] -= _alu[j] * result[_jlu[j]];
				}
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				for (int k = _diag[num2]; k < _jlu[num2 + 1]; k++)
				{
					result[num2] -= _alu[k] * result[_jlu[k]];
				}
				result[num2] = _alu[num2] * result[num2];
			}
		}

		private int Compute(int n, MathNet.Numerics.Complex32[] a, int[] ja, int[] ia, MathNet.Numerics.Complex32[] alu, int[] jlu, int[] ju, bool modified)
		{
			int[] array = new int[n];
			int num = (jlu[0] = n + 1);
			for (int i = 0; i < n; i++)
			{
				array[i] = -1;
			}
			for (int i = 0; i < n; i++)
			{
				int num2 = num;
				for (int j = ia[i]; j < ia[i + 1]; j++)
				{
					int num3 = ja[j];
					if (num3 == i)
					{
						alu[i] = a[j];
						array[num3] = i;
						ju[i] = num;
					}
					else
					{
						alu[num] = a[j];
						jlu[num] = ja[j];
						array[num3] = num;
						num++;
					}
				}
				jlu[i + 1] = num;
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = num2; j < ju[i]; j++)
				{
					int num4 = jlu[j];
					MathNet.Numerics.Complex32 complex = (alu[j] *= alu[num4]);
					for (int k = ju[num4]; k < jlu[num4 + 1]; k++)
					{
						int num5 = array[jlu[k]];
						if (num5 != -1)
						{
							alu[num5] -= complex * alu[k];
						}
						else
						{
							zero += complex * alu[k];
						}
					}
				}
				if (modified)
				{
					alu[i] -= zero;
				}
				if (alu[i] == MathNet.Numerics.Complex32.Zero)
				{
					return i;
				}
				alu[i] = 1f / alu[i];
				array[i] = -1;
				for (int k = num2; k < num; k++)
				{
					array[jlu[k]] = -1;
				}
			}
			return -1;
		}
	}
	public sealed class MlkBiCgStab : IIterativeSolver<MathNet.Numerics.Complex32>
	{
		private const int DefaultNumberOfStartingVectors = 50;

		private IList<Vector<MathNet.Numerics.Complex32>> _startingVectors;

		private int _numberOfStartingVectors = 50;

		public int NumberOfStartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _numberOfStartingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value <= 1)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfStartingVectors = value;
			}
		}

		public IList<Vector<MathNet.Numerics.Complex32>> StartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _startingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value == null || value.Count == 0)
				{
					_startingVectors = null;
				}
				else
				{
					_startingVectors = value;
				}
			}
		}

		public void ResetNumberOfStartingVectors()
		{
			_numberOfStartingVectors = 50;
		}

		private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			return Math.Min(maximumNumberOfStartingVectors, numberOfVariables - 1);
		}

		private static IList<Vector<MathNet.Numerics.Complex32>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			int columns = NumberOfStartingVectorsToCreate(maximumNumberOfStartingVectors, numberOfVariables);
			Normal normal = new Normal();
			DenseMatrix denseMatrix = new DenseMatrix(numberOfVariables, columns);
			for (int i = 0; i < denseMatrix.ColumnCount; i++)
			{
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[denseMatrix.RowCount];
				double[] array2 = normal.Samples().Take(denseMatrix.RowCount).ToArray();
				double[] array3 = normal.Samples().Take(denseMatrix.RowCount).ToArray();
				for (int j = 0; j < denseMatrix.RowCount; j++)
				{
					array[j] = new MathNet.Numerics.Complex32((float)array2[j], (float)array3[j]);
				}
				denseMatrix.SetColumn(i, array);
			}
			Matrix<MathNet.Numerics.Complex32> q = denseMatrix.GramSchmidt().Q;
			List<Vector<MathNet.Numerics.Complex32>> list = new List<Vector<MathNet.Numerics.Complex32>>(q.ColumnCount);
			for (int k = 0; k < q.ColumnCount; k++)
			{
				list.Add(q.Column(k));
				list[k].Multiply(1f / (float)list[k].L2Norm(), list[k]);
			}
			return list;
		}

		private static Vector<MathNet.Numerics.Complex32>[] CreateVectorArray(int arraySize, int vectorSize)
		{
			Vector<MathNet.Numerics.Complex32>[] array = new Vector<MathNet.Numerics.Complex32>[arraySize];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new DenseVector(vectorSize);
			}
			return array;
		}

		private static void CalculateTrueResidual(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> residual, Vector<MathNet.Numerics.Complex32> x, Vector<MathNet.Numerics.Complex32> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result, Iterator<MathNet.Numerics.Complex32> iterator, IPreconditioner<MathNet.Numerics.Complex32> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<MathNet.Numerics.Complex32>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<MathNet.Numerics.Complex32>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			bool flag = false;
			if (_startingVectors != null && _startingVectors.Count <= NumberOfStartingVectorsToCreate(_numberOfStartingVectors, input.Count) && _startingVectors[0].Count == input.Count)
			{
				flag = true;
			}
			_startingVectors = (flag ? _startingVectors : CreateStartingVectors(_numberOfStartingVectors, input.Count));
			int count = _startingVectors.Count;
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[count];
			DenseVector denseVector3 = new DenseVector(denseVector2.Count);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			Vector<MathNet.Numerics.Complex32>[] array2 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			Vector<MathNet.Numerics.Complex32>[] array3 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			denseVector2.CopyTo(array3[count - 1]);
			Vector<MathNet.Numerics.Complex32>[] array4 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				preconditioner.Approximate(array3[count - 1], denseVector3);
				matrix.Multiply(denseVector3, array4[count - 1]);
				array[count - 1] = _startingVectors[0].ConjugateDotProduct(array4[count - 1]);
				if (array[count - 1].Real.AlmostEqualNumbersBetween(0f, 1) && array[count - 1].Imaginary.AlmostEqualNumbersBetween(0f, 1))
				{
					throw new NumericalBreakdownException();
				}
				MathNet.Numerics.Complex32 complex = _startingVectors[0].ConjugateDotProduct(denseVector2) / array[count - 1];
				array4[count - 1].Multiply(-complex, denseVector6);
				denseVector2.Add(denseVector6, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector7);
				denseVector7.CopyTo(denseVector5);
				matrix.Multiply(denseVector7, denseVector6);
				MathNet.Numerics.Complex32 complex2 = denseVector6.ConjugateDotProduct(denseVector6);
				if (complex2.Real.AlmostEqualNumbersBetween(0f, 1) && complex2.Imaginary.AlmostEqualNumbersBetween(0f, 1))
				{
					complex2 = 1f;
				}
				complex2 = -denseVector4.ConjugateDotProduct(denseVector6) / complex2;
				denseVector4.CopyTo(denseVector2);
				denseVector6.Multiply(complex2, denseVector6);
				denseVector2.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector2);
				denseVector5.Multiply(-complex2, denseVector6);
				denseVector.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector3.Multiply(complex, denseVector3);
				denseVector.Add(denseVector3, denseVector8);
				denseVector8.CopyTo(denseVector);
				if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, denseVector, input);
					if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
					{
						break;
					}
				}
				for (int j = 0; j < count; j++)
				{
					denseVector4.CopyTo(denseVector9);
					denseVector2.CopyTo(denseVector10);
					denseVector11.Clear();
					MathNet.Numerics.Complex32 scalar;
					if (i >= 1)
					{
						for (int k = j; k < count - 1; k++)
						{
							scalar = -_startingVectors[k + 1].ConjugateDotProduct(denseVector9) / array[k];
							array2[k].Multiply(scalar, denseVector6);
							denseVector9.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector9);
							array3[k].Multiply(scalar, denseVector6);
							denseVector10.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector10);
							array4[k].Multiply(scalar, denseVector6);
							denseVector11.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector11);
						}
					}
					scalar = complex2 * array[count - 1];
					if (scalar.Real.AlmostEqualNumbersBetween(0f, 1) && scalar.Imaginary.AlmostEqualNumbersBetween(0f, 1))
					{
						throw new NumericalBreakdownException();
					}
					denseVector11.Multiply(complex2, denseVector8);
					denseVector2.Add(denseVector8, denseVector6);
					scalar = -_startingVectors[0].ConjugateDotProduct(denseVector6) / scalar;
					array3[count - 1].Multiply(scalar, denseVector6);
					denseVector10.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector10);
					array4[count - 1].Multiply(scalar, denseVector6);
					denseVector11.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector11);
					denseVector11.Multiply(complex2, denseVector11);
					denseVector2.Add(denseVector11, denseVector9);
					for (int l = 0; l < j - 1; l++)
					{
						scalar = -_startingVectors[l + 1].ConjugateDotProduct(denseVector9) / array[l];
						array2[l].Multiply(scalar, denseVector6);
						denseVector9.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector9);
						array3[l].Multiply(scalar, denseVector6);
						denseVector10.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector10);
					}
					denseVector9.Subtract(denseVector4, array2[j]);
					denseVector10.Add(denseVector11, array3[j]);
					if (j < count - 1)
					{
						array[j] = _startingVectors[j + 1].ConjugateDotProduct(array2[j]);
						if (array[j].Real.AlmostEqualNumbersBetween(0f, 1) && array[j].Imaginary.AlmostEqualNumbersBetween(0f, 1))
						{
							throw new NumericalBreakdownException();
						}
						complex = _startingVectors[j + 1].ConjugateDotProduct(denseVector4) / array[j];
						array2[j].Multiply(-complex, denseVector6);
						denseVector4.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector4);
						preconditioner.Approximate(array3[j], denseVector3);
						denseVector3.Multiply(complex2 * complex, denseVector6);
						denseVector.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector);
						matrix.Multiply(denseVector3, array4[j]);
						array4[j].Multiply(-complex2 * complex, denseVector6);
						denseVector2.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector2);
						if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
						{
							CalculateTrueResidual(matrix, denseVector2, denseVector, input);
						}
					}
				}
			}
			denseVector.CopyTo(result);
		}
	}
	public sealed class TFQMR : IIterativeSolver<MathNet.Numerics.Complex32>
	{
		private static void CalculateTrueResidual(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> residual, Vector<MathNet.Numerics.Complex32> x, Vector<MathNet.Numerics.Complex32> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		private static bool IsEven(int number)
		{
			return number % 2 == 0;
		}

		public void Solve(Matrix<MathNet.Numerics.Complex32> matrix, Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result, Iterator<MathNet.Numerics.Complex32> iterator, IPreconditioner<MathNet.Numerics.Complex32> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<MathNet.Numerics.Complex32>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<MathNet.Numerics.Complex32>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector denseVector2 = DenseVector.OfVector(input);
			DenseVector denseVector3 = new DenseVector(input.Count);
			DenseVector denseVector4 = new DenseVector(input.Count);
			DenseVector denseVector5 = new DenseVector(input.Count);
			DenseVector denseVector6 = DenseVector.OfVector(input);
			DenseVector denseVector7 = new DenseVector(input.Count);
			DenseVector denseVector8 = new DenseVector(input.Count);
			DenseVector denseVector9 = DenseVector.OfVector(input);
			DenseVector denseVector10 = new DenseVector(input.Count);
			DenseVector denseVector11 = new DenseVector(input.Count);
			DenseVector denseVector12 = new DenseVector(input.Count);
			MathNet.Numerics.Complex32 complex = 0;
			MathNet.Numerics.Complex32 complex2 = 0;
			float num = 0f;
			float num2 = (float)input.L2Norm();
			MathNet.Numerics.Complex32 complex3 = num2 * num2;
			preconditioner.Approximate(denseVector9, denseVector10);
			matrix.Multiply(denseVector10, denseVector5);
			denseVector5.CopyTo(denseVector4);
			for (int i = 0; iterator.DetermineStatus(i, result, input, denseVector6) == IterationStatus.Continue; i++)
			{
				if (IsEven(i))
				{
					MathNet.Numerics.Complex32 complex4 = denseVector2.ConjugateDotProduct(denseVector5);
					if (complex4.Real.AlmostEqualNumbersBetween(0f, 1) && complex4.Imaginary.AlmostEqualNumbersBetween(0f, 1))
					{
						iterator.Cancel();
						break;
					}
					complex = complex3 / complex4;
					denseVector5.Multiply(-complex, denseVector11);
					denseVector9.Add(denseVector11, denseVector8);
					preconditioner.Approximate(denseVector8, denseVector10);
					matrix.Multiply(denseVector10, denseVector3);
				}
				DenseVector obj = (IsEven(i) ? denseVector4 : denseVector3);
				DenseVector denseVector13 = (IsEven(i) ? denseVector9 : denseVector8);
				obj.Multiply(-complex, denseVector11);
				denseVector6.Add(denseVector11, denseVector12);
				denseVector12.CopyTo(denseVector6);
				denseVector.Multiply(num * num * complex2 / complex, denseVector10);
				denseVector13.Add(denseVector10, denseVector);
				num = (float)denseVector6.L2Norm() / num2;
				float num3 = 1f / (float)Math.Sqrt(1f + num * num);
				num2 *= num * num3;
				complex2 = num3 * num3 * complex;
				denseVector.Multiply(complex2, denseVector11);
				denseVector7.Add(denseVector11, denseVector12);
				denseVector12.CopyTo(denseVector7);
				if (iterator.DetermineStatus(i, result, input, denseVector6) != 0)
				{
					preconditioner.Approximate(denseVector7, result);
					CalculateTrueResidual(matrix, denseVector10, result, input);
					if (iterator.DetermineStatus(i, result, input, denseVector10) != 0)
					{
						break;
					}
				}
				if (!IsEven(i))
				{
					if (complex3.Real.AlmostEqualNumbersBetween(0f, 1) && complex3.Imaginary.AlmostEqualNumbersBetween(0f, 1))
					{
						iterator.Cancel();
						break;
					}
					MathNet.Numerics.Complex32 complex5 = denseVector2.ConjugateDotProduct(denseVector6);
					MathNet.Numerics.Complex32 scalar = complex5 / complex3;
					complex3 = complex5;
					denseVector8.Multiply(scalar, denseVector11);
					denseVector6.Add(denseVector11, denseVector9);
					preconditioner.Approximate(denseVector9, denseVector10);
					matrix.Multiply(denseVector10, denseVector4);
					denseVector5.Multiply(scalar, denseVector11);
					denseVector3.Add(denseVector11, denseVector10);
					denseVector10.Multiply(scalar, denseVector11);
					denseVector4.Add(denseVector11, denseVector5);
				}
				preconditioner.Approximate(denseVector7, result);
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Complex32.Factorization
{
	internal abstract class Cholesky : Cholesky<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Determinant
		{
			get
			{
				MathNet.Numerics.Complex32 one = MathNet.Numerics.Complex32.One;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					MathNet.Numerics.Complex32 complex = base.Factor.At(i, i);
					one *= complex * complex;
				}
				return one;
			}
		}

		public override MathNet.Numerics.Complex32 DeterminantLn
		{
			get
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					zero += 2f * base.Factor.At(i, i).NaturalLogarithm();
				}
				return zero;
			}
		}

		protected Cholesky(Matrix<MathNet.Numerics.Complex32> factor)
			: base(factor)
		{
		}
	}
	internal sealed class DenseCholesky : Cholesky
	{
		public static DenseCholesky Create(DenseMatrix matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix.Values, denseMatrix.RowCount);
			return new DenseCholesky(denseMatrix);
		}

		private DenseCholesky(Matrix<MathNet.Numerics.Complex32> factor)
			: base(factor)
		{
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Array.Copy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length);
				DenseMatrix denseMatrix3 = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix3.Values, denseMatrix3.RowCount, denseMatrix2.Values, denseMatrix2.ColumnCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Array.Copy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length);
				DenseMatrix denseMatrix = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix.Values, denseMatrix.RowCount, denseVector2.Values, 1);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense vectors at the moment.");
		}

		public override void Factorize(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			if (matrix is DenseMatrix denseMatrix)
			{
				DenseMatrix denseMatrix2 = (DenseMatrix)base.Factor;
				Array.Copy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length);
				LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix2.Values, denseMatrix2.RowCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}
	}
	internal sealed class DenseEvd : Evd
	{
		public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			DenseMatrix denseMatrix = DenseMatrix.CreateIdentity(rowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(rowCount);
			MathNet.Numerics.LinearAlgebra.Complex.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Complex.DenseVector(rowCount);
			bool isSymmetric = symmetricity switch
			{
				Symmetricity.Hermitian => true, 
				Symmetricity.Asymmetric => false, 
				_ => matrix.IsHermitian(), 
			};
			LinearAlgebraControl.Provider.EigenDecomp(isSymmetric, rowCount, matrix.Values, denseMatrix.Values, denseVector.Values, denseMatrix2.Values);
			return new DenseEvd(denseMatrix, denseVector, denseMatrix2, isSymmetric);
		}

		private DenseEvd(Matrix<MathNet.Numerics.Complex32> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<MathNet.Numerics.Complex32> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						MathNet.Numerics.Complex32 complex = 0f;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								complex += ((DenseMatrix)base.EigenVectors).Values[j * count + k].Conjugate() * input.At(k, i);
							}
							complex /= (float)base.EigenValues[j].Real;
						}
						array[j] = complex;
					}
					for (int l = 0; l < count; l++)
					{
						MathNet.Numerics.Complex32 value = 0f;
						for (int m = 0; m < count; m++)
						{
							value += ((DenseMatrix)base.EigenVectors).Values[m * count + l] * array[m];
						}
						result.At(l, i, value);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[count];
				for (int i = 0; i < count; i++)
				{
					MathNet.Numerics.Complex32 complex = 0;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							complex += ((DenseMatrix)base.EigenVectors).Values[i * count + j].Conjugate() * input[j];
						}
						complex /= (float)base.EigenValues[i].Real;
					}
					array[i] = complex;
				}
				for (int k = 0; k < count; k++)
				{
					MathNet.Numerics.Complex32 complex = 0;
					for (int l = 0; l < count; l++)
					{
						complex += ((DenseMatrix)base.EigenVectors).Values[l * count + k] * array[l];
					}
					result[k] = complex;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class DenseGramSchmidt : GramSchmidt
	{
		public static DenseGramSchmidt Create(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount, matrix.ColumnCount);
			Factorize(denseMatrix.Values, denseMatrix.RowCount, denseMatrix.ColumnCount, denseMatrix2.Values);
			return new DenseGramSchmidt(denseMatrix, denseMatrix2);
		}

		private DenseGramSchmidt(Matrix<MathNet.Numerics.Complex32> q, Matrix<MathNet.Numerics.Complex32> rFull)
			: base(q, rFull)
		{
		}

		private static void Factorize(MathNet.Numerics.Complex32[] q, int rowsQ, int columnsQ, MathNet.Numerics.Complex32[] r)
		{
			for (int i = 0; i < columnsQ; i++)
			{
				float num = 0f;
				for (int j = 0; j < rowsQ; j++)
				{
					num += q[i * rowsQ + j].Magnitude * q[i * rowsQ + j].Magnitude;
				}
				num = (float)Math.Sqrt(num);
				if (num == 0f)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				r[i * columnsQ + i] = num;
				for (int k = 0; k < rowsQ; k++)
				{
					q[i * rowsQ + k] /= num;
				}
				for (int l = i + 1; l < columnsQ; l++)
				{
					int num2 = i;
					int num3 = l;
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int m = 0; m < rowsQ; m++)
					{
						zero += q[num2 * rowsQ + m].Conjugate() * q[num3 * rowsQ + m];
					}
					r[l * columnsQ + i] = zero;
					for (int n = 0; n < rowsQ; n++)
					{
						q[l * rowsQ + n] -= q[i * rowsQ + n] * zero;
					}
				}
			}
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseVector.Values, 1, denseVector2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseLU : LU
	{
		public static DenseLU Create(DenseMatrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int[] array = new int[matrix.RowCount];
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.LUFactor(denseMatrix.Values, denseMatrix.RowCount, array);
			return new DenseLU(denseMatrix, array);
		}

		private DenseLU(Matrix<MathNet.Numerics.Complex32> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Array.Copy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length);
				DenseMatrix denseMatrix3 = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(input.ColumnCount, denseMatrix3.Values, denseMatrix3.RowCount, Pivots, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Array.Copy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length);
				DenseMatrix denseMatrix = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(1, denseMatrix.Values, denseMatrix.RowCount, Pivots, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense vectors at the moment.");
		}

		public override Matrix<MathNet.Numerics.Complex32> Inverse()
		{
			DenseMatrix denseMatrix = (DenseMatrix)Factors.Clone();
			LinearAlgebraControl.Provider.LUInverseFactored(denseMatrix.Values, denseMatrix.RowCount, Pivots);
			return denseMatrix;
		}
	}
	internal sealed class DenseQR : QR
	{
		private MathNet.Numerics.Complex32[] Tau { get; set; }

		public static DenseQR Create(DenseMatrix matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			MathNet.Numerics.Complex32[] tau = new MathNet.Numerics.Complex32[Math.Min(matrix.RowCount, matrix.ColumnCount)];
			Matrix<MathNet.Numerics.Complex32> matrix2;
			Matrix<MathNet.Numerics.Complex32> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = new DenseMatrix(matrix.RowCount);
				LinearAlgebraControl.Provider.QRFactor(((DenseMatrix)matrix2).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix3).Values, tau);
			}
			else
			{
				matrix3 = matrix.Clone();
				matrix2 = new DenseMatrix(matrix.ColumnCount);
				LinearAlgebraControl.Provider.ThinQRFactor(((DenseMatrix)matrix3).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix2).Values, tau);
			}
			return new DenseQR(matrix3, matrix2, method, tau);
		}

		private DenseQR(Matrix<MathNet.Numerics.Complex32> q, Matrix<MathNet.Numerics.Complex32> rFull, QRMethod method, MathNet.Numerics.Complex32[] tau)
			: base(q, rFull, method)
		{
			Tau = tau;
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseVector.Values, 1, denseVector2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseSvd : Svd
	{
		public static DenseSvd Create(DenseMatrix matrix, bool computeVectors)
		{
			DenseVector denseVector = new DenseVector(Math.Min(matrix.RowCount, matrix.ColumnCount));
			DenseMatrix denseMatrix = new DenseMatrix(matrix.RowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount);
			LinearAlgebraControl.Provider.SingularValueDecomposition(computeVectors, ((DenseMatrix)matrix.Clone()).Values, matrix.RowCount, matrix.ColumnCount, denseVector.Values, denseMatrix.Values, denseMatrix2.Values);
			return new DenseSvd(denseVector, denseMatrix, denseMatrix2, computeVectors);
		}

		private DenseSvd(Vector<MathNet.Numerics.Complex32> s, Matrix<MathNet.Numerics.Complex32> u, Matrix<MathNet.Numerics.Complex32> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseVector.Values, 1, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense vectors at the moment.");
		}
	}
	internal abstract class Evd : Evd<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Determinant
		{
			get
			{
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					one *= base.EigenValues[i];
					if (((MathNet.Numerics.Complex32)base.EigenValues[i]).AlmostEqual(MathNet.Numerics.Complex32.Zero))
					{
						return 0;
					}
				}
				return new MathNet.Numerics.Complex32(Convert.ToSingle(one.Magnitude), 0f);
			}
		}

		public override int Rank
		{
			get
			{
				int num = 0;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (!((MathNet.Numerics.Complex32)base.EigenValues[i]).AlmostEqual(MathNet.Numerics.Complex32.Zero))
					{
						num++;
					}
				}
				return num;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected Evd(Matrix<MathNet.Numerics.Complex32> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<MathNet.Numerics.Complex32> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}
	}
	internal abstract class GramSchmidt : GramSchmidt<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				MathNet.Numerics.Complex32 one = MathNet.Numerics.Complex32.One;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					one *= FullR.At(i, i);
					if (FullR.At(i, i).Magnitude.AlmostEqual(0f))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (FullR.At(i, i).Magnitude.AlmostEqual(0f))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected GramSchmidt(Matrix<MathNet.Numerics.Complex32> q, Matrix<MathNet.Numerics.Complex32> rFull)
			: base(q, rFull)
		{
		}
	}
	internal abstract class LU : LU<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Determinant
		{
			get
			{
				MathNet.Numerics.Complex32 one = MathNet.Numerics.Complex32.One;
				for (int i = 0; i < Factors.RowCount; i++)
				{
					if (Pivots[i] != i)
					{
						one *= -Factors.At(i, i);
					}
					else
					{
						one *= Factors.At(i, i);
					}
				}
				return one;
			}
		}

		protected LU(Matrix<MathNet.Numerics.Complex32> factors, int[] pivots)
			: base(factors, pivots)
		{
		}
	}
	internal abstract class QR : QR<MathNet.Numerics.Complex32>
	{
		public override MathNet.Numerics.Complex32 Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				MathNet.Numerics.Complex32 one = MathNet.Numerics.Complex32.One;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					one *= FullR.At(i, i);
					if (FullR.At(i, i).Magnitude.AlmostEqual(0f))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (FullR.At(i, i).Magnitude.AlmostEqual(0f))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected QR(Matrix<MathNet.Numerics.Complex32> q, Matrix<MathNet.Numerics.Complex32> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}
	}
	internal abstract class Svd : Svd<MathNet.Numerics.Complex32>
	{
		public override int Rank
		{
			get
			{
				double tolerance = base.S.AbsoluteMaximum().Magnitude.EpsilonOf() * (float)Math.Max(base.U.RowCount, base.VT.RowCount);
				return base.S.Count((MathNet.Numerics.Complex32 t) => (double)t.Magnitude > tolerance);
			}
		}

		public override double L2Norm => base.S[0].Magnitude;

		public override MathNet.Numerics.Complex32 ConditionNumber
		{
			get
			{
				int index = Math.Min(base.U.RowCount, base.VT.ColumnCount) - 1;
				return base.S[0].Magnitude / base.S[index].Magnitude;
			}
		}

		public override MathNet.Numerics.Complex32 Determinant
		{
			get
			{
				if (base.U.RowCount != base.VT.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				MathNet.Numerics.Complex32 one = MathNet.Numerics.Complex32.One;
				foreach (MathNet.Numerics.Complex32 item in (IEnumerable<MathNet.Numerics.Complex32>)base.S)
				{
					one *= item;
					if (item.Magnitude.AlmostEqual(0f))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		protected Svd(Vector<MathNet.Numerics.Complex32> s, Matrix<MathNet.Numerics.Complex32> u, Matrix<MathNet.Numerics.Complex32> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}
	}
	internal sealed class UserCholesky : Cholesky
	{
		private static void DoCholesky(Matrix<MathNet.Numerics.Complex32> factor)
		{
			if (factor.RowCount != factor.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[factor.RowCount];
			for (int i = 0; i < factor.RowCount; i++)
			{
				MathNet.Numerics.Complex32 complex = factor.At(i, i);
				if ((double)complex.Real > 0.0)
				{
					complex = complex.SquareRoot();
					factor.At(i, i, complex);
					array[i] = complex;
					for (int j = i + 1; j < factor.RowCount; j++)
					{
						factor.At(j, i, factor.At(j, i) / complex);
						array[j] = factor.At(j, i);
					}
					DoCholeskyStep(factor, factor.RowCount, i + 1, factor.RowCount, array, Control.MaxDegreeOfParallelism);
					for (int k = i + 1; k < factor.RowCount; k++)
					{
						factor.At(i, k, MathNet.Numerics.Complex32.Zero);
					}
					continue;
				}
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		public static UserCholesky Create(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			Matrix<MathNet.Numerics.Complex32> factor = matrix.Clone();
			DoCholesky(factor);
			return new UserCholesky(factor);
		}

		public override void Factorize(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			matrix.CopyTo(base.Factor);
			DoCholesky(base.Factor);
		}

		private UserCholesky(Matrix<MathNet.Numerics.Complex32> factor)
			: base(factor)
		{
		}

		private static void DoCholeskyStep(Matrix<MathNet.Numerics.Complex32> data, int rowDim, int firstCol, int colLimit, MathNet.Numerics.Complex32[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				MathNet.Numerics.Complex32 complex = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data.At(j, i, data.At(j, i) - multipliers[j] * complex.Conjugate());
				}
			}
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < result.ColumnCount; i++)
			{
				for (int j = 0; j < rowCount; j++)
				{
					MathNet.Numerics.Complex32 complex = result.At(j, i);
					for (int num = j - 1; num >= 0; num--)
					{
						complex -= base.Factor.At(j, num) * result.At(num, i);
					}
					result.At(j, i, complex / base.Factor.At(j, j));
				}
				for (int num2 = rowCount - 1; num2 >= 0; num2--)
				{
					MathNet.Numerics.Complex32 complex = result.At(num2, i);
					for (int k = num2 + 1; k < rowCount; k++)
					{
						complex -= base.Factor.At(k, num2).Conjugate() * result.At(k, i);
					}
					result.At(num2, i, complex / base.Factor.At(num2, num2));
				}
			}
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < rowCount; i++)
			{
				MathNet.Numerics.Complex32 complex = result[i];
				for (int num = i - 1; num >= 0; num--)
				{
					complex -= base.Factor.At(i, num) * result[num];
				}
				result[i] = complex / base.Factor.At(i, i);
			}
			for (int num2 = rowCount - 1; num2 >= 0; num2--)
			{
				MathNet.Numerics.Complex32 complex = result[num2];
				for (int j = num2 + 1; j < rowCount; j++)
				{
					complex -= base.Factor.At(j, num2).Conjugate() * result[j];
				}
				result[num2] = complex / base.Factor.At(num2, num2);
			}
		}
	}
	internal sealed class UserEvd : Evd
	{
		public static UserEvd Create(Matrix<MathNet.Numerics.Complex32> matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			DenseMatrix eigenVectors = DenseMatrix.CreateIdentity(rowCount);
			Matrix<MathNet.Numerics.Complex32> matrix2 = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(matrix, rowCount, rowCount);
			MathNet.Numerics.LinearAlgebra.Complex.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Complex.DenseVector(rowCount);
			bool flag = symmetricity switch
			{
				Symmetricity.Hermitian => true, 
				Symmetricity.Asymmetric => false, 
				_ => matrix.IsHermitian(), 
			};
			if (flag)
			{
				MathNet.Numerics.Complex32[,] matrixA = matrix.ToArray();
				MathNet.Numerics.Complex32[] tau = new MathNet.Numerics.Complex32[rowCount];
				float[] array = new float[rowCount];
				float[] array2 = new float[rowCount];
				SymmetricTridiagonalize(matrixA, array, array2, tau, rowCount);
				SymmetricDiagonalize(eigenVectors, array, array2, rowCount);
				SymmetricUntridiagonalize(eigenVectors, matrixA, tau, rowCount);
				for (int i = 0; i < rowCount; i++)
				{
					denseVector[i] = new System.Numerics.Complex(array[i], array2[i]);
				}
			}
			else
			{
				MathNet.Numerics.Complex32[,] matrixH = matrix.ToArray();
				NonsymmetricReduceToHessenberg(eigenVectors, matrixH, rowCount);
				NonsymmetricReduceHessenberToRealSchur(eigenVectors, denseVector, matrixH, rowCount);
			}
			for (int j = 0; j < denseVector.Count; j++)
			{
				matrix2.At(j, j, (MathNet.Numerics.Complex32)denseVector[j]);
			}
			return new UserEvd(eigenVectors, denseVector, matrix2, flag);
		}

		private UserEvd(Matrix<MathNet.Numerics.Complex32> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<MathNet.Numerics.Complex32> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		private static void SymmetricTridiagonalize(MathNet.Numerics.Complex32[,] matrixA, float[] d, float[] e, MathNet.Numerics.Complex32[] tau, int order)
		{
			tau[order - 1] = MathNet.Numerics.Complex32.One;
			for (int i = 0; i < order; i++)
			{
				d[i] = matrixA[i, i].Real;
			}
			float num4;
			for (int num = order - 1; num > 0; num--)
			{
				float num2 = 0f;
				float num3 = 0f;
				for (int j = 0; j < num; j++)
				{
					num2 = num2 + Math.Abs(matrixA[num, j].Real) + Math.Abs(matrixA[num, j].Imaginary);
				}
				if (num2 == 0f)
				{
					tau[num - 1] = MathNet.Numerics.Complex32.One;
					e[num] = 0f;
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						matrixA[num, k] /= num2;
						num3 += matrixA[num, k].MagnitudeSquared;
					}
					MathNet.Numerics.Complex32 complex = (float)Math.Sqrt(num3);
					e[num] = num2 * complex.Real;
					MathNet.Numerics.Complex32 complex2 = matrixA[num, num - 1];
					MathNet.Numerics.Complex32 complex3;
					if (complex2.Magnitude != 0f)
					{
						complex3 = -(matrixA[num, num - 1].Conjugate() * tau[num].Conjugate()) / complex2.Magnitude;
						num3 += complex2.Magnitude * complex.Real;
						complex = 1f + complex / complex2.Magnitude;
						matrixA[num, num - 1] *= complex;
					}
					else
					{
						complex3 = -tau[num].Conjugate();
						matrixA[num, num - 1] = complex;
					}
					if (complex2.Magnitude == 0f || num != 1)
					{
						complex2 = MathNet.Numerics.Complex32.Zero;
						for (int l = 0; l < num; l++)
						{
							MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
							for (int m = 0; m <= l; m++)
							{
								zero += matrixA[l, m] * matrixA[num, m].Conjugate();
							}
							for (int n = l + 1; n <= num - 1; n++)
							{
								zero += matrixA[n, l].Conjugate() * matrixA[num, n].Conjugate();
							}
							tau[l] = zero / num3;
							complex2 += zero / num3 * matrixA[num, l];
						}
						num4 = complex2.Real / (num3 + num3);
						for (int num5 = 0; num5 < num; num5++)
						{
							complex2 = matrixA[num, num5].Conjugate();
							complex = tau[num5] - num4 * complex2;
							tau[num5] = complex.Conjugate();
							for (int num6 = 0; num6 <= num5; num6++)
							{
								matrixA[num5, num6] -= complex2 * tau[num6] + complex * matrixA[num, num6];
							}
						}
					}
					for (int num7 = 0; num7 < num; num7++)
					{
						matrixA[num, num7] *= num2;
					}
					tau[num - 1] = complex3.Conjugate();
				}
				num4 = d[num];
				d[num] = matrixA[num, num].Real;
				matrixA[num, num] = new MathNet.Numerics.Complex32(num4, num2 * (float)Math.Sqrt(num3));
			}
			num4 = d[0];
			d[0] = matrixA[0, 0].Real;
			matrixA[0, 0] = num4;
			e[0] = 0f;
		}

		private static void SymmetricDiagonalize(Matrix<MathNet.Numerics.Complex32> eigenVectors, float[] d, float[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0f;
			float num = 0f;
			float num2 = 0f;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !((double)Math.Abs(e[k]) <= doublePrecision * (double)num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						float num4 = d[j];
						float num5 = (d[j + 1] - num4) / (2f * e[j]);
						float num6 = SpecialFunctions.Hypotenuse(num5, 1f);
						if (num5 < 0f)
						{
							num6 = 0f - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						float num7 = d[j + 1];
						float num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						float num9 = 1f;
						float num10 = num9;
						float num11 = num9;
						float num12 = e[j + 1];
						float num13 = 0f;
						float num14 = 0f;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = eigenVectors.At(m, num15 + 1).Real;
								eigenVectors.At(m, num15 + 1, num13 * eigenVectors.At(m, num15).Real + num9 * num8);
								eigenVectors.At(m, num15, num9 * eigenVectors.At(m, num15).Real - num13 * num8);
							}
						}
						num5 = (0f - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while ((double)Math.Abs(e[j]) > doublePrecision * (double)num2);
				}
				d[j] += num;
				e[j] = 0f;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				float num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = eigenVectors.At(num19, n).Real;
						eigenVectors.At(num19, n, eigenVectors.At(num19, num16));
						eigenVectors.At(num19, num16, num17);
					}
				}
			}
		}

		private static void SymmetricUntridiagonalize(Matrix<MathNet.Numerics.Complex32> eigenVectors, MathNet.Numerics.Complex32[,] matrixA, MathNet.Numerics.Complex32[] tau, int order)
		{
			for (int i = 0; i < order; i++)
			{
				for (int j = 0; j < order; j++)
				{
					eigenVectors.At(i, j, eigenVectors.At(i, j).Real * tau[i].Conjugate());
				}
			}
			for (int k = 1; k < order; k++)
			{
				float imaginary = matrixA[k, k].Imaginary;
				if (imaginary == 0f)
				{
					continue;
				}
				for (int l = 0; l < order; l++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int m = 0; m < k; m++)
					{
						zero += eigenVectors.At(m, l) * matrixA[k, m];
					}
					zero = zero / imaginary / imaginary;
					for (int n = 0; n < k; n++)
					{
						eigenVectors.At(n, l, eigenVectors.At(n, l) - zero * matrixA[k, n].Conjugate());
					}
				}
			}
		}

		private static void NonsymmetricReduceToHessenberg(Matrix<MathNet.Numerics.Complex32> eigenVectors, MathNet.Numerics.Complex32[,] matrixH, int order)
		{
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[order];
			for (int i = 1; i < order - 1; i++)
			{
				float num = 0f;
				for (int j = i; j < order; j++)
				{
					num += Math.Abs(matrixH[j, i - 1].Real) + Math.Abs(matrixH[j, i - 1].Imaginary);
				}
				if (num == 0f)
				{
					continue;
				}
				float num2 = 0f;
				for (int num3 = order - 1; num3 >= i; num3--)
				{
					array[num3] = matrixH[num3, i - 1] / num;
					num2 += array[num3].MagnitudeSquared;
				}
				float num4 = (float)Math.Sqrt(num2);
				if (array[i].Magnitude != 0f)
				{
					num2 += array[i].Magnitude * num4;
					num4 /= array[i].Magnitude;
					array[i] = (1f + num4) * array[i];
				}
				else
				{
					array[i] = num4;
					matrixH[i, i - 1] = num;
				}
				for (int k = i; k < order; k++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int num5 = order - 1; num5 >= i; num5--)
					{
						zero += array[num5].Conjugate() * matrixH[num5, k];
					}
					zero /= num2;
					for (int l = i; l < order; l++)
					{
						matrixH[l, k] -= zero * array[l];
					}
				}
				for (int m = 0; m < order; m++)
				{
					MathNet.Numerics.Complex32 zero2 = MathNet.Numerics.Complex32.Zero;
					for (int num6 = order - 1; num6 >= i; num6--)
					{
						zero2 += array[num6] * matrixH[m, num6];
					}
					zero2 /= num2;
					for (int n = i; n < order; n++)
					{
						matrixH[m, n] -= zero2 * array[n].Conjugate();
					}
				}
				array[i] = num * array[i];
				matrixH[i, i - 1] *= 0f - num4;
			}
			for (int num7 = 0; num7 < order; num7++)
			{
				for (int num8 = 0; num8 < order; num8++)
				{
					eigenVectors.At(num7, num8, (num7 == num8) ? MathNet.Numerics.Complex32.One : MathNet.Numerics.Complex32.Zero);
				}
			}
			for (int num9 = order - 2; num9 >= 1; num9--)
			{
				if (matrixH[num9, num9 - 1] != MathNet.Numerics.Complex32.Zero && array[num9] != MathNet.Numerics.Complex32.Zero)
				{
					float num10 = matrixH[num9, num9 - 1].Real * array[num9].Real + matrixH[num9, num9 - 1].Imaginary * array[num9].Imaginary;
					for (int num11 = num9 + 1; num11 < order; num11++)
					{
						array[num11] = matrixH[num11, num9 - 1];
					}
					for (int num12 = num9; num12 < order; num12++)
					{
						MathNet.Numerics.Complex32 zero3 = MathNet.Numerics.Complex32.Zero;
						for (int num13 = num9; num13 < order; num13++)
						{
							zero3 += array[num13].Conjugate() * eigenVectors.At(num13, num12);
						}
						zero3 /= num10;
						for (int num14 = num9; num14 < order; num14++)
						{
							eigenVectors.At(num14, num12, eigenVectors.At(num14, num12) + zero3 * array[num14]);
						}
					}
				}
			}
			for (int num15 = 1; num15 < order; num15++)
			{
				if (matrixH[num15, num15 - 1].Imaginary != 0f)
				{
					MathNet.Numerics.Complex32 complex = matrixH[num15, num15 - 1] / matrixH[num15, num15 - 1].Magnitude;
					matrixH[num15, num15 - 1] = matrixH[num15, num15 - 1].Magnitude;
					for (int num16 = num15; num16 < order; num16++)
					{
						matrixH[num15, num16] *= complex.Conjugate();
					}
					for (int num17 = 0; num17 <= Math.Min(num15 + 1, order - 1); num17++)
					{
						matrixH[num17, num15] *= complex;
					}
					for (int num18 = 0; num18 < order; num18++)
					{
						eigenVectors.At(num18, num15, eigenVectors.At(num18, num15) * complex);
					}
				}
			}
		}

		private static void NonsymmetricReduceHessenberToRealSchur(Matrix<MathNet.Numerics.Complex32> eigenVectors, Vector<System.Numerics.Complex> eigenValues, MathNet.Numerics.Complex32[,] matrixH, int order)
		{
			int num = order - 1;
			float num2 = (float)Precision.SinglePrecision;
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			int num3 = 0;
			float num6;
			while (num >= 0)
			{
				int num4;
				for (num4 = num; num4 > 0; num4--)
				{
					float num5 = Math.Abs(matrixH[num4 - 1, num4 - 1].Real) + Math.Abs(matrixH[num4 - 1, num4 - 1].Imaginary) + Math.Abs(matrixH[num4, num4].Real) + Math.Abs(matrixH[num4, num4].Imaginary);
					if (Math.Abs(matrixH[num4, num4 - 1].Real) < num2 * num5)
					{
						break;
					}
				}
				if (num4 == num)
				{
					matrixH[num, num] += zero;
					eigenValues[num] = matrixH[num, num].ToComplex();
					num--;
					num3 = 0;
					continue;
				}
				MathNet.Numerics.Complex32 complex;
				if (num3 != 10 && num3 != 20)
				{
					complex = matrixH[num, num];
					MathNet.Numerics.Complex32 complex2 = matrixH[num - 1, num] * matrixH[num, num - 1].Real;
					if (complex2.Real != 0f || complex2.Imaginary != 0f)
					{
						MathNet.Numerics.Complex32 complex3 = (matrixH[num - 1, num - 1] - complex) / 2f;
						MathNet.Numerics.Complex32 complex4 = (complex3 * complex3 + complex2).SquareRoot();
						if (complex3.Real * complex4.Real + complex3.Imaginary * complex4.Imaginary < 0f)
						{
							complex4 *= -1f;
						}
						complex2 /= complex3 + complex4;
						complex -= complex2;
					}
				}
				else
				{
					complex = Math.Abs(matrixH[num, num - 1].Real) + Math.Abs(matrixH[num - 1, num - 2].Real);
				}
				for (int i = 0; i <= num; i++)
				{
					matrixH[i, i] -= complex;
				}
				zero += complex;
				num3++;
				for (int j = num4 + 1; j <= num; j++)
				{
					complex = matrixH[j, j - 1].Real;
					num6 = SpecialFunctions.Hypotenuse(matrixH[j - 1, j - 1].Magnitude, complex.Real);
					MathNet.Numerics.Complex32 complex2 = matrixH[j - 1, j - 1] / num6;
					eigenValues[j - 1] = complex2.ToComplex();
					matrixH[j - 1, j - 1] = num6;
					matrixH[j, j - 1] = new MathNet.Numerics.Complex32(0f, complex.Real / num6);
					for (int k = j; k < order; k++)
					{
						MathNet.Numerics.Complex32 complex3 = matrixH[j - 1, k];
						MathNet.Numerics.Complex32 complex4 = matrixH[j, k];
						matrixH[j - 1, k] = complex2.Conjugate() * complex3 + matrixH[j, j - 1].Imaginary * complex4;
						matrixH[j, k] = complex2 * complex4 - matrixH[j, j - 1].Imaginary * complex3;
					}
				}
				complex = matrixH[num, num];
				if (complex.Imaginary != 0f)
				{
					complex /= matrixH[num, num].Magnitude;
					matrixH[num, num] = matrixH[num, num].Magnitude;
					for (int l = num + 1; l < order; l++)
					{
						matrixH[num, l] *= complex.Conjugate();
					}
				}
				for (int m = num4 + 1; m <= num; m++)
				{
					MathNet.Numerics.Complex32 complex2 = (MathNet.Numerics.Complex32)eigenValues[m - 1];
					for (int n = 0; n <= m; n++)
					{
						MathNet.Numerics.Complex32 complex4 = matrixH[n, m];
						MathNet.Numerics.Complex32 complex3;
						if (n != m)
						{
							complex3 = matrixH[n, m - 1];
							matrixH[n, m - 1] = complex2 * complex3 + matrixH[m, m - 1].Imaginary * complex4;
						}
						else
						{
							complex3 = matrixH[n, m - 1].Real;
							matrixH[n, m - 1] = new MathNet.Numerics.Complex32(complex2.Real * complex3.Real - complex2.Imaginary * complex3.Imaginary + matrixH[m, m - 1].Imaginary * complex4.Real, matrixH[n, m - 1].Imaginary);
						}
						matrixH[n, m] = complex2.Conjugate() * complex4 - matrixH[m, m - 1].Imaginary * complex3;
					}
					for (int num7 = 0; num7 < order; num7++)
					{
						MathNet.Numerics.Complex32 complex3 = eigenVectors.At(num7, m - 1);
						MathNet.Numerics.Complex32 complex4 = eigenVectors.At(num7, m);
						eigenVectors.At(num7, m - 1, complex2 * complex3 + matrixH[m, m - 1].Imaginary * complex4);
						eigenVectors.At(num7, m, complex2.Conjugate() * complex4 - matrixH[m, m - 1].Imaginary * complex3);
					}
				}
				if (complex.Imaginary != 0f)
				{
					for (int num8 = 0; num8 <= num; num8++)
					{
						matrixH[num8, num] *= complex;
					}
					for (int num9 = 0; num9 < order; num9++)
					{
						eigenVectors.At(num9, num, eigenVectors.At(num9, num) * complex);
					}
				}
			}
			num6 = 0f;
			for (int num10 = 0; num10 < order; num10++)
			{
				for (int num11 = num10; num11 < order; num11++)
				{
					num6 = Math.Max(num6, Math.Abs(matrixH[num10, num11].Real) + Math.Abs(matrixH[num10, num11].Imaginary));
				}
			}
			if (order == 1 || num6 == 0f)
			{
				return;
			}
			for (num = order - 1; num > 0; num--)
			{
				MathNet.Numerics.Complex32 complex2 = (MathNet.Numerics.Complex32)eigenValues[num];
				matrixH[num, num] = 1f;
				for (int num12 = num - 1; num12 >= 0; num12--)
				{
					MathNet.Numerics.Complex32 complex4 = 0f;
					for (int num13 = num12 + 1; num13 <= num; num13++)
					{
						complex4 += matrixH[num12, num13] * matrixH[num13, num];
					}
					MathNet.Numerics.Complex32 complex3 = complex2 - (MathNet.Numerics.Complex32)eigenValues[num12];
					if (complex3.Real == 0f && complex3.Imaginary == 0f)
					{
						complex3 = num2 * num6;
					}
					matrixH[num12, num] = complex4 / complex3;
					float num14 = Math.Abs(matrixH[num12, num].Real) + Math.Abs(matrixH[num12, num].Imaginary);
					if (num2 * num14 * num14 > 1f)
					{
						for (int num15 = num12; num15 <= num; num15++)
						{
							matrixH[num15, num] /= num14;
						}
					}
				}
			}
			for (int num16 = order - 1; num16 > 0; num16--)
			{
				for (int num17 = 0; num17 < order; num17++)
				{
					MathNet.Numerics.Complex32 complex4 = MathNet.Numerics.Complex32.Zero;
					for (int num18 = 0; num18 <= num16; num18++)
					{
						complex4 += eigenVectors.At(num17, num18) * matrixH[num18, num16];
					}
					eigenVectors.At(num17, num16, complex4);
				}
			}
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						MathNet.Numerics.Complex32 complex = 0f;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								complex += base.EigenVectors.At(k, j).Conjugate() * input.At(k, i);
							}
							complex /= (float)base.EigenValues[j].Real;
						}
						array[j] = complex;
					}
					for (int l = 0; l < count; l++)
					{
						MathNet.Numerics.Complex32 value = 0f;
						for (int m = 0; m < count; m++)
						{
							value += base.EigenVectors.At(l, m) * array[m];
						}
						result.At(l, i, value);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[count];
				for (int i = 0; i < count; i++)
				{
					MathNet.Numerics.Complex32 complex = 0;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							complex += base.EigenVectors.At(j, i).Conjugate() * input[j];
						}
						complex /= (float)base.EigenValues[i].Real;
					}
					array[i] = complex;
				}
				for (int k = 0; k < count; k++)
				{
					MathNet.Numerics.Complex32 complex = 0;
					for (int l = 0; l < count; l++)
					{
						complex += base.EigenVectors.At(k, l) * array[l];
					}
					result[k] = complex;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class UserGramSchmidt : GramSchmidt
	{
		public static UserGramSchmidt Create(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			Matrix<MathNet.Numerics.Complex32> matrix2 = matrix.Clone();
			Matrix<MathNet.Numerics.Complex32> matrix3 = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(matrix, matrix.ColumnCount, matrix.ColumnCount, fullyMutable: true);
			for (int i = 0; i < matrix2.ColumnCount; i++)
			{
				float num = (float)matrix2.Column(i).L2Norm();
				if (num == 0f)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				matrix3.At(i, i, num);
				for (int j = 0; j < matrix2.RowCount; j++)
				{
					matrix2.At(j, i, matrix2.At(j, i) / num);
				}
				for (int k = i + 1; k < matrix2.ColumnCount; k++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						zero += matrix2.Column(i)[l].Conjugate() * matrix2.Column(k)[l];
					}
					matrix3.At(i, k, zero);
					for (int m = 0; m < matrix2.RowCount; m++)
					{
						MathNet.Numerics.Complex32 value = matrix2.At(m, k) - matrix2.At(m, i) * zero;
						matrix2.At(m, k, value);
					}
				}
			}
			return new UserGramSchmidt(matrix2, matrix3);
		}

		private UserGramSchmidt(Matrix<MathNet.Numerics.Complex32> q, Matrix<MathNet.Numerics.Complex32> rFull)
			: base(q, rFull)
		{
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<MathNet.Numerics.Complex32> matrix = input.Clone();
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.Q.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < base.Q.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < base.Q.ColumnCount; k++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int l = 0; l < base.Q.RowCount; l++)
					{
						zero += base.Q.At(l, k).Conjugate() * array[l];
					}
					matrix.At(k, i, zero);
				}
			}
			for (int num = base.Q.ColumnCount - 1; num >= 0; num--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num, m, matrix.At(num, m) / FullR.At(num, num));
				}
				for (int n = 0; n < num; n++)
				{
					for (int num2 = 0; num2 < input.ColumnCount; num2++)
					{
						matrix.At(n, num2, matrix.At(n, num2) - matrix.At(num, num2) * FullR.At(n, num));
					}
				}
			}
			for (int num3 = 0; num3 < FullR.ColumnCount; num3++)
			{
				for (int num4 = 0; num4 < input.ColumnCount; num4++)
				{
					result.At(num3, num4, matrix.At(num3, num4));
				}
			}
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			Vector<MathNet.Numerics.Complex32> vector = input.Clone();
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.Q.RowCount];
			for (int i = 0; i < base.Q.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < base.Q.ColumnCount; j++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int k = 0; k < base.Q.RowCount; k++)
				{
					zero += base.Q.At(k, j).Conjugate() * array[k];
				}
				vector[j] = zero;
			}
			for (int num = base.Q.ColumnCount - 1; num >= 0; num--)
			{
				vector[num] /= FullR.At(num, num);
				for (int l = 0; l < num; l++)
				{
					vector[l] -= vector[num] * FullR.At(l, num);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserLU : LU
	{
		public static UserLU Create(Matrix<MathNet.Numerics.Complex32> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			Matrix<MathNet.Numerics.Complex32> matrix2 = matrix.Clone();
			int[] array = new int[rowCount];
			for (int i = 0; i < rowCount; i++)
			{
				array[i] = i;
			}
			MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[rowCount];
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = 0; k < rowCount; k++)
				{
					array2[k] = matrix2.At(k, j);
				}
				for (int l = 0; l < rowCount; l++)
				{
					int num = Math.Min(l, j);
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int m = 0; m < num; m++)
					{
						zero += matrix2.At(l, m) * array2[m];
					}
					array2[l] -= zero;
					matrix2.At(l, j, array2[l]);
				}
				int num2 = j;
				for (int n = j + 1; n < rowCount; n++)
				{
					if (array2[n].Magnitude > array2[num2].Magnitude)
					{
						num2 = n;
					}
				}
				if (num2 != j)
				{
					for (int num3 = 0; num3 < rowCount; num3++)
					{
						MathNet.Numerics.Complex32 value = matrix2.At(num2, num3);
						matrix2.At(num2, num3, matrix2.At(j, num3));
						matrix2.At(j, num3, value);
					}
					array[j] = num2;
				}
				if ((j < rowCount) & (matrix2.At(j, j) != 0f))
				{
					for (int num4 = j + 1; num4 < rowCount; num4++)
					{
						matrix2.At(num4, j, matrix2.At(num4, j) / matrix2.At(j, j));
					}
				}
			}
			return new UserLU(matrix2, array);
		}

		private UserLU(Matrix<MathNet.Numerics.Complex32> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int row = Pivots[i];
					for (int j = 0; j < result.ColumnCount; j++)
					{
						MathNet.Numerics.Complex32 value = result.At(row, j);
						result.At(row, j, result.At(i, j));
						result.At(i, j, value);
					}
				}
			}
			int rowCount = Factors.RowCount;
			for (int k = 0; k < rowCount; k++)
			{
				for (int l = k + 1; l < rowCount; l++)
				{
					for (int m = 0; m < result.ColumnCount; m++)
					{
						MathNet.Numerics.Complex32 complex = result.At(k, m) * Factors.At(l, k);
						result.At(l, m, result.At(l, m) - complex);
					}
				}
			}
			for (int num = rowCount - 1; num >= 0; num--)
			{
				for (int n = 0; n < result.ColumnCount; n++)
				{
					result.At(num, n, result.At(num, n) / Factors.At(num, num));
				}
				for (int num2 = 0; num2 < num; num2++)
				{
					for (int num3 = 0; num3 < result.ColumnCount; num3++)
					{
						MathNet.Numerics.Complex32 complex2 = result.At(num, num3) * Factors.At(num2, num);
						result.At(num2, num3, result.At(num2, num3) - complex2);
					}
				}
			}
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int index = Pivots[i];
					MathNet.Numerics.Complex32 value = result[index];
					result[index] = result[i];
					result[i] = value;
				}
			}
			int rowCount = Factors.RowCount;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = j + 1; k < rowCount; k++)
				{
					result[k] -= result[j] * Factors.At(k, j);
				}
			}
			for (int num = rowCount - 1; num >= 0; num--)
			{
				result[num] /= Factors.At(num, num);
				for (int l = 0; l < num; l++)
				{
					result[l] -= result[num] * Factors.At(l, num);
				}
			}
		}

		public override Matrix<MathNet.Numerics.Complex32> Inverse()
		{
			int rowCount = Factors.RowCount;
			Matrix<MathNet.Numerics.Complex32> matrix = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(Factors, rowCount, rowCount);
			for (int i = 0; i < rowCount; i++)
			{
				matrix.At(i, i, 1f);
			}
			return Solve(matrix);
		}
	}
	internal sealed class UserQR : QR
	{
		public static UserQR Create(Matrix<MathNet.Numerics.Complex32> matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			int num = Math.Min(matrix.RowCount, matrix.ColumnCount);
			MathNet.Numerics.Complex32[][] array = new MathNet.Numerics.Complex32[num][];
			Matrix<MathNet.Numerics.Complex32> matrix2;
			Matrix<MathNet.Numerics.Complex32> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(matrix, matrix.RowCount, matrix.RowCount, fullyMutable: true);
				for (int i = 0; i < matrix.RowCount; i++)
				{
					matrix3.At(i, i, 1f);
				}
				for (int j = 0; j < num; j++)
				{
					array[j] = GenerateColumn(matrix2, j, j);
					ComputeQR(array[j], matrix2, j, matrix.RowCount, j + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					ComputeQR(array[num2], matrix3, num2, matrix.RowCount, num2, matrix.RowCount, Control.MaxDegreeOfParallelism);
				}
			}
			else
			{
				matrix3 = matrix.Clone();
				for (int k = 0; k < num; k++)
				{
					array[k] = GenerateColumn(matrix3, k, k);
					ComputeQR(array[k], matrix3, k, matrix.RowCount, k + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				matrix2 = matrix3.SubMatrix(0, matrix.ColumnCount, 0, matrix.ColumnCount);
				matrix3.Clear();
				for (int l = 0; l < matrix.ColumnCount; l++)
				{
					matrix3.At(l, l, 1f);
				}
				for (int num3 = num - 1; num3 >= 0; num3--)
				{
					ComputeQR(array[num3], matrix3, num3, matrix.RowCount, num3, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
			}
			return new UserQR(matrix3, matrix2, method);
		}

		private UserQR(Matrix<MathNet.Numerics.Complex32> q, Matrix<MathNet.Numerics.Complex32> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}

		private static MathNet.Numerics.Complex32[] GenerateColumn(Matrix<MathNet.Numerics.Complex32> a, int row, int column)
		{
			int num = a.RowCount - row;
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[num];
			for (int i = row; i < a.RowCount; i++)
			{
				array[i - row] = a.At(i, column);
				a.At(i, column, 0f);
			}
			MathNet.Numerics.Complex32 complex = array.Aggregate(MathNet.Numerics.Complex32.Zero, (MathNet.Numerics.Complex32 current, MathNet.Numerics.Complex32 t) => current + t.Magnitude * t.Magnitude).SquareRoot();
			if (row == a.RowCount - 1 || complex.Magnitude == 0f)
			{
				a.At(row, column, -array[0]);
				array[0] = 1.4142135f;
				return array;
			}
			if (array[0].Magnitude != 0f)
			{
				complex = complex.Magnitude * (array[0] / array[0].Magnitude);
			}
			a.At(row, column, -complex);
			for (int j = 0; j < num; j++)
			{
				array[j] /= complex;
			}
			array[0] += 1f;
			MathNet.Numerics.Complex32 complex2 = (1f / array[0]).SquareRoot();
			for (int k = 0; k < num; k++)
			{
				array[k] = array[k].Conjugate() * complex2;
			}
			return array;
		}

		private static void ComputeQR(MathNet.Numerics.Complex32[] u, Matrix<MathNet.Numerics.Complex32> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores)
		{
			if (rowDim < rowStart || columnDim < columnStart)
			{
				return;
			}
			int num = columnDim - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(u, a, rowStart, rowDim, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(u, a, rowStart, rowDim, tmpSplit, columnDim, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnDim; i++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int j = rowStart; j < rowDim; j++)
				{
					zero += u[j - rowStart] * a.At(j, i);
				}
				for (int k = rowStart; k < rowDim; k++)
				{
					a.At(k, i, a.At(k, i) - u[k - rowStart].Conjugate() * zero);
				}
			}
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (FullR.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<MathNet.Numerics.Complex32> matrix = input.Clone();
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[FullR.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < FullR.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < FullR.RowCount; k++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					for (int l = 0; l < FullR.RowCount; l++)
					{
						zero += base.Q.At(l, k).Conjugate() * array[l];
					}
					matrix.At(k, i, zero);
				}
			}
			for (int num = FullR.ColumnCount - 1; num >= 0; num--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num, m, matrix.At(num, m) / FullR.At(num, num));
				}
				for (int n = 0; n < num; n++)
				{
					for (int num2 = 0; num2 < input.ColumnCount; num2++)
					{
						matrix.At(n, num2, matrix.At(n, num2) - matrix.At(num, num2) * FullR.At(n, num));
					}
				}
			}
			for (int num3 = 0; num3 < FullR.ColumnCount; num3++)
			{
				for (int num4 = 0; num4 < matrix.ColumnCount; num4++)
				{
					result.At(num3, num4, matrix.At(num3, num4));
				}
			}
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (FullR.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			Vector<MathNet.Numerics.Complex32> vector = input.Clone();
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[FullR.RowCount];
			for (int i = 0; i < FullR.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < FullR.RowCount; j++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				for (int k = 0; k < FullR.RowCount; k++)
				{
					zero += base.Q.At(k, j).Conjugate() * array[k];
				}
				vector[j] = zero;
			}
			for (int num = FullR.ColumnCount - 1; num >= 0; num--)
			{
				vector[num] /= FullR.At(num, num);
				for (int l = 0; l < num; l++)
				{
					vector[l] -= vector[num] * FullR.At(l, num);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserSvd : Svd
	{
		public static UserSvd Create(Matrix<MathNet.Numerics.Complex32> matrix, bool computeVectors)
		{
			int num = Math.Min(matrix.RowCount + 1, matrix.ColumnCount);
			Matrix<MathNet.Numerics.Complex32> matrix2 = matrix.Clone();
			Vector<MathNet.Numerics.Complex32> vector = Vector<MathNet.Numerics.Complex32>.Build.SameAs(matrix2, num);
			Matrix<MathNet.Numerics.Complex32> matrix3 = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(matrix2, matrix2.RowCount, matrix2.RowCount, fullyMutable: true);
			Matrix<MathNet.Numerics.Complex32> matrix4 = Matrix<MathNet.Numerics.Complex32>.Build.SameAs(matrix2, matrix2.ColumnCount, matrix2.ColumnCount, fullyMutable: true);
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[matrix2.ColumnCount];
			MathNet.Numerics.Complex32[] array2 = new MathNet.Numerics.Complex32[matrix2.RowCount];
			int rowCount = matrix2.RowCount;
			int num2 = Math.Min(matrix2.RowCount - 1, matrix2.ColumnCount);
			int num3 = Math.Max(0, Math.Min(matrix2.ColumnCount - 2, matrix2.RowCount));
			int num4 = Math.Max(num2, num3);
			for (int i = 0; i < num4; i++)
			{
				int num5 = i + 1;
				if (i < num2)
				{
					vector[i] = Cnrm2Column(matrix2, matrix2.RowCount, i, i);
					if (vector[i].Magnitude != 0f)
					{
						if (matrix2.At(i, i).Magnitude != 0f)
						{
							vector[i] = Csign(vector[i], matrix2.At(i, i));
						}
						CscalColumn(matrix2, matrix2.RowCount, i, i, 1f / vector[i]);
						matrix2.At(i, i, MathNet.Numerics.Complex32.One + matrix2.At(i, i));
					}
					vector[i] = -vector[i];
				}
				for (int j = num5; j < matrix2.ColumnCount; j++)
				{
					if (i < num2 && vector[i].Magnitude != 0f)
					{
						MathNet.Numerics.Complex32 complex = -Cdotc(matrix2, matrix2.RowCount, i, j, i) / matrix2.At(i, i);
						if (complex != MathNet.Numerics.Complex32.Zero)
						{
							for (int k = i; k < matrix2.RowCount; k++)
							{
								matrix2.At(k, j, matrix2.At(k, j) + complex * matrix2.At(k, i));
							}
						}
					}
					array[j] = matrix2.At(i, j).Conjugate();
				}
				if (computeVectors && i < num2)
				{
					for (int l = i; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, i, matrix2.At(l, i));
					}
				}
				if (i >= num3)
				{
					continue;
				}
				float num6 = Cnrm2Vector(array, num5);
				array[i] = num6;
				if (array[i].Magnitude != 0f)
				{
					if (array[num5].Magnitude != 0f)
					{
						array[i] = Csign(array[i], array[num5]);
					}
					CscalVector(array, num5, 1f / array[i]);
					array[num5] = MathNet.Numerics.Complex32.One + array[num5];
				}
				array[i] = -array[i].Conjugate();
				if (num5 < matrix2.RowCount && array[i].Magnitude != 0f)
				{
					for (int l = num5; l < matrix2.RowCount; l++)
					{
						array2[l] = MathNet.Numerics.Complex32.Zero;
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						if (array[j] != MathNet.Numerics.Complex32.Zero)
						{
							for (int m = num5; m < matrix2.RowCount; m++)
							{
								array2[m] += array[j] * matrix2.At(m, j);
							}
						}
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						MathNet.Numerics.Complex32 complex2 = (-array[j] / array[num5]).Conjugate();
						if (complex2 != MathNet.Numerics.Complex32.Zero)
						{
							for (int n = num5; n < matrix2.RowCount; n++)
							{
								matrix2.At(n, j, matrix2.At(n, j) + complex2 * array2[n]);
							}
						}
					}
				}
				if (computeVectors)
				{
					for (int l = num5; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, array[l]);
					}
				}
			}
			int num7 = Math.Min(matrix2.ColumnCount, matrix2.RowCount + 1);
			int num8 = num2 + 1;
			int num9 = num3 + 1;
			if (num2 < matrix2.ColumnCount)
			{
				vector[num8 - 1] = matrix2.At(num8 - 1, num8 - 1);
			}
			if (matrix2.RowCount < num7)
			{
				vector[num7 - 1] = MathNet.Numerics.Complex32.Zero;
			}
			if (num9 < num7)
			{
				array[num9 - 1] = matrix2.At(num9 - 1, num7 - 1);
			}
			array[num7 - 1] = MathNet.Numerics.Complex32.Zero;
			if (computeVectors)
			{
				for (int j = num8 - 1; j < rowCount; j++)
				{
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, j, MathNet.Numerics.Complex32.Zero);
					}
					matrix3.At(j, j, MathNet.Numerics.Complex32.One);
				}
				for (int i = num2 - 1; i >= 0; i--)
				{
					if (vector[i].Magnitude != 0f)
					{
						for (int j = i + 1; j < rowCount; j++)
						{
							MathNet.Numerics.Complex32 complex = -Cdotc(matrix3, matrix2.RowCount, i, j, i) / matrix3.At(i, i);
							if (complex != MathNet.Numerics.Complex32.Zero)
							{
								for (int num10 = i; num10 < matrix2.RowCount; num10++)
								{
									matrix3.At(num10, j, matrix3.At(num10, j) + complex * matrix3.At(num10, i));
								}
							}
						}
						CscalColumn(matrix3, matrix2.RowCount, i, i, -1f);
						matrix3.At(i, i, MathNet.Numerics.Complex32.One + matrix3.At(i, i));
						for (int l = 0; l < i; l++)
						{
							matrix3.At(l, i, MathNet.Numerics.Complex32.Zero);
						}
					}
					else
					{
						for (int l = 0; l < matrix2.RowCount; l++)
						{
							matrix3.At(l, i, MathNet.Numerics.Complex32.Zero);
						}
						matrix3.At(i, i, MathNet.Numerics.Complex32.One);
					}
				}
			}
			if (computeVectors)
			{
				for (int i = matrix2.ColumnCount - 1; i >= 0; i--)
				{
					int num5 = i + 1;
					if (i < num3 && array[i].Magnitude != 0f)
					{
						for (int j = num5; j < matrix2.ColumnCount; j++)
						{
							MathNet.Numerics.Complex32 complex = -Cdotc(matrix4, matrix2.ColumnCount, i, j, num5) / matrix4.At(num5, i);
							if (complex != MathNet.Numerics.Complex32.Zero)
							{
								for (int num11 = i; num11 < matrix2.ColumnCount; num11++)
								{
									matrix4.At(num11, j, matrix4.At(num11, j) + complex * matrix4.At(num11, i));
								}
							}
						}
					}
					for (int l = 0; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, MathNet.Numerics.Complex32.Zero);
					}
					matrix4.At(i, i, MathNet.Numerics.Complex32.One);
				}
			}
			for (int l = 0; l < num7; l++)
			{
				if (vector[l].Magnitude != 0f)
				{
					MathNet.Numerics.Complex32 complex = vector[l].Magnitude;
					MathNet.Numerics.Complex32 complex3 = vector[l] / complex;
					vector[l] = complex;
					if (l < num7 - 1)
					{
						array[l] /= complex3;
					}
					if (computeVectors)
					{
						CscalColumn(matrix3, matrix2.RowCount, l, 0, complex3);
					}
				}
				if (l == num7 - 1)
				{
					break;
				}
				if (array[l].Magnitude != 0f)
				{
					MathNet.Numerics.Complex32 complex = array[l].Magnitude;
					MathNet.Numerics.Complex32 complex3 = complex / array[l];
					array[l] = complex;
					vector[l + 1] *= complex3;
					if (computeVectors)
					{
						CscalColumn(matrix4, matrix2.ColumnCount, l + 1, 0, complex3);
					}
				}
			}
			int num12 = num7;
			int num13 = 0;
			while (num7 > 0)
			{
				if (num13 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num7 - 2; i >= 0; i--)
				{
					float num14 = vector[i].Magnitude + vector[i + 1].Magnitude;
					if ((num14 + array[i].Magnitude).AlmostEqualRelative(num14, 7))
					{
						array[i] = MathNet.Numerics.Complex32.Zero;
						break;
					}
				}
				int num15;
				if (i == num7 - 2)
				{
					num15 = 4;
				}
				else
				{
					int num16;
					for (num16 = num7 - 1; num16 > i; num16--)
					{
						float num14 = 0f;
						if (num16 != num7 - 1)
						{
							num14 += array[num16].Magnitude;
						}
						if (num16 != i + 1)
						{
							num14 += array[num16 - 1].Magnitude;
						}
						if ((num14 + vector[num16].Magnitude).AlmostEqualRelative(num14, 7))
						{
							vector[num16] = MathNet.Numerics.Complex32.Zero;
							break;
						}
					}
					if (num16 == i)
					{
						num15 = 3;
					}
					else if (num16 == num7 - 1)
					{
						num15 = 1;
					}
					else
					{
						num15 = 2;
						i = num16;
					}
				}
				i++;
				float c;
				float s;
				switch (num15)
				{
				case 1:
				{
					float da = array[num7 - 2].Real;
					array[num7 - 2] = MathNet.Numerics.Complex32.Zero;
					for (int num26 = i; num26 < num7 - 1; num26++)
					{
						int num25 = num7 - 2 - num26 + i;
						float da2 = vector[num25].Real;
						Srotg(ref da2, ref da, out c, out s);
						vector[num25] = da2;
						if (num25 != i)
						{
							da = (0f - s) * array[num25 - 1].Real;
							array[num25 - 1] = c * array[num25 - 1];
						}
						if (computeVectors)
						{
							Csrot(matrix4, matrix2.ColumnCount, num25, num7 - 1, c, s);
						}
					}
					break;
				}
				case 2:
				{
					float da = array[i - 1].Real;
					array[i - 1] = MathNet.Numerics.Complex32.Zero;
					for (int num25 = i; num25 < num7; num25++)
					{
						float da2 = vector[num25].Real;
						Srotg(ref da2, ref da, out c, out s);
						vector[num25] = da2;
						da = (0f - s) * array[num25].Real;
						array[num25] = c * array[num25];
						if (computeVectors)
						{
							Csrot(matrix3, matrix2.RowCount, num25, i - 1, c, s);
						}
					}
					break;
				}
				case 3:
				{
					float val = 0f;
					val = Math.Max(val, vector[num7 - 1].Magnitude);
					val = Math.Max(val, vector[num7 - 2].Magnitude);
					val = Math.Max(val, array[num7 - 2].Magnitude);
					val = Math.Max(val, vector[i].Magnitude);
					val = Math.Max(val, array[i].Magnitude);
					float num17 = vector[num7 - 1].Real / val;
					float num18 = vector[num7 - 2].Real / val;
					float num19 = array[num7 - 2].Real / val;
					float num20 = vector[i].Real / val;
					float num21 = array[i].Real / val;
					float num22 = ((num18 + num17) * (num18 - num17) + num19 * num19) / 2f;
					float num23 = num17 * num19 * (num17 * num19);
					float num24 = 0f;
					if (num22 != 0f || num23 != 0f)
					{
						num24 = (float)Math.Sqrt(num22 * num22 + num23);
						if (num22 < 0f)
						{
							num24 = 0f - num24;
						}
						num24 = num23 / (num22 + num24);
					}
					float da = (num20 + num17) * (num20 - num17) + num24;
					float db = num20 * num21;
					for (int num25 = i; num25 < num7 - 1; num25++)
					{
						Srotg(ref da, ref db, out c, out s);
						if (num25 != i)
						{
							array[num25 - 1] = da;
						}
						da = c * vector[num25].Real + s * array[num25].Real;
						array[num25] = c * array[num25] - s * vector[num25];
						db = s * vector[num25 + 1].Real;
						vector[num25 + 1] = c * vector[num25 + 1];
						if (computeVectors)
						{
							Csrot(matrix4, matrix2.ColumnCount, num25, num25 + 1, c, s);
						}
						Srotg(ref da, ref db, out c, out s);
						vector[num25] = da;
						da = c * array[num25].Real + s * vector[num25 + 1].Real;
						vector[num25 + 1] = (0f - s) * array[num25] + c * vector[num25 + 1];
						db = s * array[num25 + 1].Real;
						array[num25 + 1] = c * array[num25 + 1];
						if (computeVectors && num25 < matrix2.RowCount)
						{
							Csrot(matrix3, matrix2.RowCount, num25, num25 + 1, c, s);
						}
					}
					array[num7 - 2] = da;
					num13++;
					break;
				}
				case 4:
					if (vector[i].Real < 0f)
					{
						vector[i] = -vector[i];
						if (computeVectors)
						{
							CscalColumn(matrix4, matrix2.ColumnCount, i, 0, -1f);
						}
					}
					for (; i != num12 - 1 && !(vector[i].Real >= vector[i + 1].Real); i++)
					{
						MathNet.Numerics.Complex32 complex = vector[i];
						vector[i] = vector[i + 1];
						vector[i + 1] = complex;
						if (computeVectors && i < matrix2.ColumnCount)
						{
							Swap(matrix4, matrix2.ColumnCount, i, i + 1);
						}
						if (computeVectors && i < matrix2.RowCount)
						{
							Swap(matrix3, matrix2.RowCount, i, i + 1);
						}
					}
					num13 = 0;
					num7--;
					break;
				}
			}
			if (computeVectors)
			{
				matrix4 = matrix4.ConjugateTranspose();
			}
			if (matrix2.RowCount < matrix2.ColumnCount)
			{
				num--;
				Vector<MathNet.Numerics.Complex32> vector2 = Vector<MathNet.Numerics.Complex32>.Build.SameAs(matrix2, num);
				for (int l = 0; l < num; l++)
				{
					vector2[l] = vector[l];
				}
				vector = vector2;
			}
			return new UserSvd(vector, matrix3, matrix4, computeVectors);
		}

		private UserSvd(Vector<MathNet.Numerics.Complex32> s, Matrix<MathNet.Numerics.Complex32> u, Matrix<MathNet.Numerics.Complex32> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		private static MathNet.Numerics.Complex32 Csign(MathNet.Numerics.Complex32 z1, MathNet.Numerics.Complex32 z2)
		{
			return z1.Magnitude * (z2 / z2.Magnitude);
		}

		private static void Swap(Matrix<MathNet.Numerics.Complex32> a, int rowCount, int columnA, int columnB)
		{
			for (int i = 0; i < rowCount; i++)
			{
				MathNet.Numerics.Complex32 value = a.At(i, columnA);
				a.At(i, columnA, a.At(i, columnB));
				a.At(i, columnB, value);
			}
		}

		private static void CscalColumn(Matrix<MathNet.Numerics.Complex32> a, int rowCount, int column, int rowStart, MathNet.Numerics.Complex32 z)
		{
			for (int i = rowStart; i < rowCount; i++)
			{
				a.At(i, column, a.At(i, column) * z);
			}
		}

		private static void CscalVector(MathNet.Numerics.Complex32[] a, int start, MathNet.Numerics.Complex32 z)
		{
			for (int i = start; i < a.Length; i++)
			{
				a[i] *= z;
			}
		}

		private static void Srotg(ref float da, ref float db, out float c, out float s)
		{
			float num = db;
			float num2 = Math.Abs(da);
			float num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			float num4 = num2 + num3;
			float num5;
			float num6;
			if (num4 == 0f)
			{
				c = 1f;
				s = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				float num7 = da / num4;
				float num8 = db / num4;
				num5 = num4 * (float)Math.Sqrt(num7 * num7 + num8 * num8);
				if (num < 0f)
				{
					num5 = 0f - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1f;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && c != 0f)
				{
					num6 = 1f / c;
				}
			}
			da = num5;
			db = num6;
		}

		private static float Cnrm2Column(Matrix<MathNet.Numerics.Complex32> a, int rowCount, int column, int rowStart)
		{
			float num = 0f;
			for (int i = rowStart; i < rowCount; i++)
			{
				num += a.At(i, column).Magnitude * a.At(i, column).Magnitude;
			}
			return (float)Math.Sqrt(num);
		}

		private static float Cnrm2Vector(MathNet.Numerics.Complex32[] a, int rowStart)
		{
			float num = 0f;
			for (int i = rowStart; i < a.Length; i++)
			{
				num += a[i].Magnitude * a[i].Magnitude;
			}
			return (float)Math.Sqrt(num);
		}

		private static MathNet.Numerics.Complex32 Cdotc(Matrix<MathNet.Numerics.Complex32> a, int rowCount, int columnA, int columnB, int rowStart)
		{
			MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
			for (int i = rowStart; i < rowCount; i++)
			{
				zero += a.At(i, columnA).Conjugate() * a.At(i, columnB);
			}
			return zero;
		}

		private static void Csrot(Matrix<MathNet.Numerics.Complex32> a, int rowCount, int columnA, int columnB, float c, float s)
		{
			for (int i = 0; i < rowCount; i++)
			{
				MathNet.Numerics.Complex32 value = c * a.At(i, columnA) + s * a.At(i, columnB);
				MathNet.Numerics.Complex32 value2 = c * a.At(i, columnB) - s * a.At(i, columnA);
				a.At(i, columnB, value2);
				a.At(i, columnA, value);
			}
		}

		public override void Solve(Matrix<MathNet.Numerics.Complex32> input, Matrix<MathNet.Numerics.Complex32> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			int columnCount = input.ColumnCount;
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.VT.ColumnCount];
			for (int i = 0; i < columnCount; i++)
			{
				for (int j = 0; j < base.VT.ColumnCount; j++)
				{
					MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
					if (j < num)
					{
						for (int k = 0; k < base.U.RowCount; k++)
						{
							zero += base.U.At(k, j).Conjugate() * input.At(k, i);
						}
						zero /= base.S[j];
					}
					array[j] = zero;
				}
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					MathNet.Numerics.Complex32 zero2 = MathNet.Numerics.Complex32.Zero;
					for (int m = 0; m < base.VT.ColumnCount; m++)
					{
						zero2 += base.VT.At(m, l).Conjugate() * array[m];
					}
					result.At(l, i, zero2);
				}
			}
		}

		public override void Solve(Vector<MathNet.Numerics.Complex32> input, Vector<MathNet.Numerics.Complex32> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<MathNet.Numerics.Complex32>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			MathNet.Numerics.Complex32[] array = new MathNet.Numerics.Complex32[base.VT.ColumnCount];
			for (int i = 0; i < base.VT.ColumnCount; i++)
			{
				MathNet.Numerics.Complex32 zero = MathNet.Numerics.Complex32.Zero;
				if (i < num)
				{
					for (int j = 0; j < base.U.RowCount; j++)
					{
						zero += base.U.At(j, i).Conjugate() * input[j];
					}
					zero /= base.S[i];
				}
				array[i] = zero;
			}
			for (int k = 0; k < base.VT.ColumnCount; k++)
			{
				MathNet.Numerics.Complex32 zero2 = MathNet.Numerics.Complex32.Zero;
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					zero2 += base.VT.At(l, k).Conjugate() * array[l];
				}
				result[k] = zero2;
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Complex
{
	internal class MatrixBuilder : MatrixBuilder<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Zero => System.Numerics.Complex.Zero;

		public override System.Numerics.Complex One => System.Numerics.Complex.One;

		public override Matrix<System.Numerics.Complex> Dense(DenseColumnMajorMatrixStorage<System.Numerics.Complex> storage)
		{
			return new DenseMatrix(storage);
		}

		public override Matrix<System.Numerics.Complex> Sparse(SparseCompressedRowMatrixStorage<System.Numerics.Complex> storage)
		{
			return new SparseMatrix(storage);
		}

		public override Matrix<System.Numerics.Complex> Diagonal(DiagonalMatrixStorage<System.Numerics.Complex> storage)
		{
			return new DiagonalMatrix(storage);
		}

		public override Matrix<System.Numerics.Complex> Random(int rows, int columns, IContinuousDistribution distribution)
		{
			return Dense(rows, columns, Generate.RandomComplex(rows * columns, distribution));
		}

		public override IIterationStopCriterion<System.Numerics.Complex>[] IterativeSolverStopCriteria(int maxIterations = 1000)
		{
			return new IIterationStopCriterion<System.Numerics.Complex>[4]
			{
				new FailureStopCriterion<System.Numerics.Complex>(),
				new DivergenceStopCriterion<System.Numerics.Complex>(),
				new IterationCountStopCriterion<System.Numerics.Complex>(maxIterations),
				new ResidualStopCriterion<System.Numerics.Complex>(1E-12)
			};
		}

		internal override System.Numerics.Complex Add(System.Numerics.Complex x, System.Numerics.Complex y)
		{
			return x + y;
		}
	}
	internal class VectorBuilder : VectorBuilder<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Zero => System.Numerics.Complex.Zero;

		public override System.Numerics.Complex One => System.Numerics.Complex.One;

		public override Vector<System.Numerics.Complex> Dense(DenseVectorStorage<System.Numerics.Complex> storage)
		{
			return new DenseVector(storage);
		}

		public override Vector<System.Numerics.Complex> Sparse(SparseVectorStorage<System.Numerics.Complex> storage)
		{
			return new SparseVector(storage);
		}

		public override Vector<System.Numerics.Complex> Random(int length, IContinuousDistribution distribution)
		{
			return Dense(Generate.RandomComplex(length, distribution));
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseMatrix {RowCount}x{ColumnCount}-Complex")]
	public class DenseMatrix : Matrix
	{
		private readonly int _rowCount;

		private readonly int _columnCount;

		private readonly System.Numerics.Complex[] _values;

		public System.Numerics.Complex[] Values => _values;

		public DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
			_rowCount = storage.RowCount;
			_columnCount = storage.ColumnCount;
			_values = storage.Data;
		}

		public DenseMatrix(int order)
			: this(new DenseColumnMajorMatrixStorage<System.Numerics.Complex>(order, order))
		{
		}

		public DenseMatrix(int rows, int columns)
			: this(new DenseColumnMajorMatrixStorage<System.Numerics.Complex>(rows, columns))
		{
		}

		public DenseMatrix(int rows, int columns, System.Numerics.Complex[] storage)
			: this(new DenseColumnMajorMatrixStorage<System.Numerics.Complex>(rows, columns, storage))
		{
		}

		public static DenseMatrix OfMatrix(Matrix<System.Numerics.Complex> matrix)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfMatrix(matrix.Storage));
		}

		public static DenseMatrix OfArray(System.Numerics.Complex[,] array)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfArray(array));
		}

		public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, System.Numerics.Complex>> enumerable)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable<System.Numerics.Complex> columnMajor)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfColumnMajorEnumerable(rows, columns, columnMajor));
		}

		public static DenseMatrix OfColumns(IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<System.Numerics.Complex> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfColumnEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfColumnArrays(params System.Numerics.Complex[][] columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfColumnArrays(columns));
		}

		public static DenseMatrix OfColumnArrays(IEnumerable<System.Numerics.Complex[]> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfColumnArrays((columns as System.Numerics.Complex[][]) ?? columns.ToArray()));
		}

		public static DenseMatrix OfColumnVectors(params Vector<System.Numerics.Complex>[] columns)
		{
			VectorStorage<System.Numerics.Complex>[] array = new VectorStorage<System.Numerics.Complex>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfColumnVectors(array));
		}

		public static DenseMatrix OfColumnVectors(IEnumerable<Vector<System.Numerics.Complex>> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfColumnVectors(columns.Select((Vector<System.Numerics.Complex> c) => c.Storage).ToArray()));
		}

		public static DenseMatrix OfRows(IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<System.Numerics.Complex> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfRowEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfRowArrays(params System.Numerics.Complex[][] rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfRowArrays(rows));
		}

		public static DenseMatrix OfRowArrays(IEnumerable<System.Numerics.Complex[]> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfRowArrays((rows as System.Numerics.Complex[][]) ?? rows.ToArray()));
		}

		public static DenseMatrix OfRowVectors(params Vector<System.Numerics.Complex>[] rows)
		{
			VectorStorage<System.Numerics.Complex>[] array = new VectorStorage<System.Numerics.Complex>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfRowVectors(array));
		}

		public static DenseMatrix OfRowVectors(IEnumerable<Vector<System.Numerics.Complex>> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfRowVectors(rows.Select((Vector<System.Numerics.Complex> r) => r.Storage).ToArray()));
		}

		public static DenseMatrix OfDiagonalVector(Vector<System.Numerics.Complex> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Count, diagonal.Count);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector<System.Numerics.Complex> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(System.Numerics.Complex[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Length, diagonal.Length);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(int rows, int columns, System.Numerics.Complex[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix Create(int rows, int columns, System.Numerics.Complex value)
		{
			if (value == System.Numerics.Complex.Zero)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfValue(rows, columns, value));
		}

		public static DenseMatrix Create(int rows, int columns, Func<int, int, System.Numerics.Complex> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfInit(rows, columns, init));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, System.Numerics.Complex value)
		{
			if (value == System.Numerics.Complex.Zero)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, Func<int, System.Numerics.Complex> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfDiagonalInit(rows, columns, init));
		}

		public static DenseMatrix CreateIdentity(int order)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<System.Numerics.Complex>.OfDiagonalInit(order, order, (int i) => Matrix<System.Numerics.Complex>.One));
		}

		public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DenseMatrix(new DenseColumnMajorMatrixStorage<System.Numerics.Complex>(rows, columns, Generate.RandomComplex(rows * columns, distribution)));
		}

		public override double L1Norm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.OneNorm, _rowCount, _columnCount, _values);
		}

		public override double InfinityNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.InfinityNorm, _rowCount, _columnCount, _values);
		}

		public override double FrobeniusNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.FrobeniusNorm, _rowCount, _columnCount, _values);
		}

		protected override void DoNegate(Matrix<System.Numerics.Complex> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1, _values, denseMatrix._values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoConjugate(Matrix<System.Numerics.Complex> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_values, denseMatrix._values);
			}
			else
			{
				base.DoConjugate(result);
			}
		}

		protected override void DoAdd(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					System.Numerics.Complex[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				base.Storage.CopyToUnchecked(result.Storage, ExistingData.Clear);
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) + data[i]);
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					System.Numerics.Complex[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				CopyTo(result);
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) - data[i]);
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseMatrix._values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, denseVector2.Values);
			}
			else
			{
				base.DoMultiply(rightSide, result);
			}
		}

		protected override void DoMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.ColumnCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoMultiply(other, result);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, 1.0, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0.0, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.RowCount);
				if (num < other.RowCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.RowCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoConjugateTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.ConjugateTranspose, 1.0, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0.0, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				System.Numerics.Complex[] array = new System.Numerics.Complex[data.Length];
				for (int i = 0; i < data.Length; i++)
				{
					array[i] = data[i].Conjugate();
				}
				int num = Math.Min(base.ColumnCount, other.RowCount);
				if (num < other.RowCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.RowCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < base.RowCount; k++)
					{
						result.At(k, j, _values[num2] * array[j]);
						num2++;
					}
				}
			}
			else
			{
				base.DoConjugateTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1.0, _values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, 0.0, denseVector2.Values);
			}
			else
			{
				base.DoTransposeThisAndMultiply(rightSide, result);
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.ConjugateTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1.0, _values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, 0.0, denseVector2.Values);
			}
			else
			{
				base.DoConjugateTransposeThisAndMultiply(rightSide, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1.0, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0.0, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.RowCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.ColumnCount, base.RowCount, other.ColumnCount - base.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < base.ColumnCount; i++)
				{
					for (int j = 0; j < num; j++)
					{
						result.At(i, j, _values[num2] * data[j]);
						num2++;
					}
					num2 += base.RowCount - num;
				}
			}
			else
			{
				base.DoTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.ConjugateTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1.0, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0.0, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage)
			{
				System.Numerics.Complex[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.RowCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.ColumnCount, base.RowCount, other.ColumnCount - base.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < base.ColumnCount; i++)
				{
					for (int j = 0; j < num; j++)
					{
						result.At(i, j, _values[num2].Conjugate() * data[j]);
						num2++;
					}
					num2 += base.RowCount - num;
				}
			}
			else
			{
				base.DoConjugateTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoDivide(System.Numerics.Complex divisor, Matrix<System.Numerics.Complex> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1.0 / divisor, _values, denseMatrix._values);
			}
			else
			{
				base.DoDivide(divisor, result);
			}
		}

		protected override void DoPointwiseMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Matrix<System.Numerics.Complex> divisor, Matrix<System.Numerics.Complex> result)
		{
			if (divisor is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Matrix<System.Numerics.Complex> exponent, Matrix<System.Numerics.Complex> result)
		{
			if (exponent is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		public override System.Numerics.Complex Trace()
		{
			if (_rowCount != _columnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < _rowCount; i++)
			{
				zero += _values[i * _rowCount + i];
			}
			return zero;
		}

		public static DenseMatrix operator +(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Add(rightSide);
		}

		public static DenseMatrix operator +(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Clone();
		}

		public static DenseMatrix operator -(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Subtract(rightSide);
		}

		public static DenseMatrix operator -(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Negate();
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseMatrix operator *(System.Numerics.Complex leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Multiply(leftSide);
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide._columnCount != rightSide._rowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseMatrix leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseVector leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.LeftMultiply(leftSide);
		}

		public static DenseMatrix operator %(DenseMatrix leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Remainder(rightSide);
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < base.ColumnCount; i++)
			{
				int num = i * base.RowCount;
				for (int j = i + 1; j < base.RowCount; j++)
				{
					if (_values[j * base.ColumnCount + i] != _values[num + j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public override bool IsHermitian()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int num = base.RowCount + 1;
			for (int i = 0; i < _values.Length; i += num)
			{
				if (!_values[i].IsReal())
				{
					return false;
				}
			}
			for (int j = 0; j < base.ColumnCount; j++)
			{
				int num2 = j * base.RowCount;
				for (int k = j + 1; k < base.RowCount; k++)
				{
					if (_values[k * base.ColumnCount + j] != _values[num2 + k].Conjugate())
					{
						return false;
					}
				}
			}
			return true;
		}

		public override Cholesky<System.Numerics.Complex> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseCholesky.Create(this);
		}

		public override LU<System.Numerics.Complex> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseLU.Create(this);
		}

		public override QR<System.Numerics.Complex> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseQR.Create(this, method);
		}

		public override GramSchmidt<System.Numerics.Complex> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseGramSchmidt.Create(this);
		}

		public override Svd<System.Numerics.Complex> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseSvd.Create(this, computeVectors);
		}

		public override Evd<System.Numerics.Complex> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseVector {Count}-Complex")]
	public class DenseVector : Vector
	{
		private readonly int _length;

		private readonly System.Numerics.Complex[] _values;

		public System.Numerics.Complex[] Values => _values;

		public DenseVector(DenseVectorStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
			_length = storage.Length;
			_values = storage.Data;
		}

		public DenseVector(int length)
			: this(new DenseVectorStorage<System.Numerics.Complex>(length))
		{
		}

		public DenseVector(System.Numerics.Complex[] storage)
			: this(new DenseVectorStorage<System.Numerics.Complex>(storage.Length, storage))
		{
		}

		public static DenseVector OfVector(Vector<System.Numerics.Complex> vector)
		{
			return new DenseVector(DenseVectorStorage<System.Numerics.Complex>.OfVector(vector.Storage));
		}

		public static DenseVector OfArray(System.Numerics.Complex[] array)
		{
			return new DenseVector(DenseVectorStorage<System.Numerics.Complex>.OfVector(new DenseVectorStorage<System.Numerics.Complex>(array.Length, array)));
		}

		public static DenseVector OfEnumerable(IEnumerable<System.Numerics.Complex> enumerable)
		{
			return new DenseVector(DenseVectorStorage<System.Numerics.Complex>.OfEnumerable(enumerable));
		}

		public static DenseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, System.Numerics.Complex>> enumerable)
		{
			return new DenseVector(DenseVectorStorage<System.Numerics.Complex>.OfIndexedEnumerable(length, enumerable));
		}

		public static DenseVector Create(int length, System.Numerics.Complex value)
		{
			if (value == System.Numerics.Complex.Zero)
			{
				return new DenseVector(length);
			}
			return new DenseVector(DenseVectorStorage<System.Numerics.Complex>.OfValue(length, value));
		}

		public static DenseVector Create(int length, Func<int, System.Numerics.Complex> init)
		{
			return new DenseVector(DenseVectorStorage<System.Numerics.Complex>.OfInit(length, init));
		}

		public static DenseVector CreateRandom(int length, IContinuousDistribution distribution)
		{
			System.Numerics.Complex[] data = Generate.RandomComplex(length, distribution);
			return new DenseVector(new DenseVectorStorage<System.Numerics.Complex>(length, data));
		}

		public static explicit operator System.Numerics.Complex[](DenseVector vector)
		{
			if (vector == null)
			{
				throw new ArgumentNullException("vector");
			}
			return vector.Values;
		}

		public static implicit operator DenseVector(System.Numerics.Complex[] array)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			return new DenseVector(array);
		}

		protected override void DoAdd(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		public static Vector<System.Numerics.Complex>operator +(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.Add(rightSide);
		}

		protected override void DoSubtract(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		public static Vector<System.Numerics.Complex>operator -(DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return rightSide.Negate();
		}

		public static Vector<System.Numerics.Complex>operator -(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.Subtract(rightSide);
		}

		protected override void DoNegate(Vector<System.Numerics.Complex> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(-System.Numerics.Complex.One, _values, denseVector.Values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoConjugate(Vector<System.Numerics.Complex> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_values, denseVector._values);
			}
			else
			{
				base.DoConjugate(result);
			}
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseVector.Values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override System.Numerics.Complex DoDotProduct(Vector<System.Numerics.Complex> other)
		{
			if (!(other is DenseVector denseVector))
			{
				return base.DoDotProduct(other);
			}
			return LinearAlgebraControl.Provider.DotProduct(_values, denseVector.Values);
		}

		protected override System.Numerics.Complex DoConjugateDotProduct(Vector<System.Numerics.Complex> other)
		{
			if (other is DenseVector denseVector)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int i = 0; i < _values.Length; i++)
				{
					zero += _values[i].Conjugate() * denseVector._values[i];
				}
				return zero;
			}
			return base.DoConjugateDotProduct(other);
		}

		public static DenseVector operator *(DenseVector leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(System.Numerics.Complex leftSide, DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Multiply(leftSide);
		}

		public static System.Numerics.Complex operator *(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static DenseVector operator /(DenseVector leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Divide(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			double num2 = _values[num].Magnitude;
			for (int i = 1; i < _length; i++)
			{
				double magnitude = _values[i].Magnitude;
				if (magnitude < num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			double num2 = _values[num].Magnitude;
			for (int i = 1; i < _length; i++)
			{
				double magnitude = _values[i].Magnitude;
				if (magnitude > num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override System.Numerics.Complex Sum()
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < _length; i++)
			{
				zero += _values[i];
			}
			return zero;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += _values[i].Magnitude;
			}
			return num;
		}

		public override double L2Norm()
		{
			return _values.Aggregate(System.Numerics.Complex.Zero, SpecialFunctions.Hypotenuse).Magnitude;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(_values, (int i, System.Numerics.Complex v) => v.Magnitude, Math.Max, 0.0);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += Math.Pow(_values[i].Magnitude, p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Vector<System.Numerics.Complex> divisor, Vector<System.Numerics.Complex> result)
		{
			if (divisor is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Vector<System.Numerics.Complex> exponent, Vector<System.Numerics.Complex> result)
		{
			if (exponent is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		public static DenseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			string[] array = value.Split(new string[1] { formatProvider.GetTextInfo().ListSeparator }, StringSplitOptions.RemoveEmptyEntries);
			List<System.Numerics.Complex> list = new List<System.Numerics.Complex>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				string[] array3 = array2[i].Split(new string[2] { " ", "\t" }, StringSplitOptions.RemoveEmptyEntries);
				string text = string.Empty;
				for (int j = 0; j < array3.Length; j++)
				{
					text += array3[j];
					if (!text.EndsWith("+") && !text.EndsWith("-") && (!text.StartsWith("(") || text.EndsWith(")")))
					{
						string text2 = ((j < array3.Length - 1) ? array3[j + 1] : string.Empty);
						if (!text2.StartsWith("+") && !text2.StartsWith("-"))
						{
							list.Add(text.ToComplex(formatProvider));
							text = string.Empty;
						}
					}
				}
				if (text != string.Empty)
				{
					throw new FormatException();
				}
			}
			if (list.Count == 0)
			{
				throw new FormatException();
			}
			return new DenseVector(list.ToArray());
		}

		public static bool TryParse(string value, out DenseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out DenseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}
	}
	[Serializable]
	[DebuggerDisplay("DiagonalMatrix {RowCount}x{ColumnCount}-Complex")]
	public class DiagonalMatrix : Matrix
	{
		private readonly System.Numerics.Complex[] _data;

		public DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
			_data = storage.Data;
		}

		public DiagonalMatrix(int order)
			: this(new DiagonalMatrixStorage<System.Numerics.Complex>(order, order))
		{
		}

		public DiagonalMatrix(int rows, int columns)
			: this(new DiagonalMatrixStorage<System.Numerics.Complex>(rows, columns))
		{
		}

		public DiagonalMatrix(int rows, int columns, System.Numerics.Complex diagonalValue)
			: this(rows, columns)
		{
			for (int i = 0; i < _data.Length; i++)
			{
				_data[i] = diagonalValue;
			}
		}

		public DiagonalMatrix(int rows, int columns, System.Numerics.Complex[] diagonalStorage)
			: this(new DiagonalMatrixStorage<System.Numerics.Complex>(rows, columns, diagonalStorage))
		{
		}

		public static DiagonalMatrix OfMatrix(Matrix<System.Numerics.Complex> matrix)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex>.OfMatrix(matrix.Storage));
		}

		public static DiagonalMatrix OfArray(System.Numerics.Complex[,] array)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex>.OfArray(array));
		}

		public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable<Tuple<int, System.Numerics.Complex>> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex>.OfIndexedEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable<System.Numerics.Complex> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex>.OfEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix Create(int rows, int columns, Func<int, System.Numerics.Complex> init)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex>.OfInit(rows, columns, init));
		}

		public static DiagonalMatrix CreateIdentity(int order)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<System.Numerics.Complex>.OfValue(order, order, Matrix<System.Numerics.Complex>.One));
		}

		public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DiagonalMatrix(new DiagonalMatrixStorage<System.Numerics.Complex>(rows, columns, Generate.RandomComplex(Math.Min(rows, columns), distribution)));
		}

		protected override void DoNegate(Matrix<System.Numerics.Complex> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, -_data[i]);
			}
		}

		protected override void DoConjugate(Matrix<System.Numerics.Complex> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i].Conjugate());
			}
		}

		protected override void DoAdd(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.AddArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.CopyTo(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoSubtract(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.Negate(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			if (scalar == 0.0)
			{
				result.Clear();
			}
			else if (scalar == 1.0)
			{
				CopyTo(result);
			}
			else if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _data, diagonalMatrix._data);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.RowCount)
			{
				result.ClearSubVector(base.ColumnCount, base.RowCount - base.ColumnCount);
			}
			if (num == base.ColumnCount && rightSide.Storage is DenseVectorStorage<System.Numerics.Complex> denseVectorStorage && result.Storage is DenseVectorStorage<System.Numerics.Complex> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				System.Numerics.Complex[] array2 = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage)
			{
				System.Numerics.Complex[] data = denseColumnMajorMatrixStorage.Data;
				System.Numerics.Complex[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.RowCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, System.Numerics.Complex x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, System.Numerics.Complex x) => x * _data[i], 0, 0, Math.Min(base.RowCount, other.RowCount), 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				System.Numerics.Complex[] array2 = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage)
			{
				System.Numerics.Complex[] data = denseColumnMajorMatrixStorage.Data;
				System.Numerics.Complex[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount - denseColumnMajorMatrixStorage.ColumnCount, 0, denseColumnMajorMatrixStorage.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
					{
						result.At(i, j, data[num2] * data2[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoConjugateTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				System.Numerics.Complex[] array2 = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.ConjugateArray(array2, array2);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage)
			{
				System.Numerics.Complex[] data = denseColumnMajorMatrixStorage.Data;
				System.Numerics.Complex[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount - denseColumnMajorMatrixStorage.ColumnCount, 0, denseColumnMajorMatrixStorage.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
					{
						result.At(i, j, data[num2].Conjugate() * data2[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoConjugateTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				System.Numerics.Complex[] array2 = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage)
			{
				System.Numerics.Complex[] data = denseColumnMajorMatrixStorage.Data;
				System.Numerics.Complex[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount);
				if (num < base.ColumnCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, System.Numerics.Complex x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, System.Numerics.Complex x) => x * _data[i], 0, 0, other.RowCount, 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				System.Numerics.Complex[] array2 = new System.Numerics.Complex[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.ConjugateArray(array, array);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage)
			{
				System.Numerics.Complex[] data = denseColumnMajorMatrixStorage.Data;
				System.Numerics.Complex[] array3 = new System.Numerics.Complex[_data.Length];
				for (int i = 0; i < _data.Length; i++)
				{
					array3[i] = _data[i].Conjugate();
				}
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount);
				if (num < base.ColumnCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int j = 0; j < denseColumnMajorMatrixStorage.ColumnCount; j++)
				{
					for (int k = 0; k < num; k++)
					{
						result.At(k, j, data[num2] * array3[k]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else
			{
				base.DoConjugateTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.ColumnCount)
			{
				result.ClearSubVector(base.RowCount, base.ColumnCount - base.RowCount);
			}
			if (num == base.RowCount && rightSide.Storage is DenseVectorStorage<System.Numerics.Complex> denseVectorStorage && result.Storage is DenseVectorStorage<System.Numerics.Complex> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.ColumnCount)
			{
				result.ClearSubVector(base.RowCount, base.ColumnCount - base.RowCount);
			}
			if (num == base.RowCount && rightSide.Storage is DenseVectorStorage<System.Numerics.Complex> denseVectorStorage && result.Storage is DenseVectorStorage<System.Numerics.Complex> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.ConjugateArray(_data, denseVectorStorage2.Data);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(denseVectorStorage2.Data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i].Conjugate() * rightSide.At(i));
			}
		}

		protected override void DoDivide(System.Numerics.Complex divisor, Matrix<System.Numerics.Complex> result)
		{
			if (divisor == System.Numerics.Complex.One)
			{
				CopyTo(result);
				return;
			}
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1.0 / divisor, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i] / divisor);
			}
		}

		protected override void DoDivideByThis(System.Numerics.Complex dividend, Matrix<System.Numerics.Complex> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				System.Numerics.Complex[] resultData = diagonalMatrix._data;
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						resultData[j] = dividend / _data[j];
					}
				});
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, dividend / _data[i]);
				}
			}
		}

		public override System.Numerics.Complex Determinant()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			return _data.Aggregate(System.Numerics.Complex.One, (System.Numerics.Complex current, System.Numerics.Complex t) => current * t);
		}

		public override Vector<System.Numerics.Complex> Diagonal()
		{
			return new DenseVector(_data).Clone();
		}

		public override void SetDiagonal(System.Numerics.Complex[] source)
		{
			if (source.Length != _data.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "source");
			}
			Array.Copy(source, 0, _data, 0, source.Length);
		}

		public override void SetDiagonal(Vector<System.Numerics.Complex> source)
		{
			if (source is DenseVector denseVector)
			{
				if (_data.Length != denseVector.Values.Length)
				{
					throw new ArgumentException("All vectors must have the same dimensionality.", "source");
				}
				Array.Copy(denseVector.Values, 0, _data, 0, denseVector.Values.Length);
			}
			else
			{
				base.SetDiagonal(source);
			}
		}

		public override double L1Norm()
		{
			return _data.Aggregate(0.0, (double current, System.Numerics.Complex t) => Math.Max(current, t.Magnitude));
		}

		public override double L2Norm()
		{
			return _data.Aggregate(0.0, (double current, System.Numerics.Complex t) => Math.Max(current, t.Magnitude));
		}

		public override double InfinityNorm()
		{
			return L1Norm();
		}

		public override double FrobeniusNorm()
		{
			return Math.Sqrt(_data.Sum((System.Numerics.Complex t) => t.Magnitude * t.Magnitude));
		}

		public override System.Numerics.Complex ConditionNumber()
		{
			double num = double.NegativeInfinity;
			double num2 = double.PositiveInfinity;
			System.Numerics.Complex[] data = _data;
			for (int i = 0; i < data.Length; i++)
			{
				System.Numerics.Complex complex = data[i];
				num = Math.Max(num, complex.Magnitude);
				num2 = Math.Min(num2, complex.Magnitude);
			}
			return num / num2;
		}

		public override Matrix<System.Numerics.Complex> Inverse()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DiagonalMatrix diagonalMatrix = (DiagonalMatrix)Clone();
			for (int i = 0; i < _data.Length; i++)
			{
				if (_data[i] != 0.0)
				{
					diagonalMatrix._data[i] = 1.0 / _data[i];
					continue;
				}
				throw new ArgumentException("Matrix must not be singular.");
			}
			return diagonalMatrix;
		}

		public override Matrix<System.Numerics.Complex> LowerTriangle()
		{
			return Clone();
		}

		public override void LowerTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this != result)
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, _data[i]);
				}
			}
		}

		public override Matrix<System.Numerics.Complex> StrictlyLowerTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyLowerTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<System.Numerics.Complex> UpperTriangle()
		{
			return Clone();
		}

		public override void UpperTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i]);
			}
		}

		public override Matrix<System.Numerics.Complex> StrictlyUpperTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyUpperTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<System.Numerics.Complex> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			Matrix<System.Numerics.Complex> matrix = ((rowIndex == columnIndex) ? ((Matrix)new DiagonalMatrix(rowCount, columnCount)) : ((Matrix)new SparseMatrix(rowCount, columnCount)));
			base.Storage.CopySubMatrixTo(matrix.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public override void PermuteColumns(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public override void PermuteRows(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public sealed override bool IsSymmetric()
		{
			return true;
		}

		public sealed override bool IsHermitian()
		{
			for (int i = 0; i < _data.Length; i++)
			{
				if (!_data[i].IsReal())
				{
					return false;
				}
			}
			return true;
		}
	}
	[Serializable]
	public abstract class Matrix : Matrix<System.Numerics.Complex>
	{
		protected Matrix(MatrixStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((System.Numerics.Complex x) => (!(x.Magnitude < threshold)) ? x : System.Numerics.Complex.Zero);
		}

		public sealed override Matrix<System.Numerics.Complex> ConjugateTranspose()
		{
			Matrix<System.Numerics.Complex> matrix = Transpose();
			matrix.MapInplace((System.Numerics.Complex c) => c.Conjugate());
			return matrix;
		}

		public sealed override void ConjugateTranspose(Matrix<System.Numerics.Complex> result)
		{
			Transpose(result);
			result.MapInplace((System.Numerics.Complex c) => c.Conjugate());
		}

		protected override void DoConjugate(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Conjugate, result);
		}

		protected override void DoNegate(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Negate, result);
		}

		protected override void DoAdd(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Add, other, result);
		}

		protected override void DoSubtract(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Subtract, other, result);
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x * scalar, result);
		}

		protected override void DoMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					zero += At(i, j) * rightSide[j];
				}
				result[i] = zero;
			}
		}

		protected override void DoMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				for (int j = 0; j != other.ColumnCount; j++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						zero += At(i, k) * other.At(k, j);
					}
					result.At(i, j, zero);
				}
			}
		}

		protected override void DoDivide(System.Numerics.Complex divisor, Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x / divisor, result, divisor.IsZero() ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(System.Numerics.Complex dividend, Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			for (int i = 0; i < other.RowCount; i++)
			{
				for (int j = 0; j < base.RowCount; j++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						zero += At(j, k) * other.At(i, k);
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoConjugateTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			for (int i = 0; i < other.RowCount; i++)
			{
				for (int j = 0; j < base.RowCount; j++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						zero += At(j, k) * other.At(i, k).Conjugate();
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			for (int i = 0; i < other.ColumnCount; i++)
			{
				for (int j = 0; j < base.ColumnCount; j++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int k = 0; k < base.RowCount; k++)
					{
						zero += At(k, j) * other.At(k, i);
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			for (int i = 0; i < other.ColumnCount; i++)
			{
				for (int j = 0; j < base.ColumnCount; j++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int k = 0; k < base.RowCount; k++)
					{
						zero += At(k, j).Conjugate() * other.At(k, i);
					}
					result.At(j, i, zero);
				}
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			for (int i = 0; i < base.ColumnCount; i++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = 0; j < base.RowCount; j++)
				{
					zero += At(j, i) * rightSide[j];
				}
				result[i] = zero;
			}
		}

		protected override void DoConjugateTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			for (int i = 0; i < base.ColumnCount; i++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = 0; j < base.RowCount; j++)
				{
					zero += At(j, i).Conjugate() * rightSide[j];
				}
				result[i] = zero;
			}
		}

		protected override void DoPointwiseMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Multiply, other, result);
		}

		protected override void DoPointwiseDivide(Matrix<System.Numerics.Complex> divisor, Matrix<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Divide, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(System.Numerics.Complex exponent, Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x.Power(exponent), result, Zeros.Include);
		}

		protected override void DoPointwisePower(Matrix<System.Numerics.Complex> exponent, Matrix<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Pow, result, Zeros.Include);
		}

		protected sealed override void DoPointwiseModulus(Matrix<System.Numerics.Complex> divisor, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoPointwiseRemainder(Matrix<System.Numerics.Complex> divisor, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoModulus(System.Numerics.Complex divisor, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoModulusByThis(System.Numerics.Complex dividend, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainder(System.Numerics.Complex divisor, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainderByThis(System.Numerics.Complex dividend, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseExp(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Exp, result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Log, result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Matrix<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => System.Numerics.Complex.Abs(x), result);
		}

		protected override void DoPointwiseAcos(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Acos, result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Asin, result);
		}

		protected override void DoPointwiseAtan(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Atan, result);
		}

		protected override void DoPointwiseAtan2(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCeiling(Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCos(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Cos, result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Cosh, result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseLog10(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Log10, result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSign(Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSin(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Sin, result);
		}

		protected override void DoPointwiseSinh(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Sinh, result);
		}

		protected override void DoPointwiseSqrt(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Sqrt, result);
		}

		protected override void DoPointwiseTan(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Tan, result);
		}

		protected override void DoPointwiseTanh(Matrix<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Tanh, result);
		}

		public override Matrix<System.Numerics.Complex> PseudoInverse()
		{
			Svd<System.Numerics.Complex> svd = Svd();
			Matrix<System.Numerics.Complex> w = svd.W;
			Vector<System.Numerics.Complex> s = svd.S;
			double num = (double)Math.Max(base.RowCount, base.ColumnCount) * svd.L2Norm * Precision.DoublePrecision;
			for (int i = 0; i < s.Count; i++)
			{
				s[i] = ((s[i].Magnitude < num) ? ((System.Numerics.Complex)0) : (1 / s[i]));
			}
			w.SetDiagonal(s);
			return (svd.U * (w * svd.VT)).ConjugateTranspose();
		}

		public override System.Numerics.Complex Trace()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < base.RowCount; i++)
			{
				zero += At(i, i);
			}
			return zero;
		}

		protected override void DoPointwiseMinimum(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			double absolute = scalar.Magnitude;
			Map((System.Numerics.Complex x) => Math.Min(absolute, x.Magnitude), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			double absolute = scalar.Magnitude;
			Map((System.Numerics.Complex x) => Math.Max(absolute, x.Magnitude), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			Map2((System.Numerics.Complex x, System.Numerics.Complex y) => Math.Min(x.Magnitude, y.Magnitude), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			Map2((System.Numerics.Complex x, System.Numerics.Complex y) => Math.Max(x.Magnitude, y.Magnitude), other, result);
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.ColumnCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.RowCount; j++)
				{
					num2 += At(j, i).Magnitude;
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double InfinityNorm()
		{
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					num2 += At(i, j).Magnitude;
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			Matrix<System.Numerics.Complex> matrix = ConjugateTranspose();
			Matrix<System.Numerics.Complex> matrix2 = this * matrix;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				num += matrix2.At(i, i).Magnitude;
			}
			return Math.Sqrt(num);
		}

		public override Vector<double> RowNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.RowCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, System.Numerics.Complex x) => s + x.MagnitudeSquared(), (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, System.Numerics.Complex x) => s + x.Magnitude, (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByRowUnchecked(array, (double s, System.Numerics.Complex x) => Math.Max(s, x.Magnitude), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByRowUnchecked(array, (double s, System.Numerics.Complex x) => s + Math.Pow(x.Magnitude, norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> ColumnNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.ColumnCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, System.Numerics.Complex x) => s + x.MagnitudeSquared(), (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, System.Numerics.Complex x) => s + x.Magnitude, (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, System.Numerics.Complex x) => Math.Max(s, x.Magnitude), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByColumnUnchecked(array, (double s, System.Numerics.Complex x) => s + Math.Pow(x.Magnitude, norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public sealed override Matrix<System.Numerics.Complex> NormalizeRows(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)RowNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, System.Numerics.Complex x) => norminv[i] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public sealed override Matrix<System.Numerics.Complex> NormalizeColumns(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)ColumnNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, System.Numerics.Complex x) => norminv[j] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public override Vector<System.Numerics.Complex> RowSums()
		{
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (System.Numerics.Complex s, System.Numerics.Complex x) => s + x, (System.Numerics.Complex x, int c) => x, array, Zeros.AllowSkip);
			return Vector<System.Numerics.Complex>.Build.Dense(array);
		}

		public override Vector<System.Numerics.Complex> RowAbsoluteSums()
		{
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (System.Numerics.Complex s, System.Numerics.Complex x) => s + x.Magnitude, (System.Numerics.Complex x, int c) => x, array, Zeros.AllowSkip);
			return Vector<System.Numerics.Complex>.Build.Dense(array);
		}

		public override Vector<System.Numerics.Complex> ColumnSums()
		{
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (System.Numerics.Complex s, System.Numerics.Complex x) => s + x, (System.Numerics.Complex x, int c) => x, array, Zeros.AllowSkip);
			return Vector<System.Numerics.Complex>.Build.Dense(array);
		}

		public override Vector<System.Numerics.Complex> ColumnAbsoluteSums()
		{
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (System.Numerics.Complex s, System.Numerics.Complex x) => s + x.Magnitude, (System.Numerics.Complex x, int c) => x, array, Zeros.AllowSkip);
			return Vector<System.Numerics.Complex>.Build.Dense(array);
		}

		public override bool IsHermitian()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < base.RowCount; i++)
			{
				if (!At(i, i).IsReal())
				{
					return false;
				}
			}
			for (int j = 0; j < base.RowCount; j++)
			{
				for (int k = j + 1; k < base.ColumnCount; k++)
				{
					if (!At(j, k).Equals(At(k, j).Conjugate()))
					{
						return false;
					}
				}
			}
			return true;
		}

		public override Cholesky<System.Numerics.Complex> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserCholesky.Create(this);
		}

		public override LU<System.Numerics.Complex> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserLU.Create(this);
		}

		public override QR<System.Numerics.Complex> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserQR.Create(this, method);
		}

		public override GramSchmidt<System.Numerics.Complex> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserGramSchmidt.Create(this);
		}

		public override Svd<System.Numerics.Complex> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserSvd.Create(this, computeVectors);
		}

		public override Evd<System.Numerics.Complex> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseMatrix {RowCount}x{ColumnCount}-Complex {NonZerosCount}-NonZero")]
	public class SparseMatrix : Matrix
	{
		private readonly SparseCompressedRowMatrixStorage<System.Numerics.Complex> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseMatrix(int order)
			: this(order, order)
		{
		}

		public SparseMatrix(int rows, int columns)
			: this(new SparseCompressedRowMatrixStorage<System.Numerics.Complex>(rows, columns))
		{
		}

		public static SparseMatrix OfMatrix(Matrix<System.Numerics.Complex> matrix)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfMatrix(matrix.Storage));
		}

		public static SparseMatrix OfArray(System.Numerics.Complex[,] array)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfArray(array));
		}

		public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, System.Numerics.Complex>> enumerable)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable<System.Numerics.Complex> rowMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfRowMajorEnumerable(rows, columns, rowMajor));
		}

		public static SparseMatrix OfColumnMajor(int rows, int columns, IList<System.Numerics.Complex> columnMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfColumnMajorList(rows, columns, columnMajor));
		}

		public static SparseMatrix OfColumns(IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<System.Numerics.Complex> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfColumnEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfColumnArrays(params System.Numerics.Complex[][] columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfColumnArrays(columns));
		}

		public static SparseMatrix OfColumnArrays(IEnumerable<System.Numerics.Complex[]> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfColumnArrays((columns as System.Numerics.Complex[][]) ?? columns.ToArray()));
		}

		public static SparseMatrix OfColumnVectors(params Vector<System.Numerics.Complex>[] columns)
		{
			VectorStorage<System.Numerics.Complex>[] array = new VectorStorage<System.Numerics.Complex>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfColumnVectors(array));
		}

		public static SparseMatrix OfColumnVectors(IEnumerable<Vector<System.Numerics.Complex>> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfColumnVectors(columns.Select((Vector<System.Numerics.Complex> c) => c.Storage).ToArray()));
		}

		public static SparseMatrix OfRows(IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<System.Numerics.Complex> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<System.Numerics.Complex>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfRowEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfRowArrays(params System.Numerics.Complex[][] rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfRowArrays(rows));
		}

		public static SparseMatrix OfRowArrays(IEnumerable<System.Numerics.Complex[]> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfRowArrays((rows as System.Numerics.Complex[][]) ?? rows.ToArray()));
		}

		public static SparseMatrix OfRowVectors(params Vector<System.Numerics.Complex>[] rows)
		{
			VectorStorage<System.Numerics.Complex>[] array = new VectorStorage<System.Numerics.Complex>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfRowVectors(array));
		}

		public static SparseMatrix OfRowVectors(IEnumerable<Vector<System.Numerics.Complex>> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfRowVectors(rows.Select((Vector<System.Numerics.Complex> r) => r.Storage).ToArray()));
		}

		public static SparseMatrix OfDiagonalVector(Vector<System.Numerics.Complex> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Count, diagonal.Count);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector<System.Numerics.Complex> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(System.Numerics.Complex[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Length, diagonal.Length);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(int rows, int columns, System.Numerics.Complex[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix Create(int rows, int columns, System.Numerics.Complex value)
		{
			if (value == System.Numerics.Complex.Zero)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfValue(rows, columns, value));
		}

		public static SparseMatrix Create(int rows, int columns, Func<int, int, System.Numerics.Complex> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfInit(rows, columns, init));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, System.Numerics.Complex value)
		{
			if (value == System.Numerics.Complex.Zero)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, Func<int, System.Numerics.Complex> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfDiagonalInit(rows, columns, init));
		}

		public static SparseMatrix CreateIdentity(int order)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<System.Numerics.Complex>.OfDiagonalInit(order, order, (int i) => Matrix<System.Numerics.Complex>.One));
		}

		public override Matrix<System.Numerics.Complex> LowerTriangle()
		{
			Matrix<System.Numerics.Complex> result = Matrix<System.Numerics.Complex>.Build.SameAs(this);
			LowerTriangleImpl(result);
			return result;
		}

		public override void LowerTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result);
			}
			if (this == result)
			{
				Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(result);
				LowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				LowerTriangleImpl(result);
			}
		}

		private void LowerTriangleImpl(Matrix<System.Numerics.Complex> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i >= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<System.Numerics.Complex> UpperTriangle()
		{
			Matrix<System.Numerics.Complex> result = Matrix<System.Numerics.Complex>.Build.SameAs(this);
			UpperTriangleImpl(result);
			return result;
		}

		public override void UpperTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result);
			}
			if (this == result)
			{
				Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(result);
				UpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				UpperTriangleImpl(result);
			}
		}

		private void UpperTriangleImpl(Matrix<System.Numerics.Complex> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i <= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<System.Numerics.Complex> StrictlyLowerTriangle()
		{
			Matrix<System.Numerics.Complex> result = Matrix<System.Numerics.Complex>.Build.SameAs(this);
			StrictlyLowerTriangleImpl(result);
			return result;
		}

		public override void StrictlyLowerTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result);
			}
			if (this == result)
			{
				Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(result);
				StrictlyLowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyLowerTriangleImpl(result);
			}
		}

		private void StrictlyLowerTriangleImpl(Matrix<System.Numerics.Complex> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i > columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<System.Numerics.Complex> StrictlyUpperTriangle()
		{
			Matrix<System.Numerics.Complex> result = Matrix<System.Numerics.Complex>.Build.SameAs(this);
			StrictlyUpperTriangleImpl(result);
			return result;
		}

		public override void StrictlyUpperTriangle(Matrix<System.Numerics.Complex> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(this, result);
			}
			if (this == result)
			{
				Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(result);
				StrictlyUpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyUpperTriangleImpl(result);
			}
		}

		private void StrictlyUpperTriangleImpl(Matrix<System.Numerics.Complex> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i < columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		protected override void DoNegate(Matrix<System.Numerics.Complex> result)
		{
			CopyTo(result);
			DoMultiply(-1, result);
		}

		public override double InfinityNorm()
		{
			int[] rowPointers = _storage.RowPointers;
			System.Numerics.Complex[] values = _storage.Values;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num2 = rowPointers[i];
				int num3 = rowPointers[i + 1];
				if (num2 != num3)
				{
					double num4 = 0.0;
					for (int j = num2; j < num3; j++)
					{
						num4 += values[j].Magnitude;
					}
					num = Math.Max(num, num4);
				}
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			SparseCompressedRowMatrixStorage<System.Numerics.Complex> sparseCompressedRowMatrixStorage = (SparseCompressedRowMatrixStorage<System.Numerics.Complex>)(this * ConjugateTranspose()).Storage;
			double num = 0.0;
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				int num2 = sparseCompressedRowMatrixStorage.RowPointers[i];
				int num3 = sparseCompressedRowMatrixStorage.RowPointers[i + 1];
				if (num2 == num3)
				{
					continue;
				}
				for (int j = num2; j < num3; j++)
				{
					if (i == sparseCompressedRowMatrixStorage.ColumnIndices[j])
					{
						num += sparseCompressedRowMatrixStorage.Values[j].Magnitude;
					}
				}
			}
			return Math.Sqrt(num);
		}

		protected override void DoAdd(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					if (this != result)
					{
						CopyTo(result);
					}
					LinearAlgebraControl.Provider.ScaleArray(2.0, sparseMatrix2._storage.Values, sparseMatrix2._storage.Values);
					return;
				}
				SparseMatrix sparseMatrix3;
				if (sparseMatrix == sparseMatrix2)
				{
					sparseMatrix3 = this;
				}
				else if (this == sparseMatrix2)
				{
					sparseMatrix3 = sparseMatrix;
				}
				else
				{
					CopyTo(sparseMatrix2);
					sparseMatrix3 = sparseMatrix;
				}
				SparseCompressedRowMatrixStorage<System.Numerics.Complex> storage = sparseMatrix3._storage;
				for (int i = 0; i < storage.RowCount; i++)
				{
					int num = storage.RowPointers[i + 1];
					for (int j = storage.RowPointers[i]; j < num; j++)
					{
						int column = storage.ColumnIndices[j];
						System.Numerics.Complex value = storage.Values[j] + result.At(i, column);
						result.At(i, column, value);
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			SparseMatrix sparseMatrix = other as SparseMatrix;
			SparseMatrix sparseMatrix2 = result as SparseMatrix;
			if (sparseMatrix == null || sparseMatrix2 == null)
			{
				base.DoSubtract(other, result);
				return;
			}
			if (this == other)
			{
				result.Clear();
				return;
			}
			SparseCompressedRowMatrixStorage<System.Numerics.Complex> storage = sparseMatrix._storage;
			if (this == sparseMatrix2)
			{
				for (int i = 0; i < storage.RowCount; i++)
				{
					int num = storage.RowPointers[i + 1];
					for (int j = storage.RowPointers[i]; j < num; j++)
					{
						int column = storage.ColumnIndices[j];
						System.Numerics.Complex value = sparseMatrix2.At(i, column) - storage.Values[j];
						result.At(i, column, value);
					}
				}
				return;
			}
			if (sparseMatrix != sparseMatrix2)
			{
				sparseMatrix.CopyTo(sparseMatrix2);
			}
			sparseMatrix2.Negate(sparseMatrix2);
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int k = 0; k < base.RowCount; k++)
			{
				int num2 = rowPointers[k + 1];
				for (int l = rowPointers[k]; l < num2; l++)
				{
					int column2 = columnIndices[l];
					System.Numerics.Complex value2 = sparseMatrix2.At(k, column2) + values[l];
					result.At(k, column2, value2);
				}
			}
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Matrix<System.Numerics.Complex> result)
		{
			if (scalar == 1.0)
			{
				CopyTo(result);
				return;
			}
			if (scalar == 0.0 || NonZerosCount == 0)
			{
				result.Clear();
				return;
			}
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(sparseMatrix);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseMatrix._storage.Values, sparseMatrix._storage.Values);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					for (int j = num; j < num2; j++)
					{
						int column = columnIndices[j];
						result.At(i, column, values[j] * scalar);
					}
				}
			}
		}

		protected override void DoMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			SparseMatrix sparseMatrix = other as SparseMatrix;
			SparseMatrix sparseMatrix2 = result as SparseMatrix;
			if (sparseMatrix != null && sparseMatrix2 != null)
			{
				DoMultiplySparse(sparseMatrix, sparseMatrix2);
				return;
			}
			if (other.Storage is DiagonalMatrixStorage<System.Numerics.Complex> diagonalMatrixStorage && sparseMatrix2 != null)
			{
				System.Numerics.Complex[] diagonal = diagonalMatrixStorage.Data;
				if (other.ColumnCount == other.RowCount)
				{
					base.Storage.MapIndexedTo(result.Storage, (int i, int j, System.Numerics.Complex x) => x * diagonal[j], Zeros.AllowSkip, ExistingData.Clear);
					return;
				}
				result.Storage.Clear();
				base.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, System.Numerics.Complex x) => x * diagonal[j], 0, 0, base.RowCount, 0, 0, Math.Min(base.ColumnCount, other.ColumnCount), Zeros.AllowSkip, ExistingData.AssumeZeros);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			if (other.Storage is DenseColumnMajorMatrixStorage<System.Numerics.Complex> denseColumnMajorMatrixStorage)
			{
				for (int k = 0; k < base.RowCount; k++)
				{
					int num = rowPointers[k];
					int num2 = rowPointers[k + 1];
					if (num == num2)
					{
						continue;
					}
					for (int l = 0; l < other.ColumnCount; l++)
					{
						int num3 = l * other.RowCount;
						System.Numerics.Complex zero = System.Numerics.Complex.Zero;
						for (int m = num; m < num2; m++)
						{
							zero += values[m] * denseColumnMajorMatrixStorage.Data[num3 + columnIndices[m]];
						}
						result.At(k, l, zero);
					}
				}
				return;
			}
			DenseVector denseVector = new DenseVector(other.RowCount);
			for (int n = 0; n < base.RowCount; n++)
			{
				int num4 = rowPointers[n];
				int num5 = rowPointers[n + 1];
				if (num4 == num5)
				{
					continue;
				}
				for (int num6 = 0; num6 < other.ColumnCount; num6++)
				{
					other.Column(num6, denseVector);
					System.Numerics.Complex zero2 = System.Numerics.Complex.Zero;
					for (int num7 = num4; num7 < num5; num7++)
					{
						zero2 += values[num7] * denseVector[columnIndices[num7]];
					}
					result.At(n, num6, zero2);
				}
			}
		}

		private void DoMultiplySparse(SparseMatrix other, SparseMatrix result)
		{
			result.Clear();
			System.Numerics.Complex[] values = _storage.Values;
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values2 = other._storage.Values;
			int[] rowPointers2 = other._storage.RowPointers;
			int[] columnIndices2 = other._storage.ColumnIndices;
			int rowCount = base.RowCount;
			int columnCount = other.ColumnCount;
			int[] rowPointers3 = result._storage.RowPointers;
			int[] array = new int[columnCount];
			for (int i = 0; i < columnCount; i++)
			{
				array[i] = -1;
			}
			int num = 0;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = rowPointers[j]; k < rowPointers[j + 1]; k++)
				{
					int num2 = columnIndices[k];
					for (int l = rowPointers2[num2]; l < rowPointers2[num2 + 1]; l++)
					{
						int num3 = columnIndices2[l];
						if (array[num3] != j)
						{
							array[num3] = j;
							num++;
						}
					}
				}
				rowPointers3[j + 1] = num;
			}
			int[] array2 = new int[num];
			System.Numerics.Complex[] array3 = new System.Numerics.Complex[num];
			for (int m = 0; m < columnCount; m++)
			{
				array[m] = -1;
			}
			num = 0;
			for (int n = 0; n < rowCount; n++)
			{
				int num4 = rowPointers3[n];
				for (int num5 = rowPointers[n]; num5 < rowPointers[n + 1]; num5++)
				{
					int num6 = columnIndices[num5];
					System.Numerics.Complex complex = values[num5];
					for (int num7 = rowPointers2[num6]; num7 < rowPointers2[num6 + 1]; num7++)
					{
						int num8 = columnIndices2[num7];
						System.Numerics.Complex complex2 = values2[num7];
						if (array[num8] < num4)
						{
							array[num8] = num;
							array2[array[num8]] = num8;
							array3[array[num8]] = complex * complex2;
							num++;
						}
						else
						{
							array3[array[num8]] += complex * complex2;
						}
					}
				}
			}
			result._storage.Values = array3;
			result._storage.ColumnIndices = array2;
			result._storage.Normalize();
		}

		protected override void DoMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int j = num; j < num2; j++)
					{
						zero += values[j] * rightSide[columnIndices[j]];
					}
					result[i] = zero;
				}
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				sparseMatrix2.Clear();
				int[] rowPointers = _storage.RowPointers;
				System.Numerics.Complex[] values = _storage.Values;
				SparseCompressedRowMatrixStorage<System.Numerics.Complex> storage = sparseMatrix._storage;
				for (int i = 0; i < base.RowCount; i++)
				{
					int num = storage.RowPointers[i];
					int num2 = storage.RowPointers[i + 1];
					if (num == num2)
					{
						continue;
					}
					for (int j = 0; j < base.RowCount; j++)
					{
						int num3 = rowPointers[j];
						int num4 = rowPointers[j + 1];
						if (num3 == num4)
						{
							continue;
						}
						System.Numerics.Complex zero = System.Numerics.Complex.Zero;
						for (int k = num; k < num2; k++)
						{
							int num5 = _storage.FindItem(j, storage.ColumnIndices[k]);
							if (num5 >= 0)
							{
								zero += storage.Values[k] * values[num5];
							}
						}
						sparseMatrix2._storage.At(j, i, zero + result.At(j, i));
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<System.Numerics.Complex> rightSide, Vector<System.Numerics.Complex> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					System.Numerics.Complex complex = rightSide[i];
					for (int j = num; j < num2; j++)
					{
						result[columnIndices[j]] += values[j] * complex;
					}
				}
			}
		}

		protected override void DoPointwiseMultiply(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					System.Numerics.Complex complex = values[j] * other.At(i, columnIndices[j]);
					if (!complex.IsZero())
					{
						result.At(i, columnIndices[j], complex);
					}
				}
			}
		}

		protected override void DoPointwiseDivide(Matrix<System.Numerics.Complex> divisor, Matrix<System.Numerics.Complex> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (!values[j].IsZero())
					{
						result.At(i, columnIndices[j], values[j] / divisor.At(i, columnIndices[j]));
					}
				}
			}
		}

		public override void KroneckerProduct(Matrix<System.Numerics.Complex> other, Matrix<System.Numerics.Complex> result)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount * other.RowCount || result.ColumnCount != base.ColumnCount * other.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, result);
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (!values[j].IsZero())
					{
						result.SetSubMatrix(i * other.RowCount, other.RowCount, columnIndices[j] * other.ColumnCount, other.ColumnCount, values[j] * other);
					}
				}
			}
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num == num2)
				{
					continue;
				}
				for (int j = num; j < num2; j++)
				{
					int row = columnIndices[j];
					if (!values[j].Equals(At(row, i)))
					{
						return false;
					}
				}
			}
			return true;
		}

		public override bool IsHermitian()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			System.Numerics.Complex[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num == num2)
				{
					continue;
				}
				for (int j = num; j < num2; j++)
				{
					int row = columnIndices[j];
					if (!values[j].Equals(At(row, i).Conjugate()))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static SparseMatrix operator +(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Add(rightSide);
		}

		public static SparseMatrix operator +(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Clone();
		}

		public static SparseMatrix operator -(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Subtract(rightSide);
		}

		public static SparseMatrix operator -(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Negate();
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseMatrix operator *(System.Numerics.Complex leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Multiply(leftSide);
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide.ColumnCount != rightSide.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseMatrix leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.LeftMultiply(leftSide);
		}

		public static SparseMatrix operator %(SparseMatrix leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Remainder(rightSide);
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseMatrix {base.RowCount}x{base.ColumnCount}-Complex {(double)NonZerosCount / ((double)base.RowCount * (double)base.ColumnCount):P2} Filled");
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseVector {Count}-Complex {NonZerosCount}-NonZero")]
	public class SparseVector : Vector
	{
		private readonly SparseVectorStorage<System.Numerics.Complex> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseVector(SparseVectorStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseVector(int length)
			: this(new SparseVectorStorage<System.Numerics.Complex>(length))
		{
		}

		public static SparseVector OfVector(Vector<System.Numerics.Complex> vector)
		{
			return new SparseVector(SparseVectorStorage<System.Numerics.Complex>.OfVector(vector.Storage));
		}

		public static SparseVector OfEnumerable(IEnumerable<System.Numerics.Complex> enumerable)
		{
			return new SparseVector(SparseVectorStorage<System.Numerics.Complex>.OfEnumerable(enumerable));
		}

		public static SparseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, System.Numerics.Complex>> enumerable)
		{
			return new SparseVector(SparseVectorStorage<System.Numerics.Complex>.OfIndexedEnumerable(length, enumerable));
		}

		public static SparseVector Create(int length, System.Numerics.Complex value)
		{
			return new SparseVector(SparseVectorStorage<System.Numerics.Complex>.OfValue(length, value));
		}

		public static SparseVector Create(int length, Func<int, System.Numerics.Complex> init)
		{
			return new SparseVector(SparseVectorStorage<System.Numerics.Complex>.OfInit(length, init));
		}

		protected override void DoAdd(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			if (scalar == System.Numerics.Complex.Zero)
			{
				if (this != result)
				{
					CopyTo(result);
				}
			}
			else if (this == result)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[base.Count];
				int[] array2 = new int[base.Count];
				for (int i = 0; i < base.Count; i++)
				{
					array2[i] = i;
					array[i] = scalar;
				}
				int[] indices = _storage.Indices;
				System.Numerics.Complex[] values = _storage.Values;
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					array[indices[j]] = values[j] + scalar;
				}
				_storage.Values = array;
				_storage.Indices = array2;
				_storage.ValueCount = base.Count;
			}
			else
			{
				for (int k = 0; k < base.Count; k++)
				{
					result.At(k, At(k) + scalar);
				}
			}
		}

		protected override void DoAdd(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<System.Numerics.Complex> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							System.Numerics.Complex value = storage.Values[num2];
							if (!System.Numerics.Complex.Zero.Equals(value))
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], value);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] += storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num3 = 0;
				int num4 = 0;
				int num5 = -1;
				while (num3 < _storage.ValueCount || num4 < storage.ValueCount)
				{
					if (num4 >= storage.ValueCount || (num3 < _storage.ValueCount && _storage.Indices[num3] <= storage.Indices[num4]))
					{
						int num6 = _storage.Indices[num3];
						if (num6 != num5)
						{
							num5 = num6;
							result.At(num6, _storage.Values[num3] + sparseVector.At(num6));
						}
						num3++;
					}
					else
					{
						int num7 = storage.Indices[num4];
						if (num7 != num5)
						{
							num5 = num7;
							result.At(num7, At(num7) + storage.Values[num4]);
						}
						num4++;
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			DoAdd(-scalar, result);
		}

		protected override void DoSubtract(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			if (this == other)
			{
				result.Clear();
			}
			else if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<System.Numerics.Complex> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							System.Numerics.Complex complex = storage.Values[num2];
							if (!System.Numerics.Complex.Zero.Equals(complex))
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], -complex);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] -= storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num3 = 0;
				int num4 = 0;
				int num5 = -1;
				while (num3 < _storage.ValueCount || num4 < storage.ValueCount)
				{
					if (num4 >= storage.ValueCount || (num3 < _storage.ValueCount && _storage.Indices[num3] <= storage.Indices[num4]))
					{
						int num6 = _storage.Indices[num3];
						if (num6 != num5)
						{
							num5 = num6;
							result.At(num6, _storage.Values[num3] - sparseVector.At(num6));
						}
						num3++;
					}
					else
					{
						int num7 = storage.Indices[num4];
						if (num7 != num5)
						{
							num5 = num7;
							result.At(num7, At(num7) - storage.Values[num4]);
						}
						num4++;
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoNegate(Vector<System.Numerics.Complex> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new System.Numerics.Complex[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(-System.Numerics.Complex.One, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], -_storage.Values[i]);
				}
			}
		}

		protected override void DoConjugate(Vector<System.Numerics.Complex> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new System.Numerics.Complex[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ConjugateArray(sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], _storage.Values[i].Conjugate());
				}
			}
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new System.Numerics.Complex[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], scalar * _storage.Values[i]);
				}
			}
		}

		protected override System.Numerics.Complex DoDotProduct(Vector<System.Numerics.Complex> other)
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			if (this == other)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					zero += _storage.Values[i] * _storage.Values[i];
				}
			}
			else
			{
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					zero += _storage.Values[j] * other.At(_storage.Indices[j]);
				}
			}
			return zero;
		}

		protected override System.Numerics.Complex DoConjugateDotProduct(Vector<System.Numerics.Complex> other)
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			if (this == other)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					zero += _storage.Values[i].Conjugate() * _storage.Values[i];
				}
			}
			else
			{
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					zero += _storage.Values[j].Conjugate() * other.At(_storage.Indices[j]);
				}
			}
			return zero;
		}

		public static SparseVector operator +(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Add(rightSide);
		}

		public static SparseVector operator -(SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Negate();
		}

		public static SparseVector operator -(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Subtract(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(System.Numerics.Complex leftSide, SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Multiply(leftSide);
		}

		public static System.Numerics.Complex operator *(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static SparseVector operator /(SparseVector leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Divide(rightSide);
		}

		public static SparseVector operator %(SparseVector leftSide, System.Numerics.Complex rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Modulus(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			double num2 = _storage.Values[num].Magnitude;
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				double magnitude = _storage.Values[i].Magnitude;
				if (magnitude < num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return _storage.Indices[num];
		}

		public override int AbsoluteMaximumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			double num2 = _storage.Values[num].Magnitude;
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				double magnitude = _storage.Values[i].Magnitude;
				if (magnitude > num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return _storage.Indices[num];
		}

		public override System.Numerics.Complex Sum()
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				zero += _storage.Values[i];
			}
			return zero;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += _storage.Values[i].Magnitude;
			}
			return num;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, _storage.ValueCount, (int i) => _storage.Values[i].Magnitude, Math.Max, 0.0);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (_storage.ValueCount == 0)
			{
				return 0.0;
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += Math.Pow(_storage.Values[i].Magnitude, p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			if (this == other && this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] *= _storage.Values[i];
				}
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		public static SparseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			string[] array = value.Split(new string[1] { formatProvider.GetTextInfo().ListSeparator }, StringSplitOptions.RemoveEmptyEntries);
			List<System.Numerics.Complex> list = new List<System.Numerics.Complex>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				string[] array3 = array2[i].Split(new string[2] { " ", "\t" }, StringSplitOptions.RemoveEmptyEntries);
				string text = string.Empty;
				for (int j = 0; j < array3.Length; j++)
				{
					text += array3[j];
					if (!text.EndsWith("+") && !text.EndsWith("-") && (!text.StartsWith("(") || text.EndsWith(")")))
					{
						string text2 = ((j < array3.Length - 1) ? array3[j + 1] : string.Empty);
						if (!text2.StartsWith("+") && !text2.StartsWith("-"))
						{
							list.Add(text.ToComplex(formatProvider));
							text = string.Empty;
						}
					}
				}
				if (text != string.Empty)
				{
					throw new FormatException();
				}
			}
			if (list.Count == 0)
			{
				throw new FormatException();
			}
			return OfEnumerable(list);
		}

		public static bool TryParse(string value, out SparseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out SparseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseVector {base.Count}-Complex {(double)NonZerosCount / (double)base.Count:P2} Filled");
		}
	}
	[Serializable]
	public abstract class Vector : Vector<System.Numerics.Complex>
	{
		protected Vector(VectorStorage<System.Numerics.Complex> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((System.Numerics.Complex x) => (!(x.Magnitude < threshold)) ? x : System.Numerics.Complex.Zero);
		}

		protected override void DoConjugate(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Conjugate, result);
		}

		protected override void DoNegate(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Negate, result);
		}

		protected override void DoAdd(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Add, other, result);
		}

		protected override void DoSubtract(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Subtract, other, result);
		}

		protected override void DoMultiply(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x * scalar, result);
		}

		protected override void DoDivide(System.Numerics.Complex divisor, Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x / divisor, result, divisor.IsZero() ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(System.Numerics.Complex dividend, Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoPointwiseMultiply(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Multiply, other, result);
		}

		protected override void DoPointwiseDivide(Vector<System.Numerics.Complex> divisor, Vector<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Divide, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(System.Numerics.Complex exponent, Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => x.Power(exponent), result, Zeros.Include);
		}

		protected override void DoPointwisePower(Vector<System.Numerics.Complex> exponent, Vector<System.Numerics.Complex> result)
		{
			Map2(System.Numerics.Complex.Pow, exponent, result, Zeros.Include);
		}

		protected sealed override void DoPointwiseModulus(Vector<System.Numerics.Complex> divisor, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoPointwiseRemainder(Vector<System.Numerics.Complex> divisor, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseExp(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Exp, result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Log, result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Vector<System.Numerics.Complex> result)
		{
			Map((System.Numerics.Complex x) => System.Numerics.Complex.Abs(x), result);
		}

		protected override void DoPointwiseAcos(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Acos, result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Asin, result);
		}

		protected override void DoPointwiseAtan(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Atan, result);
		}

		protected override void DoPointwiseAtan2(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAtan2(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCeiling(Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseCos(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Cos, result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Cosh, result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseLog10(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Log10, result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSign(Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseSin(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Sin, result);
		}

		protected override void DoPointwiseSinh(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Sinh, result);
		}

		protected override void DoPointwiseSqrt(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Sqrt, result);
		}

		protected override void DoPointwiseTan(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Tan, result);
		}

		protected override void DoPointwiseTanh(Vector<System.Numerics.Complex> result)
		{
			Map(System.Numerics.Complex.Tanh, result);
		}

		protected override System.Numerics.Complex DoDotProduct(Vector<System.Numerics.Complex> other)
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < base.Count; i++)
			{
				zero += At(i) * other.At(i);
			}
			return zero;
		}

		protected override System.Numerics.Complex DoConjugateDotProduct(Vector<System.Numerics.Complex> other)
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < base.Count; i++)
			{
				zero += At(i).Conjugate() * other.At(i);
			}
			return zero;
		}

		protected sealed override void DoModulus(System.Numerics.Complex divisor, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoModulusByThis(System.Numerics.Complex dividend, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainder(System.Numerics.Complex divisor, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected sealed override void DoRemainderByThis(System.Numerics.Complex dividend, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMinimum(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			double absolute = scalar.Magnitude;
			Map((System.Numerics.Complex x) => Math.Min(absolute, x.Magnitude), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(System.Numerics.Complex scalar, Vector<System.Numerics.Complex> result)
		{
			double absolute = scalar.Magnitude;
			Map((System.Numerics.Complex x) => Math.Max(absolute, x.Magnitude), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseMaximum(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			throw new NotSupportedException();
		}

		protected override void DoPointwiseAbsoluteMinimum(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			Map2((System.Numerics.Complex x, System.Numerics.Complex y) => Math.Min(x.Magnitude, y.Magnitude), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Vector<System.Numerics.Complex> other, Vector<System.Numerics.Complex> result)
		{
			Map2((System.Numerics.Complex x, System.Numerics.Complex y) => Math.Max(x.Magnitude, y.Magnitude), other, result);
		}

		public sealed override System.Numerics.Complex AbsoluteMinimum()
		{
			return At(AbsoluteMinimumIndex()).Magnitude;
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			double num2 = At(num).Magnitude;
			for (int i = 1; i < base.Count; i++)
			{
				double magnitude = At(i).Magnitude;
				if (magnitude < num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override System.Numerics.Complex AbsoluteMaximum()
		{
			return At(AbsoluteMaximumIndex()).Magnitude;
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			double num2 = At(num).Magnitude;
			for (int i = 1; i < base.Count; i++)
			{
				double magnitude = At(i).Magnitude;
				if (magnitude > num2)
				{
					num = i;
					num2 = magnitude;
				}
			}
			return num;
		}

		public override System.Numerics.Complex Sum()
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = 0; i < base.Count; i++)
			{
				zero += At(i);
			}
			return zero;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += At(i).Magnitude;
			}
			return num;
		}

		public override double L2Norm()
		{
			return DoConjugateDotProduct(this).SquareRoot().Real;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, base.Count, (int i) => At(i).Magnitude, Math.Max, 0.0);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += Math.Pow(At(i).Magnitude, p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		public override int MaximumIndex()
		{
			throw new NotSupportedException();
		}

		public override int MinimumIndex()
		{
			throw new NotSupportedException();
		}

		public override Vector<System.Numerics.Complex> Normalize(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			double num = Norm(p);
			Vector<System.Numerics.Complex> vector = Clone();
			if (num == 0.0)
			{
				return vector;
			}
			vector.Multiply(1.0 / num, vector);
			return vector;
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Complex.Solvers
{
	public sealed class BiCgStab : IIterativeSolver<System.Numerics.Complex>
	{
		private static void CalculateTrueResidual(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> residual, Vector<System.Numerics.Complex> x, Vector<System.Numerics.Complex> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result, Iterator<System.Numerics.Complex> iterator, IPreconditioner<System.Numerics.Complex> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, result);
			}
			if (iterator == null)
			{
				iterator = new Iterator<System.Numerics.Complex>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<System.Numerics.Complex>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector, result, input);
			Vector<System.Numerics.Complex> vector = denseVector.Clone();
			DenseVector denseVector2 = new DenseVector(denseVector.Count);
			DenseVector denseVector3 = new DenseVector(denseVector.Count);
			DenseVector denseVector4 = new DenseVector(denseVector.Count);
			DenseVector denseVector5 = new DenseVector(denseVector.Count);
			DenseVector denseVector6 = new DenseVector(denseVector.Count);
			DenseVector denseVector7 = new DenseVector(denseVector.Count);
			DenseVector denseVector8 = new DenseVector(denseVector.Count);
			System.Numerics.Complex complex = 0;
			System.Numerics.Complex complex2 = 0;
			System.Numerics.Complex complex3 = 0;
			int num = 0;
			while (iterator.DetermineStatus(num, result, input, denseVector) == IterationStatus.Continue)
			{
				System.Numerics.Complex complex4 = complex;
				complex = vector.ConjugateDotProduct(denseVector);
				if (complex.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
				{
					throw new NumericalBreakdownException();
				}
				if (num != 0)
				{
					System.Numerics.Complex scalar = complex / complex4 * (complex2 / complex3);
					denseVector4.Multiply(-complex3, denseVector7);
					denseVector2.Add(denseVector7, denseVector8);
					denseVector8.CopyTo(denseVector2);
					denseVector2.Multiply(scalar, denseVector2);
					denseVector2.Add(denseVector, denseVector8);
					denseVector8.CopyTo(denseVector2);
				}
				else
				{
					denseVector.CopyTo(denseVector2);
				}
				preconditioner.Approximate(denseVector2, denseVector3);
				matrix.Multiply(denseVector3, denseVector4);
				complex2 = complex * 1 / vector.ConjugateDotProduct(denseVector4);
				denseVector4.Multiply(-complex2, denseVector7);
				denseVector.Add(denseVector7, denseVector5);
				denseVector3.Multiply(complex2, denseVector7);
				denseVector7.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector7);
				denseVector7.Add(result, denseVector8);
				denseVector8.CopyTo(denseVector7);
				if (iterator.DetermineStatus(num, denseVector7, input, denseVector5) != 0)
				{
					denseVector7.CopyTo(result);
					CalculateTrueResidual(matrix, denseVector, result, input);
					if (iterator.DetermineStatus(num, result, input, denseVector) != 0)
					{
						break;
					}
					num++;
					continue;
				}
				preconditioner.Approximate(denseVector5, denseVector6);
				matrix.Multiply(denseVector6, denseVector7);
				complex3 = denseVector7.ConjugateDotProduct(denseVector5) / denseVector7.ConjugateDotProduct(denseVector7);
				denseVector7.Multiply(-complex3, denseVector);
				denseVector.Add(denseVector5, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector6.Multiply(complex3, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				denseVector3.Multiply(complex2, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				if (complex3.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex3.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
				{
					throw new NumericalBreakdownException();
				}
				if (iterator.DetermineStatus(num, result, input, denseVector) != 0)
				{
					CalculateTrueResidual(matrix, denseVector, result, input);
				}
				num++;
			}
		}
	}
	public sealed class CompositeSolver : IIterativeSolver<System.Numerics.Complex>
	{
		private readonly List<Tuple<IIterativeSolver<System.Numerics.Complex>, IPreconditioner<System.Numerics.Complex>>> _solvers;

		public CompositeSolver(IEnumerable<IIterativeSolverSetup<System.Numerics.Complex>> solvers)
		{
			_solvers = solvers.Select((IIterativeSolverSetup<System.Numerics.Complex> setup) => new Tuple<IIterativeSolver<System.Numerics.Complex>, IPreconditioner<System.Numerics.Complex>>(setup.CreateSolver(), setup.CreatePreconditioner() ?? new UnitPreconditioner<System.Numerics.Complex>())).ToList();
		}

		public void Solve(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result, Iterator<System.Numerics.Complex> iterator, IPreconditioner<System.Numerics.Complex> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (iterator == null)
			{
				iterator = new Iterator<System.Numerics.Complex>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<System.Numerics.Complex>();
			}
			Vector<System.Numerics.Complex> vector = input.Clone();
			Vector<System.Numerics.Complex> vector2 = result.Clone();
			foreach (Tuple<IIterativeSolver<System.Numerics.Complex>, IPreconditioner<System.Numerics.Complex>> solver in _solvers)
			{
				IterationStatus status;
				try
				{
					iterator.Reset();
					solver.Item1.Solve(matrix, vector, vector2, iterator, solver.Item2 ?? preconditioner);
					status = iterator.Status;
				}
				catch (Exception)
				{
					input.CopyTo(vector);
					continue;
				}
				switch (status)
				{
				case IterationStatus.Converged:
					vector2.CopyTo(result);
					return;
				case IterationStatus.StoppedWithoutConvergence:
					vector2.CopyTo(result);
					break;
				default:
					input.CopyTo(vector);
					break;
				}
			}
		}
	}
	public sealed class DiagonalPreconditioner : IPreconditioner<System.Numerics.Complex>
	{
		private System.Numerics.Complex[] _inverseDiagonals;

		internal DiagonalMatrix DiagonalEntries()
		{
			DiagonalMatrix diagonalMatrix = new DiagonalMatrix(_inverseDiagonals.Length);
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				diagonalMatrix.At(i, i, 1 / _inverseDiagonals[i]);
			}
			return diagonalMatrix;
		}

		public void Initialize(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_inverseDiagonals = new System.Numerics.Complex[matrix.RowCount];
			for (int i = 0; i < matrix.RowCount; i++)
			{
				_inverseDiagonals[i] = 1 / matrix.At(i, i);
			}
		}

		public void Approximate(Vector<System.Numerics.Complex> rhs, Vector<System.Numerics.Complex> lhs)
		{
			if (_inverseDiagonals == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _inverseDiagonals.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				lhs[i] = rhs[i] * _inverseDiagonals[i];
			}
		}
	}
	public sealed class GpBiCg : IIterativeSolver<System.Numerics.Complex>
	{
		private int _numberOfBiCgStabSteps = 1;

		private int _numberOfGpbiCgSteps = 4;

		public int NumberOfBiCgStabSteps
		{
			get
			{
				return _numberOfBiCgStabSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfBiCgStabSteps = value;
			}
		}

		public int NumberOfGpBiCgSteps
		{
			get
			{
				return _numberOfGpbiCgSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfGpbiCgSteps = value;
			}
		}

		private static void CalculateTrueResidual(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> residual, Vector<System.Numerics.Complex> x, Vector<System.Numerics.Complex> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		private bool ShouldRunBiCgStabSteps(int iterationNumber)
		{
			int num = iterationNumber % (_numberOfBiCgStabSteps + _numberOfGpbiCgSteps);
			if (num >= 0)
			{
				return num < _numberOfBiCgStabSteps;
			}
			return false;
		}

		public void Solve(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result, Iterator<System.Numerics.Complex> iterator, IPreconditioner<System.Numerics.Complex> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (input.Count != matrix.RowCount || result.Count != input.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix, input, result);
			}
			if (iterator == null)
			{
				iterator = new Iterator<System.Numerics.Complex>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<System.Numerics.Complex>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			System.Numerics.Complex scalar = 0;
			DenseVector denseVector3 = DenseVector.OfVector(denseVector2);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			DenseVector denseVector12 = new DenseVector(denseVector2.Count);
			DenseVector denseVector13 = new DenseVector(denseVector2.Count);
			DenseVector denseVector14 = new DenseVector(denseVector2.Count);
			DenseVector denseVector15 = new DenseVector(denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				denseVector8.Subtract(denseVector10, denseVector13);
				denseVector13.Multiply(scalar, denseVector14);
				denseVector2.Add(denseVector14, denseVector8);
				preconditioner.Approximate(denseVector8, denseVector13);
				matrix.Multiply(denseVector13, denseVector9);
				System.Numerics.Complex complex = denseVector3.ConjugateDotProduct(denseVector2) / denseVector3.ConjugateDotProduct(denseVector9);
				denseVector9.Subtract(denseVector6, denseVector13);
				denseVector4.Subtract(denseVector2, denseVector11);
				denseVector13.Multiply(complex, denseVector14);
				denseVector11.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector11);
				denseVector4.CopyTo(denseVector5);
				denseVector9.Multiply(-complex, denseVector14);
				denseVector2.Add(denseVector14, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector13);
				matrix.Multiply(denseVector13, denseVector7);
				System.Numerics.Complex complex2 = denseVector7.ConjugateDotProduct(denseVector7);
				if (complex2.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex2.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
				{
					complex2 = 1.0;
				}
				System.Numerics.Complex complex3 = denseVector7.ConjugateDotProduct(denseVector4);
				System.Numerics.Complex complex4;
				System.Numerics.Complex complex5;
				if ((_numberOfBiCgStabSteps == 0 && i == 0) || ShouldRunBiCgStabSteps(i))
				{
					complex4 = complex3 / complex2;
					complex5 = 0;
				}
				else
				{
					System.Numerics.Complex complex6 = denseVector11.ConjugateDotProduct(denseVector11);
					if (complex6.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex6.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
					{
						complex6 = 1.0;
					}
					System.Numerics.Complex complex7 = denseVector11.ConjugateDotProduct(denseVector4);
					System.Numerics.Complex complex8 = denseVector7.ConjugateDotProduct(denseVector11);
					System.Numerics.Complex complex9 = complex2 * complex6 - complex8 * complex8;
					complex4 = (complex6 * complex3 - complex7 * complex8) / complex9;
					complex5 = (complex2 * complex7 - complex8 * complex3) / complex9;
				}
				denseVector10.Multiply(scalar, denseVector14);
				denseVector5.Add(denseVector14, denseVector13);
				denseVector13.Subtract(denseVector2, denseVector15);
				denseVector15.CopyTo(denseVector13);
				denseVector13.Multiply(complex5, denseVector13);
				denseVector9.Multiply(complex4, denseVector14);
				denseVector13.Add(denseVector14, denseVector10);
				denseVector12.Multiply(complex5, denseVector12);
				denseVector10.Multiply(-complex, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector2.Multiply(complex4, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector8.Multiply(complex, denseVector14);
				denseVector.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector.Add(denseVector12, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector2.CopyTo(denseVector5);
				denseVector11.Multiply(-complex5, denseVector14);
				denseVector4.Add(denseVector14, denseVector2);
				denseVector7.Multiply(-complex4, denseVector14);
				denseVector2.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector2);
				scalar = ((!complex4.Real.AlmostEqualNumbersBetween(0.0, 1L) || !complex4.Imaginary.AlmostEqualNumbersBetween(0.0, 1L)) ? (complex / complex4 * denseVector3.ConjugateDotProduct(denseVector2) / denseVector3.ConjugateDotProduct(denseVector5)) : ((System.Numerics.Complex)0));
				denseVector9.Multiply(scalar, denseVector14);
				denseVector7.Add(denseVector14, denseVector6);
				preconditioner.Approximate(denseVector, result);
				if (iterator.DetermineStatus(i, result, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, result, input);
				}
			}
		}
	}
	public sealed class ILU0Preconditioner : IPreconditioner<System.Numerics.Complex>
	{
		private SparseMatrix _decompositionLU;

		internal Matrix<System.Numerics.Complex> UpperTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = i; j < _decompositionLU.ColumnCount; j++)
				{
					sparseMatrix[i, j] = _decompositionLU[i, j];
				}
			}
			return sparseMatrix;
		}

		internal Matrix<System.Numerics.Complex> LowerTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j <= i; j++)
				{
					if (i == j)
					{
						sparseMatrix[i, j] = 1.0;
					}
					else
					{
						sparseMatrix[i, j] = _decompositionLU[i, j];
					}
				}
			}
			return sparseMatrix;
		}

		public void Initialize(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_decompositionLU = SparseMatrix.OfMatrix(matrix);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j < i; j++)
				{
					if (!(_decompositionLU[i, j] != 0.0))
					{
						continue;
					}
					System.Numerics.Complex complex = _decompositionLU[i, j] / _decompositionLU[j, j];
					_decompositionLU[i, j] = complex;
					if (_decompositionLU[j, i] != 0.0)
					{
						_decompositionLU[i, i] -= complex * _decompositionLU[j, i];
					}
					for (int k = j + 1; k < _decompositionLU.RowCount; k++)
					{
						if (k != i && _decompositionLU[i, k] != 0.0)
						{
							_decompositionLU[i, k] -= complex * _decompositionLU[j, k];
						}
					}
				}
			}
		}

		public void Approximate(Vector<System.Numerics.Complex> rhs, Vector<System.Numerics.Complex> lhs)
		{
			if (_decompositionLU == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _decompositionLU.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			DenseVector denseVector = new DenseVector(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				denseVector.Clear();
				_decompositionLU.Row(i, denseVector);
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = 0; j < i; j++)
				{
					zero += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - zero;
			}
			for (int num = _decompositionLU.RowCount - 1; num > -1; num--)
			{
				_decompositionLU.Row(num, denseVector);
				System.Numerics.Complex zero2 = System.Numerics.Complex.Zero;
				for (int num2 = _decompositionLU.RowCount - 1; num2 > num; num2--)
				{
					zero2 += denseVector[num2] * lhs[num2];
				}
				lhs[num] = 1 / denseVector[num] * (lhs[num] - zero2);
			}
		}
	}
	public sealed class ILUTPPreconditioner : IPreconditioner<System.Numerics.Complex>
	{
		public const double DefaultFillLevel = 200.0;

		public const double DefaultDropTolerance = 0.0001;

		private SparseMatrix _upper;

		private SparseMatrix _lower;

		private int[] _pivots;

		private double _fillLevel = 200.0;

		private double _dropTolerance = 0.0001;

		private double _pivotTolerance;

		public double FillLevel
		{
			get
			{
				return _fillLevel;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_fillLevel = value;
			}
		}

		public double DropTolerance
		{
			get
			{
				return _dropTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dropTolerance = value;
			}
		}

		public double PivotTolerance
		{
			get
			{
				return _pivotTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_pivotTolerance = value;
			}
		}

		public ILUTPPreconditioner()
		{
		}

		public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance)
		{
			if (fillLevel < 0.0)
			{
				throw new ArgumentOutOfRangeException("fillLevel");
			}
			if (dropTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("dropTolerance");
			}
			if (pivotTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("pivotTolerance");
			}
			_fillLevel = fillLevel;
			_dropTolerance = dropTolerance;
			_pivotTolerance = pivotTolerance;
		}

		internal Matrix<System.Numerics.Complex> UpperTriangle()
		{
			return _upper.Clone();
		}

		internal Matrix<System.Numerics.Complex> LowerTriangle()
		{
			return _lower.Clone();
		}

		internal int[] Pivots()
		{
			int[] array = new int[_pivots.Length];
			for (int i = 0; i < _pivots.Length; i++)
			{
				array[i] = _pivots[i];
			}
			return array;
		}

		public void Initialize(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			SparseMatrix sparseMatrix = (matrix as SparseMatrix) ?? SparseMatrix.OfMatrix(matrix);
			_lower = new SparseMatrix(sparseMatrix.RowCount);
			_upper = new SparseMatrix(sparseMatrix.RowCount);
			_pivots = new int[sparseMatrix.RowCount];
			for (int i = 0; i < _pivots.Length; i++)
			{
				_pivots[i] = i;
			}
			DenseVector denseVector = new DenseVector(sparseMatrix.RowCount);
			DenseVector denseVector2 = new DenseVector(sparseMatrix.ColumnCount);
			int[] array = new int[sparseMatrix.RowCount];
			int num = (int)_fillLevel * sparseMatrix.NonZerosCount;
			for (int j = 0; j < sparseMatrix.RowCount; j++)
			{
				sparseMatrix.Row(j, denseVector);
				PivotRow(denseVector);
				double num2 = denseVector.InfinityNorm();
				for (int k = 0; k < j; k++)
				{
					if (!(denseVector[k] != 0.0))
					{
						continue;
					}
					denseVector[k] /= _upper[k, k];
					if (denseVector[k].Magnitude < _dropTolerance)
					{
						denseVector[k] = 0.0;
					}
					if (denseVector[k] != 0.0)
					{
						_upper.Row(k, denseVector2);
						for (int l = 0; l <= k; l++)
						{
							denseVector2[l] = 0.0;
						}
						denseVector2.Multiply(denseVector[k], denseVector2);
						denseVector.Subtract(denseVector2, denseVector);
					}
				}
				for (int m = j; m < sparseMatrix.RowCount; m++)
				{
					if (denseVector[m].Magnitude <= _dropTolerance * num2)
					{
						denseVector[m] = 0.0;
					}
				}
				int num3 = num / (sparseMatrix.RowCount - j + 1);
				int num4 = num3 / 2;
				FindLargestItems(0, j - 1, array, denseVector);
				int num5 = 0;
				int num6 = 0;
				for (int n = 0; n < j; n++)
				{
					if (num6 > num4)
					{
						break;
					}
					if (array[n] == -1)
					{
						break;
					}
					_lower[j, array[n]] = denseVector[array[n]];
					num6++;
					num5++;
				}
				FindLargestItems(j + 1, sparseMatrix.RowCount - 1, array, denseVector);
				num4 = num3 - num5;
				int num7 = 0;
				num6 = 0;
				for (int num8 = 0; num8 < sparseMatrix.RowCount - j; num8++)
				{
					if (num6 > num4 - 1)
					{
						break;
					}
					if (array[num8] == -1)
					{
						break;
					}
					_upper[j, array[num8]] = denseVector[array[num8]];
					num6++;
					num7++;
				}
				_upper[j, j] = denseVector[j];
				if (j + 1 < sparseMatrix.RowCount - 1 && denseVector[j].Magnitude < _pivotTolerance * denseVector[array[0]].Magnitude)
				{
					SwapColumns(_upper, j, array[0]);
					int num9 = _pivots[j];
					_pivots[j] = _pivots[array[0]];
					_pivots[array[0]] = num9;
				}
				num -= num5 + num7;
			}
			for (int num10 = 0; num10 < _lower.RowCount; num10++)
			{
				_lower[num10, num10] = 1.0;
			}
		}

		private void PivotRow(Vector<System.Numerics.Complex> row)
		{
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			for (int i = 0; i < row.Count; i++)
			{
				if (_pivots[i] != i && !PivotMapFound(dictionary, i))
				{
					dictionary.Add(_pivots[i], i);
					System.Numerics.Complex value = row[i];
					row[i] = row[_pivots[i]];
					row[_pivots[i]] = value;
				}
			}
		}

		private bool PivotMapFound(Dictionary<int, int> knownPivots, int currentItem)
		{
			if (knownPivots.TryGetValue(_pivots[currentItem], out var value) && value.Equals(currentItem))
			{
				return true;
			}
			if (knownPivots.TryGetValue(currentItem, out var value2) && value2.Equals(_pivots[currentItem]))
			{
				return true;
			}
			return false;
		}

		private static void SwapColumns(Matrix<System.Numerics.Complex> matrix, int firstColumn, int secondColumn)
		{
			for (int i = 0; i < matrix.RowCount; i++)
			{
				System.Numerics.Complex value = matrix[i, firstColumn];
				matrix[i, firstColumn] = matrix[i, secondColumn];
				matrix[i, secondColumn] = value;
			}
		}

		private static void FindLargestItems(int lowerBound, int upperBound, int[] sortedIndices, Vector<System.Numerics.Complex> values)
		{
			for (int i = 0; i < upperBound + 1 - lowerBound; i++)
			{
				sortedIndices[i] = lowerBound + i;
			}
			for (int j = upperBound + 1 - lowerBound; j < sortedIndices.Length; j++)
			{
				sortedIndices[j] = -1;
			}
			ILUTPElementSorter.SortDoubleIndicesDecreasing(0, upperBound - lowerBound, sortedIndices, values);
		}

		public void Approximate(Vector<System.Numerics.Complex> rhs, Vector<System.Numerics.Complex> lhs)
		{
			if (_upper == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _upper.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			DenseVector denseVector = new DenseVector(_lower.RowCount);
			for (int i = 0; i < _lower.RowCount; i++)
			{
				_lower.Row(i, denseVector);
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = 0; j < i; j++)
				{
					zero += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - zero;
			}
			for (int num = _upper.RowCount - 1; num > -1; num--)
			{
				_upper.Row(num, denseVector);
				System.Numerics.Complex zero2 = System.Numerics.Complex.Zero;
				for (int num2 = _upper.RowCount - 1; num2 > num; num2--)
				{
					zero2 += denseVector[num2] * lhs[num2];
				}
				lhs[num] = 1 / denseVector[num] * (lhs[num] - zero2);
			}
			Vector<System.Numerics.Complex> vector = lhs.Clone();
			Pivot(vector, lhs);
		}

		private void Pivot(Vector<System.Numerics.Complex> vector, Vector<System.Numerics.Complex> result)
		{
			for (int i = 0; i < _pivots.Length; i++)
			{
				result[i] = vector[_pivots[i]];
			}
		}
	}
	internal static class ILUTPElementSorter
	{
		public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, int[] sortedIndices, Vector<System.Numerics.Complex> values)
		{
			if (lowerBound > 0)
			{
				for (int i = 0; i < upperBound - lowerBound + 1; i++)
				{
					Exchange(sortedIndices, i, i + lowerBound);
				}
				upperBound -= lowerBound;
				lowerBound = 0;
			}
			HeapSortDoublesIndices(lowerBound, upperBound, sortedIndices, values);
		}

		private static void HeapSortDoublesIndices(int lowerBound, int upperBound, int[] sortedIndices, Vector<System.Numerics.Complex> values)
		{
			int start = (upperBound - lowerBound + 1) / 2 - 1 + lowerBound;
			int num = upperBound - lowerBound + 1 - 1 + lowerBound;
			BuildDoubleIndexHeap(start, upperBound - lowerBound + 1, sortedIndices, values);
			while (num >= lowerBound)
			{
				Exchange(sortedIndices, num, lowerBound);
				SiftDoubleIndices(sortedIndices, values, lowerBound, num);
				num--;
			}
		}

		private static void BuildDoubleIndexHeap(int start, int count, int[] sortedIndices, Vector<System.Numerics.Complex> values)
		{
			while (start >= 0)
			{
				SiftDoubleIndices(sortedIndices, values, start, count);
				start--;
			}
		}

		private static void SiftDoubleIndices(int[] sortedIndices, Vector<System.Numerics.Complex> values, int begin, int count)
		{
			int num = begin;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[sortedIndices[num2]].Magnitude > values[sortedIndices[num2 + 1]].Magnitude)
				{
					num2++;
				}
				if (values[sortedIndices[num]].Magnitude <= values[sortedIndices[num2]].Magnitude)
				{
					break;
				}
				Exchange(sortedIndices, num, num2);
				num = num2;
			}
		}

		public static void SortIntegersDecreasing(int[] values)
		{
			HeapSortIntegers(values, values.Length);
		}

		private static void HeapSortIntegers(int[] values, int count)
		{
			int start = count / 2 - 1;
			int num = count - 1;
			BuildHeap(values, start, count);
			while (num >= 0)
			{
				Exchange(values, num, 0);
				Sift(values, 0, num);
				num--;
			}
		}

		private static void BuildHeap(int[] values, int start, int count)
		{
			while (start >= 0)
			{
				Sift(values, start, count);
				start--;
			}
		}

		private static void Sift(int[] values, int start, int count)
		{
			int num = start;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[num2] > values[num2 + 1])
				{
					num2++;
				}
				if (values[num] > values[num2])
				{
					Exchange(values, num, num2);
					num = num2;
					continue;
				}
				break;
			}
		}

		private static void Exchange(int[] values, int first, int second)
		{
			int num = values[first];
			values[first] = values[second];
			values[second] = num;
		}
	}
	public sealed class MILU0Preconditioner : IPreconditioner<System.Numerics.Complex>
	{
		private System.Numerics.Complex[] _alu;

		private int[] _jlu;

		private int[] _diag;

		public bool UseModified { get; set; }

		public bool IsInitialized { get; private set; }

		public MILU0Preconditioner(bool modified = true)
		{
			UseModified = modified;
		}

		public void Initialize(Matrix<System.Numerics.Complex> matrix)
		{
			if (!(matrix.Storage is SparseCompressedRowMatrixStorage<System.Numerics.Complex> sparseCompressedRowMatrixStorage))
			{
				throw new ArgumentException("Matrix must be in sparse storage format", "matrix");
			}
			int rowCount = sparseCompressedRowMatrixStorage.RowCount;
			if (rowCount != sparseCompressedRowMatrixStorage.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			System.Numerics.Complex[] values = sparseCompressedRowMatrixStorage.Values;
			int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			_alu = new System.Numerics.Complex[rowPointers[rowCount] + 1];
			_jlu = new int[rowPointers[rowCount] + 1];
			_diag = new int[rowCount];
			int num = Compute(rowCount, values, columnIndices, rowPointers, _alu, _jlu, _diag, UseModified);
			if (num > -1)
			{
				throw new NumericalBreakdownException("Zero pivot encountered on row " + num + " during ILU process");
			}
			IsInitialized = true;
		}

		public void Approximate(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (_alu == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (result.Count != input.Count || result.Count != _diag.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			int num = _diag.Length;
			for (int i = 0; i < num; i++)
			{
				result[i] = input[i];
				for (int j = _jlu[i]; j < _diag[i]; j++)
				{
					result[i] -= _alu[j] * result[_jlu[j]];
				}
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				for (int k = _diag[num2]; k < _jlu[num2 + 1]; k++)
				{
					result[num2] -= _alu[k] * result[_jlu[k]];
				}
				result[num2] = _alu[num2] * result[num2];
			}
		}

		private int Compute(int n, System.Numerics.Complex[] a, int[] ja, int[] ia, System.Numerics.Complex[] alu, int[] jlu, int[] ju, bool modified)
		{
			int[] array = new int[n];
			int num = (jlu[0] = n + 1);
			for (int i = 0; i < n; i++)
			{
				array[i] = -1;
			}
			for (int i = 0; i < n; i++)
			{
				int num2 = num;
				for (int j = ia[i]; j < ia[i + 1]; j++)
				{
					int num3 = ja[j];
					if (num3 == i)
					{
						alu[i] = a[j];
						array[num3] = i;
						ju[i] = num;
					}
					else
					{
						alu[num] = a[j];
						jlu[num] = ja[j];
						array[num3] = num;
						num++;
					}
				}
				jlu[i + 1] = num;
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = num2; j < ju[i]; j++)
				{
					int num4 = jlu[j];
					System.Numerics.Complex complex = (alu[j] *= alu[num4]);
					for (int k = ju[num4]; k < jlu[num4 + 1]; k++)
					{
						int num5 = array[jlu[k]];
						if (num5 != -1)
						{
							alu[num5] -= complex * alu[k];
						}
						else
						{
							zero += complex * alu[k];
						}
					}
				}
				if (modified)
				{
					alu[i] -= zero;
				}
				if (alu[i] == System.Numerics.Complex.Zero)
				{
					return i;
				}
				alu[i] = 1.0 / alu[i];
				array[i] = -1;
				for (int k = num2; k < num; k++)
				{
					array[jlu[k]] = -1;
				}
			}
			return -1;
		}
	}
	public sealed class MlkBiCgStab : IIterativeSolver<System.Numerics.Complex>
	{
		private const int DefaultNumberOfStartingVectors = 50;

		private IList<Vector<System.Numerics.Complex>> _startingVectors;

		private int _numberOfStartingVectors = 50;

		public int NumberOfStartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _numberOfStartingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value <= 1)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfStartingVectors = value;
			}
		}

		public IList<Vector<System.Numerics.Complex>> StartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _startingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value == null || value.Count == 0)
				{
					_startingVectors = null;
				}
				else
				{
					_startingVectors = value;
				}
			}
		}

		public void ResetNumberOfStartingVectors()
		{
			_numberOfStartingVectors = 50;
		}

		private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			return Math.Min(maximumNumberOfStartingVectors, numberOfVariables - 1);
		}

		private static IList<Vector<System.Numerics.Complex>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			int columns = NumberOfStartingVectorsToCreate(maximumNumberOfStartingVectors, numberOfVariables);
			Normal normal = new Normal();
			DenseMatrix denseMatrix = new DenseMatrix(numberOfVariables, columns);
			for (int i = 0; i < denseMatrix.ColumnCount; i++)
			{
				System.Numerics.Complex[] array = new System.Numerics.Complex[denseMatrix.RowCount];
				double[] array2 = normal.Samples().Take(denseMatrix.RowCount).ToArray();
				double[] array3 = normal.Samples().Take(denseMatrix.RowCount).ToArray();
				for (int j = 0; j < denseMatrix.RowCount; j++)
				{
					array[j] = new System.Numerics.Complex(array2[j], array3[j]);
				}
				denseMatrix.SetColumn(i, array);
			}
			Matrix<System.Numerics.Complex> q = denseMatrix.GramSchmidt().Q;
			List<Vector<System.Numerics.Complex>> list = new List<Vector<System.Numerics.Complex>>(q.ColumnCount);
			for (int k = 0; k < q.ColumnCount; k++)
			{
				list.Add(q.Column(k));
				list[k].Multiply(1.0 / list[k].L2Norm(), list[k]);
			}
			return list;
		}

		private static Vector<System.Numerics.Complex>[] CreateVectorArray(int arraySize, int vectorSize)
		{
			Vector<System.Numerics.Complex>[] array = new Vector<System.Numerics.Complex>[arraySize];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new DenseVector(vectorSize);
			}
			return array;
		}

		private static void CalculateTrueResidual(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> residual, Vector<System.Numerics.Complex> x, Vector<System.Numerics.Complex> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result, Iterator<System.Numerics.Complex> iterator, IPreconditioner<System.Numerics.Complex> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (input.Count != matrix.RowCount || result.Count != input.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix, input, result);
			}
			if (iterator == null)
			{
				iterator = new Iterator<System.Numerics.Complex>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<System.Numerics.Complex>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			bool flag = false;
			if (_startingVectors != null && _startingVectors.Count <= NumberOfStartingVectorsToCreate(_numberOfStartingVectors, input.Count) && _startingVectors[0].Count == input.Count)
			{
				flag = true;
			}
			_startingVectors = (flag ? _startingVectors : CreateStartingVectors(_numberOfStartingVectors, input.Count));
			int count = _startingVectors.Count;
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			System.Numerics.Complex[] array = new System.Numerics.Complex[count];
			DenseVector denseVector3 = new DenseVector(denseVector2.Count);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			Vector<System.Numerics.Complex>[] array2 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			Vector<System.Numerics.Complex>[] array3 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			denseVector2.CopyTo(array3[count - 1]);
			Vector<System.Numerics.Complex>[] array4 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				preconditioner.Approximate(array3[count - 1], denseVector3);
				matrix.Multiply(denseVector3, array4[count - 1]);
				array[count - 1] = _startingVectors[0].ConjugateDotProduct(array4[count - 1]);
				if (array[count - 1].Real.AlmostEqualNumbersBetween(0.0, 1L) && array[count - 1].Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
				{
					throw new NumericalBreakdownException();
				}
				System.Numerics.Complex complex = _startingVectors[0].ConjugateDotProduct(denseVector2) / array[count - 1];
				array4[count - 1].Multiply(-complex, denseVector6);
				denseVector2.Add(denseVector6, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector7);
				denseVector7.CopyTo(denseVector5);
				matrix.Multiply(denseVector7, denseVector6);
				System.Numerics.Complex complex2 = denseVector6.ConjugateDotProduct(denseVector6);
				if (complex2.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex2.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
				{
					complex2 = 1.0;
				}
				complex2 = -denseVector4.ConjugateDotProduct(denseVector6) / complex2;
				denseVector4.CopyTo(denseVector2);
				denseVector6.Multiply(complex2, denseVector6);
				denseVector2.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector2);
				denseVector5.Multiply(-complex2, denseVector6);
				denseVector.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector3.Multiply(complex, denseVector3);
				denseVector.Add(denseVector3, denseVector8);
				denseVector8.CopyTo(denseVector);
				if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, denseVector, input);
					if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
					{
						break;
					}
				}
				for (int j = 0; j < count; j++)
				{
					denseVector4.CopyTo(denseVector9);
					denseVector2.CopyTo(denseVector10);
					denseVector11.Clear();
					System.Numerics.Complex scalar;
					if (i >= 1)
					{
						for (int k = j; k < count - 1; k++)
						{
							scalar = -_startingVectors[k + 1].ConjugateDotProduct(denseVector9) / array[k];
							array2[k].Multiply(scalar, denseVector6);
							denseVector9.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector9);
							array3[k].Multiply(scalar, denseVector6);
							denseVector10.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector10);
							array4[k].Multiply(scalar, denseVector6);
							denseVector11.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector11);
						}
					}
					scalar = complex2 * array[count - 1];
					if (scalar.Real.AlmostEqualNumbersBetween(0.0, 1L) && scalar.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
					{
						throw new NumericalBreakdownException();
					}
					denseVector11.Multiply(complex2, denseVector8);
					denseVector2.Add(denseVector8, denseVector6);
					scalar = -_startingVectors[0].ConjugateDotProduct(denseVector6) / scalar;
					array3[count - 1].Multiply(scalar, denseVector6);
					denseVector10.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector10);
					array4[count - 1].Multiply(scalar, denseVector6);
					denseVector11.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector11);
					denseVector11.Multiply(complex2, denseVector11);
					denseVector2.Add(denseVector11, denseVector9);
					for (int l = 0; l < j - 1; l++)
					{
						scalar = -_startingVectors[l + 1].ConjugateDotProduct(denseVector9) / array[l];
						array2[l].Multiply(scalar, denseVector6);
						denseVector9.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector9);
						array3[l].Multiply(scalar, denseVector6);
						denseVector10.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector10);
					}
					denseVector9.Subtract(denseVector4, array2[j]);
					denseVector10.Add(denseVector11, array3[j]);
					if (j < count - 1)
					{
						array[j] = _startingVectors[j + 1].ConjugateDotProduct(array2[j]);
						if (array[j].Real.AlmostEqualNumbersBetween(0.0, 1L) && array[j].Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
						{
							throw new NumericalBreakdownException();
						}
						complex = _startingVectors[j + 1].ConjugateDotProduct(denseVector4) / array[j];
						array2[j].Multiply(-complex, denseVector6);
						denseVector4.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector4);
						preconditioner.Approximate(array3[j], denseVector3);
						denseVector3.Multiply(complex2 * complex, denseVector6);
						denseVector.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector);
						matrix.Multiply(denseVector3, array4[j]);
						array4[j].Multiply(-complex2 * complex, denseVector6);
						denseVector2.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector2);
						if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
						{
							CalculateTrueResidual(matrix, denseVector2, denseVector, input);
						}
					}
				}
			}
			denseVector.CopyTo(result);
		}
	}
	public sealed class TFQMR : IIterativeSolver<System.Numerics.Complex>
	{
		private static void CalculateTrueResidual(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> residual, Vector<System.Numerics.Complex> x, Vector<System.Numerics.Complex> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1, residual);
			residual.Add(b, residual);
		}

		private static bool IsEven(int number)
		{
			return number % 2 == 0;
		}

		public void Solve(Matrix<System.Numerics.Complex> matrix, Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result, Iterator<System.Numerics.Complex> iterator, IPreconditioner<System.Numerics.Complex> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (input.Count != matrix.RowCount || result.Count != input.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix, input, result);
			}
			if (iterator == null)
			{
				iterator = new Iterator<System.Numerics.Complex>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<System.Numerics.Complex>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector denseVector2 = DenseVector.OfVector(input);
			DenseVector denseVector3 = new DenseVector(input.Count);
			DenseVector denseVector4 = new DenseVector(input.Count);
			DenseVector denseVector5 = new DenseVector(input.Count);
			DenseVector denseVector6 = DenseVector.OfVector(input);
			DenseVector denseVector7 = new DenseVector(input.Count);
			DenseVector denseVector8 = new DenseVector(input.Count);
			DenseVector denseVector9 = DenseVector.OfVector(input);
			DenseVector denseVector10 = new DenseVector(input.Count);
			DenseVector denseVector11 = new DenseVector(input.Count);
			DenseVector denseVector12 = new DenseVector(input.Count);
			System.Numerics.Complex complex = 0;
			System.Numerics.Complex complex2 = 0;
			double num = 0.0;
			double num2 = input.L2Norm();
			System.Numerics.Complex complex3 = num2 * num2;
			preconditioner.Approximate(denseVector9, denseVector10);
			matrix.Multiply(denseVector10, denseVector5);
			denseVector5.CopyTo(denseVector4);
			for (int i = 0; iterator.DetermineStatus(i, result, input, denseVector6) == IterationStatus.Continue; i++)
			{
				if (IsEven(i))
				{
					System.Numerics.Complex complex4 = denseVector2.ConjugateDotProduct(denseVector5);
					if (complex4.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex4.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
					{
						iterator.Cancel();
						break;
					}
					complex = complex3 / complex4;
					denseVector5.Multiply(-complex, denseVector11);
					denseVector9.Add(denseVector11, denseVector8);
					preconditioner.Approximate(denseVector8, denseVector10);
					matrix.Multiply(denseVector10, denseVector3);
				}
				DenseVector obj = (IsEven(i) ? denseVector4 : denseVector3);
				DenseVector denseVector13 = (IsEven(i) ? denseVector9 : denseVector8);
				obj.Multiply(-complex, denseVector11);
				denseVector6.Add(denseVector11, denseVector12);
				denseVector12.CopyTo(denseVector6);
				denseVector.Multiply(num * num * complex2 / complex, denseVector10);
				denseVector13.Add(denseVector10, denseVector);
				num = denseVector6.L2Norm() / num2;
				double num3 = 1.0 / Math.Sqrt(1.0 + num * num);
				num2 *= num * num3;
				complex2 = num3 * num3 * complex;
				denseVector.Multiply(complex2, denseVector11);
				denseVector7.Add(denseVector11, denseVector12);
				denseVector12.CopyTo(denseVector7);
				if (iterator.DetermineStatus(i, result, input, denseVector6) != 0)
				{
					preconditioner.Approximate(denseVector7, result);
					CalculateTrueResidual(matrix, denseVector10, result, input);
					if (iterator.DetermineStatus(i, result, input, denseVector10) != 0)
					{
						break;
					}
				}
				if (!IsEven(i))
				{
					if (complex3.Real.AlmostEqualNumbersBetween(0.0, 1L) && complex3.Imaginary.AlmostEqualNumbersBetween(0.0, 1L))
					{
						iterator.Cancel();
						break;
					}
					System.Numerics.Complex complex5 = denseVector2.ConjugateDotProduct(denseVector6);
					System.Numerics.Complex scalar = complex5 / complex3;
					complex3 = complex5;
					denseVector8.Multiply(scalar, denseVector11);
					denseVector6.Add(denseVector11, denseVector9);
					preconditioner.Approximate(denseVector9, denseVector10);
					matrix.Multiply(denseVector10, denseVector4);
					denseVector5.Multiply(scalar, denseVector11);
					denseVector3.Add(denseVector11, denseVector10);
					denseVector10.Multiply(scalar, denseVector11);
					denseVector4.Add(denseVector11, denseVector5);
				}
				preconditioner.Approximate(denseVector7, result);
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Complex.Factorization
{
	internal abstract class Cholesky : Cholesky<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Determinant
		{
			get
			{
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					System.Numerics.Complex complex = base.Factor.At(i, i);
					one *= complex * complex;
				}
				return one;
			}
		}

		public override System.Numerics.Complex DeterminantLn
		{
			get
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					zero += 2.0 * base.Factor.At(i, i).Ln();
				}
				return zero;
			}
		}

		protected Cholesky(Matrix<System.Numerics.Complex> factor)
			: base(factor)
		{
		}
	}
	internal sealed class DenseCholesky : Cholesky
	{
		public static DenseCholesky Create(DenseMatrix matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix.Values, denseMatrix.RowCount);
			return new DenseCholesky(denseMatrix);
		}

		private DenseCholesky(Matrix<System.Numerics.Complex> factor)
			: base(factor)
		{
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Array.Copy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length);
				DenseMatrix denseMatrix3 = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix3.Values, denseMatrix3.RowCount, denseMatrix2.Values, denseMatrix2.ColumnCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Array.Copy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length);
				DenseMatrix denseMatrix = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix.Values, denseMatrix.RowCount, denseVector2.Values, 1);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense vectors at the moment.");
		}

		public override void Factorize(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			if (matrix is DenseMatrix denseMatrix)
			{
				DenseMatrix denseMatrix2 = (DenseMatrix)base.Factor;
				Array.Copy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length);
				LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix2.Values, denseMatrix2.RowCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}
	}
	internal sealed class DenseEvd : Evd
	{
		public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			DenseMatrix denseMatrix = DenseMatrix.CreateIdentity(rowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(rowCount);
			DenseVector denseVector = new DenseVector(rowCount);
			bool isSymmetric = symmetricity switch
			{
				Symmetricity.Hermitian => true, 
				Symmetricity.Asymmetric => false, 
				_ => matrix.IsHermitian(), 
			};
			LinearAlgebraControl.Provider.EigenDecomp(isSymmetric, rowCount, matrix.Values, denseMatrix.Values, denseVector.Values, denseMatrix2.Values);
			return new DenseEvd(denseMatrix, denseVector, denseMatrix2, isSymmetric);
		}

		private DenseEvd(Matrix<System.Numerics.Complex> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<System.Numerics.Complex> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				System.Numerics.Complex[] array = new System.Numerics.Complex[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						System.Numerics.Complex complex = 0.0;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								complex += ((DenseMatrix)base.EigenVectors).Values[j * count + k].Conjugate() * input.At(k, i);
							}
							complex /= (System.Numerics.Complex)base.EigenValues[j].Real;
						}
						array[j] = complex;
					}
					for (int l = 0; l < count; l++)
					{
						System.Numerics.Complex value = 0.0;
						for (int m = 0; m < count; m++)
						{
							value += ((DenseMatrix)base.EigenVectors).Values[m * count + l] * array[m];
						}
						result.At(l, i, value);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(base.EigenValues, result);
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				System.Numerics.Complex[] array = new System.Numerics.Complex[count];
				for (int i = 0; i < count; i++)
				{
					System.Numerics.Complex complex = 0;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							complex += ((DenseMatrix)base.EigenVectors).Values[i * count + j].Conjugate() * input[j];
						}
						complex /= (System.Numerics.Complex)base.EigenValues[i].Real;
					}
					array[i] = complex;
				}
				for (int k = 0; k < count; k++)
				{
					System.Numerics.Complex complex = 0;
					for (int l = 0; l < count; l++)
					{
						complex += ((DenseMatrix)base.EigenVectors).Values[l * count + k] * array[l];
					}
					result[k] = complex;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class DenseGramSchmidt : GramSchmidt
	{
		public static DenseGramSchmidt Create(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount, matrix.ColumnCount);
			Factorize(denseMatrix.Values, denseMatrix.RowCount, denseMatrix.ColumnCount, denseMatrix2.Values);
			return new DenseGramSchmidt(denseMatrix, denseMatrix2);
		}

		private DenseGramSchmidt(Matrix<System.Numerics.Complex> q, Matrix<System.Numerics.Complex> rFull)
			: base(q, rFull)
		{
		}

		private static void Factorize(System.Numerics.Complex[] q, int rowsQ, int columnsQ, System.Numerics.Complex[] r)
		{
			for (int i = 0; i < columnsQ; i++)
			{
				double num = 0.0;
				for (int j = 0; j < rowsQ; j++)
				{
					num += q[i * rowsQ + j].Magnitude * q[i * rowsQ + j].Magnitude;
				}
				num = Math.Sqrt(num);
				if (num == 0.0)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				r[i * columnsQ + i] = num;
				for (int k = 0; k < rowsQ; k++)
				{
					q[i * rowsQ + k] /= (System.Numerics.Complex)num;
				}
				for (int l = i + 1; l < columnsQ; l++)
				{
					int num2 = i;
					int num3 = l;
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int m = 0; m < rowsQ; m++)
					{
						zero += q[num2 * rowsQ + m].Conjugate() * q[num3 * rowsQ + m];
					}
					r[l * columnsQ + i] = zero;
					for (int n = 0; n < rowsQ; n++)
					{
						q[l * rowsQ + n] -= q[i * rowsQ + n] * zero;
					}
				}
			}
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseVector.Values, 1, denseVector2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseLU : LU
	{
		public static DenseLU Create(DenseMatrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int[] array = new int[matrix.RowCount];
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.LUFactor(denseMatrix.Values, denseMatrix.RowCount, array);
			return new DenseLU(denseMatrix, array);
		}

		private DenseLU(Matrix<System.Numerics.Complex> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Array.Copy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length);
				DenseMatrix denseMatrix3 = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(input.ColumnCount, denseMatrix3.Values, denseMatrix3.RowCount, Pivots, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Array.Copy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length);
				DenseMatrix denseMatrix = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(1, denseMatrix.Values, denseMatrix.RowCount, Pivots, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense vectors at the moment.");
		}

		public override Matrix<System.Numerics.Complex> Inverse()
		{
			DenseMatrix denseMatrix = (DenseMatrix)Factors.Clone();
			LinearAlgebraControl.Provider.LUInverseFactored(denseMatrix.Values, denseMatrix.RowCount, Pivots);
			return denseMatrix;
		}
	}
	internal sealed class DenseQR : QR
	{
		private System.Numerics.Complex[] Tau { get; set; }

		public static DenseQR Create(DenseMatrix matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			System.Numerics.Complex[] tau = new System.Numerics.Complex[Math.Min(matrix.RowCount, matrix.ColumnCount)];
			Matrix<System.Numerics.Complex> matrix2;
			Matrix<System.Numerics.Complex> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = new DenseMatrix(matrix.RowCount);
				LinearAlgebraControl.Provider.QRFactor(((DenseMatrix)matrix2).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix3).Values, tau);
			}
			else
			{
				matrix3 = matrix.Clone();
				matrix2 = new DenseMatrix(matrix.ColumnCount);
				LinearAlgebraControl.Provider.ThinQRFactor(((DenseMatrix)matrix3).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix2).Values, tau);
			}
			return new DenseQR(matrix3, matrix2, method, tau);
		}

		private DenseQR(Matrix<System.Numerics.Complex> q, Matrix<System.Numerics.Complex> rFull, QRMethod method, System.Numerics.Complex[] tau)
			: base(q, rFull, method)
		{
			Tau = tau;
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseVector.Values, 1, denseVector2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseSvd : Svd
	{
		public static DenseSvd Create(DenseMatrix matrix, bool computeVectors)
		{
			DenseVector denseVector = new DenseVector(Math.Min(matrix.RowCount, matrix.ColumnCount));
			DenseMatrix denseMatrix = new DenseMatrix(matrix.RowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount);
			LinearAlgebraControl.Provider.SingularValueDecomposition(computeVectors, ((DenseMatrix)matrix.Clone()).Values, matrix.RowCount, matrix.ColumnCount, denseVector.Values, denseMatrix.Values, denseMatrix2.Values);
			return new DenseSvd(denseVector, denseMatrix, denseMatrix2, computeVectors);
		}

		private DenseSvd(Vector<System.Numerics.Complex> s, Matrix<System.Numerics.Complex> u, Matrix<System.Numerics.Complex> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseVector.Values, 1, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense vectors at the moment.");
		}
	}
	internal abstract class Evd : Evd<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Determinant
		{
			get
			{
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					one *= base.EigenValues[i];
					if (base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		public override int Rank
		{
			get
			{
				int num = 0;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (!base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						num++;
					}
				}
				return num;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected Evd(Matrix<System.Numerics.Complex> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<System.Numerics.Complex> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}
	}
	internal abstract class GramSchmidt : GramSchmidt<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					one *= FullR.At(i, i);
					if (FullR.At(i, i).Magnitude.AlmostEqual(0.0))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (FullR.At(i, i).Magnitude.AlmostEqual(0.0))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected GramSchmidt(Matrix<System.Numerics.Complex> q, Matrix<System.Numerics.Complex> rFull)
			: base(q, rFull)
		{
		}
	}
	internal abstract class LU : LU<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Determinant
		{
			get
			{
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < Factors.RowCount; i++)
				{
					if (Pivots[i] != i)
					{
						one *= -Factors.At(i, i);
					}
					else
					{
						one *= Factors.At(i, i);
					}
				}
				return one;
			}
		}

		protected LU(Matrix<System.Numerics.Complex> factors, int[] pivots)
			: base(factors, pivots)
		{
		}
	}
	internal abstract class QR : QR<System.Numerics.Complex>
	{
		public override System.Numerics.Complex Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					one *= FullR.At(i, i);
					if (FullR.At(i, i).Magnitude.AlmostEqual(0.0))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (FullR.At(i, i).Magnitude.AlmostEqual(0.0))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected QR(Matrix<System.Numerics.Complex> q, Matrix<System.Numerics.Complex> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}
	}
	internal abstract class Svd : Svd<System.Numerics.Complex>
	{
		public override int Rank
		{
			get
			{
				double tolerance = base.S.AbsoluteMaximum().Magnitude.EpsilonOf() * (double)Math.Max(base.U.RowCount, base.VT.RowCount);
				return base.S.Count((System.Numerics.Complex t) => t.Magnitude > tolerance);
			}
		}

		public override double L2Norm => base.S[0].Magnitude;

		public override System.Numerics.Complex ConditionNumber
		{
			get
			{
				int index = Math.Min(base.U.RowCount, base.VT.ColumnCount) - 1;
				return base.S[0].Magnitude / base.S[index].Magnitude;
			}
		}

		public override System.Numerics.Complex Determinant
		{
			get
			{
				if (base.U.RowCount != base.VT.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				System.Numerics.Complex one = System.Numerics.Complex.One;
				foreach (System.Numerics.Complex item in (IEnumerable<System.Numerics.Complex>)base.S)
				{
					one *= item;
					if (item.Magnitude.AlmostEqual(0.0))
					{
						return 0;
					}
				}
				return one.Magnitude;
			}
		}

		protected Svd(Vector<System.Numerics.Complex> s, Matrix<System.Numerics.Complex> u, Matrix<System.Numerics.Complex> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}
	}
	internal sealed class UserCholesky : Cholesky
	{
		private static void DoCholesky(Matrix<System.Numerics.Complex> factor)
		{
			if (factor.RowCount != factor.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			System.Numerics.Complex[] array = new System.Numerics.Complex[factor.RowCount];
			for (int i = 0; i < factor.RowCount; i++)
			{
				System.Numerics.Complex complex = factor.At(i, i);
				if (complex.Real > 0.0)
				{
					complex = complex.SquareRoot();
					factor.At(i, i, complex);
					array[i] = complex;
					for (int j = i + 1; j < factor.RowCount; j++)
					{
						factor.At(j, i, factor.At(j, i) / complex);
						array[j] = factor.At(j, i);
					}
					DoCholeskyStep(factor, factor.RowCount, i + 1, factor.RowCount, array, Control.MaxDegreeOfParallelism);
					for (int k = i + 1; k < factor.RowCount; k++)
					{
						factor.At(i, k, System.Numerics.Complex.Zero);
					}
					continue;
				}
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		public static UserCholesky Create(Matrix<System.Numerics.Complex> matrix)
		{
			Matrix<System.Numerics.Complex> factor = matrix.Clone();
			DoCholesky(factor);
			return new UserCholesky(factor);
		}

		public override void Factorize(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			matrix.CopyTo(base.Factor);
			DoCholesky(base.Factor);
		}

		private UserCholesky(Matrix<System.Numerics.Complex> factor)
			: base(factor)
		{
		}

		private static void DoCholeskyStep(Matrix<System.Numerics.Complex> data, int rowDim, int firstCol, int colLimit, System.Numerics.Complex[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				System.Numerics.Complex complex = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data.At(j, i, data.At(j, i) - multipliers[j] * complex.Conjugate());
				}
			}
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < result.ColumnCount; i++)
			{
				for (int j = 0; j < rowCount; j++)
				{
					System.Numerics.Complex complex = result.At(j, i);
					for (int num = j - 1; num >= 0; num--)
					{
						complex -= base.Factor.At(j, num) * result.At(num, i);
					}
					result.At(j, i, complex / base.Factor.At(j, j));
				}
				for (int num2 = rowCount - 1; num2 >= 0; num2--)
				{
					System.Numerics.Complex complex = result.At(num2, i);
					for (int k = num2 + 1; k < rowCount; k++)
					{
						complex -= base.Factor.At(k, num2).Conjugate() * result.At(k, i);
					}
					result.At(num2, i, complex / base.Factor.At(num2, num2));
				}
			}
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < rowCount; i++)
			{
				System.Numerics.Complex complex = result[i];
				for (int num = i - 1; num >= 0; num--)
				{
					complex -= base.Factor.At(i, num) * result[num];
				}
				result[i] = complex / base.Factor.At(i, i);
			}
			for (int num2 = rowCount - 1; num2 >= 0; num2--)
			{
				System.Numerics.Complex complex = result[num2];
				for (int j = num2 + 1; j < rowCount; j++)
				{
					complex -= base.Factor.At(j, num2).Conjugate() * result[j];
				}
				result[num2] = complex / base.Factor.At(num2, num2);
			}
		}
	}
	internal sealed class UserEvd : Evd
	{
		public static UserEvd Create(Matrix<System.Numerics.Complex> matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			DenseMatrix eigenVectors = DenseMatrix.CreateIdentity(rowCount);
			Matrix<System.Numerics.Complex> matrix2 = Matrix<System.Numerics.Complex>.Build.SameAs(matrix, rowCount, rowCount);
			DenseVector denseVector = new DenseVector(rowCount);
			bool flag = symmetricity switch
			{
				Symmetricity.Hermitian => true, 
				Symmetricity.Asymmetric => false, 
				_ => matrix.IsHermitian(), 
			};
			if (flag)
			{
				System.Numerics.Complex[,] matrixA = matrix.ToArray();
				System.Numerics.Complex[] tau = new System.Numerics.Complex[rowCount];
				double[] array = new double[rowCount];
				double[] array2 = new double[rowCount];
				SymmetricTridiagonalize(matrixA, array, array2, tau, rowCount);
				SymmetricDiagonalize(eigenVectors, array, array2, rowCount);
				SymmetricUntridiagonalize(eigenVectors, matrixA, tau, rowCount);
				for (int i = 0; i < rowCount; i++)
				{
					denseVector[i] = new System.Numerics.Complex(array[i], array2[i]);
				}
			}
			else
			{
				System.Numerics.Complex[,] matrixH = matrix.ToArray();
				NonsymmetricReduceToHessenberg(eigenVectors, matrixH, rowCount);
				NonsymmetricReduceHessenberToRealSchur(eigenVectors, denseVector, matrixH, rowCount);
			}
			matrix2.SetDiagonal(denseVector);
			return new UserEvd(eigenVectors, denseVector, matrix2, flag);
		}

		private UserEvd(Matrix<System.Numerics.Complex> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<System.Numerics.Complex> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		private static void SymmetricTridiagonalize(System.Numerics.Complex[,] matrixA, double[] d, double[] e, System.Numerics.Complex[] tau, int order)
		{
			tau[order - 1] = System.Numerics.Complex.One;
			for (int i = 0; i < order; i++)
			{
				d[i] = matrixA[i, i].Real;
			}
			double num4;
			for (int num = order - 1; num > 0; num--)
			{
				double num2 = 0.0;
				double num3 = 0.0;
				for (int j = 0; j < num; j++)
				{
					num2 = num2 + Math.Abs(matrixA[num, j].Real) + Math.Abs(matrixA[num, j].Imaginary);
				}
				if (num2 == 0.0)
				{
					tau[num - 1] = System.Numerics.Complex.One;
					e[num] = 0.0;
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						matrixA[num, k] /= (System.Numerics.Complex)num2;
						num3 += matrixA[num, k].MagnitudeSquared();
					}
					System.Numerics.Complex complex = Math.Sqrt(num3);
					e[num] = num2 * complex.Real;
					System.Numerics.Complex complex2 = matrixA[num, num - 1];
					System.Numerics.Complex complex3;
					if (complex2.Magnitude != 0.0)
					{
						complex3 = -(matrixA[num, num - 1].Conjugate() * tau[num].Conjugate()) / complex2.Magnitude;
						num3 += complex2.Magnitude * complex.Real;
						complex = 1.0 + complex / complex2.Magnitude;
						matrixA[num, num - 1] *= complex;
					}
					else
					{
						complex3 = -tau[num].Conjugate();
						matrixA[num, num - 1] = complex;
					}
					if (complex2.Magnitude == 0.0 || num != 1)
					{
						complex2 = System.Numerics.Complex.Zero;
						for (int l = 0; l < num; l++)
						{
							System.Numerics.Complex zero = System.Numerics.Complex.Zero;
							for (int m = 0; m <= l; m++)
							{
								zero += matrixA[l, m] * matrixA[num, m].Conjugate();
							}
							for (int n = l + 1; n <= num - 1; n++)
							{
								zero += matrixA[n, l].Conjugate() * matrixA[num, n].Conjugate();
							}
							tau[l] = zero / num3;
							complex2 += zero / num3 * matrixA[num, l];
						}
						num4 = complex2.Real / (num3 + num3);
						for (int num5 = 0; num5 < num; num5++)
						{
							complex2 = matrixA[num, num5].Conjugate();
							complex = tau[num5] - num4 * complex2;
							tau[num5] = complex.Conjugate();
							for (int num6 = 0; num6 <= num5; num6++)
							{
								matrixA[num5, num6] -= complex2 * tau[num6] + complex * matrixA[num, num6];
							}
						}
					}
					for (int num7 = 0; num7 < num; num7++)
					{
						matrixA[num, num7] *= (System.Numerics.Complex)num2;
					}
					tau[num - 1] = complex3.Conjugate();
				}
				num4 = d[num];
				d[num] = matrixA[num, num].Real;
				matrixA[num, num] = new System.Numerics.Complex(num4, num2 * Math.Sqrt(num3));
			}
			num4 = d[0];
			d[0] = matrixA[0, 0].Real;
			matrixA[0, 0] = num4;
			e[0] = 0.0;
		}

		private static void SymmetricDiagonalize(Matrix<System.Numerics.Complex> eigenVectors, double[] d, double[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0.0;
			double num = 0.0;
			double num2 = 0.0;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !(Math.Abs(e[k]) <= doublePrecision * num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						double num4 = d[j];
						double num5 = (d[j + 1] - num4) / (2.0 * e[j]);
						double num6 = SpecialFunctions.Hypotenuse(num5, 1.0);
						if (num5 < 0.0)
						{
							num6 = 0.0 - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						double num7 = d[j + 1];
						double num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						double num9 = 1.0;
						double num10 = num9;
						double num11 = num9;
						double num12 = e[j + 1];
						double num13 = 0.0;
						double num14 = 0.0;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = eigenVectors.At(m, num15 + 1).Real;
								eigenVectors.At(m, num15 + 1, num13 * eigenVectors.At(m, num15).Real + num9 * num8);
								eigenVectors.At(m, num15, num9 * eigenVectors.At(m, num15).Real - num13 * num8);
							}
						}
						num5 = (0.0 - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while (Math.Abs(e[j]) > doublePrecision * num2);
				}
				d[j] += num;
				e[j] = 0.0;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				double num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = eigenVectors.At(num19, n).Real;
						eigenVectors.At(num19, n, eigenVectors.At(num19, num16));
						eigenVectors.At(num19, num16, num17);
					}
				}
			}
		}

		private static void SymmetricUntridiagonalize(Matrix<System.Numerics.Complex> eigenVectors, System.Numerics.Complex[,] matrixA, System.Numerics.Complex[] tau, int order)
		{
			for (int i = 0; i < order; i++)
			{
				for (int j = 0; j < order; j++)
				{
					eigenVectors.At(i, j, eigenVectors.At(i, j).Real * tau[i].Conjugate());
				}
			}
			for (int k = 1; k < order; k++)
			{
				double imaginary = matrixA[k, k].Imaginary;
				if (imaginary == 0.0)
				{
					continue;
				}
				for (int l = 0; l < order; l++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int m = 0; m < k; m++)
					{
						zero += eigenVectors.At(m, l) * matrixA[k, m];
					}
					zero = zero / imaginary / imaginary;
					for (int n = 0; n < k; n++)
					{
						eigenVectors.At(n, l, eigenVectors.At(n, l) - zero * matrixA[k, n].Conjugate());
					}
				}
			}
		}

		private static void NonsymmetricReduceToHessenberg(Matrix<System.Numerics.Complex> eigenVectors, System.Numerics.Complex[,] matrixH, int order)
		{
			System.Numerics.Complex[] array = new System.Numerics.Complex[order];
			for (int i = 1; i < order - 1; i++)
			{
				double num = 0.0;
				for (int j = i; j < order; j++)
				{
					num += Math.Abs(matrixH[j, i - 1].Real) + Math.Abs(matrixH[j, i - 1].Imaginary);
				}
				if (num == 0.0)
				{
					continue;
				}
				double num2 = 0.0;
				for (int num3 = order - 1; num3 >= i; num3--)
				{
					array[num3] = matrixH[num3, i - 1] / num;
					num2 += array[num3].MagnitudeSquared();
				}
				double num4 = Math.Sqrt(num2);
				if (array[i].Magnitude != 0.0)
				{
					num2 += array[i].Magnitude * num4;
					num4 /= array[i].Magnitude;
					array[i] = (1.0 + num4) * array[i];
				}
				else
				{
					array[i] = num4;
					matrixH[i, i - 1] = num;
				}
				for (int k = i; k < order; k++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int num5 = order - 1; num5 >= i; num5--)
					{
						zero += array[num5].Conjugate() * matrixH[num5, k];
					}
					zero /= (System.Numerics.Complex)num2;
					for (int l = i; l < order; l++)
					{
						matrixH[l, k] -= zero * array[l];
					}
				}
				for (int m = 0; m < order; m++)
				{
					System.Numerics.Complex zero2 = System.Numerics.Complex.Zero;
					for (int num6 = order - 1; num6 >= i; num6--)
					{
						zero2 += array[num6] * matrixH[m, num6];
					}
					zero2 /= (System.Numerics.Complex)num2;
					for (int n = i; n < order; n++)
					{
						matrixH[m, n] -= zero2 * array[n].Conjugate();
					}
				}
				array[i] = num * array[i];
				matrixH[i, i - 1] *= (System.Numerics.Complex)(0.0 - num4);
			}
			for (int num7 = 0; num7 < order; num7++)
			{
				for (int num8 = 0; num8 < order; num8++)
				{
					eigenVectors.At(num7, num8, (num7 == num8) ? System.Numerics.Complex.One : System.Numerics.Complex.Zero);
				}
			}
			for (int num9 = order - 2; num9 >= 1; num9--)
			{
				if (matrixH[num9, num9 - 1] != System.Numerics.Complex.Zero && array[num9] != System.Numerics.Complex.Zero)
				{
					double num10 = matrixH[num9, num9 - 1].Real * array[num9].Real + matrixH[num9, num9 - 1].Imaginary * array[num9].Imaginary;
					for (int num11 = num9 + 1; num11 < order; num11++)
					{
						array[num11] = matrixH[num11, num9 - 1];
					}
					for (int num12 = num9; num12 < order; num12++)
					{
						System.Numerics.Complex zero3 = System.Numerics.Complex.Zero;
						for (int num13 = num9; num13 < order; num13++)
						{
							zero3 += array[num13].Conjugate() * eigenVectors.At(num13, num12);
						}
						zero3 /= (System.Numerics.Complex)num10;
						for (int num14 = num9; num14 < order; num14++)
						{
							eigenVectors.At(num14, num12, eigenVectors.At(num14, num12) + zero3 * array[num14]);
						}
					}
				}
			}
			for (int num15 = 1; num15 < order; num15++)
			{
				if (matrixH[num15, num15 - 1].Imaginary != 0.0)
				{
					System.Numerics.Complex complex = matrixH[num15, num15 - 1] / matrixH[num15, num15 - 1].Magnitude;
					matrixH[num15, num15 - 1] = matrixH[num15, num15 - 1].Magnitude;
					for (int num16 = num15; num16 < order; num16++)
					{
						matrixH[num15, num16] *= complex.Conjugate();
					}
					for (int num17 = 0; num17 <= Math.Min(num15 + 1, order - 1); num17++)
					{
						matrixH[num17, num15] *= complex;
					}
					for (int num18 = 0; num18 < order; num18++)
					{
						eigenVectors.At(num18, num15, eigenVectors.At(num18, num15) * complex);
					}
				}
			}
		}

		private static void NonsymmetricReduceHessenberToRealSchur(Matrix<System.Numerics.Complex> eigenVectors, Vector<System.Numerics.Complex> eigenValues, System.Numerics.Complex[,] matrixH, int order)
		{
			int num = order - 1;
			double doublePrecision = Precision.DoublePrecision;
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			int num2 = 0;
			double num5;
			while (num >= 0)
			{
				int num3;
				for (num3 = num; num3 > 0; num3--)
				{
					double num4 = Math.Abs(matrixH[num3 - 1, num3 - 1].Real) + Math.Abs(matrixH[num3 - 1, num3 - 1].Imaginary) + Math.Abs(matrixH[num3, num3].Real) + Math.Abs(matrixH[num3, num3].Imaginary);
					if (Math.Abs(matrixH[num3, num3 - 1].Real) < doublePrecision * num4)
					{
						break;
					}
				}
				if (num3 == num)
				{
					matrixH[num, num] += zero;
					eigenValues[num] = matrixH[num, num];
					num--;
					num2 = 0;
					continue;
				}
				System.Numerics.Complex complex;
				if (num2 != 10 && num2 != 20)
				{
					complex = matrixH[num, num];
					System.Numerics.Complex complex2 = matrixH[num - 1, num] * matrixH[num, num - 1].Real;
					if (complex2.Real != 0.0 || complex2.Imaginary != 0.0)
					{
						System.Numerics.Complex complex3 = (matrixH[num - 1, num - 1] - complex) / 2.0;
						System.Numerics.Complex complex4 = (complex3 * complex3 + complex2).SquareRoot();
						if (complex3.Real * complex4.Real + complex3.Imaginary * complex4.Imaginary < 0.0)
						{
							complex4 *= (System.Numerics.Complex)(-1.0);
						}
						complex2 /= complex3 + complex4;
						complex -= complex2;
					}
				}
				else
				{
					complex = Math.Abs(matrixH[num, num - 1].Real) + Math.Abs(matrixH[num - 1, num - 2].Real);
				}
				for (int i = 0; i <= num; i++)
				{
					matrixH[i, i] -= complex;
				}
				zero += complex;
				num2++;
				for (int j = num3 + 1; j <= num; j++)
				{
					complex = matrixH[j, j - 1].Real;
					num5 = SpecialFunctions.Hypotenuse(matrixH[j - 1, j - 1].Magnitude, complex.Real);
					System.Numerics.Complex complex2 = (eigenValues[j - 1] = matrixH[j - 1, j - 1] / num5);
					matrixH[j - 1, j - 1] = num5;
					matrixH[j, j - 1] = new System.Numerics.Complex(0.0, complex.Real / num5);
					for (int k = j; k < order; k++)
					{
						System.Numerics.Complex complex3 = matrixH[j - 1, k];
						System.Numerics.Complex complex4 = matrixH[j, k];
						matrixH[j - 1, k] = complex2.Conjugate() * complex3 + matrixH[j, j - 1].Imaginary * complex4;
						matrixH[j, k] = complex2 * complex4 - matrixH[j, j - 1].Imaginary * complex3;
					}
				}
				complex = matrixH[num, num];
				if (complex.Imaginary != 0.0)
				{
					complex /= (System.Numerics.Complex)matrixH[num, num].Magnitude;
					matrixH[num, num] = matrixH[num, num].Magnitude;
					for (int l = num + 1; l < order; l++)
					{
						matrixH[num, l] *= complex.Conjugate();
					}
				}
				for (int m = num3 + 1; m <= num; m++)
				{
					System.Numerics.Complex complex2 = eigenValues[m - 1];
					for (int n = 0; n <= m; n++)
					{
						System.Numerics.Complex complex4 = matrixH[n, m];
						System.Numerics.Complex complex3;
						if (n != m)
						{
							complex3 = matrixH[n, m - 1];
							matrixH[n, m - 1] = complex2 * complex3 + matrixH[m, m - 1].Imaginary * complex4;
						}
						else
						{
							complex3 = matrixH[n, m - 1].Real;
							matrixH[n, m - 1] = new System.Numerics.Complex(complex2.Real * complex3.Real - complex2.Imaginary * complex3.Imaginary + matrixH[m, m - 1].Imaginary * complex4.Real, matrixH[n, m - 1].Imaginary);
						}
						matrixH[n, m] = complex2.Conjugate() * complex4 - matrixH[m, m - 1].Imaginary * complex3;
					}
					for (int num6 = 0; num6 < order; num6++)
					{
						System.Numerics.Complex complex3 = eigenVectors.At(num6, m - 1);
						System.Numerics.Complex complex4 = eigenVectors.At(num6, m);
						eigenVectors.At(num6, m - 1, complex2 * complex3 + matrixH[m, m - 1].Imaginary * complex4);
						eigenVectors.At(num6, m, complex2.Conjugate() * complex4 - matrixH[m, m - 1].Imaginary * complex3);
					}
				}
				if (complex.Imaginary != 0.0)
				{
					for (int num7 = 0; num7 <= num; num7++)
					{
						matrixH[num7, num] *= complex;
					}
					for (int num8 = 0; num8 < order; num8++)
					{
						eigenVectors.At(num8, num, eigenVectors.At(num8, num) * complex);
					}
				}
			}
			num5 = 0.0;
			for (int num9 = 0; num9 < order; num9++)
			{
				for (int num10 = num9; num10 < order; num10++)
				{
					num5 = Math.Max(num5, Math.Abs(matrixH[num9, num10].Real) + Math.Abs(matrixH[num9, num10].Imaginary));
				}
			}
			if (order == 1 || num5 == 0.0)
			{
				return;
			}
			for (num = order - 1; num > 0; num--)
			{
				System.Numerics.Complex complex2 = eigenValues[num];
				matrixH[num, num] = 1.0;
				for (int num11 = num - 1; num11 >= 0; num11--)
				{
					System.Numerics.Complex complex4 = 0.0;
					for (int num12 = num11 + 1; num12 <= num; num12++)
					{
						complex4 += matrixH[num11, num12] * matrixH[num12, num];
					}
					System.Numerics.Complex complex3 = complex2 - eigenValues[num11];
					if (complex3.Real == 0.0 && complex3.Imaginary == 0.0)
					{
						complex3 = doublePrecision * num5;
					}
					matrixH[num11, num] = complex4 / complex3;
					double num13 = Math.Abs(matrixH[num11, num].Real) + Math.Abs(matrixH[num11, num].Imaginary);
					if (doublePrecision * num13 * num13 > 1.0)
					{
						for (int num14 = num11; num14 <= num; num14++)
						{
							matrixH[num14, num] /= (System.Numerics.Complex)num13;
						}
					}
				}
			}
			for (int num15 = order - 1; num15 > 0; num15--)
			{
				for (int num16 = 0; num16 < order; num16++)
				{
					System.Numerics.Complex complex4 = System.Numerics.Complex.Zero;
					for (int num17 = 0; num17 <= num15; num17++)
					{
						complex4 += eigenVectors.At(num16, num17) * matrixH[num17, num15];
					}
					eigenVectors.At(num16, num15, complex4);
				}
			}
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				System.Numerics.Complex[] array = new System.Numerics.Complex[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						System.Numerics.Complex complex = 0.0;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								complex += base.EigenVectors.At(k, j).Conjugate() * input.At(k, i);
							}
							complex /= (System.Numerics.Complex)base.EigenValues[j].Real;
						}
						array[j] = complex;
					}
					for (int l = 0; l < count; l++)
					{
						System.Numerics.Complex value = 0.0;
						for (int m = 0; m < count; m++)
						{
							value += base.EigenVectors.At(l, m) * array[m];
						}
						result.At(l, i, value);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(base.EigenValues, result);
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				System.Numerics.Complex[] array = new System.Numerics.Complex[count];
				for (int i = 0; i < count; i++)
				{
					System.Numerics.Complex complex = 0;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							complex += base.EigenVectors.At(j, i).Conjugate() * input[j];
						}
						complex /= (System.Numerics.Complex)base.EigenValues[i].Real;
					}
					array[i] = complex;
				}
				for (int k = 0; k < count; k++)
				{
					System.Numerics.Complex complex = 0;
					for (int l = 0; l < count; l++)
					{
						complex += base.EigenVectors.At(k, l) * array[l];
					}
					result[k] = complex;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class UserGramSchmidt : GramSchmidt
	{
		public static UserGramSchmidt Create(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			Matrix<System.Numerics.Complex> matrix2 = matrix.Clone();
			Matrix<System.Numerics.Complex> matrix3 = Matrix<System.Numerics.Complex>.Build.SameAs(matrix, matrix.ColumnCount, matrix.ColumnCount, fullyMutable: true);
			for (int i = 0; i < matrix2.ColumnCount; i++)
			{
				double num = matrix2.Column(i).L2Norm();
				if (num == 0.0)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				matrix3.At(i, i, num);
				for (int j = 0; j < matrix2.RowCount; j++)
				{
					matrix2.At(j, i, matrix2.At(j, i) / num);
				}
				for (int k = i + 1; k < matrix2.ColumnCount; k++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						zero += matrix2.Column(i)[l].Conjugate() * matrix2.Column(k)[l];
					}
					matrix3.At(i, k, zero);
					for (int m = 0; m < matrix2.RowCount; m++)
					{
						System.Numerics.Complex value = matrix2.At(m, k) - matrix2.At(m, i) * zero;
						matrix2.At(m, k, value);
					}
				}
			}
			return new UserGramSchmidt(matrix2, matrix3);
		}

		private UserGramSchmidt(Matrix<System.Numerics.Complex> q, Matrix<System.Numerics.Complex> rFull)
			: base(q, rFull)
		{
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<System.Numerics.Complex> matrix = input.Clone();
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.Q.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < base.Q.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < base.Q.ColumnCount; k++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int l = 0; l < base.Q.RowCount; l++)
					{
						zero += base.Q.At(l, k).Conjugate() * array[l];
					}
					matrix.At(k, i, zero);
				}
			}
			for (int num = base.Q.ColumnCount - 1; num >= 0; num--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num, m, matrix.At(num, m) / FullR.At(num, num));
				}
				for (int n = 0; n < num; n++)
				{
					for (int num2 = 0; num2 < input.ColumnCount; num2++)
					{
						matrix.At(n, num2, matrix.At(n, num2) - matrix.At(num, num2) * FullR.At(n, num));
					}
				}
			}
			for (int num3 = 0; num3 < FullR.ColumnCount; num3++)
			{
				for (int num4 = 0; num4 < input.ColumnCount; num4++)
				{
					result.At(num3, num4, matrix.At(num3, num4));
				}
			}
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			Vector<System.Numerics.Complex> vector = input.Clone();
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.Q.RowCount];
			for (int i = 0; i < base.Q.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < base.Q.ColumnCount; j++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int k = 0; k < base.Q.RowCount; k++)
				{
					zero += base.Q.At(k, j).Conjugate() * array[k];
				}
				vector[j] = zero;
			}
			for (int num = base.Q.ColumnCount - 1; num >= 0; num--)
			{
				vector[num] /= FullR.At(num, num);
				for (int l = 0; l < num; l++)
				{
					vector[l] -= vector[num] * FullR.At(l, num);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserLU : LU
	{
		public static UserLU Create(Matrix<System.Numerics.Complex> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			Matrix<System.Numerics.Complex> matrix2 = matrix.Clone();
			int[] array = new int[rowCount];
			for (int i = 0; i < rowCount; i++)
			{
				array[i] = i;
			}
			System.Numerics.Complex[] array2 = new System.Numerics.Complex[rowCount];
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = 0; k < rowCount; k++)
				{
					array2[k] = matrix2.At(k, j);
				}
				for (int l = 0; l < rowCount; l++)
				{
					int num = Math.Min(l, j);
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int m = 0; m < num; m++)
					{
						zero += matrix2.At(l, m) * array2[m];
					}
					array2[l] -= zero;
					matrix2.At(l, j, array2[l]);
				}
				int num2 = j;
				for (int n = j + 1; n < rowCount; n++)
				{
					if (array2[n].Magnitude > array2[num2].Magnitude)
					{
						num2 = n;
					}
				}
				if (num2 != j)
				{
					for (int num3 = 0; num3 < rowCount; num3++)
					{
						System.Numerics.Complex value = matrix2.At(num2, num3);
						matrix2.At(num2, num3, matrix2.At(j, num3));
						matrix2.At(j, num3, value);
					}
					array[j] = num2;
				}
				if ((j < rowCount) & (matrix2.At(j, j) != 0.0))
				{
					for (int num4 = j + 1; num4 < rowCount; num4++)
					{
						matrix2.At(num4, j, matrix2.At(num4, j) / matrix2.At(j, j));
					}
				}
			}
			return new UserLU(matrix2, array);
		}

		private UserLU(Matrix<System.Numerics.Complex> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int row = Pivots[i];
					for (int j = 0; j < result.ColumnCount; j++)
					{
						System.Numerics.Complex value = result.At(row, j);
						result.At(row, j, result.At(i, j));
						result.At(i, j, value);
					}
				}
			}
			int rowCount = Factors.RowCount;
			for (int k = 0; k < rowCount; k++)
			{
				for (int l = k + 1; l < rowCount; l++)
				{
					for (int m = 0; m < result.ColumnCount; m++)
					{
						System.Numerics.Complex complex = result.At(k, m) * Factors.At(l, k);
						result.At(l, m, result.At(l, m) - complex);
					}
				}
			}
			for (int num = rowCount - 1; num >= 0; num--)
			{
				for (int n = 0; n < result.ColumnCount; n++)
				{
					result.At(num, n, result.At(num, n) / Factors.At(num, num));
				}
				for (int num2 = 0; num2 < num; num2++)
				{
					for (int num3 = 0; num3 < result.ColumnCount; num3++)
					{
						System.Numerics.Complex complex2 = result.At(num, num3) * Factors.At(num2, num);
						result.At(num2, num3, result.At(num2, num3) - complex2);
					}
				}
			}
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int index = Pivots[i];
					System.Numerics.Complex value = result[index];
					result[index] = result[i];
					result[i] = value;
				}
			}
			int rowCount = Factors.RowCount;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = j + 1; k < rowCount; k++)
				{
					result[k] -= result[j] * Factors.At(k, j);
				}
			}
			for (int num = rowCount - 1; num >= 0; num--)
			{
				result[num] /= Factors.At(num, num);
				for (int l = 0; l < num; l++)
				{
					result[l] -= result[num] * Factors.At(l, num);
				}
			}
		}

		public override Matrix<System.Numerics.Complex> Inverse()
		{
			int rowCount = Factors.RowCount;
			Matrix<System.Numerics.Complex> matrix = Matrix<System.Numerics.Complex>.Build.SameAs(Factors, rowCount, rowCount);
			for (int i = 0; i < rowCount; i++)
			{
				matrix.At(i, i, 1.0);
			}
			return Solve(matrix);
		}
	}
	internal sealed class UserQR : QR
	{
		public static UserQR Create(Matrix<System.Numerics.Complex> matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			int num = Math.Min(matrix.RowCount, matrix.ColumnCount);
			System.Numerics.Complex[][] array = new System.Numerics.Complex[num][];
			Matrix<System.Numerics.Complex> matrix2;
			Matrix<System.Numerics.Complex> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = Matrix<System.Numerics.Complex>.Build.SameAs(matrix, matrix.RowCount, matrix.RowCount, fullyMutable: true);
				for (int i = 0; i < matrix.RowCount; i++)
				{
					matrix3.At(i, i, 1f);
				}
				for (int j = 0; j < num; j++)
				{
					array[j] = GenerateColumn(matrix2, j, j);
					ComputeQR(array[j], matrix2, j, matrix.RowCount, j + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					ComputeQR(array[num2], matrix3, num2, matrix.RowCount, num2, matrix.RowCount, Control.MaxDegreeOfParallelism);
				}
			}
			else
			{
				matrix3 = matrix.Clone();
				for (int k = 0; k < num; k++)
				{
					array[k] = GenerateColumn(matrix3, k, k);
					ComputeQR(array[k], matrix3, k, matrix.RowCount, k + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				matrix2 = matrix3.SubMatrix(0, matrix.ColumnCount, 0, matrix.ColumnCount);
				matrix3.Clear();
				for (int l = 0; l < matrix.ColumnCount; l++)
				{
					matrix3.At(l, l, 1f);
				}
				for (int num3 = num - 1; num3 >= 0; num3--)
				{
					ComputeQR(array[num3], matrix3, num3, matrix.RowCount, num3, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
			}
			return new UserQR(matrix3, matrix2, method);
		}

		private UserQR(Matrix<System.Numerics.Complex> q, Matrix<System.Numerics.Complex> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}

		private static System.Numerics.Complex[] GenerateColumn(Matrix<System.Numerics.Complex> a, int row, int column)
		{
			int num = a.RowCount - row;
			System.Numerics.Complex[] array = new System.Numerics.Complex[num];
			for (int i = row; i < a.RowCount; i++)
			{
				array[i - row] = a.At(i, column);
				a.At(i, column, 0.0);
			}
			System.Numerics.Complex complex = array.Aggregate(System.Numerics.Complex.Zero, (System.Numerics.Complex current, System.Numerics.Complex t) => current + t.Magnitude * t.Magnitude);
			complex = complex.SquareRoot();
			if (row == a.RowCount - 1 || complex.Magnitude == 0.0)
			{
				a.At(row, column, -array[0]);
				array[0] = 1.4142135623730951;
				return array;
			}
			if (array[0].Magnitude != 0.0)
			{
				complex = complex.Magnitude * (array[0] / array[0].Magnitude);
			}
			a.At(row, column, -complex);
			for (int j = 0; j < num; j++)
			{
				array[j] /= complex;
			}
			array[0] += (System.Numerics.Complex)1.0;
			System.Numerics.Complex complex2 = (1.0 / array[0]).SquareRoot();
			for (int k = 0; k < num; k++)
			{
				array[k] = array[k].Conjugate() * complex2;
			}
			return array;
		}

		private static void ComputeQR(System.Numerics.Complex[] u, Matrix<System.Numerics.Complex> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores)
		{
			if (rowDim < rowStart || columnDim < columnStart)
			{
				return;
			}
			int num = columnDim - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(u, a, rowStart, rowDim, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(u, a, rowStart, rowDim, tmpSplit, columnDim, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnDim; i++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int j = rowStart; j < rowDim; j++)
				{
					zero += u[j - rowStart] * a.At(j, i);
				}
				for (int k = rowStart; k < rowDim; k++)
				{
					a.At(k, i, a.At(k, i) - u[k - rowStart].Conjugate() * zero);
				}
			}
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (FullR.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<System.Numerics.Complex> matrix = input.Clone();
			System.Numerics.Complex[] array = new System.Numerics.Complex[FullR.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < FullR.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < FullR.RowCount; k++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					for (int l = 0; l < FullR.RowCount; l++)
					{
						zero += base.Q.At(l, k).Conjugate() * array[l];
					}
					matrix.At(k, i, zero);
				}
			}
			for (int num = FullR.ColumnCount - 1; num >= 0; num--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num, m, matrix.At(num, m) / FullR.At(num, num));
				}
				for (int n = 0; n < num; n++)
				{
					for (int num2 = 0; num2 < input.ColumnCount; num2++)
					{
						matrix.At(n, num2, matrix.At(n, num2) - matrix.At(num, num2) * FullR.At(n, num));
					}
				}
			}
			for (int num3 = 0; num3 < FullR.ColumnCount; num3++)
			{
				for (int num4 = 0; num4 < matrix.ColumnCount; num4++)
				{
					result.At(num3, num4, matrix.At(num3, num4));
				}
			}
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (FullR.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			Vector<System.Numerics.Complex> vector = input.Clone();
			System.Numerics.Complex[] array = new System.Numerics.Complex[FullR.RowCount];
			for (int i = 0; i < FullR.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < FullR.RowCount; j++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				for (int k = 0; k < FullR.RowCount; k++)
				{
					zero += base.Q.At(k, j).Conjugate() * array[k];
				}
				vector[j] = zero;
			}
			for (int num = FullR.ColumnCount - 1; num >= 0; num--)
			{
				vector[num] /= FullR.At(num, num);
				for (int l = 0; l < num; l++)
				{
					vector[l] -= vector[num] * FullR.At(l, num);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserSvd : Svd
	{
		public static UserSvd Create(Matrix<System.Numerics.Complex> matrix, bool computeVectors)
		{
			int num = Math.Min(matrix.RowCount + 1, matrix.ColumnCount);
			Matrix<System.Numerics.Complex> matrix2 = matrix.Clone();
			Vector<System.Numerics.Complex> vector = Vector<System.Numerics.Complex>.Build.SameAs(matrix2, num);
			Matrix<System.Numerics.Complex> matrix3 = Matrix<System.Numerics.Complex>.Build.SameAs(matrix2, matrix2.RowCount, matrix2.RowCount, fullyMutable: true);
			Matrix<System.Numerics.Complex> matrix4 = Matrix<System.Numerics.Complex>.Build.SameAs(matrix2, matrix2.ColumnCount, matrix2.ColumnCount, fullyMutable: true);
			System.Numerics.Complex[] array = new System.Numerics.Complex[matrix2.ColumnCount];
			System.Numerics.Complex[] array2 = new System.Numerics.Complex[matrix2.RowCount];
			int rowCount = matrix2.RowCount;
			int num2 = Math.Min(matrix2.RowCount - 1, matrix2.ColumnCount);
			int num3 = Math.Max(0, Math.Min(matrix2.ColumnCount - 2, matrix2.RowCount));
			int num4 = Math.Max(num2, num3);
			for (int i = 0; i < num4; i++)
			{
				int num5 = i + 1;
				if (i < num2)
				{
					vector[i] = Cnrm2Column(matrix2, matrix2.RowCount, i, i);
					if (vector[i].Magnitude != 0.0)
					{
						if (matrix2.At(i, i).Magnitude != 0.0)
						{
							vector[i] = Csign(vector[i], matrix2.At(i, i));
						}
						CscalColumn(matrix2, matrix2.RowCount, i, i, 1.0 / vector[i]);
						matrix2.At(i, i, System.Numerics.Complex.One + matrix2.At(i, i));
					}
					vector[i] = -vector[i];
				}
				for (int j = num5; j < matrix2.ColumnCount; j++)
				{
					if (i < num2 && vector[i].Magnitude != 0.0)
					{
						System.Numerics.Complex complex = -Cdotc(matrix2, matrix2.RowCount, i, j, i) / matrix2.At(i, i);
						if (complex != System.Numerics.Complex.Zero)
						{
							for (int k = i; k < matrix2.RowCount; k++)
							{
								matrix2.At(k, j, matrix2.At(k, j) + complex * matrix2.At(k, i));
							}
						}
					}
					array[j] = matrix2.At(i, j).Conjugate();
				}
				if (computeVectors && i < num2)
				{
					for (int l = i; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, i, matrix2.At(l, i));
					}
				}
				if (i >= num3)
				{
					continue;
				}
				double num6 = Cnrm2Vector(array, num5);
				array[i] = num6;
				if (array[i].Magnitude != 0.0)
				{
					if (array[num5].Magnitude != 0.0)
					{
						array[i] = Csign(array[i], array[num5]);
					}
					CscalVector(array, num5, 1.0 / array[i]);
					array[num5] = System.Numerics.Complex.One + array[num5];
				}
				array[i] = -array[i].Conjugate();
				if (num5 < matrix2.RowCount && array[i].Magnitude != 0.0)
				{
					for (int l = num5; l < matrix2.RowCount; l++)
					{
						array2[l] = System.Numerics.Complex.Zero;
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						if (array[j] != System.Numerics.Complex.Zero)
						{
							for (int m = num5; m < matrix2.RowCount; m++)
							{
								array2[m] += array[j] * matrix2.At(m, j);
							}
						}
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						System.Numerics.Complex complex2 = (-array[j] / array[num5]).Conjugate();
						if (complex2 != System.Numerics.Complex.Zero)
						{
							for (int n = num5; n < matrix2.RowCount; n++)
							{
								matrix2.At(n, j, matrix2.At(n, j) + complex2 * array2[n]);
							}
						}
					}
				}
				if (computeVectors)
				{
					for (int l = num5; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, array[l]);
					}
				}
			}
			int num7 = Math.Min(matrix2.ColumnCount, matrix2.RowCount + 1);
			int num8 = num2 + 1;
			int num9 = num3 + 1;
			if (num2 < matrix2.ColumnCount)
			{
				vector[num8 - 1] = matrix2.At(num8 - 1, num8 - 1);
			}
			if (matrix2.RowCount < num7)
			{
				vector[num7 - 1] = System.Numerics.Complex.Zero;
			}
			if (num9 < num7)
			{
				array[num9 - 1] = matrix2.At(num9 - 1, num7 - 1);
			}
			array[num7 - 1] = System.Numerics.Complex.Zero;
			if (computeVectors)
			{
				for (int j = num8 - 1; j < rowCount; j++)
				{
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, j, System.Numerics.Complex.Zero);
					}
					matrix3.At(j, j, System.Numerics.Complex.One);
				}
				for (int i = num2 - 1; i >= 0; i--)
				{
					if (vector[i].Magnitude != 0.0)
					{
						for (int j = i + 1; j < rowCount; j++)
						{
							System.Numerics.Complex complex = -Cdotc(matrix3, matrix2.RowCount, i, j, i) / matrix3.At(i, i);
							if (complex != System.Numerics.Complex.Zero)
							{
								for (int num10 = i; num10 < matrix2.RowCount; num10++)
								{
									matrix3.At(num10, j, matrix3.At(num10, j) + complex * matrix3.At(num10, i));
								}
							}
						}
						CscalColumn(matrix3, matrix2.RowCount, i, i, -1.0);
						matrix3.At(i, i, System.Numerics.Complex.One + matrix3.At(i, i));
						for (int l = 0; l < i; l++)
						{
							matrix3.At(l, i, System.Numerics.Complex.Zero);
						}
					}
					else
					{
						for (int l = 0; l < matrix2.RowCount; l++)
						{
							matrix3.At(l, i, System.Numerics.Complex.Zero);
						}
						matrix3.At(i, i, System.Numerics.Complex.One);
					}
				}
			}
			if (computeVectors)
			{
				for (int i = matrix2.ColumnCount - 1; i >= 0; i--)
				{
					int num5 = i + 1;
					if (i < num3 && array[i].Magnitude != 0.0)
					{
						for (int j = num5; j < matrix2.ColumnCount; j++)
						{
							System.Numerics.Complex complex = -Cdotc(matrix4, matrix2.ColumnCount, i, j, num5) / matrix4.At(num5, i);
							if (complex != System.Numerics.Complex.Zero)
							{
								for (int num11 = i; num11 < matrix2.ColumnCount; num11++)
								{
									matrix4.At(num11, j, matrix4.At(num11, j) + complex * matrix4.At(num11, i));
								}
							}
						}
					}
					for (int l = 0; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, System.Numerics.Complex.Zero);
					}
					matrix4.At(i, i, System.Numerics.Complex.One);
				}
			}
			for (int l = 0; l < num7; l++)
			{
				if (vector[l].Magnitude != 0.0)
				{
					System.Numerics.Complex complex = vector[l].Magnitude;
					System.Numerics.Complex complex3 = vector[l] / complex;
					vector[l] = complex;
					if (l < num7 - 1)
					{
						array[l] /= complex3;
					}
					if (computeVectors)
					{
						CscalColumn(matrix3, matrix2.RowCount, l, 0, complex3);
					}
				}
				if (l == num7 - 1)
				{
					break;
				}
				if (array[l].Magnitude != 0.0)
				{
					System.Numerics.Complex complex = array[l].Magnitude;
					System.Numerics.Complex complex3 = complex / array[l];
					array[l] = complex;
					vector[l + 1] *= complex3;
					if (computeVectors)
					{
						CscalColumn(matrix4, matrix2.ColumnCount, l + 1, 0, complex3);
					}
				}
			}
			int num12 = num7;
			int num13 = 0;
			while (num7 > 0)
			{
				if (num13 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num7 - 2; i >= 0; i--)
				{
					double num14 = vector[i].Magnitude + vector[i + 1].Magnitude;
					if ((num14 + array[i].Magnitude).AlmostEqualRelative(num14, 15))
					{
						array[i] = System.Numerics.Complex.Zero;
						break;
					}
				}
				int num15;
				if (i == num7 - 2)
				{
					num15 = 4;
				}
				else
				{
					int num16;
					for (num16 = num7 - 1; num16 > i; num16--)
					{
						double num14 = 0.0;
						if (num16 != num7 - 1)
						{
							num14 += array[num16].Magnitude;
						}
						if (num16 != i + 1)
						{
							num14 += array[num16 - 1].Magnitude;
						}
						if ((num14 + vector[num16].Magnitude).AlmostEqualRelative(num14, 15))
						{
							vector[num16] = System.Numerics.Complex.Zero;
							break;
						}
					}
					if (num16 == i)
					{
						num15 = 3;
					}
					else if (num16 == num7 - 1)
					{
						num15 = 1;
					}
					else
					{
						num15 = 2;
						i = num16;
					}
				}
				i++;
				double c;
				double s;
				switch (num15)
				{
				case 1:
				{
					double da = array[num7 - 2].Real;
					array[num7 - 2] = System.Numerics.Complex.Zero;
					for (int num26 = i; num26 < num7 - 1; num26++)
					{
						int num25 = num7 - 2 - num26 + i;
						double da2 = vector[num25].Real;
						Srotg(ref da2, ref da, out c, out s);
						vector[num25] = da2;
						if (num25 != i)
						{
							da = (0.0 - s) * array[num25 - 1].Real;
							array[num25 - 1] = c * array[num25 - 1];
						}
						if (computeVectors)
						{
							Csrot(matrix4, matrix2.ColumnCount, num25, num7 - 1, c, s);
						}
					}
					break;
				}
				case 2:
				{
					double da = array[i - 1].Real;
					array[i - 1] = System.Numerics.Complex.Zero;
					for (int num25 = i; num25 < num7; num25++)
					{
						double da2 = vector[num25].Real;
						Srotg(ref da2, ref da, out c, out s);
						vector[num25] = da2;
						da = (0.0 - s) * array[num25].Real;
						array[num25] = c * array[num25];
						if (computeVectors)
						{
							Csrot(matrix3, matrix2.RowCount, num25, i - 1, c, s);
						}
					}
					break;
				}
				case 3:
				{
					double val = 0.0;
					val = Math.Max(val, vector[num7 - 1].Magnitude);
					val = Math.Max(val, vector[num7 - 2].Magnitude);
					val = Math.Max(val, array[num7 - 2].Magnitude);
					val = Math.Max(val, vector[i].Magnitude);
					val = Math.Max(val, array[i].Magnitude);
					double num17 = vector[num7 - 1].Real / val;
					double num18 = vector[num7 - 2].Real / val;
					double num19 = array[num7 - 2].Real / val;
					double num20 = vector[i].Real / val;
					double num21 = array[i].Real / val;
					double num22 = ((num18 + num17) * (num18 - num17) + num19 * num19) / 2.0;
					double num23 = num17 * num19 * (num17 * num19);
					double num24 = 0.0;
					if (num22 != 0.0 || num23 != 0.0)
					{
						num24 = Math.Sqrt(num22 * num22 + num23);
						if (num22 < 0.0)
						{
							num24 = 0.0 - num24;
						}
						num24 = num23 / (num22 + num24);
					}
					double da = (num20 + num17) * (num20 - num17) + num24;
					double db = num20 * num21;
					for (int num25 = i; num25 < num7 - 1; num25++)
					{
						Srotg(ref da, ref db, out c, out s);
						if (num25 != i)
						{
							array[num25 - 1] = da;
						}
						da = c * vector[num25].Real + s * array[num25].Real;
						array[num25] = c * array[num25] - s * vector[num25];
						db = s * vector[num25 + 1].Real;
						vector[num25 + 1] = c * vector[num25 + 1];
						if (computeVectors)
						{
							Csrot(matrix4, matrix2.ColumnCount, num25, num25 + 1, c, s);
						}
						Srotg(ref da, ref db, out c, out s);
						vector[num25] = da;
						da = c * array[num25].Real + s * vector[num25 + 1].Real;
						vector[num25 + 1] = (0.0 - s) * array[num25] + c * vector[num25 + 1];
						db = s * array[num25 + 1].Real;
						array[num25 + 1] = c * array[num25 + 1];
						if (computeVectors && num25 < matrix2.RowCount)
						{
							Csrot(matrix3, matrix2.RowCount, num25, num25 + 1, c, s);
						}
					}
					array[num7 - 2] = da;
					num13++;
					break;
				}
				case 4:
					if (vector[i].Real < 0.0)
					{
						vector[i] = -vector[i];
						if (computeVectors)
						{
							CscalColumn(matrix4, matrix2.ColumnCount, i, 0, -1.0);
						}
					}
					for (; i != num12 - 1 && !(vector[i].Real >= vector[i + 1].Real); i++)
					{
						System.Numerics.Complex complex = vector[i];
						vector[i] = vector[i + 1];
						vector[i + 1] = complex;
						if (computeVectors && i < matrix2.ColumnCount)
						{
							Swap(matrix4, matrix2.ColumnCount, i, i + 1);
						}
						if (computeVectors && i < matrix2.RowCount)
						{
							Swap(matrix3, matrix2.RowCount, i, i + 1);
						}
					}
					num13 = 0;
					num7--;
					break;
				}
			}
			if (computeVectors)
			{
				matrix4 = matrix4.ConjugateTranspose();
			}
			if (matrix2.RowCount < matrix2.ColumnCount)
			{
				num--;
				Vector<System.Numerics.Complex> vector2 = Vector<System.Numerics.Complex>.Build.SameAs(matrix2, num);
				for (int l = 0; l < num; l++)
				{
					vector2[l] = vector[l];
				}
				vector = vector2;
			}
			return new UserSvd(vector, matrix3, matrix4, computeVectors);
		}

		private UserSvd(Vector<System.Numerics.Complex> s, Matrix<System.Numerics.Complex> u, Matrix<System.Numerics.Complex> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		private static System.Numerics.Complex Csign(System.Numerics.Complex z1, System.Numerics.Complex z2)
		{
			return z1.Magnitude * (z2 / z2.Magnitude);
		}

		private static void Swap(Matrix<System.Numerics.Complex> a, int rowCount, int columnA, int columnB)
		{
			for (int i = 0; i < rowCount; i++)
			{
				System.Numerics.Complex value = a.At(i, columnA);
				a.At(i, columnA, a.At(i, columnB));
				a.At(i, columnB, value);
			}
		}

		private static void CscalColumn(Matrix<System.Numerics.Complex> a, int rowCount, int column, int rowStart, System.Numerics.Complex z)
		{
			for (int i = rowStart; i < rowCount; i++)
			{
				a.At(i, column, a.At(i, column) * z);
			}
		}

		private static void CscalVector(System.Numerics.Complex[] a, int start, System.Numerics.Complex z)
		{
			for (int i = start; i < a.Length; i++)
			{
				a[i] *= z;
			}
		}

		private static void Srotg(ref double da, ref double db, out double c, out double s)
		{
			double num = db;
			double num2 = Math.Abs(da);
			double num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			double num4 = num2 + num3;
			double num5;
			double num6;
			if (num4 == 0.0)
			{
				c = 1.0;
				s = 0.0;
				num5 = 0.0;
				num6 = 0.0;
			}
			else
			{
				double num7 = da / num4;
				double num8 = db / num4;
				num5 = num4 * Math.Sqrt(num7 * num7 + num8 * num8);
				if (num < 0.0)
				{
					num5 = 0.0 - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1.0;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && c != 0.0)
				{
					num6 = 1.0 / c;
				}
			}
			da = num5;
			db = num6;
		}

		private static double Cnrm2Column(Matrix<System.Numerics.Complex> a, int rowCount, int column, int rowStart)
		{
			double num = 0.0;
			for (int i = rowStart; i < rowCount; i++)
			{
				num += a.At(i, column).Magnitude * a.At(i, column).Magnitude;
			}
			return Math.Sqrt(num);
		}

		private static double Cnrm2Vector(System.Numerics.Complex[] a, int rowStart)
		{
			double num = 0.0;
			for (int i = rowStart; i < a.Length; i++)
			{
				num += a[i].Magnitude * a[i].Magnitude;
			}
			return Math.Sqrt(num);
		}

		private static System.Numerics.Complex Cdotc(Matrix<System.Numerics.Complex> a, int rowCount, int columnA, int columnB, int rowStart)
		{
			System.Numerics.Complex zero = System.Numerics.Complex.Zero;
			for (int i = rowStart; i < rowCount; i++)
			{
				zero += a.At(i, columnA).Conjugate() * a.At(i, columnB);
			}
			return zero;
		}

		private static void Csrot(Matrix<System.Numerics.Complex> a, int rowCount, int columnA, int columnB, double c, double s)
		{
			for (int i = 0; i < rowCount; i++)
			{
				System.Numerics.Complex value = c * a.At(i, columnA) + s * a.At(i, columnB);
				System.Numerics.Complex value2 = c * a.At(i, columnB) - s * a.At(i, columnA);
				a.At(i, columnB, value2);
				a.At(i, columnA, value);
			}
		}

		public override void Solve(Matrix<System.Numerics.Complex> input, Matrix<System.Numerics.Complex> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			int columnCount = input.ColumnCount;
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.VT.ColumnCount];
			for (int i = 0; i < columnCount; i++)
			{
				for (int j = 0; j < base.VT.ColumnCount; j++)
				{
					System.Numerics.Complex zero = System.Numerics.Complex.Zero;
					if (j < num)
					{
						for (int k = 0; k < base.U.RowCount; k++)
						{
							zero += base.U.At(k, j).Conjugate() * input.At(k, i);
						}
						zero /= base.S[j];
					}
					array[j] = zero;
				}
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					System.Numerics.Complex zero2 = System.Numerics.Complex.Zero;
					for (int m = 0; m < base.VT.ColumnCount; m++)
					{
						zero2 += base.VT.At(m, l).Conjugate() * array[m];
					}
					result.At(l, i, zero2);
				}
			}
		}

		public override void Solve(Vector<System.Numerics.Complex> input, Vector<System.Numerics.Complex> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<System.Numerics.Complex>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			System.Numerics.Complex[] array = new System.Numerics.Complex[base.VT.ColumnCount];
			for (int i = 0; i < base.VT.ColumnCount; i++)
			{
				System.Numerics.Complex zero = System.Numerics.Complex.Zero;
				if (i < num)
				{
					for (int j = 0; j < base.U.RowCount; j++)
					{
						zero += base.U.At(j, i).Conjugate() * input[j];
					}
					zero /= base.S[i];
				}
				array[i] = zero;
			}
			for (int k = 0; k < base.VT.ColumnCount; k++)
			{
				System.Numerics.Complex zero2 = System.Numerics.Complex.Zero;
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					zero2 += base.VT.At(l, k).Conjugate() * array[l];
				}
				result[k] = zero2;
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Single
{
	internal class MatrixBuilder : MatrixBuilder<float>
	{
		public override float Zero => 0f;

		public override float One => 1f;

		public override Matrix<float> Dense(DenseColumnMajorMatrixStorage<float> storage)
		{
			return new DenseMatrix(storage);
		}

		public override Matrix<float> Sparse(SparseCompressedRowMatrixStorage<float> storage)
		{
			return new SparseMatrix(storage);
		}

		public override Matrix<float> Diagonal(DiagonalMatrixStorage<float> storage)
		{
			return new DiagonalMatrix(storage);
		}

		public override Matrix<float> Random(int rows, int columns, IContinuousDistribution distribution)
		{
			return Dense(rows, columns, Generate.RandomSingle(rows * columns, distribution));
		}

		public override IIterationStopCriterion<float>[] IterativeSolverStopCriteria(int maxIterations = 1000)
		{
			return new IIterationStopCriterion<float>[4]
			{
				new FailureStopCriterion<float>(),
				new DivergenceStopCriterion<float>(),
				new IterationCountStopCriterion<float>(maxIterations),
				new ResidualStopCriterion<float>(1E-06)
			};
		}

		internal override float Add(float x, float y)
		{
			return x + y;
		}
	}
	internal class VectorBuilder : VectorBuilder<float>
	{
		public override float Zero => 0f;

		public override float One => 1f;

		public override Vector<float> Dense(DenseVectorStorage<float> storage)
		{
			return new DenseVector(storage);
		}

		public override Vector<float> Sparse(SparseVectorStorage<float> storage)
		{
			return new SparseVector(storage);
		}

		public override Vector<float> Random(int length, IContinuousDistribution distribution)
		{
			return Dense(Generate.RandomSingle(length, distribution));
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseMatrix {RowCount}x{ColumnCount}-Single")]
	public class DenseMatrix : Matrix
	{
		private readonly int _rowCount;

		private readonly int _columnCount;

		private readonly float[] _values;

		public float[] Values => _values;

		public DenseMatrix(DenseColumnMajorMatrixStorage<float> storage)
			: base(storage)
		{
			_rowCount = storage.RowCount;
			_columnCount = storage.ColumnCount;
			_values = storage.Data;
		}

		public DenseMatrix(int order)
			: this(new DenseColumnMajorMatrixStorage<float>(order, order))
		{
		}

		public DenseMatrix(int rows, int columns)
			: this(new DenseColumnMajorMatrixStorage<float>(rows, columns))
		{
		}

		public DenseMatrix(int rows, int columns, float[] storage)
			: this(new DenseColumnMajorMatrixStorage<float>(rows, columns, storage))
		{
		}

		public static DenseMatrix OfMatrix(Matrix<float> matrix)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfMatrix(matrix.Storage));
		}

		public static DenseMatrix OfArray(float[,] array)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfArray(array));
		}

		public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, float>> enumerable)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable<float> columnMajor)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfColumnMajorEnumerable(rows, columns, columnMajor));
		}

		public static DenseMatrix OfColumns(IEnumerable<IEnumerable<float>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<float> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<float>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfColumnEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfColumnArrays(params float[][] columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfColumnArrays(columns));
		}

		public static DenseMatrix OfColumnArrays(IEnumerable<float[]> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfColumnArrays((columns as float[][]) ?? columns.ToArray()));
		}

		public static DenseMatrix OfColumnVectors(params Vector<float>[] columns)
		{
			VectorStorage<float>[] array = new VectorStorage<float>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfColumnVectors(array));
		}

		public static DenseMatrix OfColumnVectors(IEnumerable<Vector<float>> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfColumnVectors(columns.Select((Vector<float> c) => c.Storage).ToArray()));
		}

		public static DenseMatrix OfRows(IEnumerable<IEnumerable<float>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<float> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<float>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfRowEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfRowArrays(params float[][] rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfRowArrays(rows));
		}

		public static DenseMatrix OfRowArrays(IEnumerable<float[]> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfRowArrays((rows as float[][]) ?? rows.ToArray()));
		}

		public static DenseMatrix OfRowVectors(params Vector<float>[] rows)
		{
			VectorStorage<float>[] array = new VectorStorage<float>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfRowVectors(array));
		}

		public static DenseMatrix OfRowVectors(IEnumerable<Vector<float>> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfRowVectors(rows.Select((Vector<float> r) => r.Storage).ToArray()));
		}

		public static DenseMatrix OfDiagonalVector(Vector<float> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Count, diagonal.Count);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector<float> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(float[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Length, diagonal.Length);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(int rows, int columns, float[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix Create(int rows, int columns, float value)
		{
			if (value == 0f)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfValue(rows, columns, value));
		}

		public static DenseMatrix Create(int rows, int columns, Func<int, int, float> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfInit(rows, columns, init));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, float value)
		{
			if (value == 0f)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, Func<int, float> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfDiagonalInit(rows, columns, init));
		}

		public static DenseMatrix CreateIdentity(int order)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<float>.OfDiagonalInit(order, order, (int i) => Matrix<float>.One));
		}

		public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DenseMatrix(new DenseColumnMajorMatrixStorage<float>(rows, columns, Generate.RandomSingle(rows * columns, distribution)));
		}

		public override double L1Norm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.OneNorm, _rowCount, _columnCount, _values);
		}

		public override double InfinityNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.InfinityNorm, _rowCount, _columnCount, _values);
		}

		public override double FrobeniusNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.FrobeniusNorm, _rowCount, _columnCount, _values);
		}

		protected override void DoNegate(Matrix<float> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1f, _values, denseMatrix._values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoAdd(float scalar, Matrix<float> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					float[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Matrix<float> other, Matrix<float> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<float> diagonalMatrixStorage)
			{
				base.Storage.CopyToUnchecked(result.Storage, ExistingData.Clear);
				float[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) + data[i]);
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(float scalar, Matrix<float> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					float[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Matrix<float> other, Matrix<float> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<float> diagonalMatrixStorage)
			{
				CopyTo(result);
				float[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) - data[i]);
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(float scalar, Matrix<float> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseMatrix._values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<float> rightSide, Vector<float> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, denseVector2.Values);
			}
			else
			{
				base.DoMultiply(rightSide, result);
			}
		}

		protected override void DoMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<float> diagonalMatrixStorage)
			{
				float[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.ColumnCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoMultiply(other, result);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, 1f, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0f, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<float> diagonalMatrixStorage)
			{
				float[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.RowCount);
				if (num < other.RowCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.RowCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<float> rightSide, Vector<float> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1f, _values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, 0f, denseVector2.Values);
			}
			else
			{
				base.DoTransposeThisAndMultiply(rightSide, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1f, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0f, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<float> diagonalMatrixStorage)
			{
				float[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.RowCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.ColumnCount, base.RowCount, other.ColumnCount - base.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < base.ColumnCount; i++)
				{
					for (int j = 0; j < num; j++)
					{
						result.At(i, j, _values[num2] * data[j]);
						num2++;
					}
					num2 += base.RowCount - num;
				}
			}
			else
			{
				base.DoTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoDivide(float divisor, Matrix<float> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1f / divisor, _values, denseMatrix._values);
			}
			else
			{
				base.DoDivide(divisor, result);
			}
		}

		protected override void DoPointwiseMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Matrix<float> divisor, Matrix<float> result)
		{
			if (divisor is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Matrix<float> exponent, Matrix<float> result)
		{
			if (exponent is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		protected override void DoModulus(float divisor, Matrix<float> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				CommonParallel.For(0, _values.Length, delegate(int a, int b)
				{
					float[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = Euclid.Modulus(values[i], divisor);
					}
				});
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoModulusByThis(float dividend, Matrix<float> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					float[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = Euclid.Modulus(dividend, _values[i]);
					}
				});
			}
			else
			{
				base.DoModulusByThis(dividend, result);
			}
		}

		protected override void DoRemainder(float divisor, Matrix<float> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				CommonParallel.For(0, _values.Length, delegate(int a, int b)
				{
					float[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] %= divisor;
					}
				});
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		protected override void DoRemainderByThis(float dividend, Matrix<float> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					float[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = dividend % _values[i];
					}
				});
			}
			else
			{
				base.DoRemainderByThis(dividend, result);
			}
		}

		public override float Trace()
		{
			if (_rowCount != _columnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			float num = 0f;
			for (int i = 0; i < _rowCount; i++)
			{
				num += _values[i * _rowCount + i];
			}
			return num;
		}

		public static DenseMatrix operator +(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Add(rightSide);
		}

		public static DenseMatrix operator +(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Clone();
		}

		public static DenseMatrix operator -(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Subtract(rightSide);
		}

		public static DenseMatrix operator -(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Negate();
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseMatrix operator *(float leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Multiply(leftSide);
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide._columnCount != rightSide._rowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseMatrix leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseVector leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.LeftMultiply(leftSide);
		}

		public static DenseMatrix operator %(DenseMatrix leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Remainder(rightSide);
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < base.ColumnCount; i++)
			{
				int num = i * base.RowCount;
				for (int j = i + 1; j < base.RowCount; j++)
				{
					if (_values[j * base.ColumnCount + i] != _values[num + j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public override Cholesky<float> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseCholesky.Create(this);
		}

		public override LU<float> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseLU.Create(this);
		}

		public override QR<float> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseQR.Create(this, method);
		}

		public override GramSchmidt<float> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseGramSchmidt.Create(this);
		}

		public override Svd<float> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseSvd.Create(this, computeVectors);
		}

		public override Evd<float> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseVector {Count}-Single")]
	public class DenseVector : Vector
	{
		private readonly int _length;

		private readonly float[] _values;

		public float[] Values => _values;

		public DenseVector(DenseVectorStorage<float> storage)
			: base(storage)
		{
			_length = storage.Length;
			_values = storage.Data;
		}

		public DenseVector(int length)
			: this(new DenseVectorStorage<float>(length))
		{
		}

		public DenseVector(float[] storage)
			: this(new DenseVectorStorage<float>(storage.Length, storage))
		{
		}

		public static DenseVector OfVector(Vector<float> vector)
		{
			return new DenseVector(DenseVectorStorage<float>.OfVector(vector.Storage));
		}

		public static DenseVector OfArray(float[] array)
		{
			return new DenseVector(DenseVectorStorage<float>.OfVector(new DenseVectorStorage<float>(array.Length, array)));
		}

		public static DenseVector OfEnumerable(IEnumerable<float> enumerable)
		{
			return new DenseVector(DenseVectorStorage<float>.OfEnumerable(enumerable));
		}

		public static DenseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, float>> enumerable)
		{
			return new DenseVector(DenseVectorStorage<float>.OfIndexedEnumerable(length, enumerable));
		}

		public static DenseVector Create(int length, float value)
		{
			if (value == 0f)
			{
				return new DenseVector(length);
			}
			return new DenseVector(DenseVectorStorage<float>.OfValue(length, value));
		}

		public static DenseVector Create(int length, Func<int, float> init)
		{
			return new DenseVector(DenseVectorStorage<float>.OfInit(length, init));
		}

		public static DenseVector CreateRandom(int length, IContinuousDistribution distribution)
		{
			float[] data = Generate.RandomSingle(length, distribution);
			return new DenseVector(new DenseVectorStorage<float>(length, data));
		}

		public static explicit operator float[](DenseVector vector)
		{
			if (vector == null)
			{
				throw new ArgumentNullException("vector");
			}
			return vector.Values;
		}

		public static implicit operator DenseVector(float[] array)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			return new DenseVector(array);
		}

		protected override void DoAdd(float scalar, Vector<float> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Vector<float> other, Vector<float> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		public static DenseVector operator +(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Add(rightSide);
		}

		protected override void DoSubtract(float scalar, Vector<float> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Vector<float> other, Vector<float> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		public static DenseVector operator -(DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Negate();
		}

		public static DenseVector operator -(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Subtract(rightSide);
		}

		protected override void DoNegate(Vector<float> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1f, _values, denseVector.Values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoMultiply(float scalar, Vector<float> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseVector.Values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override float DoDotProduct(Vector<float> other)
		{
			if (!(other is DenseVector denseVector))
			{
				return base.DoDotProduct(other);
			}
			return LinearAlgebraControl.Provider.DotProduct(_values, denseVector.Values);
		}

		public static DenseVector operator *(DenseVector leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(float leftSide, DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Multiply(leftSide);
		}

		public static float operator *(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static DenseVector operator /(DenseVector leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Divide(rightSide);
		}

		protected override void DoModulus(float divisor, Vector<float> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = Euclid.Modulus(_values[i], divisor);
					}
				});
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoRemainder(float divisor, Vector<float> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] % divisor;
					}
				});
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		public static DenseVector operator %(DenseVector leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Remainder(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			float num2 = Math.Abs(_values[num]);
			for (int i = 1; i < _length; i++)
			{
				float num3 = Math.Abs(_values[i]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			float num2 = Math.Abs(_values[num]);
			for (int i = 1; i < _length; i++)
			{
				float num3 = Math.Abs(_values[i]);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override int MaximumIndex()
		{
			int result = 0;
			float num = _values[0];
			for (int i = 1; i < _length; i++)
			{
				if (num < _values[i])
				{
					result = i;
					num = _values[i];
				}
			}
			return result;
		}

		public override int MinimumIndex()
		{
			int result = 0;
			float num = _values[0];
			for (int i = 1; i < _length; i++)
			{
				if (num > _values[i])
				{
					result = i;
					num = _values[i];
				}
			}
			return result;
		}

		public override float Sum()
		{
			float num = 0f;
			for (int i = 0; i < _length; i++)
			{
				num += _values[i];
			}
			return num;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += (double)Math.Abs(_values[i]);
			}
			return num;
		}

		public override double L2Norm()
		{
			return _values.Aggregate(0f, SpecialFunctions.Hypotenuse);
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(_values, (int i, float v) => Math.Abs(v), Math.Max, 0f);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += Math.Pow(Math.Abs(_values[i]), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<float> other, Vector<float> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Vector<float> divisor, Vector<float> result)
		{
			if (divisor is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Vector<float> exponent, Vector<float> result)
		{
			if (exponent is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		public static DenseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			float[] array = (from t in value.Split(new string[3]
				{
					formatProvider.GetTextInfo().ListSeparator,
					" ",
					"\t"
				}, StringSplitOptions.RemoveEmptyEntries)
				select float.Parse(t, NumberStyles.Any, formatProvider)).ToArray();
			if (array.Length == 0)
			{
				throw new FormatException();
			}
			return new DenseVector(array);
		}

		public static bool TryParse(string value, out DenseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out DenseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}
	}
	[Serializable]
	[DebuggerDisplay("DiagonalMatrix {RowCount}x{ColumnCount}-Single")]
	public class DiagonalMatrix : Matrix
	{
		private readonly float[] _data;

		public DiagonalMatrix(DiagonalMatrixStorage<float> storage)
			: base(storage)
		{
			_data = storage.Data;
		}

		public DiagonalMatrix(int order)
			: this(new DiagonalMatrixStorage<float>(order, order))
		{
		}

		public DiagonalMatrix(int rows, int columns)
			: this(new DiagonalMatrixStorage<float>(rows, columns))
		{
		}

		public DiagonalMatrix(int rows, int columns, float diagonalValue)
			: this(rows, columns)
		{
			for (int i = 0; i < _data.Length; i++)
			{
				_data[i] = diagonalValue;
			}
		}

		public DiagonalMatrix(int rows, int columns, float[] diagonalStorage)
			: this(new DiagonalMatrixStorage<float>(rows, columns, diagonalStorage))
		{
		}

		public static DiagonalMatrix OfMatrix(Matrix<float> matrix)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<float>.OfMatrix(matrix.Storage));
		}

		public static DiagonalMatrix OfArray(float[,] array)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<float>.OfArray(array));
		}

		public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable<Tuple<int, float>> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<float>.OfIndexedEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable<float> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<float>.OfEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix Create(int rows, int columns, Func<int, float> init)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<float>.OfInit(rows, columns, init));
		}

		public static DiagonalMatrix CreateIdentity(int order)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<float>.OfValue(order, order, Matrix<float>.One));
		}

		public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DiagonalMatrix(new DiagonalMatrixStorage<float>(rows, columns, Generate.RandomSingle(Math.Min(rows, columns), distribution)));
		}

		protected override void DoNegate(Matrix<float> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1f, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, 0f - _data[i]);
			}
		}

		protected override void DoAdd(Matrix<float> other, Matrix<float> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.AddArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.CopyTo(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoSubtract(Matrix<float> other, Matrix<float> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.Negate(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoMultiply(float scalar, Matrix<float> result)
		{
			if ((double)scalar == 0.0)
			{
				result.Clear();
			}
			else if ((double)scalar == 1.0)
			{
				CopyTo(result);
			}
			else if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _data, diagonalMatrix._data);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<float> rightSide, Vector<float> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.RowCount)
			{
				result.ClearSubVector(base.ColumnCount, base.RowCount - base.ColumnCount);
			}
			if (num == base.ColumnCount && rightSide.Storage is DenseVectorStorage<float> denseVectorStorage && result.Storage is DenseVectorStorage<float> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				float[] array = new float[diagonalMatrix2._data.Length];
				float[] array2 = new float[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage)
			{
				float[] data = denseColumnMajorMatrixStorage.Data;
				float[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.RowCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, float x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, float x) => x * _data[i], 0, 0, Math.Min(base.RowCount, other.RowCount), 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				float[] array = new float[diagonalMatrix2._data.Length];
				float[] array2 = new float[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage)
			{
				float[] data = denseColumnMajorMatrixStorage.Data;
				float[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount - denseColumnMajorMatrixStorage.ColumnCount, 0, denseColumnMajorMatrixStorage.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
					{
						result.At(i, j, data[num2] * data2[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				float[] array = new float[diagonalMatrix2._data.Length];
				float[] array2 = new float[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage)
			{
				float[] data = denseColumnMajorMatrixStorage.Data;
				float[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount);
				if (num < base.ColumnCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, float x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, float x) => x * _data[i], 0, 0, other.RowCount, 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<float> rightSide, Vector<float> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.ColumnCount)
			{
				result.ClearSubVector(base.RowCount, base.ColumnCount - base.RowCount);
			}
			if (num == base.RowCount && rightSide.Storage is DenseVectorStorage<float> denseVectorStorage && result.Storage is DenseVectorStorage<float> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoDivide(float divisor, Matrix<float> result)
		{
			if (divisor == 1f)
			{
				CopyTo(result);
				return;
			}
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1f / divisor, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i] / divisor);
			}
		}

		protected override void DoDivideByThis(float dividend, Matrix<float> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				float[] resultData = diagonalMatrix._data;
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						resultData[j] = dividend / _data[j];
					}
				});
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, dividend / _data[i]);
				}
			}
		}

		public override float Determinant()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			return _data.Aggregate(1f, (float current, float t) => current * t);
		}

		public override Vector<float> Diagonal()
		{
			return new DenseVector(_data).Clone();
		}

		public override void SetDiagonal(float[] source)
		{
			if (source.Length != _data.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "source");
			}
			Buffer.BlockCopy(source, 0, _data, 0, source.Length * 4);
		}

		public override void SetDiagonal(Vector<float> source)
		{
			if (source is DenseVector denseVector)
			{
				if (_data.Length != denseVector.Values.Length)
				{
					throw new ArgumentException("All vectors must have the same dimensionality.", "source");
				}
				Buffer.BlockCopy(denseVector.Values, 0, _data, 0, denseVector.Values.Length * 4);
			}
			else
			{
				base.SetDiagonal(source);
			}
		}

		public override double L1Norm()
		{
			return _data.Aggregate(0f, (float current, float t) => Math.Max(current, Math.Abs(t)));
		}

		public override double L2Norm()
		{
			return _data.Aggregate(0f, (float current, float t) => Math.Max(current, Math.Abs(t)));
		}

		public override double InfinityNorm()
		{
			return L1Norm();
		}

		public override double FrobeniusNorm()
		{
			return Math.Sqrt(_data.Sum((float t) => t * t));
		}

		public override float ConditionNumber()
		{
			float num = float.NegativeInfinity;
			float num2 = float.PositiveInfinity;
			float[] data = _data;
			foreach (float value in data)
			{
				num = Math.Max(num, Math.Abs(value));
				num2 = Math.Min(num2, Math.Abs(value));
			}
			return num / num2;
		}

		public override Matrix<float> Inverse()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DiagonalMatrix diagonalMatrix = (DiagonalMatrix)Clone();
			for (int i = 0; i < _data.Length; i++)
			{
				if ((double)_data[i] != 0.0)
				{
					diagonalMatrix._data[i] = 1f / _data[i];
					continue;
				}
				throw new ArgumentException("Matrix must not be singular.");
			}
			return diagonalMatrix;
		}

		public override Matrix<float> LowerTriangle()
		{
			return Clone();
		}

		public override void LowerTriangle(Matrix<float> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this != result)
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, _data[i]);
				}
			}
		}

		public override Matrix<float> StrictlyLowerTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyLowerTriangle(Matrix<float> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<float> UpperTriangle()
		{
			return Clone();
		}

		public override void UpperTriangle(Matrix<float> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i]);
			}
		}

		public override Matrix<float> StrictlyUpperTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyUpperTriangle(Matrix<float> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<float> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			Matrix<float> matrix = ((rowIndex == columnIndex) ? ((Matrix)new DiagonalMatrix(rowCount, columnCount)) : ((Matrix)new SparseMatrix(rowCount, columnCount)));
			base.Storage.CopySubMatrixTo(matrix.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public override void PermuteColumns(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public override void PermuteRows(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public sealed override bool IsSymmetric()
		{
			return true;
		}

		protected override void DoModulus(float divisor, Matrix<float> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					float[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = Euclid.Modulus(_data[i], divisor);
					}
				});
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoModulusByThis(float dividend, Matrix<float> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					float[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = Euclid.Modulus(dividend, _data[i]);
					}
				});
			}
			else
			{
				base.DoModulusByThis(dividend, result);
			}
		}

		protected override void DoRemainder(float divisor, Matrix<float> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					float[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = _data[i] % divisor;
					}
				});
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		protected override void DoRemainderByThis(float dividend, Matrix<float> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					float[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = dividend % _data[i];
					}
				});
			}
			else
			{
				base.DoRemainderByThis(dividend, result);
			}
		}
	}
	[Serializable]
	public abstract class Matrix : Matrix<float>
	{
		protected Matrix(MatrixStorage<float> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((float x) => (!((double)Math.Abs(x) < threshold)) ? x : 0f);
		}

		public sealed override Matrix<float> ConjugateTranspose()
		{
			return Transpose();
		}

		public sealed override void ConjugateTranspose(Matrix<float> result)
		{
			Transpose(result);
		}

		protected sealed override void DoConjugate(Matrix<float> result)
		{
			if (this != result)
			{
				CopyTo(result);
			}
		}

		protected override void DoNegate(Matrix<float> result)
		{
			Map((float x) => 0f - x, result);
		}

		protected override void DoAdd(float scalar, Matrix<float> result)
		{
			Map((float x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Matrix<float> other, Matrix<float> result)
		{
			Map2((float x, float y) => x + y, other, result);
		}

		protected override void DoSubtract(float scalar, Matrix<float> result)
		{
			Map((float x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Matrix<float> other, Matrix<float> result)
		{
			Map2((float x, float y) => x - y, other, result);
		}

		protected override void DoMultiply(float scalar, Matrix<float> result)
		{
			Map((float x) => x * scalar, result);
		}

		protected override void DoMultiply(Vector<float> rightSide, Vector<float> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				float num = 0f;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					num += At(i, j) * rightSide[j];
				}
				result[i] = num;
			}
		}

		protected override void DoMultiply(Matrix<float> other, Matrix<float> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				for (int j = 0; j < other.ColumnCount; j++)
				{
					float num = 0f;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						num += At(i, k) * other.At(k, j);
					}
					result.At(i, j, num);
				}
			}
		}

		protected override void DoDivide(float divisor, Matrix<float> result)
		{
			Map((float x) => x / divisor, result, (divisor == 0f) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(float dividend, Matrix<float> result)
		{
			Map((float x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoTransposeAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			for (int i = 0; i < other.RowCount; i++)
			{
				for (int j = 0; j < base.RowCount; j++)
				{
					float num = 0f;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						num += At(j, k) * other.At(i, k);
					}
					result.At(j, i, num);
				}
			}
		}

		protected sealed override void DoConjugateTransposeAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			DoTransposeAndMultiply(other, result);
		}

		protected override void DoTransposeThisAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			for (int i = 0; i < other.ColumnCount; i++)
			{
				for (int j = 0; j < base.ColumnCount; j++)
				{
					float num = 0f;
					for (int k = 0; k < base.RowCount; k++)
					{
						num += At(k, j) * other.At(k, i);
					}
					result.At(j, i, num);
				}
			}
		}

		protected sealed override void DoConjugateTransposeThisAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			DoTransposeThisAndMultiply(other, result);
		}

		protected override void DoTransposeThisAndMultiply(Vector<float> rightSide, Vector<float> result)
		{
			for (int i = 0; i < base.ColumnCount; i++)
			{
				float num = 0f;
				for (int j = 0; j < base.RowCount; j++)
				{
					num += At(j, i) * rightSide[j];
				}
				result[i] = num;
			}
		}

		protected sealed override void DoConjugateTransposeThisAndMultiply(Vector<float> rightSide, Vector<float> result)
		{
			DoTransposeThisAndMultiply(rightSide, result);
		}

		protected override void DoModulus(float divisor, Matrix<float> result)
		{
			Map((float x) => Euclid.Modulus(x, divisor), result, Zeros.Include);
		}

		protected override void DoModulusByThis(float dividend, Matrix<float> result)
		{
			Map((float x) => Euclid.Modulus(dividend, x), result, Zeros.Include);
		}

		protected override void DoRemainder(float divisor, Matrix<float> result)
		{
			Map((float x) => Euclid.Remainder(x, divisor), result, Zeros.Include);
		}

		protected override void DoRemainderByThis(float dividend, Matrix<float> result)
		{
			Map((float x) => Euclid.Remainder(dividend, x), result, Zeros.Include);
		}

		protected override void DoPointwiseMultiply(Matrix<float> other, Matrix<float> result)
		{
			Map2((float x, float y) => x * y, other, result);
		}

		protected override void DoPointwiseDivide(Matrix<float> divisor, Matrix<float> result)
		{
			Map2((float x, float y) => x / y, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(float exponent, Matrix<float> result)
		{
			Map((float x) => (float)Math.Pow(x, exponent), result, (!(exponent > 0f)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwisePower(Matrix<float> exponent, Matrix<float> result)
		{
			Map2((float x, float y) => (float)Math.Pow(x, y), result, Zeros.Include);
		}

		protected override void DoPointwiseModulus(Matrix<float> divisor, Matrix<float> result)
		{
			Map2(Euclid.Modulus, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseRemainder(Matrix<float> divisor, Matrix<float> result)
		{
			Map2(Euclid.Remainder, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseExp(Matrix<float> result)
		{
			Map((float x) => (float)Math.Exp(x), result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Matrix<float> result)
		{
			Map((float x) => (float)Math.Log(x), result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Matrix<float> result)
		{
			Map((float x) => Math.Abs(x), result);
		}

		protected override void DoPointwiseAcos(Matrix<float> result)
		{
			Map((float x) => (float)Math.Acos(x), result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Matrix<float> result)
		{
			Map((float x) => (float)Math.Asin(x), result);
		}

		protected override void DoPointwiseAtan(Matrix<float> result)
		{
			Map((float x) => (float)Math.Atan(x), result);
		}

		protected override void DoPointwiseAtan2(Matrix<float> other, Matrix<float> result)
		{
			Map2((float x, float y) => (float)Math.Atan2(x, y), other, result, Zeros.Include);
		}

		protected override void DoPointwiseCeiling(Matrix<float> result)
		{
			Map((float x) => (float)Math.Ceiling(x), result);
		}

		protected override void DoPointwiseCos(Matrix<float> result)
		{
			Map((float x) => (float)Math.Cos(x), result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Matrix<float> result)
		{
			Map((float x) => (float)Math.Cosh(x), result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Matrix<float> result)
		{
			Map((float x) => (float)Math.Floor(x), result);
		}

		protected override void DoPointwiseLog10(Matrix<float> result)
		{
			Map((float x) => (float)Math.Log10(x), result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Matrix<float> result)
		{
			Map((float x) => (float)Math.Round(x), result);
		}

		protected override void DoPointwiseSign(Matrix<float> result)
		{
			Map((float x) => Math.Sign(x), result);
		}

		protected override void DoPointwiseSin(Matrix<float> result)
		{
			Map((float x) => (float)Math.Sin(x), result);
		}

		protected override void DoPointwiseSinh(Matrix<float> result)
		{
			Map((float x) => (float)Math.Sinh(x), result);
		}

		protected override void DoPointwiseSqrt(Matrix<float> result)
		{
			Map((float x) => (float)Math.Sqrt(x), result);
		}

		protected override void DoPointwiseTan(Matrix<float> result)
		{
			Map((float x) => (float)Math.Tan(x), result);
		}

		protected override void DoPointwiseTanh(Matrix<float> result)
		{
			Map((float x) => (float)Math.Tanh(x), result);
		}

		public override Matrix<float> PseudoInverse()
		{
			Svd<float> svd = Svd();
			Matrix<float> w = svd.W;
			Vector<float> s = svd.S;
			float num = (float)((double)Math.Max(base.RowCount, base.ColumnCount) * svd.L2Norm * Precision.SinglePrecision);
			for (int i = 0; i < s.Count; i++)
			{
				s[i] = ((s[i] < num) ? 0f : (1f / s[i]));
			}
			w.SetDiagonal(s);
			return (svd.U * (w * svd.VT)).Transpose();
		}

		public override float Trace()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			float num = 0f;
			for (int i = 0; i < base.RowCount; i++)
			{
				num += At(i, i);
			}
			return num;
		}

		protected override void DoPointwiseMinimum(float scalar, Matrix<float> result)
		{
			Map((float x) => Math.Min(scalar, x), result, (!((double)scalar >= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseMaximum(float scalar, Matrix<float> result)
		{
			Map((float x) => Math.Max(scalar, x), result, (!((double)scalar <= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseAbsoluteMinimum(float scalar, Matrix<float> result)
		{
			float absolute = Math.Abs(scalar);
			Map((float x) => Math.Min(absolute, Math.Abs(x)), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(float scalar, Matrix<float> result)
		{
			float absolute = Math.Abs(scalar);
			Map((float x) => Math.Max(absolute, Math.Abs(x)), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Matrix<float> other, Matrix<float> result)
		{
			Map2(Math.Min, other, result);
		}

		protected override void DoPointwiseMaximum(Matrix<float> other, Matrix<float> result)
		{
			Map2(Math.Max, other, result);
		}

		protected override void DoPointwiseAbsoluteMinimum(Matrix<float> other, Matrix<float> result)
		{
			Map2((float x, float y) => Math.Min(Math.Abs(x), Math.Abs(y)), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Matrix<float> other, Matrix<float> result)
		{
			Map2((float x, float y) => Math.Max(Math.Abs(x), Math.Abs(y)), other, result);
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.ColumnCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.RowCount; j++)
				{
					num2 += (double)Math.Abs(At(j, i));
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double InfinityNorm()
		{
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					num2 += (double)Math.Abs(At(i, j));
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			Matrix<float> matrix = Transpose();
			Matrix<float> matrix2 = this * matrix;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				num += (double)matrix2.At(i, i);
			}
			return Math.Sqrt(num);
		}

		public override Vector<double> RowNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.RowCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, float x) => s + (double)(x * x), (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, float x) => s + (double)Math.Abs(x), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByRowUnchecked(array, (double s, float x) => Math.Max(s, Math.Abs(x)), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByRowUnchecked(array, (double s, float x) => s + Math.Pow(Math.Abs(x), norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> ColumnNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.ColumnCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, float x) => s + (double)(x * x), (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, float x) => s + (double)Math.Abs(x), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, float x) => Math.Max(s, Math.Abs(x)), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByColumnUnchecked(array, (double s, float x) => s + Math.Pow(Math.Abs(x), norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public sealed override Matrix<float> NormalizeRows(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)RowNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<float> matrix = Matrix<float>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, float x) => (float)norminv[i] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public sealed override Matrix<float> NormalizeColumns(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)ColumnNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<float> matrix = Matrix<float>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, float x) => (float)norminv[j] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public override Vector<float> RowSums()
		{
			float[] array = new float[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (float s, float x) => s + x, (float x, int c) => x, array, Zeros.AllowSkip);
			return Vector<float>.Build.Dense(array);
		}

		public override Vector<float> RowAbsoluteSums()
		{
			float[] array = new float[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (float s, float x) => s + Math.Abs(x), (float x, int c) => x, array, Zeros.AllowSkip);
			return Vector<float>.Build.Dense(array);
		}

		public override Vector<float> ColumnSums()
		{
			float[] array = new float[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (float s, float x) => s + x, (float x, int c) => x, array, Zeros.AllowSkip);
			return Vector<float>.Build.Dense(array);
		}

		public override Vector<float> ColumnAbsoluteSums()
		{
			float[] array = new float[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (float s, float x) => s + Math.Abs(x), (float x, int c) => x, array, Zeros.AllowSkip);
			return Vector<float>.Build.Dense(array);
		}

		public sealed override bool IsHermitian()
		{
			return IsSymmetric();
		}

		public override Cholesky<float> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.UserCholesky.Create(this);
		}

		public override LU<float> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.UserLU.Create(this);
		}

		public override QR<float> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.UserQR.Create(this, method);
		}

		public override GramSchmidt<float> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.UserGramSchmidt.Create(this);
		}

		public override Svd<float> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.UserSvd.Create(this, computeVectors);
		}

		public override Evd<float> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Single.Factorization.UserEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseMatrix {RowCount}x{ColumnCount}-Single {NonZerosCount}-NonZero")]
	public class SparseMatrix : Matrix
	{
		private readonly SparseCompressedRowMatrixStorage<float> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseMatrix(SparseCompressedRowMatrixStorage<float> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseMatrix(int order)
			: this(order, order)
		{
		}

		public SparseMatrix(int rows, int columns)
			: this(new SparseCompressedRowMatrixStorage<float>(rows, columns))
		{
		}

		public static SparseMatrix OfMatrix(Matrix<float> matrix)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfMatrix(matrix.Storage));
		}

		public static SparseMatrix OfArray(float[,] array)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfArray(array));
		}

		public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, float>> enumerable)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable<float> rowMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfRowMajorEnumerable(rows, columns, rowMajor));
		}

		public static SparseMatrix OfColumnMajor(int rows, int columns, IList<float> columnMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfColumnMajorList(rows, columns, columnMajor));
		}

		public static SparseMatrix OfColumns(IEnumerable<IEnumerable<float>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<float> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<float>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfColumnEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfColumnArrays(params float[][] columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfColumnArrays(columns));
		}

		public static SparseMatrix OfColumnArrays(IEnumerable<float[]> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfColumnArrays((columns as float[][]) ?? columns.ToArray()));
		}

		public static SparseMatrix OfColumnVectors(params Vector<float>[] columns)
		{
			VectorStorage<float>[] array = new VectorStorage<float>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfColumnVectors(array));
		}

		public static SparseMatrix OfColumnVectors(IEnumerable<Vector<float>> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfColumnVectors(columns.Select((Vector<float> c) => c.Storage).ToArray()));
		}

		public static SparseMatrix OfRows(IEnumerable<IEnumerable<float>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<float> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<float>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfRowEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfRowArrays(params float[][] rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfRowArrays(rows));
		}

		public static SparseMatrix OfRowArrays(IEnumerable<float[]> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfRowArrays((rows as float[][]) ?? rows.ToArray()));
		}

		public static SparseMatrix OfRowVectors(params Vector<float>[] rows)
		{
			VectorStorage<float>[] array = new VectorStorage<float>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfRowVectors(array));
		}

		public static SparseMatrix OfRowVectors(IEnumerable<Vector<float>> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfRowVectors(rows.Select((Vector<float> r) => r.Storage).ToArray()));
		}

		public static SparseMatrix OfDiagonalVector(Vector<float> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Count, diagonal.Count);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector<float> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(float[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Length, diagonal.Length);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(int rows, int columns, float[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix Create(int rows, int columns, float value)
		{
			if (value == 0f)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfValue(rows, columns, value));
		}

		public static SparseMatrix Create(int rows, int columns, Func<int, int, float> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfInit(rows, columns, init));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, float value)
		{
			if (value == 0f)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, Func<int, float> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfDiagonalInit(rows, columns, init));
		}

		public static SparseMatrix CreateIdentity(int order)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<float>.OfDiagonalInit(order, order, (int i) => Matrix<float>.One));
		}

		public override Matrix<float> LowerTriangle()
		{
			Matrix<float> result = Matrix<float>.Build.SameAs(this);
			LowerTriangleImpl(result);
			return result;
		}

		public override void LowerTriangle(Matrix<float> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<float> matrix = Matrix<float>.Build.SameAs(result);
				LowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				LowerTriangleImpl(result);
			}
		}

		private void LowerTriangleImpl(Matrix<float> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i >= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<float> UpperTriangle()
		{
			Matrix<float> result = Matrix<float>.Build.SameAs(this);
			UpperTriangleImpl(result);
			return result;
		}

		public override void UpperTriangle(Matrix<float> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<float> matrix = Matrix<float>.Build.SameAs(result);
				UpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				UpperTriangleImpl(result);
			}
		}

		private void UpperTriangleImpl(Matrix<float> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i <= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<float> StrictlyLowerTriangle()
		{
			Matrix<float> result = Matrix<float>.Build.SameAs(this);
			StrictlyLowerTriangleImpl(result);
			return result;
		}

		public override void StrictlyLowerTriangle(Matrix<float> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<float> matrix = Matrix<float>.Build.SameAs(result);
				StrictlyLowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyLowerTriangleImpl(result);
			}
		}

		private void StrictlyLowerTriangleImpl(Matrix<float> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i > columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<float> StrictlyUpperTriangle()
		{
			Matrix<float> result = Matrix<float>.Build.SameAs(this);
			StrictlyUpperTriangleImpl(result);
			return result;
		}

		public override void StrictlyUpperTriangle(Matrix<float> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<float> matrix = Matrix<float>.Build.SameAs(result);
				StrictlyUpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyUpperTriangleImpl(result);
			}
		}

		private void StrictlyUpperTriangleImpl(Matrix<float> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i < columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		protected override void DoNegate(Matrix<float> result)
		{
			CopyTo(result);
			DoMultiply(-1f, result);
		}

		public override double InfinityNorm()
		{
			int[] rowPointers = _storage.RowPointers;
			float[] values = _storage.Values;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num2 = rowPointers[i];
				int num3 = rowPointers[i + 1];
				if (num2 != num3)
				{
					double num4 = 0.0;
					for (int j = num2; j < num3; j++)
					{
						num4 += (double)Math.Abs(values[j]);
					}
					num = Math.Max(num, num4);
				}
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			SparseCompressedRowMatrixStorage<float> sparseCompressedRowMatrixStorage = (SparseCompressedRowMatrixStorage<float>)(this * Transpose()).Storage;
			double num = 0.0;
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				int num2 = sparseCompressedRowMatrixStorage.RowPointers[i];
				int num3 = sparseCompressedRowMatrixStorage.RowPointers[i + 1];
				if (num2 == num3)
				{
					continue;
				}
				for (int j = num2; j < num3; j++)
				{
					if (i == sparseCompressedRowMatrixStorage.ColumnIndices[j])
					{
						num += (double)Math.Abs(sparseCompressedRowMatrixStorage.Values[j]);
					}
				}
			}
			return Math.Sqrt(num);
		}

		protected override void DoAdd(Matrix<float> other, Matrix<float> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					if (this != result)
					{
						CopyTo(result);
					}
					LinearAlgebraControl.Provider.ScaleArray(2f, sparseMatrix2._storage.Values, sparseMatrix2._storage.Values);
					return;
				}
				SparseMatrix sparseMatrix3;
				if (sparseMatrix == sparseMatrix2)
				{
					sparseMatrix3 = this;
				}
				else if (this == sparseMatrix2)
				{
					sparseMatrix3 = sparseMatrix;
				}
				else
				{
					CopyTo(sparseMatrix2);
					sparseMatrix3 = sparseMatrix;
				}
				SparseCompressedRowMatrixStorage<float> storage = sparseMatrix3._storage;
				for (int i = 0; i < storage.RowCount; i++)
				{
					int num = storage.RowPointers[i + 1];
					for (int j = storage.RowPointers[i]; j < num; j++)
					{
						int column = storage.ColumnIndices[j];
						float value = storage.Values[j] + result.At(i, column);
						result.At(i, column, value);
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(Matrix<float> other, Matrix<float> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					result.Clear();
					return;
				}
				SparseCompressedRowMatrixStorage<float> storage = sparseMatrix._storage;
				if (this == sparseMatrix2)
				{
					for (int i = 0; i < storage.RowCount; i++)
					{
						int num = storage.RowPointers[i + 1];
						for (int j = storage.RowPointers[i]; j < num; j++)
						{
							int column = storage.ColumnIndices[j];
							float value = sparseMatrix2.At(i, column) - storage.Values[j];
							result.At(i, column, value);
						}
					}
					return;
				}
				if (sparseMatrix != sparseMatrix2)
				{
					sparseMatrix.CopyTo(sparseMatrix2);
				}
				sparseMatrix2.Negate(sparseMatrix2);
				int[] rowPointers = _storage.RowPointers;
				int[] columnIndices = _storage.ColumnIndices;
				float[] values = _storage.Values;
				for (int k = 0; k < base.RowCount; k++)
				{
					int num2 = rowPointers[k + 1];
					for (int l = rowPointers[k]; l < num2; l++)
					{
						int column2 = columnIndices[l];
						float value2 = sparseMatrix2.At(k, column2) + values[l];
						result.At(k, column2, value2);
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(float scalar, Matrix<float> result)
		{
			if ((double)scalar == 1.0)
			{
				CopyTo(result);
				return;
			}
			if ((double)scalar == 0.0 || NonZerosCount == 0)
			{
				result.Clear();
				return;
			}
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(sparseMatrix);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseMatrix._storage.Values, sparseMatrix._storage.Values);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					for (int j = num; j < num2; j++)
					{
						int column = columnIndices[j];
						result.At(i, column, values[j] * scalar);
					}
				}
			}
		}

		protected override void DoMultiply(Matrix<float> other, Matrix<float> result)
		{
			SparseMatrix sparseMatrix = other as SparseMatrix;
			SparseMatrix sparseMatrix2 = result as SparseMatrix;
			if (sparseMatrix != null && sparseMatrix2 != null)
			{
				DoMultiplySparse(sparseMatrix, sparseMatrix2);
				return;
			}
			if (other.Storage is DiagonalMatrixStorage<float> diagonalMatrixStorage && sparseMatrix2 != null)
			{
				float[] diagonal = diagonalMatrixStorage.Data;
				if (other.ColumnCount == other.RowCount)
				{
					base.Storage.MapIndexedTo(result.Storage, (int i, int j, float x) => x * diagonal[j], Zeros.AllowSkip, ExistingData.Clear);
					return;
				}
				result.Storage.Clear();
				base.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, float x) => x * diagonal[j], 0, 0, base.RowCount, 0, 0, Math.Min(base.ColumnCount, other.ColumnCount), Zeros.AllowSkip, ExistingData.AssumeZeros);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			if (other.Storage is DenseColumnMajorMatrixStorage<float> denseColumnMajorMatrixStorage)
			{
				for (int k = 0; k < base.RowCount; k++)
				{
					int num = rowPointers[k];
					int num2 = rowPointers[k + 1];
					if (num == num2)
					{
						continue;
					}
					for (int l = 0; l < other.ColumnCount; l++)
					{
						int num3 = l * other.RowCount;
						float num4 = 0f;
						for (int m = num; m < num2; m++)
						{
							num4 += values[m] * denseColumnMajorMatrixStorage.Data[num3 + columnIndices[m]];
						}
						result.At(k, l, num4);
					}
				}
				return;
			}
			DenseVector denseVector = new DenseVector(other.RowCount);
			for (int n = 0; n < base.RowCount; n++)
			{
				int num5 = rowPointers[n];
				int num6 = rowPointers[n + 1];
				if (num5 == num6)
				{
					continue;
				}
				for (int num7 = 0; num7 < other.ColumnCount; num7++)
				{
					other.Column(num7, denseVector);
					float num8 = 0f;
					for (int num9 = num5; num9 < num6; num9++)
					{
						num8 += values[num9] * denseVector[columnIndices[num9]];
					}
					result.At(n, num7, num8);
				}
			}
		}

		private void DoMultiplySparse(SparseMatrix other, SparseMatrix result)
		{
			result.Clear();
			float[] values = _storage.Values;
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values2 = other._storage.Values;
			int[] rowPointers2 = other._storage.RowPointers;
			int[] columnIndices2 = other._storage.ColumnIndices;
			int rowCount = base.RowCount;
			int columnCount = other.ColumnCount;
			int[] rowPointers3 = result._storage.RowPointers;
			int[] array = new int[columnCount];
			for (int i = 0; i < columnCount; i++)
			{
				array[i] = -1;
			}
			int num = 0;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = rowPointers[j]; k < rowPointers[j + 1]; k++)
				{
					int num2 = columnIndices[k];
					for (int l = rowPointers2[num2]; l < rowPointers2[num2 + 1]; l++)
					{
						int num3 = columnIndices2[l];
						if (array[num3] != j)
						{
							array[num3] = j;
							num++;
						}
					}
				}
				rowPointers3[j + 1] = num;
			}
			int[] array2 = new int[num];
			float[] array3 = new float[num];
			for (int m = 0; m < columnCount; m++)
			{
				array[m] = -1;
			}
			num = 0;
			for (int n = 0; n < rowCount; n++)
			{
				int num4 = rowPointers3[n];
				for (int num5 = rowPointers[n]; num5 < rowPointers[n + 1]; num5++)
				{
					int num6 = columnIndices[num5];
					float num7 = values[num5];
					for (int num8 = rowPointers2[num6]; num8 < rowPointers2[num6 + 1]; num8++)
					{
						int num9 = columnIndices2[num8];
						float num10 = values2[num8];
						if (array[num9] < num4)
						{
							array[num9] = num;
							array2[array[num9]] = num9;
							array3[array[num9]] = num7 * num10;
							num++;
						}
						else
						{
							array3[array[num9]] += num7 * num10;
						}
					}
				}
			}
			result._storage.Values = array3;
			result._storage.ColumnIndices = array2;
			result._storage.Normalize();
		}

		protected override void DoMultiply(Vector<float> rightSide, Vector<float> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					float num3 = 0f;
					for (int j = num; j < num2; j++)
					{
						num3 += values[j] * rightSide[columnIndices[j]];
					}
					result[i] = num3;
				}
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<float> other, Matrix<float> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				sparseMatrix2.Clear();
				int[] rowPointers = _storage.RowPointers;
				float[] values = _storage.Values;
				SparseCompressedRowMatrixStorage<float> storage = sparseMatrix._storage;
				for (int i = 0; i < base.RowCount; i++)
				{
					int num = storage.RowPointers[i];
					int num2 = storage.RowPointers[i + 1];
					if (num == num2)
					{
						continue;
					}
					for (int j = 0; j < base.RowCount; j++)
					{
						int num3 = rowPointers[j];
						int num4 = rowPointers[j + 1];
						if (num3 == num4)
						{
							continue;
						}
						float num5 = 0f;
						for (int k = num; k < num2; k++)
						{
							int num6 = _storage.FindItem(j, storage.ColumnIndices[k]);
							if (num6 >= 0)
							{
								num5 += storage.Values[k] * values[num6];
							}
						}
						sparseMatrix2._storage.At(j, i, num5 + result.At(j, i));
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<float> rightSide, Vector<float> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					float num3 = rightSide[i];
					for (int j = num; j < num2; j++)
					{
						result[columnIndices[j]] += values[j] * num3;
					}
				}
			}
		}

		protected override void DoPointwiseMultiply(Matrix<float> other, Matrix<float> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					float num2 = values[j] * other.At(i, columnIndices[j]);
					if (num2 != 0f)
					{
						result.At(i, columnIndices[j], num2);
					}
				}
			}
		}

		protected override void DoPointwiseDivide(Matrix<float> divisor, Matrix<float> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (values[j] != 0f)
					{
						result.At(i, columnIndices[j], values[j] / divisor.At(i, columnIndices[j]));
					}
				}
			}
		}

		public override void KroneckerProduct(Matrix<float> other, Matrix<float> result)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount * other.RowCount || result.ColumnCount != base.ColumnCount * other.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, result);
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (values[j] != 0f)
					{
						result.SetSubMatrix(i * other.RowCount, other.RowCount, columnIndices[j] * other.ColumnCount, other.ColumnCount, values[j] * other);
					}
				}
			}
		}

		protected override void DoModulus(float divisor, Matrix<float> result)
		{
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				SparseCompressedRowMatrixStorage<float> storage = sparseMatrix._storage;
				for (int i = 0; i < storage.Values.Length; i++)
				{
					storage.Values[i] = Euclid.Modulus(storage.Values[i], divisor);
				}
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoRemainder(float divisor, Matrix<float> result)
		{
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				SparseCompressedRowMatrixStorage<float> storage = sparseMatrix._storage;
				for (int i = 0; i < storage.Values.Length; i++)
				{
					storage.Values[i] %= divisor;
				}
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			float[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num == num2)
				{
					continue;
				}
				for (int j = num; j < num2; j++)
				{
					int row = columnIndices[j];
					float obj = At(row, i);
					if (!values[j].Equals(obj))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static SparseMatrix operator +(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Add(rightSide);
		}

		public static SparseMatrix operator +(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Clone();
		}

		public static SparseMatrix operator -(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Subtract(rightSide);
		}

		public static SparseMatrix operator -(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Negate();
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseMatrix operator *(float leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Multiply(leftSide);
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide.ColumnCount != rightSide.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseMatrix leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.LeftMultiply(leftSide);
		}

		public static SparseMatrix operator %(SparseMatrix leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Remainder(rightSide);
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseMatrix {base.RowCount}x{base.ColumnCount}-Single {(double)NonZerosCount / ((double)base.RowCount * (double)base.ColumnCount):P2} Filled");
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseVector {Count}-Single {NonZerosCount}-NonZero")]
	public class SparseVector : Vector
	{
		private readonly SparseVectorStorage<float> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseVector(SparseVectorStorage<float> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseVector(int length)
			: this(new SparseVectorStorage<float>(length))
		{
		}

		public static SparseVector OfVector(Vector<float> vector)
		{
			return new SparseVector(SparseVectorStorage<float>.OfVector(vector.Storage));
		}

		public static SparseVector OfEnumerable(IEnumerable<float> enumerable)
		{
			return new SparseVector(SparseVectorStorage<float>.OfEnumerable(enumerable));
		}

		public static SparseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, float>> enumerable)
		{
			return new SparseVector(SparseVectorStorage<float>.OfIndexedEnumerable(length, enumerable));
		}

		public static SparseVector Create(int length, float value)
		{
			return new SparseVector(SparseVectorStorage<float>.OfValue(length, value));
		}

		public static SparseVector Create(int length, Func<int, float> init)
		{
			return new SparseVector(SparseVectorStorage<float>.OfInit(length, init));
		}

		protected override void DoAdd(float scalar, Vector<float> result)
		{
			if (scalar == 0f)
			{
				if (this != result)
				{
					CopyTo(result);
				}
			}
			else if (this == result)
			{
				float[] array = new float[base.Count];
				int[] array2 = new int[base.Count];
				for (int i = 0; i < base.Count; i++)
				{
					array2[i] = i;
					array[i] = scalar;
				}
				int[] indices = _storage.Indices;
				float[] values = _storage.Values;
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					array[indices[j]] = values[j] + scalar;
				}
				_storage.Values = array;
				_storage.Indices = array2;
				_storage.ValueCount = base.Count;
			}
			else
			{
				for (int k = 0; k < base.Count; k++)
				{
					result.At(k, At(k) + scalar);
				}
			}
		}

		protected override void DoAdd(Vector<float> other, Vector<float> result)
		{
			if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<float> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							float num3 = storage.Values[num2];
							if (num3 != 0f)
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], num3);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] += storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num4 = 0;
				int num5 = 0;
				int num6 = -1;
				while (num4 < _storage.ValueCount || num5 < storage.ValueCount)
				{
					if (num5 >= storage.ValueCount || (num4 < _storage.ValueCount && _storage.Indices[num4] <= storage.Indices[num5]))
					{
						int num7 = _storage.Indices[num4];
						if (num7 != num6)
						{
							num6 = num7;
							result.At(num7, _storage.Values[num4] + sparseVector.At(num7));
						}
						num4++;
					}
					else
					{
						int num8 = storage.Indices[num5];
						if (num8 != num6)
						{
							num6 = num8;
							result.At(num8, At(num8) + storage.Values[num5]);
						}
						num5++;
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(float scalar, Vector<float> result)
		{
			DoAdd(0f - scalar, result);
		}

		protected override void DoSubtract(Vector<float> other, Vector<float> result)
		{
			if (this == other)
			{
				result.Clear();
			}
			else if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<float> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							float num3 = storage.Values[num2];
							if (num3 != 0f)
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], 0f - num3);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] -= storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num4 = 0;
				int num5 = 0;
				int num6 = -1;
				while (num4 < _storage.ValueCount || num5 < storage.ValueCount)
				{
					if (num5 >= storage.ValueCount || (num4 < _storage.ValueCount && _storage.Indices[num4] <= storage.Indices[num5]))
					{
						int num7 = _storage.Indices[num4];
						if (num7 != num6)
						{
							num6 = num7;
							result.At(num7, _storage.Values[num4] - sparseVector.At(num7));
						}
						num4++;
					}
					else
					{
						int num8 = storage.Indices[num5];
						if (num8 != num6)
						{
							num6 = num8;
							result.At(num8, At(num8) - storage.Values[num5]);
						}
						num5++;
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoNegate(Vector<float> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new float[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(-1f, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], 0f - _storage.Values[i]);
				}
			}
		}

		protected override void DoMultiply(float scalar, Vector<float> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new float[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], scalar * _storage.Values[i]);
				}
			}
		}

		protected override float DoDotProduct(Vector<float> other)
		{
			float num = 0f;
			if (this == other)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					num += _storage.Values[i] * _storage.Values[i];
				}
			}
			else
			{
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					num += _storage.Values[j] * other.At(_storage.Indices[j]);
				}
			}
			return num;
		}

		protected override void DoModulus(float divisor, Vector<float> result)
		{
			if (this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] = Euclid.Modulus(_storage.Values[i], divisor);
				}
				return;
			}
			result.Clear();
			for (int j = 0; j < _storage.ValueCount; j++)
			{
				result.At(_storage.Indices[j], Euclid.Modulus(_storage.Values[j], divisor));
			}
		}

		protected override void DoRemainder(float divisor, Vector<float> result)
		{
			if (this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] %= divisor;
				}
				return;
			}
			result.Clear();
			for (int j = 0; j < _storage.ValueCount; j++)
			{
				result.At(_storage.Indices[j], _storage.Values[j] % divisor);
			}
		}

		public static SparseVector operator +(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Add(rightSide);
		}

		public static SparseVector operator -(SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Negate();
		}

		public static SparseVector operator -(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Subtract(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(float leftSide, SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Multiply(leftSide);
		}

		public static float operator *(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static SparseVector operator /(SparseVector leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Divide(rightSide);
		}

		public static SparseVector operator %(SparseVector leftSide, float rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Remainder(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			float num2 = Math.Abs(_storage.Values[num]);
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				float num3 = Math.Abs(_storage.Values[i]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return _storage.Indices[num];
		}

		public override int AbsoluteMaximumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			float num2 = Math.Abs(_storage.Values[num]);
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				float num3 = Math.Abs(_storage.Values[i]);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return _storage.Indices[num];
		}

		public override int MaximumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			float num2 = _storage.Values[0];
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				if (num2 < _storage.Values[i])
				{
					num = i;
					num2 = _storage.Values[i];
				}
			}
			return _storage.Indices[num];
		}

		public override int MinimumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			float num2 = _storage.Values[0];
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				if (num2 > _storage.Values[i])
				{
					num = i;
					num2 = _storage.Values[i];
				}
			}
			return _storage.Indices[num];
		}

		public override float Sum()
		{
			float num = 0f;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += _storage.Values[i];
			}
			return num;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += (double)Math.Abs(_storage.Values[i]);
			}
			return num;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, _storage.ValueCount, (int i) => Math.Abs(_storage.Values[i]), Math.Max, 0f);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (_storage.ValueCount == 0)
			{
				return 0.0;
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += Math.Pow(Math.Abs(_storage.Values[i]), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<float> other, Vector<float> result)
		{
			if (this == other && this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] *= _storage.Values[i];
				}
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		public static SparseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			List<float> list = (from t in value.Split(new string[3]
				{
					formatProvider.GetTextInfo().ListSeparator,
					" ",
					"\t"
				}, StringSplitOptions.RemoveEmptyEntries)
				select float.Parse(t, NumberStyles.Any, formatProvider)).ToList();
			if (list.Count == 0)
			{
				throw new FormatException();
			}
			return OfEnumerable(list);
		}

		public static bool TryParse(string value, out SparseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out SparseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseVector {base.Count}-Single {(double)NonZerosCount / (double)base.Count:P2} Filled");
		}
	}
	[Serializable]
	public abstract class Vector : Vector<float>
	{
		protected Vector(VectorStorage<float> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((float x) => (!((double)Math.Abs(x) < threshold)) ? x : 0f);
		}

		protected sealed override void DoConjugate(Vector<float> result)
		{
			if (this != result)
			{
				CopyTo(result);
			}
		}

		protected override void DoNegate(Vector<float> result)
		{
			Map((float x) => 0f - x, result);
		}

		protected override void DoAdd(float scalar, Vector<float> result)
		{
			Map((float x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Vector<float> other, Vector<float> result)
		{
			Map2((float x, float y) => x + y, other, result);
		}

		protected override void DoSubtract(float scalar, Vector<float> result)
		{
			Map((float x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Vector<float> other, Vector<float> result)
		{
			Map2((float x, float y) => x - y, other, result);
		}

		protected override void DoMultiply(float scalar, Vector<float> result)
		{
			Map((float x) => x * scalar, result);
		}

		protected override void DoDivide(float divisor, Vector<float> result)
		{
			Map((float x) => x / divisor, result, (divisor == 0f) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(float dividend, Vector<float> result)
		{
			Map((float x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoPointwiseMultiply(Vector<float> other, Vector<float> result)
		{
			Map2((float x, float y) => x * y, other, result);
		}

		protected override void DoPointwiseDivide(Vector<float> divisor, Vector<float> result)
		{
			Map2((float x, float y) => x / y, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(float exponent, Vector<float> result)
		{
			Map((float x) => (float)Math.Pow(x, exponent), result, (!(exponent > 0f)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwisePower(Vector<float> exponent, Vector<float> result)
		{
			Map2((float x, float y) => (float)Math.Pow(x, y), exponent, result, Zeros.Include);
		}

		protected override void DoPointwiseModulus(Vector<float> divisor, Vector<float> result)
		{
			Map2(Euclid.Modulus, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseRemainder(Vector<float> divisor, Vector<float> result)
		{
			Map2(Euclid.Remainder, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseExp(Vector<float> result)
		{
			Map((float x) => (float)Math.Exp(x), result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Vector<float> result)
		{
			Map((float x) => (float)Math.Log(x), result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Vector<float> result)
		{
			Map((float x) => Math.Abs(x), result);
		}

		protected override void DoPointwiseAcos(Vector<float> result)
		{
			Map((float x) => (float)Math.Acos(x), result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Vector<float> result)
		{
			Map((float x) => (float)Math.Asin(x), result);
		}

		protected override void DoPointwiseAtan(Vector<float> result)
		{
			Map((float x) => (float)Math.Atan(x), result);
		}

		protected override void DoPointwiseAtan2(Vector<float> other, Vector<float> result)
		{
			Map2((float x, float y) => (float)Math.Atan2(x, y), other, result, Zeros.Include);
		}

		protected override void DoPointwiseAtan2(float scalar, Vector<float> result)
		{
			Map((float x) => (float)Math.Atan2(x, scalar), result, Zeros.Include);
		}

		protected override void DoPointwiseCeiling(Vector<float> result)
		{
			Map((float x) => (float)Math.Ceiling(x), result);
		}

		protected override void DoPointwiseCos(Vector<float> result)
		{
			Map((float x) => (float)Math.Cos(x), result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Vector<float> result)
		{
			Map((float x) => (float)Math.Cosh(x), result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Vector<float> result)
		{
			Map((float x) => (float)Math.Floor(x), result);
		}

		protected override void DoPointwiseLog10(Vector<float> result)
		{
			Map((float x) => (float)Math.Log10(x), result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Vector<float> result)
		{
			Map((float x) => (float)Math.Round(x), result);
		}

		protected override void DoPointwiseSign(Vector<float> result)
		{
			Map((float x) => Math.Sign(x), result);
		}

		protected override void DoPointwiseSin(Vector<float> result)
		{
			Map((float x) => (float)Math.Sin(x), result);
		}

		protected override void DoPointwiseSinh(Vector<float> result)
		{
			Map((float x) => (float)Math.Sinh(x), result);
		}

		protected override void DoPointwiseSqrt(Vector<float> result)
		{
			Map((float x) => (float)Math.Sqrt(x), result);
		}

		protected override void DoPointwiseTan(Vector<float> result)
		{
			Map((float x) => (float)Math.Tan(x), result);
		}

		protected override void DoPointwiseTanh(Vector<float> result)
		{
			Map((float x) => (float)Math.Tanh(x), result);
		}

		protected override float DoDotProduct(Vector<float> other)
		{
			float num = 0f;
			for (int i = 0; i < base.Count; i++)
			{
				num += At(i) * other.At(i);
			}
			return num;
		}

		protected sealed override float DoConjugateDotProduct(Vector<float> other)
		{
			return DoDotProduct(other);
		}

		protected override void DoModulus(float divisor, Vector<float> result)
		{
			Map((float x) => Euclid.Modulus(x, divisor), result, Zeros.Include);
		}

		protected override void DoModulusByThis(float dividend, Vector<float> result)
		{
			Map((float x) => Euclid.Modulus(dividend, x), result, Zeros.Include);
		}

		protected override void DoRemainder(float divisor, Vector<float> result)
		{
			Map((float x) => Euclid.Remainder(x, divisor), result, Zeros.Include);
		}

		protected override void DoRemainderByThis(float dividend, Vector<float> result)
		{
			Map((float x) => Euclid.Remainder(dividend, x), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(float scalar, Vector<float> result)
		{
			Map((float x) => Math.Min(scalar, x), result, (!((double)scalar >= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseMaximum(float scalar, Vector<float> result)
		{
			Map((float x) => Math.Max(scalar, x), result, (!((double)scalar <= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseAbsoluteMinimum(float scalar, Vector<float> result)
		{
			float absolute = Math.Abs(scalar);
			Map((float x) => Math.Min(absolute, Math.Abs(x)), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(float scalar, Vector<float> result)
		{
			float absolute = Math.Abs(scalar);
			Map((float x) => Math.Max(absolute, Math.Abs(x)), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Vector<float> other, Vector<float> result)
		{
			Map2(Math.Min, other, result);
		}

		protected override void DoPointwiseMaximum(Vector<float> other, Vector<float> result)
		{
			Map2(Math.Max, other, result);
		}

		protected override void DoPointwiseAbsoluteMinimum(Vector<float> other, Vector<float> result)
		{
			Map2((float x, float y) => Math.Min(Math.Abs(x), Math.Abs(y)), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Vector<float> other, Vector<float> result)
		{
			Map2((float x, float y) => Math.Max(Math.Abs(x), Math.Abs(y)), other, result);
		}

		public override float AbsoluteMinimum()
		{
			return Math.Abs(At(AbsoluteMinimumIndex()));
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			float num2 = Math.Abs(At(num));
			for (int i = 1; i < base.Count; i++)
			{
				float num3 = Math.Abs(At(i));
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override float AbsoluteMaximum()
		{
			return Math.Abs(At(AbsoluteMaximumIndex()));
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			float num2 = Math.Abs(At(num));
			for (int i = 1; i < base.Count; i++)
			{
				float num3 = Math.Abs(At(i));
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override float Sum()
		{
			float num = 0f;
			for (int i = 0; i < base.Count; i++)
			{
				num += At(i);
			}
			return num;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += (double)Math.Abs(At(i));
			}
			return num;
		}

		public override double L2Norm()
		{
			return Math.Sqrt(DoDotProduct(this));
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, base.Count, (int i) => Math.Abs(At(i)), Math.Max, 0f);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += Math.Pow(Math.Abs(At(i)), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		public override int MaximumIndex()
		{
			int num = 0;
			float num2 = At(num);
			for (int i = 1; i < base.Count; i++)
			{
				float num3 = At(i);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override int MinimumIndex()
		{
			int num = 0;
			float num2 = At(num);
			for (int i = 1; i < base.Count; i++)
			{
				float num3 = At(i);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override Vector<float> Normalize(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			double num = Norm(p);
			Vector<float> vector = Clone();
			if (num == 0.0)
			{
				return vector;
			}
			vector.Multiply((float)(1.0 / num), vector);
			return vector;
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Single.Solvers
{
	public sealed class BiCgStab : IIterativeSolver<float>
	{
		private static void CalculateTrueResidual(Matrix<float> matrix, Vector<float> residual, Vector<float> x, Vector<float> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1f, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<float> matrix, Vector<float> input, Vector<float> result, Iterator<float> iterator, IPreconditioner<float> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<float>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<float>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector, result, input);
			Vector<float> vector = denseVector.Clone();
			DenseVector denseVector2 = new DenseVector(denseVector.Count);
			DenseVector denseVector3 = new DenseVector(denseVector.Count);
			DenseVector denseVector4 = new DenseVector(denseVector.Count);
			DenseVector denseVector5 = new DenseVector(denseVector.Count);
			DenseVector denseVector6 = new DenseVector(denseVector.Count);
			DenseVector denseVector7 = new DenseVector(denseVector.Count);
			DenseVector denseVector8 = new DenseVector(denseVector.Count);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			int num4 = 0;
			while (iterator.DetermineStatus(num4, result, input, denseVector) == IterationStatus.Continue)
			{
				float num5 = num;
				num = vector.DotProduct(denseVector);
				if (num.AlmostEqualNumbersBetween(0f, 1))
				{
					throw new NumericalBreakdownException();
				}
				if (num4 != 0)
				{
					float scalar = num / num5 * (num2 / num3);
					denseVector4.Multiply(0f - num3, denseVector7);
					denseVector2.Add(denseVector7, denseVector8);
					denseVector8.CopyTo(denseVector2);
					denseVector2.Multiply(scalar, denseVector2);
					denseVector2.Add(denseVector, denseVector8);
					denseVector8.CopyTo(denseVector2);
				}
				else
				{
					denseVector.CopyTo(denseVector2);
				}
				preconditioner.Approximate(denseVector2, denseVector3);
				matrix.Multiply(denseVector3, denseVector4);
				num2 = num * 1f / vector.DotProduct(denseVector4);
				denseVector4.Multiply(0f - num2, denseVector7);
				denseVector.Add(denseVector7, denseVector5);
				denseVector3.Multiply(num2, denseVector7);
				denseVector7.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector7);
				denseVector7.Add(result, denseVector8);
				denseVector8.CopyTo(denseVector7);
				if (iterator.DetermineStatus(num4, denseVector7, input, denseVector5) != 0)
				{
					denseVector7.CopyTo(result);
					CalculateTrueResidual(matrix, denseVector, result, input);
					if (iterator.DetermineStatus(num4, result, input, denseVector) != 0)
					{
						break;
					}
					num4++;
					continue;
				}
				preconditioner.Approximate(denseVector5, denseVector6);
				matrix.Multiply(denseVector6, denseVector7);
				num3 = denseVector7.DotProduct(denseVector5) / denseVector7.DotProduct(denseVector7);
				denseVector7.Multiply(0f - num3, denseVector);
				denseVector.Add(denseVector5, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector6.Multiply(num3, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				denseVector3.Multiply(num2, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				if (num3.AlmostEqualNumbersBetween(0f, 1))
				{
					throw new NumericalBreakdownException();
				}
				if (iterator.DetermineStatus(num4, result, input, denseVector) != 0)
				{
					CalculateTrueResidual(matrix, denseVector, result, input);
				}
				num4++;
			}
		}
	}
	public sealed class CompositeSolver : IIterativeSolver<float>
	{
		private readonly List<Tuple<IIterativeSolver<float>, IPreconditioner<float>>> _solvers;

		public CompositeSolver(IEnumerable<IIterativeSolverSetup<float>> solvers)
		{
			_solvers = solvers.Select((IIterativeSolverSetup<float> setup) => new Tuple<IIterativeSolver<float>, IPreconditioner<float>>(setup.CreateSolver(), setup.CreatePreconditioner() ?? new UnitPreconditioner<float>())).ToList();
		}

		public void Solve(Matrix<float> matrix, Vector<float> input, Vector<float> result, Iterator<float> iterator, IPreconditioner<float> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (iterator == null)
			{
				iterator = new Iterator<float>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<float>();
			}
			Vector<float> vector = input.Clone();
			Vector<float> vector2 = result.Clone();
			foreach (Tuple<IIterativeSolver<float>, IPreconditioner<float>> solver in _solvers)
			{
				IterationStatus status;
				try
				{
					iterator.Reset();
					solver.Item1.Solve(matrix, vector, vector2, iterator, solver.Item2 ?? preconditioner);
					status = iterator.Status;
				}
				catch (Exception)
				{
					input.CopyTo(vector);
					continue;
				}
				switch (status)
				{
				case IterationStatus.Converged:
					vector2.CopyTo(result);
					return;
				case IterationStatus.StoppedWithoutConvergence:
					vector2.CopyTo(result);
					break;
				default:
					input.CopyTo(vector);
					break;
				}
			}
		}
	}
	public sealed class DiagonalPreconditioner : IPreconditioner<float>
	{
		private float[] _inverseDiagonals;

		internal DiagonalMatrix DiagonalEntries()
		{
			DiagonalMatrix diagonalMatrix = new DiagonalMatrix(_inverseDiagonals.Length);
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				diagonalMatrix[i, i] = 1f / _inverseDiagonals[i];
			}
			return diagonalMatrix;
		}

		public void Initialize(Matrix<float> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_inverseDiagonals = new float[matrix.RowCount];
			for (int i = 0; i < matrix.RowCount; i++)
			{
				_inverseDiagonals[i] = 1f / matrix[i, i];
			}
		}

		public void Approximate(Vector<float> rhs, Vector<float> lhs)
		{
			if (_inverseDiagonals == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _inverseDiagonals.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				lhs[i] = rhs[i] * _inverseDiagonals[i];
			}
		}
	}
	public sealed class GpBiCg : IIterativeSolver<float>
	{
		private int _numberOfBiCgStabSteps = 1;

		private int _numberOfGpbiCgSteps = 4;

		public int NumberOfBiCgStabSteps
		{
			get
			{
				return _numberOfBiCgStabSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfBiCgStabSteps = value;
			}
		}

		public int NumberOfGpBiCgSteps
		{
			get
			{
				return _numberOfGpbiCgSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfGpbiCgSteps = value;
			}
		}

		private static void CalculateTrueResidual(Matrix<float> matrix, Vector<float> residual, Vector<float> x, Vector<float> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1f, residual);
			residual.Add(b, residual);
		}

		private bool ShouldRunBiCgStabSteps(int iterationNumber)
		{
			int num = iterationNumber % (_numberOfBiCgStabSteps + _numberOfGpbiCgSteps);
			if (num >= 0)
			{
				return num < _numberOfBiCgStabSteps;
			}
			return false;
		}

		public void Solve(Matrix<float> matrix, Vector<float> input, Vector<float> result, Iterator<float> iterator, IPreconditioner<float> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<float>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<float>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			float scalar = 0f;
			DenseVector denseVector3 = DenseVector.OfVector(denseVector2);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			DenseVector denseVector12 = new DenseVector(denseVector2.Count);
			DenseVector denseVector13 = new DenseVector(denseVector2.Count);
			DenseVector denseVector14 = new DenseVector(denseVector2.Count);
			DenseVector denseVector15 = new DenseVector(denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				denseVector8.Subtract(denseVector10, denseVector13);
				denseVector13.Multiply(scalar, denseVector14);
				denseVector2.Add(denseVector14, denseVector8);
				preconditioner.Approximate(denseVector8, denseVector13);
				matrix.Multiply(denseVector13, denseVector9);
				float num = denseVector3.DotProduct(denseVector2) / denseVector3.DotProduct(denseVector9);
				denseVector9.Subtract(denseVector6, denseVector13);
				denseVector4.Subtract(denseVector2, denseVector11);
				denseVector13.Multiply(num, denseVector14);
				denseVector11.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector11);
				denseVector4.CopyTo(denseVector5);
				denseVector9.Multiply(0f - num, denseVector14);
				denseVector2.Add(denseVector14, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector13);
				matrix.Multiply(denseVector13, denseVector7);
				float num2 = denseVector7.DotProduct(denseVector7);
				if (num2.AlmostEqualNumbersBetween(0f, 1))
				{
					num2 = 1f;
				}
				float num3 = denseVector7.DotProduct(denseVector4);
				float num4;
				float num5;
				if ((_numberOfBiCgStabSteps == 0 && i == 0) || ShouldRunBiCgStabSteps(i))
				{
					num4 = num3 / num2;
					num5 = 0f;
				}
				else
				{
					float num6 = denseVector11.DotProduct(denseVector11);
					if (num6.AlmostEqualNumbersBetween(0f, 1))
					{
						num6 = 1f;
					}
					float num7 = denseVector11.DotProduct(denseVector4);
					float num8 = denseVector7.DotProduct(denseVector11);
					float num9 = num2 * num6 - num8 * num8;
					num4 = (num6 * num3 - num7 * num8) / num9;
					num5 = (num2 * num7 - num8 * num3) / num9;
				}
				denseVector10.Multiply(scalar, denseVector14);
				denseVector5.Add(denseVector14, denseVector13);
				denseVector13.Subtract(denseVector2, denseVector15);
				denseVector15.CopyTo(denseVector13);
				denseVector13.Multiply(num5, denseVector13);
				denseVector9.Multiply(num4, denseVector14);
				denseVector13.Add(denseVector14, denseVector10);
				denseVector12.Multiply(num5, denseVector12);
				denseVector10.Multiply(0f - num, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector2.Multiply(num4, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector8.Multiply(num, denseVector14);
				denseVector.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector.Add(denseVector12, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector2.CopyTo(denseVector5);
				denseVector11.Multiply(0f - num5, denseVector14);
				denseVector4.Add(denseVector14, denseVector2);
				denseVector7.Multiply(0f - num4, denseVector14);
				denseVector2.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector2);
				scalar = ((!num4.AlmostEqualNumbersBetween(0f, 1)) ? (num / num4 * denseVector3.DotProduct(denseVector2) / denseVector3.DotProduct(denseVector5)) : 0f);
				denseVector9.Multiply(scalar, denseVector14);
				denseVector7.Add(denseVector14, denseVector6);
				preconditioner.Approximate(denseVector, result);
				if (iterator.DetermineStatus(i, result, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, result, input);
				}
			}
		}
	}
	public sealed class ILU0Preconditioner : IPreconditioner<float>
	{
		private SparseMatrix _decompositionLU;

		internal Matrix<float> UpperTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = i; j < _decompositionLU.ColumnCount; j++)
				{
					sparseMatrix[i, j] = _decompositionLU[i, j];
				}
			}
			return sparseMatrix;
		}

		internal Matrix<float> LowerTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j <= i; j++)
				{
					if (i == j)
					{
						sparseMatrix[i, j] = 1f;
					}
					else
					{
						sparseMatrix[i, j] = _decompositionLU[i, j];
					}
				}
			}
			return sparseMatrix;
		}

		public void Initialize(Matrix<float> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_decompositionLU = SparseMatrix.OfMatrix(matrix);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j < i; j++)
				{
					if ((double)_decompositionLU[i, j] == 0.0)
					{
						continue;
					}
					float num = _decompositionLU[i, j] / _decompositionLU[j, j];
					_decompositionLU[i, j] = num;
					if ((double)_decompositionLU[j, i] != 0.0)
					{
						_decompositionLU[i, i] -= num * _decompositionLU[j, i];
					}
					for (int k = j + 1; k < _decompositionLU.RowCount; k++)
					{
						if (k != i && (double)_decompositionLU[i, k] != 0.0)
						{
							_decompositionLU[i, k] -= num * _decompositionLU[j, k];
						}
					}
				}
			}
		}

		public void Approximate(Vector<float> rhs, Vector<float> lhs)
		{
			if (_decompositionLU == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _decompositionLU.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			DenseVector denseVector = new DenseVector(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				denseVector.Clear();
				_decompositionLU.Row(i, denseVector);
				float num = 0f;
				for (int j = 0; j < i; j++)
				{
					num += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - num;
			}
			for (int num2 = _decompositionLU.RowCount - 1; num2 > -1; num2--)
			{
				_decompositionLU.Row(num2, denseVector);
				float num3 = 0f;
				for (int num4 = _decompositionLU.RowCount - 1; num4 > num2; num4--)
				{
					num3 += denseVector[num4] * lhs[num4];
				}
				lhs[num2] = 1f / denseVector[num2] * (lhs[num2] - num3);
			}
		}
	}
	public sealed class ILUTPPreconditioner : IPreconditioner<float>
	{
		public const double DefaultFillLevel = 200.0;

		public const double DefaultDropTolerance = 0.0001;

		private SparseMatrix _upper;

		private SparseMatrix _lower;

		private int[] _pivots;

		private double _fillLevel = 200.0;

		private double _dropTolerance = 0.0001;

		private double _pivotTolerance;

		public double FillLevel
		{
			get
			{
				return _fillLevel;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_fillLevel = value;
			}
		}

		public double DropTolerance
		{
			get
			{
				return _dropTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dropTolerance = value;
			}
		}

		public double PivotTolerance
		{
			get
			{
				return _pivotTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_pivotTolerance = value;
			}
		}

		public ILUTPPreconditioner()
		{
		}

		public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance)
		{
			if (fillLevel < 0.0)
			{
				throw new ArgumentOutOfRangeException("fillLevel");
			}
			if (dropTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("dropTolerance");
			}
			if (pivotTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("pivotTolerance");
			}
			_fillLevel = fillLevel;
			_dropTolerance = dropTolerance;
			_pivotTolerance = pivotTolerance;
		}

		internal Matrix<float> UpperTriangle()
		{
			return _upper.Clone();
		}

		internal Matrix<float> LowerTriangle()
		{
			return _lower.Clone();
		}

		internal int[] Pivots()
		{
			int[] array = new int[_pivots.Length];
			for (int i = 0; i < _pivots.Length; i++)
			{
				array[i] = _pivots[i];
			}
			return array;
		}

		public void Initialize(Matrix<float> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			SparseMatrix sparseMatrix = (matrix as SparseMatrix) ?? SparseMatrix.OfMatrix(matrix);
			_lower = new SparseMatrix(sparseMatrix.RowCount);
			_upper = new SparseMatrix(sparseMatrix.RowCount);
			_pivots = new int[sparseMatrix.RowCount];
			for (int i = 0; i < _pivots.Length; i++)
			{
				_pivots[i] = i;
			}
			DenseVector denseVector = new DenseVector(sparseMatrix.RowCount);
			DenseVector denseVector2 = new DenseVector(sparseMatrix.ColumnCount);
			int[] array = new int[sparseMatrix.RowCount];
			int num = (int)_fillLevel * sparseMatrix.NonZerosCount;
			for (int j = 0; j < sparseMatrix.RowCount; j++)
			{
				sparseMatrix.Row(j, denseVector);
				PivotRow(denseVector);
				double num2 = denseVector.InfinityNorm();
				for (int k = 0; k < j; k++)
				{
					if ((double)denseVector[k] == 0.0)
					{
						continue;
					}
					denseVector[k] /= _upper[k, k];
					if ((double)Math.Abs(denseVector[k]) < _dropTolerance)
					{
						denseVector[k] = 0f;
					}
					if ((double)denseVector[k] != 0.0)
					{
						_upper.Row(k, denseVector2);
						for (int l = 0; l <= k; l++)
						{
							denseVector2[l] = 0f;
						}
						denseVector2.Multiply(denseVector[k], denseVector2);
						denseVector.Subtract(denseVector2, denseVector);
					}
				}
				for (int m = j; m < sparseMatrix.RowCount; m++)
				{
					if ((double)Math.Abs(denseVector[m]) <= _dropTolerance * num2)
					{
						denseVector[m] = 0f;
					}
				}
				int num3 = num / (sparseMatrix.RowCount - j + 1);
				int num4 = num3 / 2;
				FindLargestItems(0, j - 1, array, denseVector);
				int num5 = 0;
				int num6 = 0;
				for (int n = 0; n < j; n++)
				{
					if (num6 > num4)
					{
						break;
					}
					if (array[n] == -1)
					{
						break;
					}
					_lower[j, array[n]] = denseVector[array[n]];
					num6++;
					num5++;
				}
				FindLargestItems(j + 1, sparseMatrix.RowCount - 1, array, denseVector);
				num4 = num3 - num5;
				int num7 = 0;
				num6 = 0;
				for (int num8 = 0; num8 < sparseMatrix.RowCount - j; num8++)
				{
					if (num6 > num4 - 1)
					{
						break;
					}
					if (array[num8] == -1)
					{
						break;
					}
					_upper[j, array[num8]] = denseVector[array[num8]];
					num6++;
					num7++;
				}
				_upper[j, j] = denseVector[j];
				if (j + 1 < sparseMatrix.RowCount - 1 && (double)Math.Abs(denseVector[j]) < _pivotTolerance * (double)Math.Abs(denseVector[array[0]]))
				{
					SwapColumns(_upper, j, array[0]);
					int num9 = _pivots[j];
					_pivots[j] = _pivots[array[0]];
					_pivots[array[0]] = num9;
				}
				num -= num5 + num7;
			}
			for (int num10 = 0; num10 < _lower.RowCount; num10++)
			{
				_lower[num10, num10] = 1f;
			}
		}

		private void PivotRow(Vector<float> row)
		{
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			for (int i = 0; i < row.Count; i++)
			{
				if (_pivots[i] != i && !PivotMapFound(dictionary, i))
				{
					dictionary.Add(_pivots[i], i);
					float value = row[i];
					row[i] = row[_pivots[i]];
					row[_pivots[i]] = value;
				}
			}
		}

		private bool PivotMapFound(Dictionary<int, int> knownPivots, int currentItem)
		{
			if (knownPivots.ContainsKey(_pivots[currentItem]) && knownPivots[_pivots[currentItem]].Equals(currentItem))
			{
				return true;
			}
			if (knownPivots.ContainsKey(currentItem) && knownPivots[currentItem].Equals(_pivots[currentItem]))
			{
				return true;
			}
			return false;
		}

		private static void SwapColumns(Matrix<float> matrix, int firstColumn, int secondColumn)
		{
			for (int i = 0; i < matrix.RowCount; i++)
			{
				float value = matrix[i, firstColumn];
				matrix[i, firstColumn] = matrix[i, secondColumn];
				matrix[i, secondColumn] = value;
			}
		}

		private static void FindLargestItems(int lowerBound, int upperBound, int[] sortedIndices, Vector<float> values)
		{
			for (int i = 0; i < upperBound + 1 - lowerBound; i++)
			{
				sortedIndices[i] = lowerBound + i;
			}
			for (int j = upperBound + 1 - lowerBound; j < sortedIndices.Length; j++)
			{
				sortedIndices[j] = -1;
			}
			ILUTPElementSorter.SortDoubleIndicesDecreasing(0, upperBound - lowerBound, sortedIndices, values);
		}

		public void Approximate(Vector<float> rhs, Vector<float> lhs)
		{
			if (_upper == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _upper.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			DenseVector denseVector = new DenseVector(_lower.RowCount);
			for (int i = 0; i < _lower.RowCount; i++)
			{
				_lower.Row(i, denseVector);
				float num = 0f;
				for (int j = 0; j < i; j++)
				{
					num += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - num;
			}
			for (int num2 = _upper.RowCount - 1; num2 > -1; num2--)
			{
				_upper.Row(num2, denseVector);
				float num3 = 0f;
				for (int num4 = _upper.RowCount - 1; num4 > num2; num4--)
				{
					num3 += denseVector[num4] * lhs[num4];
				}
				lhs[num2] = 1f / denseVector[num2] * (lhs[num2] - num3);
			}
			Vector<float> vector = lhs.Clone();
			Pivot(vector, lhs);
		}

		private void Pivot(Vector<float> vector, Vector<float> result)
		{
			for (int i = 0; i < _pivots.Length; i++)
			{
				result[i] = vector[_pivots[i]];
			}
		}
	}
	internal static class ILUTPElementSorter
	{
		public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, int[] sortedIndices, Vector<float> values)
		{
			if (lowerBound > 0)
			{
				for (int i = 0; i < upperBound - lowerBound + 1; i++)
				{
					Exchange(sortedIndices, i, i + lowerBound);
				}
				upperBound -= lowerBound;
				lowerBound = 0;
			}
			HeapSortDoublesIndices(lowerBound, upperBound, sortedIndices, values);
		}

		private static void HeapSortDoublesIndices(int lowerBound, int upperBound, int[] sortedIndices, Vector<float> values)
		{
			int start = (upperBound - lowerBound + 1) / 2 - 1 + lowerBound;
			int num = upperBound - lowerBound + 1 - 1 + lowerBound;
			BuildDoubleIndexHeap(start, upperBound - lowerBound + 1, sortedIndices, values);
			while (num >= lowerBound)
			{
				Exchange(sortedIndices, num, lowerBound);
				SiftDoubleIndices(sortedIndices, values, lowerBound, num);
				num--;
			}
		}

		private static void BuildDoubleIndexHeap(int start, int count, int[] sortedIndices, Vector<float> values)
		{
			while (start >= 0)
			{
				SiftDoubleIndices(sortedIndices, values, start, count);
				start--;
			}
		}

		private static void SiftDoubleIndices(int[] sortedIndices, Vector<float> values, int begin, int count)
		{
			int num = begin;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[sortedIndices[num2]] > values[sortedIndices[num2 + 1]])
				{
					num2++;
				}
				if (values[sortedIndices[num]] <= values[sortedIndices[num2]])
				{
					break;
				}
				Exchange(sortedIndices, num, num2);
				num = num2;
			}
		}

		public static void SortIntegersDecreasing(int[] values)
		{
			HeapSortIntegers(values, values.Length);
		}

		private static void HeapSortIntegers(int[] values, int count)
		{
			int start = count / 2 - 1;
			int num = count - 1;
			BuildHeap(values, start, count);
			while (num >= 0)
			{
				Exchange(values, num, 0);
				Sift(values, 0, num);
				num--;
			}
		}

		private static void BuildHeap(int[] values, int start, int count)
		{
			while (start >= 0)
			{
				Sift(values, start, count);
				start--;
			}
		}

		private static void Sift(int[] values, int start, int count)
		{
			int num = start;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[num2] > values[num2 + 1])
				{
					num2++;
				}
				if (values[num] > values[num2])
				{
					Exchange(values, num, num2);
					num = num2;
					continue;
				}
				break;
			}
		}

		private static void Exchange(int[] values, int first, int second)
		{
			int num = values[first];
			values[first] = values[second];
			values[second] = num;
		}
	}
	public sealed class MILU0Preconditioner : IPreconditioner<float>
	{
		private float[] _alu;

		private int[] _jlu;

		private int[] _diag;

		public bool UseModified { get; set; }

		public bool IsInitialized { get; private set; }

		public MILU0Preconditioner(bool modified = true)
		{
			UseModified = modified;
		}

		public void Initialize(Matrix<float> matrix)
		{
			if (!(matrix.Storage is SparseCompressedRowMatrixStorage<float> sparseCompressedRowMatrixStorage))
			{
				throw new ArgumentException("Matrix must be in sparse storage format", "matrix");
			}
			int rowCount = sparseCompressedRowMatrixStorage.RowCount;
			if (rowCount != sparseCompressedRowMatrixStorage.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			float[] values = sparseCompressedRowMatrixStorage.Values;
			int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			_alu = new float[rowPointers[rowCount] + 1];
			_jlu = new int[rowPointers[rowCount] + 1];
			_diag = new int[rowCount];
			int num = Compute(rowCount, values, columnIndices, rowPointers, _alu, _jlu, _diag, UseModified);
			if (num > -1)
			{
				throw new NumericalBreakdownException("Zero pivot encountered on row " + num + " during ILU process");
			}
			IsInitialized = true;
		}

		public void Approximate(Vector<float> input, Vector<float> result)
		{
			if (_alu == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (result.Count != input.Count || result.Count != _diag.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			int num = _diag.Length;
			for (int i = 0; i < num; i++)
			{
				result[i] = input[i];
				for (int j = _jlu[i]; j < _diag[i]; j++)
				{
					result[i] -= _alu[j] * result[_jlu[j]];
				}
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				for (int k = _diag[num2]; k < _jlu[num2 + 1]; k++)
				{
					result[num2] -= _alu[k] * result[_jlu[k]];
				}
				result[num2] = _alu[num2] * result[num2];
			}
		}

		private int Compute(int n, float[] a, int[] ja, int[] ia, float[] alu, int[] jlu, int[] ju, bool modified)
		{
			int[] array = new int[n];
			int num = (jlu[0] = n + 1);
			for (int i = 0; i < n; i++)
			{
				array[i] = -1;
			}
			for (int i = 0; i < n; i++)
			{
				int num2 = num;
				for (int j = ia[i]; j < ia[i + 1]; j++)
				{
					int num3 = ja[j];
					if (num3 == i)
					{
						alu[i] = a[j];
						array[num3] = i;
						ju[i] = num;
					}
					else
					{
						alu[num] = a[j];
						jlu[num] = ja[j];
						array[num3] = num;
						num++;
					}
				}
				jlu[i + 1] = num;
				float num4 = 0f;
				for (int j = num2; j < ju[i]; j++)
				{
					int num5 = jlu[j];
					float num6 = (alu[j] *= alu[num5]);
					for (int k = ju[num5]; k < jlu[num5 + 1]; k++)
					{
						int num7 = array[jlu[k]];
						if (num7 != -1)
						{
							alu[num7] -= num6 * alu[k];
						}
						else
						{
							num4 += num6 * alu[k];
						}
					}
				}
				if (modified)
				{
					alu[i] -= num4;
				}
				if (alu[i] == 0f)
				{
					return i;
				}
				alu[i] = 1f / alu[i];
				array[i] = -1;
				for (int k = num2; k < num; k++)
				{
					array[jlu[k]] = -1;
				}
			}
			return -1;
		}
	}
	public sealed class MlkBiCgStab : IIterativeSolver<float>
	{
		private const int DefaultNumberOfStartingVectors = 50;

		private IList<Vector<float>> _startingVectors;

		private int _numberOfStartingVectors = 50;

		public int NumberOfStartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _numberOfStartingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value <= 1)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfStartingVectors = value;
			}
		}

		public IList<Vector<float>> StartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _startingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value == null || value.Count == 0)
				{
					_startingVectors = null;
				}
				else
				{
					_startingVectors = value;
				}
			}
		}

		public void ResetNumberOfStartingVectors()
		{
			_numberOfStartingVectors = 50;
		}

		private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			return Math.Min(maximumNumberOfStartingVectors, numberOfVariables - 1);
		}

		private static IList<Vector<float>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			int columns = NumberOfStartingVectorsToCreate(maximumNumberOfStartingVectors, numberOfVariables);
			Normal normal = new Normal();
			DenseMatrix denseMatrix = new DenseMatrix(numberOfVariables, columns);
			for (int i = 0; i < denseMatrix.ColumnCount; i++)
			{
				float[] array = new float[denseMatrix.RowCount];
				for (int j = 0; j < denseMatrix.RowCount; j++)
				{
					array[j] = (float)normal.Sample();
				}
				denseMatrix.SetColumn(i, array);
			}
			Matrix<float> q = denseMatrix.GramSchmidt().Q;
			List<Vector<float>> list = new List<Vector<float>>(q.ColumnCount);
			for (int k = 0; k < q.ColumnCount; k++)
			{
				list.Add(q.Column(k));
				list[k].Multiply(1f / (float)list[k].L2Norm(), list[k]);
			}
			return list;
		}

		private static Vector<float>[] CreateVectorArray(int arraySize, int vectorSize)
		{
			Vector<float>[] array = new Vector<float>[arraySize];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new DenseVector(vectorSize);
			}
			return array;
		}

		private static void CalculateTrueResidual(Matrix<float> matrix, Vector<float> residual, Vector<float> x, Vector<float> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1f, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<float> matrix, Vector<float> input, Vector<float> result, Iterator<float> iterator, IPreconditioner<float> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<float>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<float>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			bool flag = false;
			if (_startingVectors != null && _startingVectors.Count <= NumberOfStartingVectorsToCreate(_numberOfStartingVectors, input.Count) && _startingVectors[0].Count == input.Count)
			{
				flag = true;
			}
			_startingVectors = (flag ? _startingVectors : CreateStartingVectors(_numberOfStartingVectors, input.Count));
			int count = _startingVectors.Count;
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			float[] array = new float[count];
			DenseVector denseVector3 = new DenseVector(denseVector2.Count);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			Vector<float>[] array2 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			Vector<float>[] array3 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			denseVector2.CopyTo(array3[count - 1]);
			Vector<float>[] array4 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				preconditioner.Approximate(array3[count - 1], denseVector3);
				matrix.Multiply(denseVector3, array4[count - 1]);
				array[count - 1] = _startingVectors[0].DotProduct(array4[count - 1]);
				if (array[count - 1].AlmostEqualNumbersBetween(0f, 1))
				{
					throw new NumericalBreakdownException();
				}
				float num = _startingVectors[0].DotProduct(denseVector2) / array[count - 1];
				array4[count - 1].Multiply(0f - num, denseVector6);
				denseVector2.Add(denseVector6, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector7);
				denseVector7.CopyTo(denseVector5);
				matrix.Multiply(denseVector7, denseVector6);
				float num2 = denseVector6.DotProduct(denseVector6);
				if (num2.AlmostEqualNumbersBetween(0f, 1))
				{
					num2 = 1f;
				}
				num2 = (0f - denseVector4.DotProduct(denseVector6)) / num2;
				denseVector4.CopyTo(denseVector2);
				denseVector6.Multiply(num2, denseVector6);
				denseVector2.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector2);
				denseVector5.Multiply(0f - num2, denseVector6);
				denseVector.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector3.Multiply(num, denseVector3);
				denseVector.Add(denseVector3, denseVector8);
				denseVector8.CopyTo(denseVector);
				if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, denseVector, input);
					if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
					{
						break;
					}
				}
				for (int j = 0; j < count; j++)
				{
					denseVector4.CopyTo(denseVector9);
					denseVector2.CopyTo(denseVector10);
					denseVector11.Clear();
					float scalar;
					if (i >= 1)
					{
						for (int k = j; k < count - 1; k++)
						{
							scalar = (0f - _startingVectors[k + 1].DotProduct(denseVector9)) / array[k];
							array2[k].Multiply(scalar, denseVector6);
							denseVector9.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector9);
							array3[k].Multiply(scalar, denseVector6);
							denseVector10.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector10);
							array4[k].Multiply(scalar, denseVector6);
							denseVector11.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector11);
						}
					}
					scalar = num2 * array[count - 1];
					if (scalar.AlmostEqualNumbersBetween(0f, 1))
					{
						throw new NumericalBreakdownException();
					}
					denseVector11.Multiply(num2, denseVector8);
					denseVector2.Add(denseVector8, denseVector6);
					scalar = (0f - _startingVectors[0].DotProduct(denseVector6)) / scalar;
					array3[count - 1].Multiply(scalar, denseVector6);
					denseVector10.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector10);
					array4[count - 1].Multiply(scalar, denseVector6);
					denseVector11.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector11);
					denseVector11.Multiply(num2, denseVector11);
					denseVector2.Add(denseVector11, denseVector9);
					for (int l = 0; l < j - 1; l++)
					{
						scalar = (0f - _startingVectors[l + 1].DotProduct(denseVector9)) / array[l];
						array2[l].Multiply(scalar, denseVector6);
						denseVector9.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector9);
						array3[l].Multiply(scalar, denseVector6);
						denseVector10.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector10);
					}
					denseVector9.Subtract(denseVector4, array2[j]);
					denseVector10.Add(denseVector11, array3[j]);
					if (j < count - 1)
					{
						array[j] = _startingVectors[j + 1].DotProduct(array2[j]);
						if (array[j].AlmostEqualNumbersBetween(0f, 1))
						{
							throw new NumericalBreakdownException();
						}
						num = _startingVectors[j + 1].DotProduct(denseVector4) / array[j];
						array2[j].Multiply(0f - num, denseVector6);
						denseVector4.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector4);
						preconditioner.Approximate(array3[j], denseVector3);
						denseVector3.Multiply(num2 * num, denseVector6);
						denseVector.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector);
						matrix.Multiply(denseVector3, array4[j]);
						array4[j].Multiply((0f - num2) * num, denseVector6);
						denseVector2.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector2);
						if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
						{
							CalculateTrueResidual(matrix, denseVector2, denseVector, input);
						}
					}
				}
			}
			denseVector.CopyTo(result);
		}
	}
	public sealed class TFQMR : IIterativeSolver<float>
	{
		private static void CalculateTrueResidual(Matrix<float> matrix, Vector<float> residual, Vector<float> x, Vector<float> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1f, residual);
			residual.Add(b, residual);
		}

		private static bool IsEven(int number)
		{
			return number % 2 == 0;
		}

		public void Solve(Matrix<float> matrix, Vector<float> input, Vector<float> result, Iterator<float> iterator, IPreconditioner<float> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<float>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<float>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector other = DenseVector.OfVector(input);
			DenseVector denseVector2 = new DenseVector(input.Count);
			DenseVector denseVector3 = new DenseVector(input.Count);
			DenseVector denseVector4 = new DenseVector(input.Count);
			DenseVector denseVector5 = DenseVector.OfVector(input);
			DenseVector denseVector6 = new DenseVector(input.Count);
			DenseVector denseVector7 = new DenseVector(input.Count);
			DenseVector denseVector8 = DenseVector.OfVector(input);
			DenseVector denseVector9 = new DenseVector(input.Count);
			DenseVector denseVector10 = new DenseVector(input.Count);
			DenseVector denseVector11 = new DenseVector(input.Count);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = (float)input.L2Norm();
			float num5 = num4 * num4;
			preconditioner.Approximate(denseVector8, denseVector9);
			matrix.Multiply(denseVector9, denseVector4);
			denseVector4.CopyTo(denseVector3);
			for (int i = 0; iterator.DetermineStatus(i, result, input, denseVector5) == IterationStatus.Continue; i++)
			{
				if (IsEven(i))
				{
					float num6 = denseVector4.DotProduct(other);
					if (num6.AlmostEqualNumbersBetween(0f, 1))
					{
						iterator.Cancel();
						break;
					}
					num = num5 / num6;
					denseVector4.Multiply(0f - num, denseVector10);
					denseVector8.Add(denseVector10, denseVector7);
					preconditioner.Approximate(denseVector7, denseVector9);
					matrix.Multiply(denseVector9, denseVector2);
				}
				DenseVector obj = (IsEven(i) ? denseVector3 : denseVector2);
				DenseVector denseVector12 = (IsEven(i) ? denseVector8 : denseVector7);
				obj.Multiply(0f - num, denseVector10);
				denseVector5.Add(denseVector10, denseVector11);
				denseVector11.CopyTo(denseVector5);
				denseVector.Multiply(num3 * num3 * num2 / num, denseVector9);
				denseVector12.Add(denseVector9, denseVector);
				num3 = (float)denseVector5.L2Norm() / num4;
				float num7 = 1f / (float)Math.Sqrt(1f + num3 * num3);
				num4 *= num3 * num7;
				num2 = num7 * num7 * num;
				denseVector.Multiply(num2, denseVector10);
				denseVector6.Add(denseVector10, denseVector11);
				denseVector11.CopyTo(denseVector6);
				if (iterator.DetermineStatus(i, result, input, denseVector5) != 0)
				{
					preconditioner.Approximate(denseVector6, result);
					CalculateTrueResidual(matrix, denseVector9, result, input);
					if (iterator.DetermineStatus(i, result, input, denseVector9) != 0)
					{
						break;
					}
				}
				if (!IsEven(i))
				{
					if (num5.AlmostEqualNumbersBetween(0f, 1))
					{
						iterator.Cancel();
						break;
					}
					float num8 = denseVector5.DotProduct(other);
					float scalar = num8 / num5;
					num5 = num8;
					denseVector7.Multiply(scalar, denseVector10);
					denseVector5.Add(denseVector10, denseVector8);
					preconditioner.Approximate(denseVector8, denseVector9);
					matrix.Multiply(denseVector9, denseVector3);
					denseVector4.Multiply(scalar, denseVector10);
					denseVector2.Add(denseVector10, denseVector9);
					denseVector9.Multiply(scalar, denseVector10);
					denseVector3.Add(denseVector10, denseVector4);
				}
				preconditioner.Approximate(denseVector6, result);
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Single.Factorization
{
	internal abstract class Cholesky : Cholesky<float>
	{
		public override float Determinant
		{
			get
			{
				float num = 1f;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					float num2 = base.Factor.At(i, i);
					num *= num2 * num2;
				}
				return num;
			}
		}

		public override float DeterminantLn
		{
			get
			{
				float num = 0f;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					num += 2f * Convert.ToSingle(Math.Log(base.Factor.At(i, i)));
				}
				return num;
			}
		}

		protected Cholesky(Matrix<float> factor)
			: base(factor)
		{
		}
	}
	internal sealed class DenseCholesky : Cholesky
	{
		public static DenseCholesky Create(DenseMatrix matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix.Values, denseMatrix.RowCount);
			return new DenseCholesky(denseMatrix);
		}

		private DenseCholesky(Matrix<float> factor)
			: base(factor)
		{
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Buffer.BlockCopy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length * 4);
				DenseMatrix denseMatrix3 = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix3.Values, denseMatrix3.RowCount, denseMatrix2.Values, denseMatrix2.ColumnCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Buffer.BlockCopy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length * 4);
				DenseMatrix denseMatrix = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix.Values, denseMatrix.RowCount, denseVector2.Values, 1);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense vectors at the moment.");
		}

		public override void Factorize(Matrix<float> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			if (matrix is DenseMatrix denseMatrix)
			{
				DenseMatrix denseMatrix2 = (DenseMatrix)base.Factor;
				Buffer.BlockCopy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length * 4);
				LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix2.Values, denseMatrix2.RowCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}
	}
	internal sealed class DenseEvd : Evd
	{
		public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			DenseMatrix denseMatrix = new DenseMatrix(rowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(rowCount);
			MathNet.Numerics.LinearAlgebra.Complex.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Complex.DenseVector(rowCount);
			bool isSymmetric;
			switch (symmetricity)
			{
			case Symmetricity.Symmetric:
			case Symmetricity.Hermitian:
				isSymmetric = true;
				break;
			case Symmetricity.Asymmetric:
				isSymmetric = false;
				break;
			default:
				isSymmetric = matrix.IsSymmetric();
				break;
			}
			LinearAlgebraControl.Provider.EigenDecomp(isSymmetric, rowCount, matrix.Values, denseMatrix.Values, denseVector.Values, denseMatrix2.Values);
			return new DenseEvd(denseMatrix, denseVector, denseMatrix2, isSymmetric);
		}

		private DenseEvd(Matrix<float> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<float> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				float[] array = new float[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						float num = 0f;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								num += ((DenseMatrix)base.EigenVectors).Values[j * count + k] * input.At(k, i);
							}
							num /= (float)base.EigenValues[j].Real;
						}
						array[j] = num;
					}
					for (int l = 0; l < count; l++)
					{
						float num2 = 0f;
						for (int m = 0; m < count; m++)
						{
							num2 += ((DenseMatrix)base.EigenVectors).Values[m * count + l] * array[m];
						}
						result.At(l, i, num2);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				float[] array = new float[count];
				for (int i = 0; i < count; i++)
				{
					float num = 0f;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							num += ((DenseMatrix)base.EigenVectors).Values[i * count + j] * input[j];
						}
						num /= (float)base.EigenValues[i].Real;
					}
					array[i] = num;
				}
				for (int k = 0; k < count; k++)
				{
					float num = 0f;
					for (int l = 0; l < count; l++)
					{
						num += ((DenseMatrix)base.EigenVectors).Values[l * count + k] * array[l];
					}
					result[k] = num;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class DenseGramSchmidt : GramSchmidt
	{
		public static DenseGramSchmidt Create(Matrix<float> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount, matrix.ColumnCount);
			Factorize(denseMatrix.Values, denseMatrix.RowCount, denseMatrix.ColumnCount, denseMatrix2.Values);
			return new DenseGramSchmidt(denseMatrix, denseMatrix2);
		}

		private DenseGramSchmidt(Matrix<float> q, Matrix<float> rFull)
			: base(q, rFull)
		{
		}

		private static void Factorize(float[] q, int rowsQ, int columnsQ, float[] r)
		{
			for (int i = 0; i < columnsQ; i++)
			{
				float num = 0f;
				for (int j = 0; j < rowsQ; j++)
				{
					num += q[i * rowsQ + j] * q[i * rowsQ + j];
				}
				num = (float)Math.Sqrt(num);
				if ((double)num == 0.0)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				r[i * columnsQ + i] = num;
				for (int k = 0; k < rowsQ; k++)
				{
					q[i * rowsQ + k] /= num;
				}
				for (int l = i + 1; l < columnsQ; l++)
				{
					int num2 = i;
					int num3 = l;
					float num4 = 0f;
					for (int m = 0; m < rowsQ; m++)
					{
						num4 += q[num2 * rowsQ + m] * q[num3 * rowsQ + m];
					}
					r[l * columnsQ + i] = num4;
					for (int n = 0; n < rowsQ; n++)
					{
						q[l * rowsQ + n] -= q[i * rowsQ + n] * num4;
					}
				}
			}
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseVector.Values, 1, denseVector2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseLU : LU
	{
		public static DenseLU Create(DenseMatrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int[] array = new int[matrix.RowCount];
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.LUFactor(denseMatrix.Values, denseMatrix.RowCount, array);
			return new DenseLU(denseMatrix, array);
		}

		private DenseLU(Matrix<float> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Buffer.BlockCopy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length * 4);
				DenseMatrix denseMatrix3 = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(input.ColumnCount, denseMatrix3.Values, denseMatrix3.RowCount, Pivots, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Buffer.BlockCopy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length * 4);
				DenseMatrix denseMatrix = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(1, denseMatrix.Values, denseMatrix.RowCount, Pivots, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense vectors at the moment.");
		}

		public override Matrix<float> Inverse()
		{
			DenseMatrix denseMatrix = (DenseMatrix)Factors.Clone();
			LinearAlgebraControl.Provider.LUInverseFactored(denseMatrix.Values, denseMatrix.RowCount, Pivots);
			return denseMatrix;
		}
	}
	internal sealed class DenseQR : QR
	{
		private float[] Tau { get; set; }

		public static DenseQR Create(DenseMatrix matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			float[] tau = new float[Math.Min(matrix.RowCount, matrix.ColumnCount)];
			Matrix<float> matrix2;
			Matrix<float> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = new DenseMatrix(matrix.RowCount);
				LinearAlgebraControl.Provider.QRFactor(((DenseMatrix)matrix2).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix3).Values, tau);
			}
			else
			{
				matrix3 = matrix.Clone();
				matrix2 = new DenseMatrix(matrix.ColumnCount);
				LinearAlgebraControl.Provider.ThinQRFactor(((DenseMatrix)matrix3).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix2).Values, tau);
			}
			return new DenseQR(matrix3, matrix2, method, tau);
		}

		private DenseQR(Matrix<float> q, Matrix<float> rFull, QRMethod method, float[] tau)
			: base(q, rFull, method)
		{
			Tau = tau;
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseVector.Values, 1, denseVector2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseSvd : Svd
	{
		public static DenseSvd Create(DenseMatrix matrix, bool computeVectors)
		{
			DenseVector denseVector = new DenseVector(Math.Min(matrix.RowCount, matrix.ColumnCount));
			DenseMatrix denseMatrix = new DenseMatrix(matrix.RowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount);
			LinearAlgebraControl.Provider.SingularValueDecomposition(computeVectors, ((DenseMatrix)matrix.Clone()).Values, matrix.RowCount, matrix.ColumnCount, denseVector.Values, denseMatrix.Values, denseMatrix2.Values);
			return new DenseSvd(denseVector, denseMatrix, denseMatrix2, computeVectors);
		}

		private DenseSvd(Vector<float> s, Matrix<float> u, Matrix<float> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseVector.Values, 1, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense vectors at the moment.");
		}
	}
	internal abstract class Evd : Evd<float>
	{
		public override float Determinant
		{
			get
			{
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					one *= base.EigenValues[i];
					if (((MathNet.Numerics.Complex32)base.EigenValues[i]).AlmostEqual(MathNet.Numerics.Complex32.Zero))
					{
						return 0f;
					}
				}
				return Convert.ToSingle(one.Magnitude);
			}
		}

		public override int Rank
		{
			get
			{
				int num = 0;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (!((MathNet.Numerics.Complex32)base.EigenValues[i]).AlmostEqual(MathNet.Numerics.Complex32.Zero))
					{
						num++;
					}
				}
				return num;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected Evd(Matrix<float> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<float> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}
	}
	internal abstract class GramSchmidt : GramSchmidt<float>
	{
		public override float Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				double num = 1.0;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					num *= (double)FullR.At(i, i);
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0f))
					{
						return 0f;
					}
				}
				return Convert.ToSingle(Math.Abs(num));
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0f))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected GramSchmidt(Matrix<float> q, Matrix<float> rFull)
			: base(q, rFull)
		{
		}
	}
	internal abstract class LU : LU<float>
	{
		public override float Determinant
		{
			get
			{
				float num = 1f;
				for (int i = 0; i < Factors.RowCount; i++)
				{
					num = ((Pivots[i] == i) ? (num * Factors.At(i, i)) : (num * (0f - Factors.At(i, i))));
				}
				return num;
			}
		}

		protected LU(Matrix<float> factors, int[] pivots)
			: base(factors, pivots)
		{
		}
	}
	internal abstract class QR : QR<float>
	{
		public override float Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				double num = 1.0;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					num *= (double)FullR.At(i, i);
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0f))
					{
						return 0f;
					}
				}
				return Convert.ToSingle(Math.Abs(num));
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0f))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected QR(Matrix<float> q, Matrix<float> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}
	}
	internal abstract class Svd : Svd<float>
	{
		public override int Rank
		{
			get
			{
				double tolerance = base.S.Maximum().EpsilonOf() * (float)Math.Max(base.U.RowCount, base.VT.RowCount);
				return base.S.Count((float t) => (double)Math.Abs(t) > tolerance);
			}
		}

		public override double L2Norm => Math.Abs(base.S[0]);

		public override float ConditionNumber
		{
			get
			{
				int index = Math.Min(base.U.RowCount, base.VT.ColumnCount) - 1;
				return Math.Abs(base.S[0]) / Math.Abs(base.S[index]);
			}
		}

		public override float Determinant
		{
			get
			{
				if (base.U.RowCount != base.VT.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				double num = 1.0;
				foreach (float item in (IEnumerable<float>)base.S)
				{
					num *= (double)item;
					if (Math.Abs(item).AlmostEqual(0f))
					{
						return 0f;
					}
				}
				return Convert.ToSingle(Math.Abs(num));
			}
		}

		protected Svd(Vector<float> s, Matrix<float> u, Matrix<float> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}
	}
	internal sealed class UserCholesky : Cholesky
	{
		private static void DoCholesky(Matrix<float> factor)
		{
			if (factor.RowCount != factor.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			float[] array = new float[factor.RowCount];
			for (int i = 0; i < factor.RowCount; i++)
			{
				float num = factor.At(i, i);
				if ((double)num > 0.0)
				{
					num = (float)Math.Sqrt(num);
					factor.At(i, i, num);
					array[i] = num;
					for (int j = i + 1; j < factor.RowCount; j++)
					{
						factor.At(j, i, factor.At(j, i) / num);
						array[j] = factor.At(j, i);
					}
					DoCholeskyStep(factor, factor.RowCount, i + 1, factor.RowCount, array, Control.MaxDegreeOfParallelism);
					for (int k = i + 1; k < factor.RowCount; k++)
					{
						factor.At(i, k, 0f);
					}
					continue;
				}
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		public static UserCholesky Create(Matrix<float> matrix)
		{
			Matrix<float> factor = matrix.Clone();
			DoCholesky(factor);
			return new UserCholesky(factor);
		}

		public override void Factorize(Matrix<float> matrix)
		{
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			matrix.CopyTo(base.Factor);
			DoCholesky(base.Factor);
		}

		private UserCholesky(Matrix<float> factor)
			: base(factor)
		{
		}

		private static void DoCholeskyStep(Matrix<float> data, int rowDim, int firstCol, int colLimit, float[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				float num2 = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data.At(j, i, data.At(j, i) - multipliers[j] * num2);
				}
			}
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < result.ColumnCount; i++)
			{
				for (int j = 0; j < rowCount; j++)
				{
					float num = result.At(j, i);
					for (int num2 = j - 1; num2 >= 0; num2--)
					{
						num -= base.Factor.At(j, num2) * result.At(num2, i);
					}
					result.At(j, i, num / base.Factor.At(j, j));
				}
				for (int num3 = rowCount - 1; num3 >= 0; num3--)
				{
					float num = result.At(num3, i);
					for (int k = num3 + 1; k < rowCount; k++)
					{
						num -= base.Factor.At(k, num3) * result.At(k, i);
					}
					result.At(num3, i, num / base.Factor.At(num3, num3));
				}
			}
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < rowCount; i++)
			{
				float num = result[i];
				for (int num2 = i - 1; num2 >= 0; num2--)
				{
					num -= base.Factor.At(i, num2) * result[num2];
				}
				result[i] = num / base.Factor.At(i, i);
			}
			for (int num3 = rowCount - 1; num3 >= 0; num3--)
			{
				float num = result[num3];
				for (int j = num3 + 1; j < rowCount; j++)
				{
					num -= base.Factor.At(j, num3) * result[j];
				}
				result[num3] = num / base.Factor.At(num3, num3);
			}
		}
	}
	internal sealed class UserEvd : Evd
	{
		public static UserEvd Create(Matrix<float> matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			Matrix<float> matrix2 = Matrix<float>.Build.SameAs(matrix, rowCount, rowCount, fullyMutable: true);
			Matrix<float> matrix3 = Matrix<float>.Build.SameAs(matrix, rowCount, rowCount);
			MathNet.Numerics.LinearAlgebra.Complex.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Complex.DenseVector(rowCount);
			bool flag;
			switch (symmetricity)
			{
			case Symmetricity.Symmetric:
			case Symmetricity.Hermitian:
				flag = true;
				break;
			case Symmetricity.Asymmetric:
				flag = false;
				break;
			default:
				flag = matrix.IsSymmetric();
				break;
			}
			float[] array = new float[rowCount];
			float[] array2 = new float[rowCount];
			if (flag)
			{
				matrix.CopyTo(matrix2);
				array = matrix2.Row(rowCount - 1).ToArray();
				SymmetricTridiagonalize(matrix2, array, array2, rowCount);
				SymmetricDiagonalize(matrix2, array, array2, rowCount);
			}
			else
			{
				float[,] matrixH = matrix.ToArray();
				NonsymmetricReduceToHessenberg(matrix2, matrixH, rowCount);
				NonsymmetricReduceHessenberToRealSchur(matrix2, matrixH, array, array2, rowCount);
			}
			for (int i = 0; i < rowCount; i++)
			{
				matrix3.At(i, i, array[i]);
				if (array2[i] > 0f)
				{
					matrix3.At(i, i + 1, array2[i]);
				}
				else if (array2[i] < 0f)
				{
					matrix3.At(i, i - 1, array2[i]);
				}
			}
			for (int j = 0; j < rowCount; j++)
			{
				denseVector[j] = new System.Numerics.Complex(array[j], array2[j]);
			}
			return new UserEvd(matrix2, denseVector, matrix3, flag);
		}

		private UserEvd(Matrix<float> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<float> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		private static void SymmetricTridiagonalize(Matrix<float> eigenVectors, float[] d, float[] e, int order)
		{
			for (int num = order - 1; num > 0; num--)
			{
				float num2 = 0f;
				float num3 = 0f;
				for (int i = 0; i < num; i++)
				{
					num2 += Math.Abs(d[i]);
				}
				if (num2 == 0f)
				{
					e[num] = d[num - 1];
					for (int j = 0; j < num; j++)
					{
						d[j] = eigenVectors.At(num - 1, j);
						eigenVectors.At(num, j, 0f);
						eigenVectors.At(j, num, 0f);
					}
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						d[k] /= num2;
						num3 += d[k] * d[k];
					}
					float num4 = d[num - 1];
					float num5 = (float)Math.Sqrt(num3);
					if (num4 > 0f)
					{
						num5 = 0f - num5;
					}
					e[num] = num2 * num5;
					num3 -= num4 * num5;
					d[num - 1] = num4 - num5;
					for (int l = 0; l < num; l++)
					{
						e[l] = 0f;
					}
					for (int m = 0; m < num; m++)
					{
						num4 = d[m];
						eigenVectors.At(m, num, num4);
						num5 = e[m] + eigenVectors.At(m, m) * num4;
						for (int n = m + 1; n <= num - 1; n++)
						{
							num5 += eigenVectors.At(n, m) * d[n];
							e[n] += eigenVectors.At(n, m) * num4;
						}
						e[m] = num5;
					}
					num4 = 0f;
					for (int num6 = 0; num6 < num; num6++)
					{
						e[num6] /= num3;
						num4 += e[num6] * d[num6];
					}
					float num7 = num4 / (num3 + num3);
					for (int num8 = 0; num8 < num; num8++)
					{
						e[num8] -= num7 * d[num8];
					}
					for (int num9 = 0; num9 < num; num9++)
					{
						num4 = d[num9];
						num5 = e[num9];
						for (int num10 = num9; num10 <= num - 1; num10++)
						{
							eigenVectors.At(num10, num9, eigenVectors.At(num10, num9) - num4 * e[num10] - num5 * d[num10]);
						}
						d[num9] = eigenVectors.At(num - 1, num9);
						eigenVectors.At(num, num9, 0f);
					}
				}
				d[num] = num3;
			}
			for (int num11 = 0; num11 < order - 1; num11++)
			{
				eigenVectors.At(order - 1, num11, eigenVectors.At(num11, num11));
				eigenVectors.At(num11, num11, 1f);
				float num12 = d[num11 + 1];
				if (num12 != 0f)
				{
					for (int num13 = 0; num13 <= num11; num13++)
					{
						d[num13] = eigenVectors.At(num13, num11 + 1) / num12;
					}
					for (int num14 = 0; num14 <= num11; num14++)
					{
						float num15 = 0f;
						for (int num16 = 0; num16 <= num11; num16++)
						{
							num15 += eigenVectors.At(num16, num11 + 1) * eigenVectors.At(num16, num14);
						}
						for (int num17 = 0; num17 <= num11; num17++)
						{
							eigenVectors.At(num17, num14, eigenVectors.At(num17, num14) - num15 * d[num17]);
						}
					}
				}
				for (int num18 = 0; num18 <= num11; num18++)
				{
					eigenVectors.At(num18, num11 + 1, 0f);
				}
			}
			for (int num19 = 0; num19 < order; num19++)
			{
				d[num19] = eigenVectors.At(order - 1, num19);
				eigenVectors.At(order - 1, num19, 0f);
			}
			eigenVectors.At(order - 1, order - 1, 1f);
			e[0] = 0f;
		}

		private static void SymmetricDiagonalize(Matrix<float> eigenVectors, float[] d, float[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0f;
			float num = 0f;
			float num2 = 0f;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !((double)Math.Abs(e[k]) <= doublePrecision * (double)num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						float num4 = d[j];
						float num5 = (d[j + 1] - num4) / (2f * e[j]);
						float num6 = SpecialFunctions.Hypotenuse(num5, 1f);
						if (num5 < 0f)
						{
							num6 = 0f - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						float num7 = d[j + 1];
						float num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						float num9 = 1f;
						float num10 = num9;
						float num11 = num9;
						float num12 = e[j + 1];
						float num13 = 0f;
						float num14 = 0f;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = eigenVectors.At(m, num15 + 1);
								eigenVectors.At(m, num15 + 1, num13 * eigenVectors.At(m, num15) + num9 * num8);
								eigenVectors.At(m, num15, num9 * eigenVectors.At(m, num15) - num13 * num8);
							}
						}
						num5 = (0f - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while ((double)Math.Abs(e[j]) > doublePrecision * (double)num2);
				}
				d[j] += num;
				e[j] = 0f;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				float num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = eigenVectors.At(num19, n);
						eigenVectors.At(num19, n, eigenVectors.At(num19, num16));
						eigenVectors.At(num19, num16, num17);
					}
				}
			}
		}

		private static void NonsymmetricReduceToHessenberg(Matrix<float> eigenVectors, float[,] matrixH, int order)
		{
			float[] array = new float[order];
			for (int i = 1; i < order - 1; i++)
			{
				float num = 0f;
				for (int j = i; j < order; j++)
				{
					num += Math.Abs(matrixH[j, i - 1]);
				}
				if (num == 0f)
				{
					continue;
				}
				float num2 = 0f;
				for (int num3 = order - 1; num3 >= i; num3--)
				{
					array[num3] = matrixH[num3, i - 1] / num;
					num2 += array[num3] * array[num3];
				}
				float num4 = (float)Math.Sqrt(num2);
				if (array[i] > 0f)
				{
					num4 = 0f - num4;
				}
				num2 -= array[i] * num4;
				array[i] -= num4;
				for (int k = i; k < order; k++)
				{
					float num5 = 0f;
					for (int num6 = order - 1; num6 >= i; num6--)
					{
						num5 += array[num6] * matrixH[num6, k];
					}
					num5 /= num2;
					for (int l = i; l < order; l++)
					{
						matrixH[l, k] -= num5 * array[l];
					}
				}
				for (int m = 0; m < order; m++)
				{
					float num7 = 0f;
					for (int num8 = order - 1; num8 >= i; num8--)
					{
						num7 += array[num8] * matrixH[m, num8];
					}
					num7 /= num2;
					for (int n = i; n < order; n++)
					{
						matrixH[m, n] -= num7 * array[n];
					}
				}
				array[i] = num * array[i];
				matrixH[i, i - 1] = num * num4;
			}
			for (int num9 = 0; num9 < order; num9++)
			{
				for (int num10 = 0; num10 < order; num10++)
				{
					eigenVectors.At(num9, num10, (num9 == num10) ? 1f : 0f);
				}
			}
			for (int num11 = order - 2; num11 >= 1; num11--)
			{
				if (matrixH[num11, num11 - 1] != 0f)
				{
					for (int num12 = num11 + 1; num12 < order; num12++)
					{
						array[num12] = matrixH[num12, num11 - 1];
					}
					for (int num13 = num11; num13 < order; num13++)
					{
						float num14 = 0f;
						for (int num15 = num11; num15 < order; num15++)
						{
							num14 += array[num15] * eigenVectors.At(num15, num13);
						}
						num14 = num14 / array[num11] / matrixH[num11, num11 - 1];
						for (int num16 = num11; num16 < order; num16++)
						{
							eigenVectors.At(num16, num13, eigenVectors.At(num16, num13) + num14 * array[num16]);
						}
					}
				}
			}
		}

		private static void NonsymmetricReduceHessenberToRealSchur(Matrix<float> eigenVectors, float[,] matrixH, float[] d, float[] e, int order)
		{
			int num = order - 1;
			float num2 = (float)Precision.SinglePrecision;
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			float num6 = 0f;
			float num7 = 0f;
			float num8 = 0f;
			float num9 = 0f;
			for (int i = 0; i < order; i++)
			{
				for (int j = Math.Max(i - 1, 0); j < order; j++)
				{
					num9 += Math.Abs(matrixH[i, j]);
				}
			}
			int num10 = 0;
			while (num >= 0)
			{
				int num11;
				for (num11 = num; num11 > 0; num11--)
				{
					num7 = Math.Abs(matrixH[num11 - 1, num11 - 1]) + Math.Abs(matrixH[num11, num11]);
					if (num7 == 0f)
					{
						num7 = num9;
					}
					if (Math.Abs(matrixH[num11, num11 - 1]) < num2 * num7)
					{
						break;
					}
				}
				if (num11 == num)
				{
					matrixH[num, num] += num3;
					d[num] = matrixH[num, num];
					e[num] = 0f;
					num--;
					num10 = 0;
					continue;
				}
				float num13;
				float num12;
				if (num11 == num - 1)
				{
					num12 = matrixH[num, num - 1] * matrixH[num - 1, num];
					num4 = (matrixH[num - 1, num - 1] - matrixH[num, num]) / 2f;
					num5 = num4 * num4 + num12;
					num8 = (float)Math.Sqrt(Math.Abs(num5));
					matrixH[num, num] += num3;
					matrixH[num - 1, num - 1] += num3;
					num13 = matrixH[num, num];
					if (num5 >= 0f)
					{
						num8 = ((!(num4 >= 0f)) ? (num4 - num8) : (num4 + num8));
						d[num - 1] = num13 + num8;
						d[num] = d[num - 1];
						if (num8 != 0f)
						{
							d[num] = num13 - num12 / num8;
						}
						e[num - 1] = 0f;
						e[num] = 0f;
						num13 = matrixH[num, num - 1];
						num7 = Math.Abs(num13) + Math.Abs(num8);
						num4 = num13 / num7;
						num5 = num8 / num7;
						num6 = (float)Math.Sqrt(num4 * num4 + num5 * num5);
						num4 /= num6;
						num5 /= num6;
						for (int k = num - 1; k < order; k++)
						{
							num8 = matrixH[num - 1, k];
							matrixH[num - 1, k] = num5 * num8 + num4 * matrixH[num, k];
							matrixH[num, k] = num5 * matrixH[num, k] - num4 * num8;
						}
						for (int l = 0; l <= num; l++)
						{
							num8 = matrixH[l, num - 1];
							matrixH[l, num - 1] = num5 * num8 + num4 * matrixH[l, num];
							matrixH[l, num] = num5 * matrixH[l, num] - num4 * num8;
						}
						for (int m = 0; m < order; m++)
						{
							num8 = eigenVectors.At(m, num - 1);
							eigenVectors.At(m, num - 1, num5 * num8 + num4 * eigenVectors.At(m, num));
							eigenVectors.At(m, num, num5 * eigenVectors.At(m, num) - num4 * num8);
						}
					}
					else
					{
						d[num - 1] = num13 + num4;
						d[num] = num13 + num4;
						e[num - 1] = num8;
						e[num] = 0f - num8;
					}
					num -= 2;
					num10 = 0;
					continue;
				}
				num13 = matrixH[num, num];
				float num14 = 0f;
				num12 = 0f;
				if (num11 < num)
				{
					num14 = matrixH[num - 1, num - 1];
					num12 = matrixH[num, num - 1] * matrixH[num - 1, num];
				}
				if (num10 == 10)
				{
					num3 += num13;
					for (int n = 0; n <= num; n++)
					{
						matrixH[n, n] -= num13;
					}
					num7 = Math.Abs(matrixH[num, num - 1]) + Math.Abs(matrixH[num - 1, num - 2]);
					num13 = (num14 = 0.75f * num7);
					num12 = -0.4375f * num7 * num7;
				}
				if (num10 == 30)
				{
					num7 = (num14 - num13) / 2f;
					num7 = num7 * num7 + num12;
					if (num7 > 0f)
					{
						num7 = (float)Math.Sqrt(num7);
						if (num14 < num13)
						{
							num7 = 0f - num7;
						}
						num7 = num13 - num12 / ((num14 - num13) / 2f + num7);
						for (int num15 = 0; num15 <= num; num15++)
						{
							matrixH[num15, num15] -= num7;
						}
						num3 += num7;
						num13 = (num14 = (num12 = 0.964f));
					}
				}
				num10++;
				int num16;
				for (num16 = num - 2; num16 >= num11; num16--)
				{
					num8 = matrixH[num16, num16];
					num6 = num13 - num8;
					num7 = num14 - num8;
					num4 = (num6 * num7 - num12) / matrixH[num16 + 1, num16] + matrixH[num16, num16 + 1];
					num5 = matrixH[num16 + 1, num16 + 1] - num8 - num6 - num7;
					num6 = matrixH[num16 + 2, num16 + 1];
					num7 = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6);
					num4 /= num7;
					num5 /= num7;
					num6 /= num7;
					if (num16 == num11 || Math.Abs(matrixH[num16, num16 - 1]) * (Math.Abs(num5) + Math.Abs(num6)) < num2 * (Math.Abs(num4) * (Math.Abs(matrixH[num16 - 1, num16 - 1]) + Math.Abs(num8) + Math.Abs(matrixH[num16 + 1, num16 + 1]))))
					{
						break;
					}
				}
				for (int num17 = num16 + 2; num17 <= num; num17++)
				{
					matrixH[num17, num17 - 2] = 0f;
					if (num17 > num16 + 2)
					{
						matrixH[num17, num17 - 3] = 0f;
					}
				}
				for (int num18 = num16; num18 <= num - 1; num18++)
				{
					bool flag = num18 != num - 1;
					if (num18 != num16)
					{
						num4 = matrixH[num18, num18 - 1];
						num5 = matrixH[num18 + 1, num18 - 1];
						num6 = (flag ? matrixH[num18 + 2, num18 - 1] : 0f);
						num13 = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6);
						if (num13 != 0f)
						{
							num4 /= num13;
							num5 /= num13;
							num6 /= num13;
						}
					}
					if (num13 == 0f)
					{
						break;
					}
					num7 = (float)Math.Sqrt(num4 * num4 + num5 * num5 + num6 * num6);
					if (num4 < 0f)
					{
						num7 = 0f - num7;
					}
					if (num7 == 0f)
					{
						continue;
					}
					if (num18 != num16)
					{
						matrixH[num18, num18 - 1] = (0f - num7) * num13;
					}
					else if (num11 != num16)
					{
						matrixH[num18, num18 - 1] = 0f - matrixH[num18, num18 - 1];
					}
					num4 += num7;
					num13 = num4 / num7;
					num14 = num5 / num7;
					num8 = num6 / num7;
					num5 /= num4;
					num6 /= num4;
					for (int num19 = num18; num19 < order; num19++)
					{
						num4 = matrixH[num18, num19] + num5 * matrixH[num18 + 1, num19];
						if (flag)
						{
							num4 += num6 * matrixH[num18 + 2, num19];
							matrixH[num18 + 2, num19] -= num4 * num8;
						}
						matrixH[num18, num19] -= num4 * num13;
						matrixH[num18 + 1, num19] -= num4 * num14;
					}
					for (int num20 = 0; num20 <= Math.Min(num, num18 + 3); num20++)
					{
						num4 = num13 * matrixH[num20, num18] + num14 * matrixH[num20, num18 + 1];
						if (flag)
						{
							num4 += num8 * matrixH[num20, num18 + 2];
							matrixH[num20, num18 + 2] -= num4 * num6;
						}
						matrixH[num20, num18] -= num4;
						matrixH[num20, num18 + 1] -= num4 * num5;
					}
					for (int num21 = 0; num21 < order; num21++)
					{
						num4 = num13 * eigenVectors.At(num21, num18) + num14 * eigenVectors.At(num21, num18 + 1);
						if (flag)
						{
							num4 += num8 * eigenVectors.At(num21, num18 + 2);
							eigenVectors.At(num21, num18 + 2, eigenVectors.At(num21, num18 + 2) - num4 * num6);
						}
						eigenVectors.At(num21, num18, eigenVectors.At(num21, num18) - num4);
						eigenVectors.At(num21, num18 + 1, eigenVectors.At(num21, num18 + 1) - num4 * num5);
					}
				}
			}
			if (num9 == 0f)
			{
				return;
			}
			for (num = order - 1; num >= 0; num--)
			{
				num4 = d[num];
				num5 = e[num];
				if (num5 == 0f)
				{
					int num22 = num;
					matrixH[num, num] = 1f;
					for (int num23 = num - 1; num23 >= 0; num23--)
					{
						float num12 = matrixH[num23, num23] - num4;
						num6 = 0f;
						for (int num24 = num22; num24 <= num; num24++)
						{
							num6 += matrixH[num23, num24] * matrixH[num24, num];
						}
						if (e[num23] < 0f)
						{
							num8 = num12;
							num7 = num6;
						}
						else
						{
							num22 = num23;
							float num25;
							if (e[num23] == 0f)
							{
								if (num12 != 0f)
								{
									matrixH[num23, num] = (0f - num6) / num12;
								}
								else
								{
									matrixH[num23, num] = (0f - num6) / (num2 * num9);
								}
							}
							else
							{
								float num13 = matrixH[num23, num23 + 1];
								float num14 = matrixH[num23 + 1, num23];
								num5 = (d[num23] - num4) * (d[num23] - num4) + e[num23] * e[num23];
								num25 = (matrixH[num23, num] = (num13 * num7 - num8 * num6) / num5);
								if (Math.Abs(num13) > Math.Abs(num8))
								{
									matrixH[num23 + 1, num] = (0f - num6 - num12 * num25) / num13;
								}
								else
								{
									matrixH[num23 + 1, num] = (0f - num7 - num14 * num25) / num8;
								}
							}
							num25 = Math.Abs(matrixH[num23, num]);
							if (num2 * num25 * num25 > 1f)
							{
								for (int num26 = num23; num26 <= num; num26++)
								{
									matrixH[num26, num] /= num25;
								}
							}
						}
					}
				}
				else if (num5 < 0f)
				{
					int num27 = num - 1;
					if (Math.Abs(matrixH[num, num - 1]) > Math.Abs(matrixH[num - 1, num]))
					{
						matrixH[num - 1, num - 1] = num5 / matrixH[num, num - 1];
						matrixH[num - 1, num] = (0f - (matrixH[num, num] - num4)) / matrixH[num, num - 1];
					}
					else
					{
						MathNet.Numerics.Complex32 complex = Cdiv(0f, 0f - matrixH[num - 1, num], matrixH[num - 1, num - 1] - num4, num5);
						matrixH[num - 1, num - 1] = complex.Real;
						matrixH[num - 1, num] = complex.Imaginary;
					}
					matrixH[num, num - 1] = 0f;
					matrixH[num, num] = 1f;
					for (int num28 = num - 2; num28 >= 0; num28--)
					{
						float num29 = 0f;
						float num30 = 0f;
						for (int num31 = num27; num31 <= num; num31++)
						{
							num29 += matrixH[num28, num31] * matrixH[num31, num - 1];
							num30 += matrixH[num28, num31] * matrixH[num31, num];
						}
						float num12 = matrixH[num28, num28] - num4;
						if (e[num28] < 0f)
						{
							num8 = num12;
							num6 = num29;
							num7 = num30;
						}
						else
						{
							num27 = num28;
							if (e[num28] == 0f)
							{
								MathNet.Numerics.Complex32 complex2 = Cdiv(0f - num29, 0f - num30, num12, num5);
								matrixH[num28, num - 1] = complex2.Real;
								matrixH[num28, num] = complex2.Imaginary;
							}
							else
							{
								float num13 = matrixH[num28, num28 + 1];
								float num14 = matrixH[num28 + 1, num28];
								float num32 = (d[num28] - num4) * (d[num28] - num4) + e[num28] * e[num28] - num5 * num5;
								float num33 = (d[num28] - num4) * 2f * num5;
								if (num32 == 0f && num33 == 0f)
								{
									num32 = num2 * num9 * (Math.Abs(num12) + Math.Abs(num5) + Math.Abs(num13) + Math.Abs(num14) + Math.Abs(num8));
								}
								MathNet.Numerics.Complex32 complex3 = Cdiv(num13 * num6 - num8 * num29 + num5 * num30, num13 * num7 - num8 * num30 - num5 * num29, num32, num33);
								matrixH[num28, num - 1] = complex3.Real;
								matrixH[num28, num] = complex3.Imaginary;
								if (Math.Abs(num13) > Math.Abs(num8) + Math.Abs(num5))
								{
									matrixH[num28 + 1, num - 1] = (0f - num29 - num12 * matrixH[num28, num - 1] + num5 * matrixH[num28, num]) / num13;
									matrixH[num28 + 1, num] = (0f - num30 - num12 * matrixH[num28, num] - num5 * matrixH[num28, num - 1]) / num13;
								}
								else
								{
									complex3 = Cdiv(0f - num6 - num14 * matrixH[num28, num - 1], 0f - num7 - num14 * matrixH[num28, num], num8, num5);
									matrixH[num28 + 1, num - 1] = complex3.Real;
									matrixH[num28 + 1, num] = complex3.Imaginary;
								}
							}
							float num25 = Math.Max(Math.Abs(matrixH[num28, num - 1]), Math.Abs(matrixH[num28, num]));
							if (num2 * num25 * num25 > 1f)
							{
								for (int num34 = num28; num34 <= num; num34++)
								{
									matrixH[num34, num - 1] /= num25;
									matrixH[num34, num] /= num25;
								}
							}
						}
					}
				}
			}
			for (int num35 = order - 1; num35 >= 0; num35--)
			{
				for (int num36 = 0; num36 < order; num36++)
				{
					num8 = 0f;
					for (int num37 = 0; num37 <= num35; num37++)
					{
						num8 += eigenVectors.At(num36, num37) * matrixH[num37, num35];
					}
					eigenVectors.At(num36, num35, num8);
				}
			}
		}

		private static MathNet.Numerics.Complex32 Cdiv(float xreal, float ximag, float yreal, float yimag)
		{
			if (Math.Abs(yimag) < Math.Abs(yreal))
			{
				return new MathNet.Numerics.Complex32((xreal + ximag * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)), (ximag - xreal * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)));
			}
			return new MathNet.Numerics.Complex32((ximag + xreal * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)), (0f - xreal + ximag * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)));
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				float[] array = new float[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						float num = 0f;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								num += base.EigenVectors.At(k, j) * input.At(k, i);
							}
							num /= (float)base.EigenValues[j].Real;
						}
						array[j] = num;
					}
					for (int l = 0; l < count; l++)
					{
						float num2 = 0f;
						for (int m = 0; m < count; m++)
						{
							num2 += base.EigenVectors.At(l, m) * array[m];
						}
						result.At(l, i, num2);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				float[] array = new float[count];
				for (int i = 0; i < count; i++)
				{
					float num = 0f;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							num += base.EigenVectors.At(j, i) * input[j];
						}
						num /= (float)base.EigenValues[i].Real;
					}
					array[i] = num;
				}
				for (int k = 0; k < count; k++)
				{
					float num = 0f;
					for (int l = 0; l < count; l++)
					{
						num += base.EigenVectors.At(k, l) * array[l];
					}
					result[k] = num;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class UserGramSchmidt : GramSchmidt
	{
		public static UserGramSchmidt Create(Matrix<float> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			Matrix<float> matrix2 = matrix.Clone();
			Matrix<float> matrix3 = Matrix<float>.Build.SameAs(matrix, matrix.ColumnCount, matrix.ColumnCount, fullyMutable: true);
			for (int i = 0; i < matrix2.ColumnCount; i++)
			{
				float num = (float)matrix2.Column(i).L2Norm();
				if (num == 0f)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				matrix3.At(i, i, num);
				for (int j = 0; j < matrix2.RowCount; j++)
				{
					matrix2.At(j, i, matrix2.At(j, i) / num);
				}
				for (int k = i + 1; k < matrix2.ColumnCount; k++)
				{
					float num2 = matrix2.Column(i).DotProduct(matrix2.Column(k));
					matrix3.At(i, k, num2);
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						float value = matrix2.At(l, k) - matrix2.At(l, i) * num2;
						matrix2.At(l, k, value);
					}
				}
			}
			return new UserGramSchmidt(matrix2, matrix3);
		}

		private UserGramSchmidt(Matrix<float> q, Matrix<float> rFull)
			: base(q, rFull)
		{
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<float> matrix = input.Clone();
			float[] array = new float[base.Q.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < base.Q.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < base.Q.ColumnCount; k++)
				{
					float num = 0f;
					for (int l = 0; l < base.Q.RowCount; l++)
					{
						num += base.Q.At(l, k) * array[l];
					}
					matrix.At(k, i, num);
				}
			}
			for (int num2 = base.Q.ColumnCount - 1; num2 >= 0; num2--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num2, m, matrix.At(num2, m) / FullR.At(num2, num2));
				}
				for (int n = 0; n < num2; n++)
				{
					for (int num3 = 0; num3 < input.ColumnCount; num3++)
					{
						matrix.At(n, num3, matrix.At(n, num3) - matrix.At(num2, num3) * FullR.At(n, num2));
					}
				}
			}
			for (int num4 = 0; num4 < FullR.ColumnCount; num4++)
			{
				for (int num5 = 0; num5 < input.ColumnCount; num5++)
				{
					result.At(num4, num5, matrix.At(num4, num5));
				}
			}
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			Vector<float> vector = input.Clone();
			float[] array = new float[base.Q.RowCount];
			for (int i = 0; i < base.Q.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < base.Q.ColumnCount; j++)
			{
				float num = 0f;
				for (int k = 0; k < base.Q.RowCount; k++)
				{
					num += base.Q.At(k, j) * array[k];
				}
				vector[j] = num;
			}
			for (int num2 = base.Q.ColumnCount - 1; num2 >= 0; num2--)
			{
				vector[num2] /= FullR.At(num2, num2);
				for (int l = 0; l < num2; l++)
				{
					vector[l] -= vector[num2] * FullR.At(l, num2);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserLU : LU
	{
		public static UserLU Create(Matrix<float> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			Matrix<float> matrix2 = matrix.Clone();
			int[] array = new int[rowCount];
			for (int i = 0; i < rowCount; i++)
			{
				array[i] = i;
			}
			float[] array2 = new float[rowCount];
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = 0; k < rowCount; k++)
				{
					array2[k] = matrix2.At(k, j);
				}
				for (int l = 0; l < rowCount; l++)
				{
					int num = Math.Min(l, j);
					float num2 = 0f;
					for (int m = 0; m < num; m++)
					{
						num2 += matrix2.At(l, m) * array2[m];
					}
					array2[l] -= num2;
					matrix2.At(l, j, array2[l]);
				}
				int num3 = j;
				for (int n = j + 1; n < rowCount; n++)
				{
					if (Math.Abs(array2[n]) > Math.Abs(array2[num3]))
					{
						num3 = n;
					}
				}
				if (num3 != j)
				{
					for (int num4 = 0; num4 < rowCount; num4++)
					{
						float value = matrix2.At(num3, num4);
						matrix2.At(num3, num4, matrix2.At(j, num4));
						matrix2.At(j, num4, value);
					}
					array[j] = num3;
				}
				if ((j < rowCount) & ((double)matrix2.At(j, j) != 0.0))
				{
					for (int num5 = j + 1; num5 < rowCount; num5++)
					{
						matrix2.At(num5, j, matrix2.At(num5, j) / matrix2.At(j, j));
					}
				}
			}
			return new UserLU(matrix2, array);
		}

		private UserLU(Matrix<float> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int row = Pivots[i];
					for (int j = 0; j < result.ColumnCount; j++)
					{
						float value = result.At(row, j);
						result.At(row, j, result.At(i, j));
						result.At(i, j, value);
					}
				}
			}
			int rowCount = Factors.RowCount;
			for (int k = 0; k < rowCount; k++)
			{
				for (int l = k + 1; l < rowCount; l++)
				{
					for (int m = 0; m < result.ColumnCount; m++)
					{
						float num = result.At(k, m) * Factors.At(l, k);
						result.At(l, m, result.At(l, m) - num);
					}
				}
			}
			for (int num2 = rowCount - 1; num2 >= 0; num2--)
			{
				for (int n = 0; n < result.ColumnCount; n++)
				{
					result.At(num2, n, result.At(num2, n) / Factors.At(num2, num2));
				}
				for (int num3 = 0; num3 < num2; num3++)
				{
					for (int num4 = 0; num4 < result.ColumnCount; num4++)
					{
						float num5 = result.At(num2, num4) * Factors.At(num3, num2);
						result.At(num3, num4, result.At(num3, num4) - num5);
					}
				}
			}
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int index = Pivots[i];
					float value = result[index];
					result[index] = result[i];
					result[i] = value;
				}
			}
			int rowCount = Factors.RowCount;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = j + 1; k < rowCount; k++)
				{
					result[k] -= result[j] * Factors.At(k, j);
				}
			}
			for (int num = rowCount - 1; num >= 0; num--)
			{
				result[num] /= Factors.At(num, num);
				for (int l = 0; l < num; l++)
				{
					result[l] -= result[num] * Factors.At(l, num);
				}
			}
		}

		public override Matrix<float> Inverse()
		{
			int rowCount = Factors.RowCount;
			Matrix<float> matrix = Matrix<float>.Build.SameAs(Factors, rowCount, rowCount);
			for (int i = 0; i < rowCount; i++)
			{
				matrix.At(i, i, 1f);
			}
			return Solve(matrix);
		}
	}
	internal sealed class UserQR : QR
	{
		public static UserQR Create(Matrix<float> matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			int num = Math.Min(matrix.RowCount, matrix.ColumnCount);
			float[][] array = new float[num][];
			Matrix<float> matrix2;
			Matrix<float> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = Matrix<float>.Build.SameAs(matrix, matrix.RowCount, matrix.RowCount, fullyMutable: true);
				for (int i = 0; i < matrix.RowCount; i++)
				{
					matrix3.At(i, i, 1f);
				}
				for (int j = 0; j < num; j++)
				{
					array[j] = GenerateColumn(matrix2, j, j);
					ComputeQR(array[j], matrix2, j, matrix.RowCount, j + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					ComputeQR(array[num2], matrix3, num2, matrix.RowCount, num2, matrix.RowCount, Control.MaxDegreeOfParallelism);
				}
			}
			else
			{
				matrix3 = matrix.Clone();
				for (int k = 0; k < num; k++)
				{
					array[k] = GenerateColumn(matrix3, k, k);
					ComputeQR(array[k], matrix3, k, matrix.RowCount, k + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				matrix2 = matrix3.SubMatrix(0, matrix.ColumnCount, 0, matrix.ColumnCount);
				matrix3.Clear();
				for (int l = 0; l < matrix.ColumnCount; l++)
				{
					matrix3.At(l, l, 1f);
				}
				for (int num3 = num - 1; num3 >= 0; num3--)
				{
					ComputeQR(array[num3], matrix3, num3, matrix.RowCount, num3, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
			}
			return new UserQR(matrix3, matrix2, method);
		}

		private UserQR(Matrix<float> q, Matrix<float> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}

		private static float[] GenerateColumn(Matrix<float> a, int row, int column)
		{
			int num = a.RowCount - row;
			float[] array = new float[num];
			for (int i = row; i < a.RowCount; i++)
			{
				array[i - row] = a.At(i, row);
				a.At(i, row, 0f);
			}
			float num2 = array.Sum((float t) => t * t);
			num2 = (float)Math.Sqrt(num2);
			if (row == a.RowCount - 1 || num2 == 0f)
			{
				a.At(row, column, 0f - array[0]);
				array[0] = 1.4142135f;
				return array;
			}
			float num3 = 1f / num2;
			if ((double)array[0] < 0.0)
			{
				num3 *= -1f;
			}
			a.At(row, column, -1f / num3);
			for (int j = 0; j < num; j++)
			{
				array[j] *= num3;
			}
			array[0] += 1f;
			float num4 = (float)Math.Sqrt(1.0 / (double)array[0]);
			for (int k = 0; k < num; k++)
			{
				array[k] *= num4;
			}
			return array;
		}

		private static void ComputeQR(float[] u, Matrix<float> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores)
		{
			if (rowDim < rowStart || columnDim < columnStart)
			{
				return;
			}
			int num = columnDim - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(u, a, rowStart, rowDim, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(u, a, rowStart, rowDim, tmpSplit, columnDim, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnDim; i++)
			{
				float num2 = 0f;
				for (int j = rowStart; j < rowDim; j++)
				{
					num2 += u[j - rowStart] * a.At(j, i);
				}
				for (int k = rowStart; k < rowDim; k++)
				{
					a.At(k, i, a.At(k, i) - u[k - rowStart] * num2);
				}
			}
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (FullR.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<float> matrix = input.Clone();
			float[] array = new float[FullR.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < FullR.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < FullR.RowCount; k++)
				{
					float num = 0f;
					for (int l = 0; l < FullR.RowCount; l++)
					{
						num += base.Q.At(l, k) * array[l];
					}
					matrix.At(k, i, num);
				}
			}
			for (int num2 = FullR.ColumnCount - 1; num2 >= 0; num2--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num2, m, matrix.At(num2, m) / FullR.At(num2, num2));
				}
				for (int n = 0; n < num2; n++)
				{
					for (int num3 = 0; num3 < input.ColumnCount; num3++)
					{
						matrix.At(n, num3, matrix.At(n, num3) - matrix.At(num2, num3) * FullR.At(n, num2));
					}
				}
			}
			for (int num4 = 0; num4 < FullR.ColumnCount; num4++)
			{
				for (int num5 = 0; num5 < matrix.ColumnCount; num5++)
				{
					result.At(num4, num5, matrix.At(num4, num5));
				}
			}
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (FullR.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			Vector<float> vector = input.Clone();
			float[] array = new float[FullR.RowCount];
			for (int i = 0; i < FullR.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < FullR.RowCount; j++)
			{
				float num = 0f;
				for (int k = 0; k < FullR.RowCount; k++)
				{
					num += base.Q.At(k, j) * array[k];
				}
				vector[j] = num;
			}
			for (int num2 = FullR.ColumnCount - 1; num2 >= 0; num2--)
			{
				vector[num2] /= FullR.At(num2, num2);
				for (int l = 0; l < num2; l++)
				{
					vector[l] -= vector[num2] * FullR.At(l, num2);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserSvd : Svd
	{
		public static UserSvd Create(Matrix<float> matrix, bool computeVectors)
		{
			int num = Math.Min(matrix.RowCount + 1, matrix.ColumnCount);
			Matrix<float> matrix2 = matrix.Clone();
			Vector<float> vector = Vector<float>.Build.SameAs(matrix2, num);
			Matrix<float> matrix3 = Matrix<float>.Build.SameAs(matrix2, matrix2.RowCount, matrix2.RowCount, fullyMutable: true);
			Matrix<float> matrix4 = Matrix<float>.Build.SameAs(matrix2, matrix2.ColumnCount, matrix2.ColumnCount, fullyMutable: true);
			float[] array = new float[matrix2.ColumnCount];
			float[] array2 = new float[matrix2.RowCount];
			int rowCount = matrix2.RowCount;
			int num2 = Math.Min(matrix2.RowCount - 1, matrix2.ColumnCount);
			int num3 = Math.Max(0, Math.Min(matrix2.ColumnCount - 2, matrix2.RowCount));
			int num4 = Math.Max(num2, num3);
			for (int i = 0; i < num4; i++)
			{
				int num5 = i + 1;
				if (i < num2)
				{
					float num7 = (vector[i] = Dnrm2Column(matrix2, matrix2.RowCount, i, i));
					if ((double)vector[i] != 0.0)
					{
						if ((double)matrix2.At(i, i) != 0.0)
						{
							vector[i] = Dsign(vector[i], matrix2.At(i, i));
						}
						DscalColumn(matrix2, matrix2.RowCount, i, i, 1f / vector[i]);
						matrix2.At(i, i, 1f + matrix2.At(i, i));
					}
					vector[i] = 0f - vector[i];
				}
				for (int j = num5; j < matrix2.ColumnCount; j++)
				{
					if (i < num2 && (double)vector[i] != 0.0)
					{
						float num8 = (0f - Ddot(matrix2, matrix2.RowCount, i, j, i)) / matrix2.At(i, i);
						for (int k = i; k < matrix2.RowCount; k++)
						{
							matrix2.At(k, j, matrix2.At(k, j) + num8 * matrix2.At(k, i));
						}
					}
					array[j] = matrix2.At(i, j);
				}
				if (computeVectors && i < num2)
				{
					for (int l = i; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, i, matrix2.At(l, i));
					}
				}
				if (i >= num3)
				{
					continue;
				}
				float num9 = (array[i] = Dnrm2Vector(array, num5));
				if ((double)array[i] != 0.0)
				{
					if ((double)array[num5] != 0.0)
					{
						array[i] = Dsign(array[i], array[num5]);
					}
					DscalVector(array, num5, 1f / array[i]);
					array[num5] = 1f + array[num5];
				}
				array[i] = 0f - array[i];
				if (num5 < matrix2.RowCount && (double)array[i] != 0.0)
				{
					for (int l = num5; l < matrix2.RowCount; l++)
					{
						array2[l] = 0f;
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						for (int m = num5; m < matrix2.RowCount; m++)
						{
							array2[m] += array[j] * matrix2.At(m, j);
						}
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						float num10 = (0f - array[j]) / array[num5];
						for (int n = num5; n < matrix2.RowCount; n++)
						{
							matrix2.At(n, j, matrix2.At(n, j) + num10 * array2[n]);
						}
					}
				}
				if (computeVectors)
				{
					for (int l = num5; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, array[l]);
					}
				}
			}
			int num11 = Math.Min(matrix2.ColumnCount, matrix2.RowCount + 1);
			int num12 = num2 + 1;
			int num13 = num3 + 1;
			if (num2 < matrix2.ColumnCount)
			{
				vector[num12 - 1] = matrix2.At(num12 - 1, num12 - 1);
			}
			if (matrix2.RowCount < num11)
			{
				vector[num11 - 1] = 0f;
			}
			if (num13 < num11)
			{
				array[num13 - 1] = matrix2.At(num13 - 1, num11 - 1);
			}
			array[num11 - 1] = 0f;
			if (computeVectors)
			{
				for (int j = num12 - 1; j < rowCount; j++)
				{
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, j, 0f);
					}
					matrix3.At(j, j, 1f);
				}
				for (int i = num2 - 1; i >= 0; i--)
				{
					if ((double)vector[i] != 0.0)
					{
						for (int j = i + 1; j < rowCount; j++)
						{
							float num8 = (0f - Ddot(matrix3, matrix2.RowCount, i, j, i)) / matrix3.At(i, i);
							for (int num14 = i; num14 < matrix2.RowCount; num14++)
							{
								matrix3.At(num14, j, matrix3.At(num14, j) + num8 * matrix3.At(num14, i));
							}
						}
						DscalColumn(matrix3, matrix2.RowCount, i, i, -1f);
						matrix3.At(i, i, 1f + matrix3.At(i, i));
						for (int l = 0; l < i; l++)
						{
							matrix3.At(l, i, 0f);
						}
					}
					else
					{
						for (int l = 0; l < matrix2.RowCount; l++)
						{
							matrix3.At(l, i, 0f);
						}
						matrix3.At(i, i, 1f);
					}
				}
			}
			if (computeVectors)
			{
				for (int i = matrix2.ColumnCount - 1; i >= 0; i--)
				{
					int num5 = i + 1;
					if (i < num3 && (double)array[i] != 0.0)
					{
						for (int j = num5; j < matrix2.ColumnCount; j++)
						{
							float num8 = (0f - Ddot(matrix4, matrix2.ColumnCount, i, j, num5)) / matrix4.At(num5, i);
							for (int num15 = i; num15 < matrix2.ColumnCount; num15++)
							{
								matrix4.At(num15, j, matrix4.At(num15, j) + num8 * matrix4.At(num15, i));
							}
						}
					}
					for (int l = 0; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, 0f);
					}
					matrix4.At(i, i, 1f);
				}
			}
			for (int l = 0; l < num11; l++)
			{
				if ((double)vector[l] != 0.0)
				{
					float num8 = vector[l];
					float num16 = vector[l] / num8;
					vector[l] = num8;
					if (l < num11 - 1)
					{
						array[l] /= num16;
					}
					if (computeVectors)
					{
						DscalColumn(matrix3, matrix2.RowCount, l, 0, num16);
					}
				}
				if (l == num11 - 1)
				{
					break;
				}
				if ((double)array[l] != 0.0)
				{
					float num8 = array[l];
					float num16 = num8 / array[l];
					array[l] = num8;
					vector[l + 1] *= num16;
					if (computeVectors)
					{
						DscalColumn(matrix4, matrix2.ColumnCount, l + 1, 0, num16);
					}
				}
			}
			int num17 = num11;
			int num18 = 0;
			while (num11 > 0)
			{
				if (num18 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num11 - 2; i >= 0; i--)
				{
					float num19 = Math.Abs(vector[i]) + Math.Abs(vector[i + 1]);
					if ((num19 + Math.Abs(array[i])).AlmostEqualRelative(num19, 7))
					{
						array[i] = 0f;
						break;
					}
				}
				int num20;
				if (i == num11 - 2)
				{
					num20 = 4;
				}
				else
				{
					int num21;
					for (num21 = num11 - 1; num21 > i; num21--)
					{
						float num19 = 0f;
						if (num21 != num11 - 1)
						{
							num19 += Math.Abs(array[num21]);
						}
						if (num21 != i + 1)
						{
							num19 += Math.Abs(array[num21 - 1]);
						}
						if ((num19 + Math.Abs(vector[num21])).AlmostEqualRelative(num19, 7))
						{
							vector[num21] = 0f;
							break;
						}
					}
					if (num21 == i)
					{
						num20 = 3;
					}
					else if (num21 == num11 - 1)
					{
						num20 = 1;
					}
					else
					{
						num20 = 2;
						i = num21;
					}
				}
				i++;
				float c;
				float s;
				switch (num20)
				{
				case 1:
				{
					float da = array[num11 - 2];
					array[num11 - 2] = 0f;
					for (int num31 = i; num31 < num11 - 1; num31++)
					{
						int num30 = num11 - 2 - num31 + i;
						float da2 = vector[num30];
						Drotg(ref da2, ref da, out c, out s);
						vector[num30] = da2;
						if (num30 != i)
						{
							da = (0f - s) * array[num30 - 1];
							array[num30 - 1] = c * array[num30 - 1];
						}
						if (computeVectors)
						{
							Drot(matrix4, matrix2.ColumnCount, num30, num11 - 1, c, s);
						}
					}
					break;
				}
				case 2:
				{
					float da = array[i - 1];
					array[i - 1] = 0f;
					for (int num30 = i; num30 < num11; num30++)
					{
						float da2 = vector[num30];
						Drotg(ref da2, ref da, out c, out s);
						vector[num30] = da2;
						da = (0f - s) * array[num30];
						array[num30] = c * array[num30];
						if (computeVectors)
						{
							Drot(matrix3, matrix2.RowCount, num30, i - 1, c, s);
						}
					}
					break;
				}
				case 3:
				{
					float val = 0f;
					val = Math.Max(val, Math.Abs(vector[num11 - 1]));
					val = Math.Max(val, Math.Abs(vector[num11 - 2]));
					val = Math.Max(val, Math.Abs(array[num11 - 2]));
					val = Math.Max(val, Math.Abs(vector[i]));
					val = Math.Max(val, Math.Abs(array[i]));
					float num22 = vector[num11 - 1] / val;
					float num23 = vector[num11 - 2] / val;
					float num24 = array[num11 - 2] / val;
					float num25 = vector[i] / val;
					float num26 = array[i] / val;
					float num27 = ((num23 + num22) * (num23 - num22) + num24 * num24) / 2f;
					float num28 = num22 * num24 * (num22 * num24);
					float num29 = 0f;
					if ((double)num27 != 0.0 || (double)num28 != 0.0)
					{
						num29 = (float)Math.Sqrt(num27 * num27 + num28);
						if ((double)num27 < 0.0)
						{
							num29 = 0f - num29;
						}
						num29 = num28 / (num27 + num29);
					}
					float da = (num25 + num22) * (num25 - num22) + num29;
					float db = num25 * num26;
					for (int num30 = i; num30 < num11 - 1; num30++)
					{
						Drotg(ref da, ref db, out c, out s);
						if (num30 != i)
						{
							array[num30 - 1] = da;
						}
						da = c * vector[num30] + s * array[num30];
						array[num30] = c * array[num30] - s * vector[num30];
						db = s * vector[num30 + 1];
						vector[num30 + 1] = c * vector[num30 + 1];
						if (computeVectors)
						{
							Drot(matrix4, matrix2.ColumnCount, num30, num30 + 1, c, s);
						}
						Drotg(ref da, ref db, out c, out s);
						vector[num30] = da;
						da = c * array[num30] + s * vector[num30 + 1];
						vector[num30 + 1] = (0f - s) * array[num30] + c * vector[num30 + 1];
						db = s * array[num30 + 1];
						array[num30 + 1] = c * array[num30 + 1];
						if (computeVectors && num30 < matrix2.RowCount)
						{
							Drot(matrix3, matrix2.RowCount, num30, num30 + 1, c, s);
						}
					}
					array[num11 - 2] = da;
					num18++;
					break;
				}
				case 4:
					if ((double)vector[i] < 0.0)
					{
						vector[i] = 0f - vector[i];
						if (computeVectors)
						{
							DscalColumn(matrix4, matrix2.ColumnCount, i, 0, -1f);
						}
					}
					for (; i != num17 - 1 && !(vector[i] >= vector[i + 1]); i++)
					{
						float num8 = vector[i];
						vector[i] = vector[i + 1];
						vector[i + 1] = num8;
						if (computeVectors && i < matrix2.ColumnCount)
						{
							Dswap(matrix4, matrix2.ColumnCount, i, i + 1);
						}
						if (computeVectors && i < matrix2.RowCount)
						{
							Dswap(matrix3, matrix2.RowCount, i, i + 1);
						}
					}
					num18 = 0;
					num11--;
					break;
				}
			}
			if (computeVectors)
			{
				matrix4 = matrix4.Transpose();
			}
			if (matrix2.RowCount < matrix2.ColumnCount)
			{
				num--;
				Vector<float> vector2 = Vector<float>.Build.SameAs(matrix2, num);
				for (int l = 0; l < num; l++)
				{
					vector2[l] = vector[l];
				}
				vector = vector2;
			}
			return new UserSvd(vector, matrix3, matrix4, computeVectors);
		}

		private UserSvd(Vector<float> s, Matrix<float> u, Matrix<float> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		private static float Dsign(float z1, float z2)
		{
			return Math.Abs(z1) * (z2 / Math.Abs(z2));
		}

		private static void Dswap(Matrix<float> a, int rowCount, int columnA, int columnB)
		{
			for (int i = 0; i < rowCount; i++)
			{
				float value = a.At(i, columnA);
				a.At(i, columnA, a.At(i, columnB));
				a.At(i, columnB, value);
			}
		}

		private static void DscalColumn(Matrix<float> a, int rowCount, int column, int rowStart, float z)
		{
			for (int i = rowStart; i < rowCount; i++)
			{
				a.At(i, column, a.At(i, column) * z);
			}
		}

		private static void DscalVector(float[] a, int start, float z)
		{
			for (int i = start; i < a.Length; i++)
			{
				a[i] *= z;
			}
		}

		private static void Drotg(ref float da, ref float db, out float c, out float s)
		{
			float num = db;
			float num2 = Math.Abs(da);
			float num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			float num4 = num2 + num3;
			float num5;
			float num6;
			if ((double)num4 == 0.0)
			{
				c = 1f;
				s = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				float num7 = da / num4;
				float num8 = db / num4;
				num5 = num4 * (float)Math.Sqrt(num7 * num7 + num8 * num8);
				if ((double)num < 0.0)
				{
					num5 = 0f - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1f;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && (double)c != 0.0)
				{
					num6 = 1f / c;
				}
			}
			da = num5;
			db = num6;
		}

		private static float Dnrm2Column(Matrix<float> a, int rowCount, int column, int rowStart)
		{
			float num = 0f;
			for (int i = rowStart; i < rowCount; i++)
			{
				num += a.At(i, column) * a.At(i, column);
			}
			return (float)Math.Sqrt(num);
		}

		private static float Dnrm2Vector(float[] a, int rowStart)
		{
			float num = 0f;
			for (int i = rowStart; i < a.Length; i++)
			{
				num += a[i] * a[i];
			}
			return (float)Math.Sqrt(num);
		}

		private static float Ddot(Matrix<float> a, int rowCount, int columnA, int columnB, int rowStart)
		{
			float num = 0f;
			for (int i = rowStart; i < rowCount; i++)
			{
				num += a.At(i, columnB) * a.At(i, columnA);
			}
			return num;
		}

		private static void Drot(Matrix<float> a, int rowCount, int columnA, int columnB, float c, float s)
		{
			for (int i = 0; i < rowCount; i++)
			{
				float value = c * a.At(i, columnA) + s * a.At(i, columnB);
				float value2 = c * a.At(i, columnB) - s * a.At(i, columnA);
				a.At(i, columnB, value2);
				a.At(i, columnA, value);
			}
		}

		public override void Solve(Matrix<float> input, Matrix<float> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			int columnCount = input.ColumnCount;
			float[] array = new float[base.VT.ColumnCount];
			for (int i = 0; i < columnCount; i++)
			{
				for (int j = 0; j < base.VT.ColumnCount; j++)
				{
					float num2 = 0f;
					if (j < num)
					{
						for (int k = 0; k < base.U.RowCount; k++)
						{
							num2 += base.U.At(k, j) * input.At(k, i);
						}
						num2 /= base.S[j];
					}
					array[j] = num2;
				}
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					float num3 = 0f;
					for (int m = 0; m < base.VT.ColumnCount; m++)
					{
						num3 += base.VT.At(m, l) * array[m];
					}
					result.At(l, i, num3);
				}
			}
		}

		public override void Solve(Vector<float> input, Vector<float> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<float>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			float[] array = new float[base.VT.ColumnCount];
			for (int i = 0; i < base.VT.ColumnCount; i++)
			{
				float num2 = 0f;
				if (i < num)
				{
					for (int j = 0; j < base.U.RowCount; j++)
					{
						num2 += base.U.At(j, i) * input[j];
					}
					num2 /= base.S[i];
				}
				array[i] = num2;
			}
			for (int k = 0; k < base.VT.ColumnCount; k++)
			{
				float num2 = 0f;
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					num2 += base.VT.At(l, k) * array[l];
				}
				result[k] = num2;
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Double
{
	internal class MatrixBuilder : MatrixBuilder<double>
	{
		public override double Zero => 0.0;

		public override double One => 1.0;

		public override Matrix<double> Dense(DenseColumnMajorMatrixStorage<double> storage)
		{
			return new DenseMatrix(storage);
		}

		public override Matrix<double> Sparse(SparseCompressedRowMatrixStorage<double> storage)
		{
			return new SparseMatrix(storage);
		}

		public override Matrix<double> Diagonal(DiagonalMatrixStorage<double> storage)
		{
			return new DiagonalMatrix(storage);
		}

		public override Matrix<double> Random(int rows, int columns, IContinuousDistribution distribution)
		{
			return Dense(rows, columns, Generate.Random(rows * columns, distribution));
		}

		public override IIterationStopCriterion<double>[] IterativeSolverStopCriteria(int maxIterations = 1000)
		{
			return new IIterationStopCriterion<double>[4]
			{
				new FailureStopCriterion<double>(),
				new DivergenceStopCriterion<double>(),
				new IterationCountStopCriterion<double>(maxIterations),
				new ResidualStopCriterion<double>(1E-12)
			};
		}

		internal override double Add(double x, double y)
		{
			return x + y;
		}
	}
	internal class VectorBuilder : VectorBuilder<double>
	{
		public override double Zero => 0.0;

		public override double One => 1.0;

		public override Vector<double> Dense(DenseVectorStorage<double> storage)
		{
			return new DenseVector(storage);
		}

		public override Vector<double> Sparse(SparseVectorStorage<double> storage)
		{
			return new SparseVector(storage);
		}

		public override Vector<double> Random(int length, IContinuousDistribution distribution)
		{
			return Dense(Generate.Random(length, distribution));
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseMatrix {RowCount}x{ColumnCount}-Double")]
	public class DenseMatrix : Matrix
	{
		private readonly int _rowCount;

		private readonly int _columnCount;

		private readonly double[] _values;

		public double[] Values => _values;

		public DenseMatrix(DenseColumnMajorMatrixStorage<double> storage)
			: base(storage)
		{
			_rowCount = storage.RowCount;
			_columnCount = storage.ColumnCount;
			_values = storage.Data;
		}

		public DenseMatrix(int order)
			: this(new DenseColumnMajorMatrixStorage<double>(order, order))
		{
		}

		public DenseMatrix(int rows, int columns)
			: this(new DenseColumnMajorMatrixStorage<double>(rows, columns))
		{
		}

		public DenseMatrix(int rows, int columns, double[] storage)
			: this(new DenseColumnMajorMatrixStorage<double>(rows, columns, storage))
		{
		}

		public static DenseMatrix OfMatrix(Matrix<double> matrix)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfMatrix(matrix.Storage));
		}

		public static DenseMatrix OfArray(double[,] array)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfArray(array));
		}

		public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, double>> enumerable)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable<double> columnMajor)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfColumnMajorEnumerable(rows, columns, columnMajor));
		}

		public static DenseMatrix OfColumns(IEnumerable<IEnumerable<double>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<double> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<double>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfColumnEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfColumnArrays(params double[][] columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfColumnArrays(columns));
		}

		public static DenseMatrix OfColumnArrays(IEnumerable<double[]> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfColumnArrays((columns as double[][]) ?? columns.ToArray()));
		}

		public static DenseMatrix OfColumnVectors(params Vector<double>[] columns)
		{
			VectorStorage<double>[] array = new VectorStorage<double>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfColumnVectors(array));
		}

		public static DenseMatrix OfColumnVectors(IEnumerable<Vector<double>> columns)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfColumnVectors(columns.Select((Vector<double> c) => c.Storage).ToArray()));
		}

		public static DenseMatrix OfRows(IEnumerable<IEnumerable<double>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<double> v) => v.ToArray()).ToArray());
		}

		public static DenseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<double>> data)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfRowEnumerables(rows, columns, data));
		}

		public static DenseMatrix OfRowArrays(params double[][] rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfRowArrays(rows));
		}

		public static DenseMatrix OfRowArrays(IEnumerable<double[]> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfRowArrays((rows as double[][]) ?? rows.ToArray()));
		}

		public static DenseMatrix OfRowVectors(params Vector<double>[] rows)
		{
			VectorStorage<double>[] array = new VectorStorage<double>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfRowVectors(array));
		}

		public static DenseMatrix OfRowVectors(IEnumerable<Vector<double>> rows)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfRowVectors(rows.Select((Vector<double> r) => r.Storage).ToArray()));
		}

		public static DenseMatrix OfDiagonalVector(Vector<double> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Count, diagonal.Count);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector<double> diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(double[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(diagonal.Length, diagonal.Length);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix OfDiagonalArray(int rows, int columns, double[] diagonal)
		{
			DenseMatrix denseMatrix = new DenseMatrix(rows, columns);
			denseMatrix.SetDiagonal(diagonal);
			return denseMatrix;
		}

		public static DenseMatrix Create(int rows, int columns, double value)
		{
			if (value == 0.0)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfValue(rows, columns, value));
		}

		public static DenseMatrix Create(int rows, int columns, Func<int, int, double> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfInit(rows, columns, init));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, double value)
		{
			if (value == 0.0)
			{
				return new DenseMatrix(rows, columns);
			}
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static DenseMatrix CreateDiagonal(int rows, int columns, Func<int, double> init)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfDiagonalInit(rows, columns, init));
		}

		public static DenseMatrix CreateIdentity(int order)
		{
			return new DenseMatrix(DenseColumnMajorMatrixStorage<double>.OfDiagonalInit(order, order, (int i) => Matrix<double>.One));
		}

		public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DenseMatrix(new DenseColumnMajorMatrixStorage<double>(rows, columns, Generate.Random(rows * columns, distribution)));
		}

		public override double L1Norm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.OneNorm, _rowCount, _columnCount, _values);
		}

		public override double InfinityNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.InfinityNorm, _rowCount, _columnCount, _values);
		}

		public override double FrobeniusNorm()
		{
			return LinearAlgebraControl.Provider.MatrixNorm(Norm.FrobeniusNorm, _rowCount, _columnCount, _values);
		}

		protected override void DoNegate(Matrix<double> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1.0, _values, denseMatrix._values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoAdd(double scalar, Matrix<double> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					double[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Matrix<double> other, Matrix<double> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<double> diagonalMatrixStorage)
			{
				base.Storage.CopyToUnchecked(result.Storage, ExistingData.Clear);
				double[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) + data[i]);
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(double scalar, Matrix<double> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					double[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Matrix<double> other, Matrix<double> result)
		{
			if (other.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage && result.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseColumnMajorMatrixStorage.Data, denseColumnMajorMatrixStorage2.Data);
			}
			else if (other.Storage is DiagonalMatrixStorage<double> diagonalMatrixStorage)
			{
				CopyTo(result);
				double[] data = diagonalMatrixStorage.Data;
				for (int i = 0; i < data.Length; i++)
				{
					result.At(i, i, result.At(i, i) - data[i]);
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(double scalar, Matrix<double> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseMatrix._values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<double> rightSide, Vector<double> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, denseVector2.Values);
			}
			else
			{
				base.DoMultiply(rightSide, result);
			}
		}

		protected override void DoMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiply(_values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<double> diagonalMatrixStorage)
			{
				double[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.ColumnCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoMultiply(other, result);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, 1.0, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0.0, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<double> diagonalMatrixStorage)
			{
				double[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.ColumnCount, other.RowCount);
				if (num < other.RowCount)
				{
					result.ClearSubMatrix(0, base.RowCount, base.ColumnCount, other.RowCount - base.ColumnCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < base.RowCount; j++)
					{
						result.At(j, i, _values[num2] * data[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<double> rightSide, Vector<double> result)
		{
			if (rightSide is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1.0, _values, _rowCount, _columnCount, denseVector.Values, denseVector.Count, 1, 0.0, denseVector2.Values);
			}
			else
			{
				base.DoTransposeThisAndMultiply(rightSide, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.MatrixMultiplyWithUpdate(MathNet.Numerics.Providers.LinearAlgebra.Transpose.Transpose, MathNet.Numerics.Providers.LinearAlgebra.Transpose.DontTranspose, 1.0, _values, _rowCount, _columnCount, denseMatrix._values, denseMatrix._rowCount, denseMatrix._columnCount, 0.0, denseMatrix2._values);
			}
			else if (other.Storage is DiagonalMatrixStorage<double> diagonalMatrixStorage)
			{
				double[] data = diagonalMatrixStorage.Data;
				int num = Math.Min(base.RowCount, other.ColumnCount);
				if (num < other.ColumnCount)
				{
					result.ClearSubMatrix(0, base.ColumnCount, base.RowCount, other.ColumnCount - base.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < base.ColumnCount; i++)
				{
					for (int j = 0; j < num; j++)
					{
						result.At(i, j, _values[num2] * data[j]);
						num2++;
					}
					num2 += base.RowCount - num;
				}
			}
			else
			{
				base.DoTransposeThisAndMultiply(other, result);
			}
		}

		protected override void DoDivide(double divisor, Matrix<double> result)
		{
			if (result is DenseMatrix denseMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1.0 / divisor, _values, denseMatrix._values);
			}
			else
			{
				base.DoDivide(divisor, result);
			}
		}

		protected override void DoPointwiseMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Matrix<double> divisor, Matrix<double> result)
		{
			if (divisor is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Matrix<double> exponent, Matrix<double> result)
		{
			if (exponent is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseMatrix._values, denseMatrix2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		protected override void DoModulus(double divisor, Matrix<double> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				CommonParallel.For(0, _values.Length, delegate(int a, int b)
				{
					double[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = Euclid.Modulus(values[i], divisor);
					}
				});
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoModulusByThis(double dividend, Matrix<double> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					double[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = Euclid.Modulus(dividend, _values[i]);
					}
				});
			}
			else
			{
				base.DoModulusByThis(dividend, result);
			}
		}

		protected override void DoRemainder(double divisor, Matrix<double> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				CommonParallel.For(0, _values.Length, delegate(int a, int b)
				{
					double[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] %= divisor;
					}
				});
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		protected override void DoRemainderByThis(double dividend, Matrix<double> result)
		{
			DenseMatrix denseResult = result as DenseMatrix;
			if (denseResult != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					double[] values = denseResult._values;
					for (int i = a; i < b; i++)
					{
						values[i] = dividend % _values[i];
					}
				});
			}
			else
			{
				base.DoRemainderByThis(dividend, result);
			}
		}

		public override double Trace()
		{
			if (_rowCount != _columnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			double num = 0.0;
			for (int i = 0; i < _rowCount; i++)
			{
				num += _values[i * _rowCount + i];
			}
			return num;
		}

		public static DenseMatrix operator +(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Add(rightSide);
		}

		public static DenseMatrix operator +(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Clone();
		}

		public static DenseMatrix operator -(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide._rowCount != rightSide._rowCount || leftSide._columnCount != rightSide._columnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Subtract(rightSide);
		}

		public static DenseMatrix operator -(DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Negate();
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseMatrix operator *(double leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseMatrix)rightSide.Multiply(leftSide);
		}

		public static DenseMatrix operator *(DenseMatrix leftSide, DenseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide._columnCount != rightSide._rowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (DenseMatrix)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseMatrix leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(DenseVector leftSide, DenseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.LeftMultiply(leftSide);
		}

		public static DenseMatrix operator %(DenseMatrix leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseMatrix)leftSide.Remainder(rightSide);
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < base.ColumnCount; i++)
			{
				int num = i * base.RowCount;
				for (int j = i + 1; j < base.RowCount; j++)
				{
					if (_values[j * base.ColumnCount + i] != _values[num + j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public override Cholesky<double> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseCholesky.Create(this);
		}

		public override LU<double> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU.Create(this);
		}

		public override QR<double> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseQR.Create(this, method);
		}

		public override GramSchmidt<double> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseGramSchmidt.Create(this);
		}

		public override Svd<double> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd.Create(this, computeVectors);
		}

		public override Evd<double> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("DenseVector {Count}-Double")]
	public class DenseVector : Vector
	{
		private readonly int _length;

		private readonly double[] _values;

		public double[] Values => _values;

		public DenseVector(DenseVectorStorage<double> storage)
			: base(storage)
		{
			_length = storage.Length;
			_values = storage.Data;
		}

		public DenseVector(int length)
			: this(new DenseVectorStorage<double>(length))
		{
		}

		public DenseVector(double[] storage)
			: this(new DenseVectorStorage<double>(storage.Length, storage))
		{
		}

		public static DenseVector OfVector(Vector<double> vector)
		{
			return new DenseVector(DenseVectorStorage<double>.OfVector(vector.Storage));
		}

		public static DenseVector OfArray(double[] array)
		{
			return new DenseVector(DenseVectorStorage<double>.OfVector(new DenseVectorStorage<double>(array.Length, array)));
		}

		public static DenseVector OfEnumerable(IEnumerable<double> enumerable)
		{
			return new DenseVector(DenseVectorStorage<double>.OfEnumerable(enumerable));
		}

		public static DenseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, double>> enumerable)
		{
			return new DenseVector(DenseVectorStorage<double>.OfIndexedEnumerable(length, enumerable));
		}

		public static DenseVector Create(int length, double value)
		{
			if (value == 0.0)
			{
				return new DenseVector(length);
			}
			return new DenseVector(DenseVectorStorage<double>.OfValue(length, value));
		}

		public static DenseVector Create(int length, Func<int, double> init)
		{
			return new DenseVector(DenseVectorStorage<double>.OfInit(length, init));
		}

		public static DenseVector CreateRandom(int length, IContinuousDistribution distribution)
		{
			double[] data = Generate.Random(length, distribution);
			return new DenseVector(new DenseVectorStorage<double>(length, data));
		}

		public static explicit operator double[](DenseVector vector)
		{
			if (vector == null)
			{
				throw new ArgumentNullException("vector");
			}
			return vector.Values;
		}

		public static implicit operator DenseVector(double[] array)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			return new DenseVector(array);
		}

		protected override void DoAdd(double scalar, Vector<double> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] + scalar;
					}
				});
			}
			else
			{
				base.DoAdd(scalar, result);
			}
		}

		protected override void DoAdd(Vector<double> other, Vector<double> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.AddArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		public static DenseVector operator +(DenseVector leftSide, DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.Count != rightSide.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rightSide");
			}
			return (DenseVector)leftSide.Add(rightSide);
		}

		protected override void DoSubtract(double scalar, Vector<double> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _values.Length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] - scalar;
					}
				});
			}
			else
			{
				base.DoSubtract(scalar, result);
			}
		}

		protected override void DoSubtract(Vector<double> other, Vector<double> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		public static DenseVector operator -(DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Negate();
		}

		public static DenseVector operator -(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Subtract(rightSide);
		}

		protected override void DoNegate(Vector<double> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1.0, _values, denseVector.Values);
			}
			else
			{
				base.DoNegate(result);
			}
		}

		protected override void DoMultiply(double scalar, Vector<double> result)
		{
			if (result is DenseVector denseVector)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _values, denseVector.Values);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override double DoDotProduct(Vector<double> other)
		{
			if (!(other is DenseVector denseVector))
			{
				return base.DoDotProduct(other);
			}
			return LinearAlgebraControl.Provider.DotProduct(_values, denseVector.Values);
		}

		public static DenseVector operator *(DenseVector leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Multiply(rightSide);
		}

		public static DenseVector operator *(double leftSide, DenseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (DenseVector)rightSide.Multiply(leftSide);
		}

		public static double operator *(DenseVector leftSide, DenseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static DenseVector operator /(DenseVector leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Divide(rightSide);
		}

		protected override void DoModulus(double divisor, Vector<double> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = Euclid.Modulus(_values[i], divisor);
					}
				});
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoRemainder(double divisor, Vector<double> result)
		{
			DenseVector dense = result as DenseVector;
			if (dense != null)
			{
				CommonParallel.For(0, _length, 4096, delegate(int a, int b)
				{
					for (int i = a; i < b; i++)
					{
						dense._values[i] = _values[i] % divisor;
					}
				});
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		public static DenseVector operator %(DenseVector leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (DenseVector)leftSide.Remainder(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			double num2 = Math.Abs(_values[num]);
			for (int i = 1; i < _length; i++)
			{
				double num3 = Math.Abs(_values[i]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			double num2 = Math.Abs(_values[num]);
			for (int i = 1; i < _length; i++)
			{
				double num3 = Math.Abs(_values[i]);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override int MaximumIndex()
		{
			int result = 0;
			double num = _values[0];
			for (int i = 1; i < _length; i++)
			{
				if (num < _values[i])
				{
					result = i;
					num = _values[i];
				}
			}
			return result;
		}

		public override int MinimumIndex()
		{
			int result = 0;
			double num = _values[0];
			for (int i = 1; i < _length; i++)
			{
				if (num > _values[i])
				{
					result = i;
					num = _values[i];
				}
			}
			return result;
		}

		public override double Sum()
		{
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += _values[i];
			}
			return num;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += Math.Abs(_values[i]);
			}
			return num;
		}

		public override double L2Norm()
		{
			return _values.Aggregate(0.0, SpecialFunctions.Hypotenuse);
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(_values, (int i, double v) => Math.Abs(v), Math.Max, 0.0);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _length; i++)
			{
				num += Math.Pow(Math.Abs(_values[i]), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<double> other, Vector<double> result)
		{
			if (other is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		protected override void DoPointwiseDivide(Vector<double> divisor, Vector<double> result)
		{
			if (divisor is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWiseDivideArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwiseDivide(divisor, result);
			}
		}

		protected override void DoPointwisePower(Vector<double> exponent, Vector<double> result)
		{
			if (exponent is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.PointWisePowerArrays(_values, denseVector._values, denseVector2._values);
			}
			else
			{
				base.DoPointwisePower(exponent, result);
			}
		}

		public static DenseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			double[] array = (from t in value.Split(new string[3]
				{
					formatProvider.GetTextInfo().ListSeparator,
					" ",
					"\t"
				}, StringSplitOptions.RemoveEmptyEntries)
				select double.Parse(t, NumberStyles.Any, formatProvider)).ToArray();
			if (array.Length == 0)
			{
				throw new FormatException();
			}
			return new DenseVector(array);
		}

		public static bool TryParse(string value, out DenseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out DenseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}
	}
	[Serializable]
	[DebuggerDisplay("DiagonalMatrix {RowCount}x{ColumnCount}-Double")]
	public class DiagonalMatrix : Matrix
	{
		private readonly double[] _data;

		public DiagonalMatrix(DiagonalMatrixStorage<double> storage)
			: base(storage)
		{
			_data = storage.Data;
		}

		public DiagonalMatrix(int order)
			: this(new DiagonalMatrixStorage<double>(order, order))
		{
		}

		public DiagonalMatrix(int rows, int columns)
			: this(new DiagonalMatrixStorage<double>(rows, columns))
		{
		}

		public DiagonalMatrix(int rows, int columns, double diagonalValue)
			: this(rows, columns)
		{
			for (int i = 0; i < _data.Length; i++)
			{
				_data[i] = diagonalValue;
			}
		}

		public DiagonalMatrix(int rows, int columns, double[] diagonalStorage)
			: this(new DiagonalMatrixStorage<double>(rows, columns, diagonalStorage))
		{
		}

		public static DiagonalMatrix OfMatrix(Matrix<double> matrix)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<double>.OfMatrix(matrix.Storage));
		}

		public static DiagonalMatrix OfArray(double[,] array)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<double>.OfArray(array));
		}

		public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable<Tuple<int, double>> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<double>.OfIndexedEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable<double> diagonal)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<double>.OfEnumerable(rows, columns, diagonal));
		}

		public static DiagonalMatrix Create(int rows, int columns, Func<int, double> init)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<double>.OfInit(rows, columns, init));
		}

		public static DiagonalMatrix CreateIdentity(int order)
		{
			return new DiagonalMatrix(DiagonalMatrixStorage<double>.OfValue(order, order, Matrix<double>.One));
		}

		public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution)
		{
			return new DiagonalMatrix(new DiagonalMatrixStorage<double>(rows, columns, Generate.Random(Math.Min(rows, columns), distribution)));
		}

		protected override void DoNegate(Matrix<double> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(-1.0, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, 0.0 - _data[i]);
			}
		}

		protected override void DoAdd(Matrix<double> other, Matrix<double> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.AddArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.CopyTo(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoSubtract(Matrix<double> other, Matrix<double> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				LinearAlgebraControl.Provider.SubtractArrays(_data, diagonalMatrix._data, diagonalMatrix2._data);
				return;
			}
			other.Negate(result);
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, result.At(i, i) + _data[i]);
			}
		}

		protected override void DoMultiply(double scalar, Matrix<double> result)
		{
			if (scalar == 0.0)
			{
				result.Clear();
			}
			else if (scalar == 1.0)
			{
				CopyTo(result);
			}
			else if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(scalar, _data, diagonalMatrix._data);
			}
			else
			{
				base.DoMultiply(scalar, result);
			}
		}

		protected override void DoMultiply(Vector<double> rightSide, Vector<double> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.RowCount)
			{
				result.ClearSubVector(base.ColumnCount, base.RowCount - base.ColumnCount);
			}
			if (num == base.ColumnCount && rightSide.Storage is DenseVectorStorage<double> denseVectorStorage && result.Storage is DenseVectorStorage<double> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				double[] array = new double[diagonalMatrix2._data.Length];
				double[] array2 = new double[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage)
			{
				double[] data = denseColumnMajorMatrixStorage.Data;
				double[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.RowCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, double x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, double x) => x * _data[i], 0, 0, Math.Min(base.RowCount, other.RowCount), 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				double[] array = new double[diagonalMatrix2._data.Length];
				double[] array2 = new double[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage)
			{
				double[] data = denseColumnMajorMatrixStorage.Data;
				double[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount);
				if (num < base.RowCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.ColumnCount, base.RowCount - denseColumnMajorMatrixStorage.ColumnCount, 0, denseColumnMajorMatrixStorage.RowCount);
				}
				int num2 = 0;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < denseColumnMajorMatrixStorage.RowCount; j++)
					{
						result.At(i, j, data[num2] * data2[i]);
						num2++;
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is DiagonalMatrix diagonalMatrix && result is DiagonalMatrix diagonalMatrix2)
			{
				double[] array = new double[diagonalMatrix2._data.Length];
				double[] array2 = new double[diagonalMatrix2._data.Length];
				Array.Copy(_data, 0, array, 0, (diagonalMatrix2._data.Length > _data.Length) ? _data.Length : diagonalMatrix2._data.Length);
				Array.Copy(diagonalMatrix._data, 0, array2, 0, (diagonalMatrix2._data.Length > diagonalMatrix._data.Length) ? diagonalMatrix._data.Length : diagonalMatrix2._data.Length);
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(array, array2, diagonalMatrix2._data);
			}
			else if (other.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage)
			{
				double[] data = denseColumnMajorMatrixStorage.Data;
				double[] data2 = _data;
				int num = Math.Min(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount);
				if (num < base.ColumnCount)
				{
					result.ClearSubMatrix(denseColumnMajorMatrixStorage.RowCount, base.ColumnCount - denseColumnMajorMatrixStorage.RowCount, 0, denseColumnMajorMatrixStorage.ColumnCount);
				}
				int num2 = 0;
				for (int k = 0; k < denseColumnMajorMatrixStorage.ColumnCount; k++)
				{
					for (int l = 0; l < num; l++)
					{
						result.At(l, k, data[num2] * data2[l]);
						num2++;
					}
					num2 += denseColumnMajorMatrixStorage.RowCount - num;
				}
			}
			else if (base.ColumnCount == base.RowCount)
			{
				other.Storage.MapIndexedTo(result.Storage, (int i, int j, double x) => x * _data[i], Zeros.AllowSkip, ExistingData.Clear);
			}
			else
			{
				result.Clear();
				other.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, double x) => x * _data[i], 0, 0, other.RowCount, 0, 0, other.ColumnCount, Zeros.AllowSkip, ExistingData.AssumeZeros);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<double> rightSide, Vector<double> result)
		{
			int num = Math.Min(base.ColumnCount, base.RowCount);
			if (num < base.ColumnCount)
			{
				result.ClearSubVector(base.RowCount, base.ColumnCount - base.RowCount);
			}
			if (num == base.RowCount && rightSide.Storage is DenseVectorStorage<double> denseVectorStorage && result.Storage is DenseVectorStorage<double> denseVectorStorage2)
			{
				LinearAlgebraControl.Provider.PointWiseMultiplyArrays(_data, denseVectorStorage.Data, denseVectorStorage2.Data);
				return;
			}
			for (int i = 0; i < num; i++)
			{
				result.At(i, _data[i] * rightSide.At(i));
			}
		}

		protected override void DoDivide(double divisor, Matrix<double> result)
		{
			if (divisor == 1.0)
			{
				CopyTo(result);
				return;
			}
			if (result is DiagonalMatrix diagonalMatrix)
			{
				LinearAlgebraControl.Provider.ScaleArray(1.0 / divisor, _data, diagonalMatrix._data);
				return;
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i] / divisor);
			}
		}

		protected override void DoDivideByThis(double dividend, Matrix<double> result)
		{
			if (result is DiagonalMatrix diagonalMatrix)
			{
				double[] resultData = diagonalMatrix._data;
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						resultData[j] = dividend / _data[j];
					}
				});
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, dividend / _data[i]);
				}
			}
		}

		public override double Determinant()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			return _data.Aggregate(1.0, (double current, double t) => current * t);
		}

		public override Vector<double> Diagonal()
		{
			return new DenseVector(_data).Clone();
		}

		public override void SetDiagonal(double[] source)
		{
			if (source.Length != _data.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.", "source");
			}
			Buffer.BlockCopy(source, 0, _data, 0, source.Length * 8);
		}

		public override void SetDiagonal(Vector<double> source)
		{
			if (source is DenseVector denseVector)
			{
				if (_data.Length != denseVector.Values.Length)
				{
					throw new ArgumentException("All vectors must have the same dimensionality.", "source");
				}
				Buffer.BlockCopy(denseVector.Values, 0, _data, 0, denseVector.Values.Length * 8);
			}
			else
			{
				base.SetDiagonal(source);
			}
		}

		public override double L1Norm()
		{
			return _data.Aggregate(0.0, (double current, double t) => Math.Max(current, Math.Abs(t)));
		}

		public override double L2Norm()
		{
			return _data.Aggregate(0.0, (double current, double t) => Math.Max(current, Math.Abs(t)));
		}

		public override double InfinityNorm()
		{
			return L1Norm();
		}

		public override double FrobeniusNorm()
		{
			return Math.Sqrt(_data.Sum((double t) => t * t));
		}

		public override double ConditionNumber()
		{
			double num = double.NegativeInfinity;
			double num2 = double.PositiveInfinity;
			double[] data = _data;
			foreach (double value in data)
			{
				num = Math.Max(num, Math.Abs(value));
				num2 = Math.Min(num2, Math.Abs(value));
			}
			return num / num2;
		}

		public override Matrix<double> Inverse()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DiagonalMatrix diagonalMatrix = (DiagonalMatrix)Clone();
			for (int i = 0; i < _data.Length; i++)
			{
				if (_data[i] != 0.0)
				{
					diagonalMatrix._data[i] = 1.0 / _data[i];
					continue;
				}
				throw new ArgumentException("Matrix must not be singular.");
			}
			return diagonalMatrix;
		}

		public override Matrix<double> LowerTriangle()
		{
			return Clone();
		}

		public override void LowerTriangle(Matrix<double> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this != result)
			{
				result.Clear();
				for (int i = 0; i < _data.Length; i++)
				{
					result.At(i, i, _data[i]);
				}
			}
		}

		public override Matrix<double> StrictlyLowerTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyLowerTriangle(Matrix<double> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<double> UpperTriangle()
		{
			return Clone();
		}

		public override void UpperTriangle(Matrix<double> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
			for (int i = 0; i < _data.Length; i++)
			{
				result.At(i, i, _data[i]);
			}
		}

		public override Matrix<double> StrictlyUpperTriangle()
		{
			return new DiagonalMatrix(base.RowCount, base.ColumnCount);
		}

		public override void StrictlyUpperTriangle(Matrix<double> result)
		{
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			result.Clear();
		}

		public override Matrix<double> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount)
		{
			Matrix<double> matrix = ((rowIndex == columnIndex) ? ((Matrix)new DiagonalMatrix(rowCount, columnCount)) : ((Matrix)new SparseMatrix(rowCount, columnCount)));
			base.Storage.CopySubMatrixTo(matrix.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, ExistingData.AssumeZeros);
			return matrix;
		}

		public override void PermuteColumns(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public override void PermuteRows(Permutation p)
		{
			throw new InvalidOperationException("Permutations in diagonal matrix are not allowed");
		}

		public sealed override bool IsSymmetric()
		{
			return true;
		}

		protected override void DoModulus(double divisor, Matrix<double> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					double[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = Euclid.Modulus(_data[i], divisor);
					}
				});
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoModulusByThis(double dividend, Matrix<double> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					double[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = Euclid.Modulus(dividend, _data[i]);
					}
				});
			}
			else
			{
				base.DoModulusByThis(dividend, result);
			}
		}

		protected override void DoRemainder(double divisor, Matrix<double> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					double[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = _data[i] % divisor;
					}
				});
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		protected override void DoRemainderByThis(double dividend, Matrix<double> result)
		{
			DiagonalMatrix diagonalResult = result as DiagonalMatrix;
			if (diagonalResult != null)
			{
				CommonParallel.For(0, _data.Length, 4096, delegate(int a, int b)
				{
					double[] data = diagonalResult._data;
					for (int i = a; i < b; i++)
					{
						data[i] = dividend % _data[i];
					}
				});
			}
			else
			{
				base.DoRemainderByThis(dividend, result);
			}
		}
	}
	[Serializable]
	public abstract class Matrix : Matrix<double>
	{
		protected Matrix(MatrixStorage<double> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((double x) => (!(Math.Abs(x) < threshold)) ? x : 0.0);
		}

		public sealed override Matrix<double> ConjugateTranspose()
		{
			return Transpose();
		}

		public sealed override void ConjugateTranspose(Matrix<double> result)
		{
			Transpose(result);
		}

		protected sealed override void DoConjugate(Matrix<double> result)
		{
			if (this != result)
			{
				CopyTo(result);
			}
		}

		protected override void DoNegate(Matrix<double> result)
		{
			Map((double x) => 0.0 - x, result);
		}

		protected override void DoAdd(double scalar, Matrix<double> result)
		{
			Map((double x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Matrix<double> other, Matrix<double> result)
		{
			Map2((double x, double y) => x + y, other, result);
		}

		protected override void DoSubtract(double scalar, Matrix<double> result)
		{
			Map((double x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Matrix<double> other, Matrix<double> result)
		{
			Map2((double x, double y) => x - y, other, result);
		}

		protected override void DoMultiply(double scalar, Matrix<double> result)
		{
			Map((double x) => x * scalar, result);
		}

		protected override void DoMultiply(Vector<double> rightSide, Vector<double> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				double num = 0.0;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					num += At(i, j) * rightSide[j];
				}
				result[i] = num;
			}
		}

		protected override void DoDivide(double divisor, Matrix<double> result)
		{
			Map((double x) => x / divisor, result, (divisor == 0.0) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(double dividend, Matrix<double> result)
		{
			Map((double x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoMultiply(Matrix<double> other, Matrix<double> result)
		{
			for (int i = 0; i < base.RowCount; i++)
			{
				for (int j = 0; j < other.ColumnCount; j++)
				{
					double num = 0.0;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						num += At(i, k) * other.At(k, j);
					}
					result.At(i, j, num);
				}
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			for (int i = 0; i < other.RowCount; i++)
			{
				for (int j = 0; j < base.RowCount; j++)
				{
					double num = 0.0;
					for (int k = 0; k < base.ColumnCount; k++)
					{
						num += At(j, k) * other.At(i, k);
					}
					result.At(j, i, num);
				}
			}
		}

		protected sealed override void DoConjugateTransposeAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			DoTransposeAndMultiply(other, result);
		}

		protected override void DoTransposeThisAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			for (int i = 0; i < other.ColumnCount; i++)
			{
				for (int j = 0; j < base.ColumnCount; j++)
				{
					double num = 0.0;
					for (int k = 0; k < base.RowCount; k++)
					{
						num += At(k, j) * other.At(k, i);
					}
					result.At(j, i, num);
				}
			}
		}

		protected sealed override void DoConjugateTransposeThisAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			DoTransposeThisAndMultiply(other, result);
		}

		protected override void DoTransposeThisAndMultiply(Vector<double> rightSide, Vector<double> result)
		{
			for (int i = 0; i < base.ColumnCount; i++)
			{
				double num = 0.0;
				for (int j = 0; j < base.RowCount; j++)
				{
					num += At(j, i) * rightSide[j];
				}
				result[i] = num;
			}
		}

		protected sealed override void DoConjugateTransposeThisAndMultiply(Vector<double> rightSide, Vector<double> result)
		{
			DoTransposeThisAndMultiply(rightSide, result);
		}

		protected override void DoModulus(double divisor, Matrix<double> result)
		{
			Map((double x) => Euclid.Modulus(x, divisor), result, Zeros.Include);
		}

		protected override void DoModulusByThis(double dividend, Matrix<double> result)
		{
			Map((double x) => Euclid.Modulus(dividend, x), result, Zeros.Include);
		}

		protected override void DoRemainder(double divisor, Matrix<double> result)
		{
			Map((double x) => Euclid.Remainder(x, divisor), result, Zeros.Include);
		}

		protected override void DoRemainderByThis(double dividend, Matrix<double> result)
		{
			Map((double x) => Euclid.Remainder(dividend, x), result, Zeros.Include);
		}

		protected override void DoPointwiseMultiply(Matrix<double> other, Matrix<double> result)
		{
			Map2((double x, double y) => x * y, other, result);
		}

		protected override void DoPointwiseDivide(Matrix<double> divisor, Matrix<double> result)
		{
			Map2((double x, double y) => x / y, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(double exponent, Matrix<double> result)
		{
			Map((double x) => Math.Pow(x, exponent), result, (!(exponent > 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwisePower(Matrix<double> exponent, Matrix<double> result)
		{
			Map2(Math.Pow, result, Zeros.Include);
		}

		protected override void DoPointwiseModulus(Matrix<double> divisor, Matrix<double> result)
		{
			Map2(Euclid.Modulus, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseRemainder(Matrix<double> divisor, Matrix<double> result)
		{
			Map2(Euclid.Remainder, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseExp(Matrix<double> result)
		{
			Map(Math.Exp, result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Matrix<double> result)
		{
			Map(Math.Log, result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Matrix<double> result)
		{
			Map(Math.Abs, result);
		}

		protected override void DoPointwiseAcos(Matrix<double> result)
		{
			Map(Math.Acos, result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Matrix<double> result)
		{
			Map(Math.Asin, result);
		}

		protected override void DoPointwiseAtan(Matrix<double> result)
		{
			Map(Math.Atan, result);
		}

		protected override void DoPointwiseAtan2(Matrix<double> other, Matrix<double> result)
		{
			Map2(Math.Atan2, other, result, Zeros.Include);
		}

		protected override void DoPointwiseCeiling(Matrix<double> result)
		{
			Map(Math.Ceiling, result);
		}

		protected override void DoPointwiseCos(Matrix<double> result)
		{
			Map(Math.Cos, result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Matrix<double> result)
		{
			Map(Math.Cosh, result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Matrix<double> result)
		{
			Map(Math.Floor, result);
		}

		protected override void DoPointwiseLog10(Matrix<double> result)
		{
			Map(Math.Log10, result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Matrix<double> result)
		{
			Map(Math.Round, result);
		}

		protected override void DoPointwiseSign(Matrix<double> result)
		{
			Map((double x) => Math.Sign(x), result);
		}

		protected override void DoPointwiseSin(Matrix<double> result)
		{
			Map(Math.Sin, result);
		}

		protected override void DoPointwiseSinh(Matrix<double> result)
		{
			Map(Math.Sinh, result);
		}

		protected override void DoPointwiseSqrt(Matrix<double> result)
		{
			Map(Math.Sqrt, result);
		}

		protected override void DoPointwiseTan(Matrix<double> result)
		{
			Map(Math.Tan, result);
		}

		protected override void DoPointwiseTanh(Matrix<double> result)
		{
			Map(Math.Tanh, result);
		}

		public override Matrix<double> PseudoInverse()
		{
			Svd<double> svd = Svd();
			Matrix<double> w = svd.W;
			Vector<double> s = svd.S;
			double num = (double)Math.Max(base.RowCount, base.ColumnCount) * svd.L2Norm * Precision.DoublePrecision;
			for (int i = 0; i < s.Count; i++)
			{
				s[i] = ((s[i] < num) ? 0.0 : (1.0 / s[i]));
			}
			w.SetDiagonal(s);
			return (svd.U * (w * svd.VT)).Transpose();
		}

		public override double Trace()
		{
			if (base.RowCount != base.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				num += At(i, i);
			}
			return num;
		}

		protected override void DoPointwiseMinimum(double scalar, Matrix<double> result)
		{
			Map((double x) => Math.Min(scalar, x), result, (!(scalar >= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseMaximum(double scalar, Matrix<double> result)
		{
			Map((double x) => Math.Max(scalar, x), result, (!(scalar <= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseAbsoluteMinimum(double scalar, Matrix<double> result)
		{
			double absolute = Math.Abs(scalar);
			Map((double x) => Math.Min(absolute, Math.Abs(x)), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(double scalar, Matrix<double> result)
		{
			double absolute = Math.Abs(scalar);
			Map((double x) => Math.Max(absolute, Math.Abs(x)), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Matrix<double> other, Matrix<double> result)
		{
			Map2(Math.Min, other, result);
		}

		protected override void DoPointwiseMaximum(Matrix<double> other, Matrix<double> result)
		{
			Map2(Math.Max, other, result);
		}

		protected override void DoPointwiseAbsoluteMinimum(Matrix<double> other, Matrix<double> result)
		{
			Map2((double x, double y) => Math.Min(Math.Abs(x), Math.Abs(y)), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Matrix<double> other, Matrix<double> result)
		{
			Map2((double x, double y) => Math.Max(Math.Abs(x), Math.Abs(y)), other, result);
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.ColumnCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.RowCount; j++)
				{
					num2 += Math.Abs(At(j, i));
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double InfinityNorm()
		{
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				double num2 = 0.0;
				for (int j = 0; j < base.ColumnCount; j++)
				{
					num2 += Math.Abs(At(i, j));
				}
				num = Math.Max(num, num2);
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			Matrix<double> matrix = Transpose();
			Matrix<double> matrix2 = this * matrix;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				num += matrix2.At(i, i);
			}
			return Math.Sqrt(num);
		}

		public override Vector<double> RowNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.RowCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, double x) => s + x * x, (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByRowUnchecked(array, (double s, double x) => s + Math.Abs(x), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByRowUnchecked(array, (double s, double x) => Math.Max(s, Math.Abs(x)), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByRowUnchecked(array, (double s, double x) => s + Math.Pow(Math.Abs(x), norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> ColumnNorms(double norm)
		{
			if (norm <= 0.0)
			{
				throw new ArgumentOutOfRangeException("norm", "Value must be positive.");
			}
			double[] array = new double[base.ColumnCount];
			if (norm == 2.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, double x) => s + x * x, (double x, int c) => Math.Sqrt(x), array, Zeros.AllowSkip);
			}
			else if (norm == 1.0)
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, double x) => s + Math.Abs(x), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else if (double.IsPositiveInfinity(norm))
			{
				base.Storage.FoldByColumnUnchecked(array, (double s, double x) => Math.Max(s, Math.Abs(x)), (double x, int c) => x, array, Zeros.AllowSkip);
			}
			else
			{
				double invnorm = 1.0 / norm;
				base.Storage.FoldByColumnUnchecked(array, (double s, double x) => s + Math.Pow(Math.Abs(x), norm), (double x, int c) => Math.Pow(x, invnorm), array, Zeros.AllowSkip);
			}
			return Vector<double>.Build.Dense(array);
		}

		public sealed override Matrix<double> NormalizeRows(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)RowNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<double> matrix = Matrix<double>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, double x) => norminv[i] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public sealed override Matrix<double> NormalizeColumns(double norm)
		{
			double[] norminv = ((DenseVectorStorage<double>)ColumnNorms(norm).Storage).Data;
			for (int k = 0; k < norminv.Length; k++)
			{
				norminv[k] = ((norminv[k] == 0.0) ? 1.0 : (1.0 / norminv[k]));
			}
			Matrix<double> matrix = Matrix<double>.Build.SameAs(this, base.RowCount, base.ColumnCount);
			base.Storage.MapIndexedTo(matrix.Storage, (int i, int j, double x) => norminv[j] * x, Zeros.AllowSkip, ExistingData.AssumeZeros);
			return matrix;
		}

		public override Vector<double> RowSums()
		{
			double[] array = new double[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (double s, double x) => s + x, (double x, int c) => x, array, Zeros.AllowSkip);
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> RowAbsoluteSums()
		{
			double[] array = new double[base.RowCount];
			base.Storage.FoldByRowUnchecked(array, (double s, double x) => s + Math.Abs(x), (double x, int c) => x, array, Zeros.AllowSkip);
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> ColumnSums()
		{
			double[] array = new double[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (double s, double x) => s + x, (double x, int c) => x, array, Zeros.AllowSkip);
			return Vector<double>.Build.Dense(array);
		}

		public override Vector<double> ColumnAbsoluteSums()
		{
			double[] array = new double[base.ColumnCount];
			base.Storage.FoldByColumnUnchecked(array, (double s, double x) => s + Math.Abs(x), (double x, int c) => x, array, Zeros.AllowSkip);
			return Vector<double>.Build.Dense(array);
		}

		public sealed override bool IsHermitian()
		{
			return IsSymmetric();
		}

		public override Cholesky<double> Cholesky()
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserCholesky.Create(this);
		}

		public override LU<double> LU()
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserLU.Create(this);
		}

		public override QR<double> QR(QRMethod method = QRMethod.Thin)
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserQR.Create(this, method);
		}

		public override GramSchmidt<double> GramSchmidt()
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserGramSchmidt.Create(this);
		}

		public override Svd<double> Svd(bool computeVectors = true)
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Create(this, computeVectors);
		}

		public override Evd<double> Evd(Symmetricity symmetricity = Symmetricity.Unknown)
		{
			return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserEvd.Create(this, symmetricity);
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseMatrix {RowCount}x{ColumnCount}-Double {NonZerosCount}-NonZero")]
	public class SparseMatrix : Matrix
	{
		private readonly SparseCompressedRowMatrixStorage<double> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseMatrix(SparseCompressedRowMatrixStorage<double> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseMatrix(int order)
			: this(order, order)
		{
		}

		public SparseMatrix(int rows, int columns)
			: this(new SparseCompressedRowMatrixStorage<double>(rows, columns))
		{
		}

		public static SparseMatrix OfMatrix(Matrix<double> matrix)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfMatrix(matrix.Storage));
		}

		public static SparseMatrix OfArray(double[,] array)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfArray(array));
		}

		public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable<Tuple<int, int, double>> enumerable)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfIndexedEnumerable(rows, columns, enumerable));
		}

		public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable<double> rowMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfRowMajorEnumerable(rows, columns, rowMajor));
		}

		public static SparseMatrix OfColumnMajor(int rows, int columns, IList<double> columnMajor)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfColumnMajorList(rows, columns, columnMajor));
		}

		public static SparseMatrix OfColumns(IEnumerable<IEnumerable<double>> data)
		{
			return OfColumnArrays(data.Select((IEnumerable<double> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfColumns(int rows, int columns, IEnumerable<IEnumerable<double>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfColumnEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfColumnArrays(params double[][] columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfColumnArrays(columns));
		}

		public static SparseMatrix OfColumnArrays(IEnumerable<double[]> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfColumnArrays((columns as double[][]) ?? columns.ToArray()));
		}

		public static SparseMatrix OfColumnVectors(params Vector<double>[] columns)
		{
			VectorStorage<double>[] array = new VectorStorage<double>[columns.Length];
			for (int i = 0; i < columns.Length; i++)
			{
				array[i] = columns[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfColumnVectors(array));
		}

		public static SparseMatrix OfColumnVectors(IEnumerable<Vector<double>> columns)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfColumnVectors(columns.Select((Vector<double> c) => c.Storage).ToArray()));
		}

		public static SparseMatrix OfRows(IEnumerable<IEnumerable<double>> data)
		{
			return OfRowArrays(data.Select((IEnumerable<double> v) => v.ToArray()).ToArray());
		}

		public static SparseMatrix OfRows(int rows, int columns, IEnumerable<IEnumerable<double>> data)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfRowEnumerables(rows, columns, data));
		}

		public static SparseMatrix OfRowArrays(params double[][] rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfRowArrays(rows));
		}

		public static SparseMatrix OfRowArrays(IEnumerable<double[]> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfRowArrays((rows as double[][]) ?? rows.ToArray()));
		}

		public static SparseMatrix OfRowVectors(params Vector<double>[] rows)
		{
			VectorStorage<double>[] array = new VectorStorage<double>[rows.Length];
			for (int i = 0; i < rows.Length; i++)
			{
				array[i] = rows[i].Storage;
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfRowVectors(array));
		}

		public static SparseMatrix OfRowVectors(IEnumerable<Vector<double>> rows)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfRowVectors(rows.Select((Vector<double> r) => r.Storage).ToArray()));
		}

		public static SparseMatrix OfDiagonalVector(Vector<double> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Count, diagonal.Count);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector<double> diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(double[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(diagonal.Length, diagonal.Length);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix OfDiagonalArray(int rows, int columns, double[] diagonal)
		{
			SparseMatrix sparseMatrix = new SparseMatrix(rows, columns);
			sparseMatrix.SetDiagonal(diagonal);
			return sparseMatrix;
		}

		public static SparseMatrix Create(int rows, int columns, double value)
		{
			if (value == 0.0)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfValue(rows, columns, value));
		}

		public static SparseMatrix Create(int rows, int columns, Func<int, int, double> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfInit(rows, columns, init));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, double value)
		{
			if (value == 0.0)
			{
				return new SparseMatrix(rows, columns);
			}
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfDiagonalInit(rows, columns, (int i) => value));
		}

		public static SparseMatrix CreateDiagonal(int rows, int columns, Func<int, double> init)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfDiagonalInit(rows, columns, init));
		}

		public static SparseMatrix CreateIdentity(int order)
		{
			return new SparseMatrix(SparseCompressedRowMatrixStorage<double>.OfDiagonalInit(order, order, (int i) => Matrix<double>.One));
		}

		public override Matrix<double> LowerTriangle()
		{
			Matrix<double> result = Matrix<double>.Build.SameAs(this);
			LowerTriangleImpl(result);
			return result;
		}

		public override void LowerTriangle(Matrix<double> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<double> matrix = Matrix<double>.Build.SameAs(result);
				LowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				LowerTriangleImpl(result);
			}
		}

		private void LowerTriangleImpl(Matrix<double> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i >= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<double> UpperTriangle()
		{
			Matrix<double> result = Matrix<double>.Build.SameAs(this);
			UpperTriangleImpl(result);
			return result;
		}

		public override void UpperTriangle(Matrix<double> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<double> matrix = Matrix<double>.Build.SameAs(result);
				UpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				UpperTriangleImpl(result);
			}
		}

		private void UpperTriangleImpl(Matrix<double> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i <= columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<double> StrictlyLowerTriangle()
		{
			Matrix<double> result = Matrix<double>.Build.SameAs(this);
			StrictlyLowerTriangleImpl(result);
			return result;
		}

		public override void StrictlyLowerTriangle(Matrix<double> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<double> matrix = Matrix<double>.Build.SameAs(result);
				StrictlyLowerTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyLowerTriangleImpl(result);
			}
		}

		private void StrictlyLowerTriangleImpl(Matrix<double> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i > columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		public override Matrix<double> StrictlyUpperTriangle()
		{
			Matrix<double> result = Matrix<double>.Build.SameAs(this);
			StrictlyUpperTriangleImpl(result);
			return result;
		}

		public override void StrictlyUpperTriangle(Matrix<double> result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount || result.ColumnCount != base.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(this, result, "result");
			}
			if (this == result)
			{
				Matrix<double> matrix = Matrix<double>.Build.SameAs(result);
				StrictlyUpperTriangle(matrix);
				matrix.CopyTo(result);
			}
			else
			{
				result.Clear();
				StrictlyUpperTriangleImpl(result);
			}
		}

		private void StrictlyUpperTriangleImpl(Matrix<double> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < result.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (i < columnIndices[j])
					{
						result.At(i, columnIndices[j], values[j]);
					}
				}
			}
		}

		protected override void DoNegate(Matrix<double> result)
		{
			CopyTo(result);
			DoMultiply(-1.0, result);
		}

		public override double InfinityNorm()
		{
			int[] rowPointers = _storage.RowPointers;
			double[] values = _storage.Values;
			double num = 0.0;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num2 = rowPointers[i];
				int num3 = rowPointers[i + 1];
				if (num2 != num3)
				{
					double num4 = 0.0;
					for (int j = num2; j < num3; j++)
					{
						num4 += Math.Abs(values[j]);
					}
					num = Math.Max(num, num4);
				}
			}
			return num;
		}

		public override double FrobeniusNorm()
		{
			SparseCompressedRowMatrixStorage<double> sparseCompressedRowMatrixStorage = (SparseCompressedRowMatrixStorage<double>)(this * Transpose()).Storage;
			double num = 0.0;
			for (int i = 0; i < sparseCompressedRowMatrixStorage.RowCount; i++)
			{
				int num2 = sparseCompressedRowMatrixStorage.RowPointers[i];
				int num3 = sparseCompressedRowMatrixStorage.RowPointers[i + 1];
				if (num2 == num3)
				{
					continue;
				}
				for (int j = num2; j < num3; j++)
				{
					if (i == sparseCompressedRowMatrixStorage.ColumnIndices[j])
					{
						num += Math.Abs(sparseCompressedRowMatrixStorage.Values[j]);
					}
				}
			}
			return Math.Sqrt(num);
		}

		protected override void DoAdd(Matrix<double> other, Matrix<double> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					if (this != result)
					{
						CopyTo(result);
					}
					LinearAlgebraControl.Provider.ScaleArray(2.0, sparseMatrix2._storage.Values, sparseMatrix2._storage.Values);
					return;
				}
				SparseMatrix sparseMatrix3;
				if (sparseMatrix == sparseMatrix2)
				{
					sparseMatrix3 = this;
				}
				else if (this == sparseMatrix2)
				{
					sparseMatrix3 = sparseMatrix;
				}
				else
				{
					CopyTo(sparseMatrix2);
					sparseMatrix3 = sparseMatrix;
				}
				SparseCompressedRowMatrixStorage<double> storage = sparseMatrix3._storage;
				for (int i = 0; i < storage.RowCount; i++)
				{
					int num = storage.RowPointers[i + 1];
					for (int j = storage.RowPointers[i]; j < num; j++)
					{
						int column = storage.ColumnIndices[j];
						double value = storage.Values[j] + result.At(i, column);
						result.At(i, column, value);
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(Matrix<double> other, Matrix<double> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				if (this == other)
				{
					result.Clear();
					return;
				}
				SparseCompressedRowMatrixStorage<double> storage = sparseMatrix._storage;
				if (this == sparseMatrix2)
				{
					for (int i = 0; i < storage.RowCount; i++)
					{
						int num = storage.RowPointers[i + 1];
						for (int j = storage.RowPointers[i]; j < num; j++)
						{
							int column = storage.ColumnIndices[j];
							double value = sparseMatrix2.At(i, column) - storage.Values[j];
							result.At(i, column, value);
						}
					}
					return;
				}
				if (sparseMatrix != sparseMatrix2)
				{
					sparseMatrix.CopyTo(sparseMatrix2);
				}
				sparseMatrix2.Negate(sparseMatrix2);
				int[] rowPointers = _storage.RowPointers;
				int[] columnIndices = _storage.ColumnIndices;
				double[] values = _storage.Values;
				for (int k = 0; k < base.RowCount; k++)
				{
					int num2 = rowPointers[k + 1];
					for (int l = rowPointers[k]; l < num2; l++)
					{
						int column2 = columnIndices[l];
						double value2 = sparseMatrix2.At(k, column2) + values[l];
						result.At(k, column2, value2);
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoMultiply(double scalar, Matrix<double> result)
		{
			if (scalar == 1.0)
			{
				CopyTo(result);
				return;
			}
			if (scalar == 0.0 || NonZerosCount == 0)
			{
				result.Clear();
				return;
			}
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(sparseMatrix);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseMatrix._storage.Values, sparseMatrix._storage.Values);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					for (int j = num; j < num2; j++)
					{
						int column = columnIndices[j];
						result.At(i, column, values[j] * scalar);
					}
				}
			}
		}

		protected override void DoMultiply(Matrix<double> other, Matrix<double> result)
		{
			SparseMatrix sparseMatrix = other as SparseMatrix;
			SparseMatrix sparseMatrix2 = result as SparseMatrix;
			if (sparseMatrix != null && sparseMatrix2 != null)
			{
				DoMultiplySparse(sparseMatrix, sparseMatrix2);
				return;
			}
			if (other.Storage is DiagonalMatrixStorage<double> diagonalMatrixStorage && sparseMatrix2 != null)
			{
				double[] diagonal = diagonalMatrixStorage.Data;
				if (other.ColumnCount == other.RowCount)
				{
					base.Storage.MapIndexedTo(result.Storage, (int i, int j, double x) => x * diagonal[j], Zeros.AllowSkip, ExistingData.Clear);
					return;
				}
				result.Storage.Clear();
				base.Storage.MapSubMatrixIndexedTo(result.Storage, (int i, int j, double x) => x * diagonal[j], 0, 0, base.RowCount, 0, 0, Math.Min(base.ColumnCount, other.ColumnCount), Zeros.AllowSkip, ExistingData.AssumeZeros);
				return;
			}
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			if (other.Storage is DenseColumnMajorMatrixStorage<double> denseColumnMajorMatrixStorage)
			{
				for (int k = 0; k < base.RowCount; k++)
				{
					int num = rowPointers[k];
					int num2 = rowPointers[k + 1];
					if (num == num2)
					{
						continue;
					}
					for (int l = 0; l < other.ColumnCount; l++)
					{
						int num3 = l * other.RowCount;
						double num4 = 0.0;
						for (int m = num; m < num2; m++)
						{
							num4 += values[m] * denseColumnMajorMatrixStorage.Data[num3 + columnIndices[m]];
						}
						result.At(k, l, num4);
					}
				}
				return;
			}
			DenseVector denseVector = new DenseVector(other.RowCount);
			for (int n = 0; n < base.RowCount; n++)
			{
				int num5 = rowPointers[n];
				int num6 = rowPointers[n + 1];
				if (num5 == num6)
				{
					continue;
				}
				for (int num7 = 0; num7 < other.ColumnCount; num7++)
				{
					other.Column(num7, denseVector);
					double num8 = 0.0;
					for (int num9 = num5; num9 < num6; num9++)
					{
						num8 += values[num9] * denseVector[columnIndices[num9]];
					}
					result.At(n, num7, num8);
				}
			}
		}

		private void DoMultiplySparse(SparseMatrix other, SparseMatrix result)
		{
			result.Clear();
			double[] values = _storage.Values;
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values2 = other._storage.Values;
			int[] rowPointers2 = other._storage.RowPointers;
			int[] columnIndices2 = other._storage.ColumnIndices;
			int rowCount = base.RowCount;
			int columnCount = other.ColumnCount;
			int[] rowPointers3 = result._storage.RowPointers;
			int[] array = new int[columnCount];
			for (int i = 0; i < columnCount; i++)
			{
				array[i] = -1;
			}
			int num = 0;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = rowPointers[j]; k < rowPointers[j + 1]; k++)
				{
					int num2 = columnIndices[k];
					for (int l = rowPointers2[num2]; l < rowPointers2[num2 + 1]; l++)
					{
						int num3 = columnIndices2[l];
						if (array[num3] != j)
						{
							array[num3] = j;
							num++;
						}
					}
				}
				rowPointers3[j + 1] = num;
			}
			int[] array2 = new int[num];
			double[] array3 = new double[num];
			for (int m = 0; m < columnCount; m++)
			{
				array[m] = -1;
			}
			num = 0;
			for (int n = 0; n < rowCount; n++)
			{
				int num4 = rowPointers3[n];
				for (int num5 = rowPointers[n]; num5 < rowPointers[n + 1]; num5++)
				{
					int num6 = columnIndices[num5];
					double num7 = values[num5];
					for (int num8 = rowPointers2[num6]; num8 < rowPointers2[num6 + 1]; num8++)
					{
						int num9 = columnIndices2[num8];
						double num10 = values2[num8];
						if (array[num9] < num4)
						{
							array[num9] = num;
							array2[array[num9]] = num9;
							array3[array[num9]] = num7 * num10;
							num++;
						}
						else
						{
							array3[array[num9]] += num7 * num10;
						}
					}
				}
			}
			result._storage.Values = array3;
			result._storage.ColumnIndices = array2;
			result._storage.Normalize();
		}

		protected override void DoMultiply(Vector<double> rightSide, Vector<double> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					double num3 = 0.0;
					for (int j = num; j < num2; j++)
					{
						num3 += values[j] * rightSide[columnIndices[j]];
					}
					result[i] = num3;
				}
			}
		}

		protected override void DoTransposeAndMultiply(Matrix<double> other, Matrix<double> result)
		{
			if (other is SparseMatrix sparseMatrix && result is SparseMatrix sparseMatrix2)
			{
				sparseMatrix2.Clear();
				int[] rowPointers = _storage.RowPointers;
				double[] values = _storage.Values;
				SparseCompressedRowMatrixStorage<double> storage = sparseMatrix._storage;
				for (int i = 0; i < base.RowCount; i++)
				{
					int num = storage.RowPointers[i];
					int num2 = storage.RowPointers[i + 1];
					if (num == num2)
					{
						continue;
					}
					for (int j = 0; j < base.RowCount; j++)
					{
						int num3 = rowPointers[j];
						int num4 = rowPointers[j + 1];
						if (num3 == num4)
						{
							continue;
						}
						double num5 = 0.0;
						for (int k = num; k < num2; k++)
						{
							int num6 = _storage.FindItem(j, storage.ColumnIndices[k]);
							if (num6 >= 0)
							{
								num5 += storage.Values[k] * values[num6];
							}
						}
						sparseMatrix2._storage.At(j, i, num5 + result.At(j, i));
					}
				}
			}
			else
			{
				base.DoTransposeAndMultiply(other, result);
			}
		}

		protected override void DoTransposeThisAndMultiply(Vector<double> rightSide, Vector<double> result)
		{
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num != num2)
				{
					double num3 = rightSide[i];
					for (int j = num; j < num2; j++)
					{
						result[columnIndices[j]] += values[j] * num3;
					}
				}
			}
		}

		protected override void DoPointwiseMultiply(Matrix<double> other, Matrix<double> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					double num2 = values[j] * other.At(i, columnIndices[j]);
					if (num2 != 0.0)
					{
						result.At(i, columnIndices[j], num2);
					}
				}
			}
		}

		protected override void DoPointwiseDivide(Matrix<double> divisor, Matrix<double> result)
		{
			result.Clear();
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (values[j] != 0.0)
					{
						result.At(i, columnIndices[j], values[j] / divisor.At(i, columnIndices[j]));
					}
				}
			}
		}

		public override void KroneckerProduct(Matrix<double> other, Matrix<double> result)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != base.RowCount * other.RowCount || result.ColumnCount != base.ColumnCount * other.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(this, other, result);
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i + 1];
				for (int j = rowPointers[i]; j < num; j++)
				{
					if (values[j] != 0.0)
					{
						result.SetSubMatrix(i * other.RowCount, other.RowCount, columnIndices[j] * other.ColumnCount, other.ColumnCount, values[j] * other);
					}
				}
			}
		}

		protected override void DoModulus(double divisor, Matrix<double> result)
		{
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				SparseCompressedRowMatrixStorage<double> storage = sparseMatrix._storage;
				for (int i = 0; i < storage.Values.Length; i++)
				{
					storage.Values[i] = Euclid.Modulus(storage.Values[i], divisor);
				}
			}
			else
			{
				base.DoModulus(divisor, result);
			}
		}

		protected override void DoRemainder(double divisor, Matrix<double> result)
		{
			if (result is SparseMatrix sparseMatrix)
			{
				if (this != result)
				{
					CopyTo(result);
				}
				SparseCompressedRowMatrixStorage<double> storage = sparseMatrix._storage;
				for (int i = 0; i < storage.Values.Length; i++)
				{
					storage.Values[i] %= divisor;
				}
			}
			else
			{
				base.DoRemainder(divisor, result);
			}
		}

		public override bool IsSymmetric()
		{
			if (base.RowCount != base.ColumnCount)
			{
				return false;
			}
			int[] rowPointers = _storage.RowPointers;
			int[] columnIndices = _storage.ColumnIndices;
			double[] values = _storage.Values;
			for (int i = 0; i < base.RowCount; i++)
			{
				int num = rowPointers[i];
				int num2 = rowPointers[i + 1];
				if (num == num2)
				{
					continue;
				}
				for (int j = num; j < num2; j++)
				{
					int row = columnIndices[j];
					if (!values[j].Equals(At(row, i)))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static SparseMatrix operator +(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Add(rightSide);
		}

		public static SparseMatrix operator +(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Clone();
		}

		public static SparseMatrix operator -(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (leftSide.RowCount != rightSide.RowCount || leftSide.ColumnCount != rightSide.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Subtract(rightSide);
		}

		public static SparseMatrix operator -(SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Negate();
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseMatrix operator *(double leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseMatrix)rightSide.Multiply(leftSide);
		}

		public static SparseMatrix operator *(SparseMatrix leftSide, SparseMatrix rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			if (leftSide.ColumnCount != rightSide.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(leftSide, rightSide);
			}
			return (SparseMatrix)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseMatrix leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, SparseMatrix rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.LeftMultiply(leftSide);
		}

		public static SparseMatrix operator %(SparseMatrix leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseMatrix)leftSide.Remainder(rightSide);
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseMatrix {base.RowCount}x{base.ColumnCount}-Double {(double)NonZerosCount / ((double)base.RowCount * (double)base.ColumnCount):P2} Filled");
		}
	}
	[Serializable]
	[DebuggerDisplay("SparseVector {Count}-Double {NonZerosCount}-NonZero")]
	public class SparseVector : Vector
	{
		private readonly SparseVectorStorage<double> _storage;

		public int NonZerosCount => _storage.ValueCount;

		public SparseVector(SparseVectorStorage<double> storage)
			: base(storage)
		{
			_storage = storage;
		}

		public SparseVector(int length)
			: this(new SparseVectorStorage<double>(length))
		{
		}

		public static SparseVector OfVector(Vector<double> vector)
		{
			return new SparseVector(SparseVectorStorage<double>.OfVector(vector.Storage));
		}

		public static SparseVector OfEnumerable(IEnumerable<double> enumerable)
		{
			return new SparseVector(SparseVectorStorage<double>.OfEnumerable(enumerable));
		}

		public static SparseVector OfIndexedEnumerable(int length, IEnumerable<Tuple<int, double>> enumerable)
		{
			return new SparseVector(SparseVectorStorage<double>.OfIndexedEnumerable(length, enumerable));
		}

		public static SparseVector Create(int length, double value)
		{
			return new SparseVector(SparseVectorStorage<double>.OfValue(length, value));
		}

		public static SparseVector Create(int length, Func<int, double> init)
		{
			return new SparseVector(SparseVectorStorage<double>.OfInit(length, init));
		}

		protected override void DoAdd(double scalar, Vector<double> result)
		{
			if (scalar == 0.0)
			{
				if (this != result)
				{
					CopyTo(result);
				}
			}
			else if (this == result)
			{
				double[] array = new double[base.Count];
				int[] array2 = new int[base.Count];
				for (int i = 0; i < base.Count; i++)
				{
					array2[i] = i;
					array[i] = scalar;
				}
				int[] indices = _storage.Indices;
				double[] values = _storage.Values;
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					array[indices[j]] = values[j] + scalar;
				}
				_storage.Values = array;
				_storage.Indices = array2;
				_storage.ValueCount = base.Count;
			}
			else
			{
				for (int k = 0; k < base.Count; k++)
				{
					result.At(k, At(k) + scalar);
				}
			}
		}

		protected override void DoAdd(Vector<double> other, Vector<double> result)
		{
			if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<double> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							double num3 = storage.Values[num2];
							if (num3 != 0.0)
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], num3);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] += storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num4 = 0;
				int num5 = 0;
				int num6 = -1;
				while (num4 < _storage.ValueCount || num5 < storage.ValueCount)
				{
					if (num5 >= storage.ValueCount || (num4 < _storage.ValueCount && _storage.Indices[num4] <= storage.Indices[num5]))
					{
						int num7 = _storage.Indices[num4];
						if (num7 != num6)
						{
							num6 = num7;
							result.At(num7, _storage.Values[num4] + sparseVector.At(num7));
						}
						num4++;
					}
					else
					{
						int num8 = storage.Indices[num5];
						if (num8 != num6)
						{
							num6 = num8;
							result.At(num8, At(num8) + storage.Values[num5]);
						}
						num5++;
					}
				}
			}
			else
			{
				base.DoAdd(other, result);
			}
		}

		protected override void DoSubtract(double scalar, Vector<double> result)
		{
			DoAdd(0.0 - scalar, result);
		}

		protected override void DoSubtract(Vector<double> other, Vector<double> result)
		{
			if (this == other)
			{
				result.Clear();
			}
			else if (other is SparseVector sparseVector && result is SparseVector sparseVector2)
			{
				SparseVectorStorage<double> storage = sparseVector._storage;
				if (this == sparseVector2)
				{
					int num = 0;
					int num2 = 0;
					while (num2 < storage.ValueCount)
					{
						if (num >= _storage.ValueCount || _storage.Indices[num] > storage.Indices[num2])
						{
							double num3 = storage.Values[num2];
							if (num3 != 0.0)
							{
								_storage.InsertAtIndexUnchecked(num++, storage.Indices[num2], 0.0 - num3);
							}
							num2++;
						}
						else if (_storage.Indices[num] == storage.Indices[num2])
						{
							_storage.Values[num++] -= storage.Values[num2++];
						}
						else
						{
							num++;
						}
					}
					return;
				}
				result.Clear();
				int num4 = 0;
				int num5 = 0;
				int num6 = -1;
				while (num4 < _storage.ValueCount || num5 < storage.ValueCount)
				{
					if (num5 >= storage.ValueCount || (num4 < _storage.ValueCount && _storage.Indices[num4] <= storage.Indices[num5]))
					{
						int num7 = _storage.Indices[num4];
						if (num7 != num6)
						{
							num6 = num7;
							result.At(num7, _storage.Values[num4] - sparseVector.At(num7));
						}
						num4++;
					}
					else
					{
						int num8 = storage.Indices[num5];
						if (num8 != num6)
						{
							num6 = num8;
							result.At(num8, At(num8) - storage.Values[num5]);
						}
						num5++;
					}
				}
			}
			else
			{
				base.DoSubtract(other, result);
			}
		}

		protected override void DoNegate(Vector<double> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new double[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(-1.0, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], 0.0 - _storage.Values[i]);
				}
			}
		}

		protected override void DoMultiply(double scalar, Vector<double> result)
		{
			if (result is SparseVector sparseVector)
			{
				if (this != result)
				{
					sparseVector._storage.ValueCount = _storage.ValueCount;
					sparseVector._storage.Indices = new int[_storage.ValueCount];
					Buffer.BlockCopy(_storage.Indices, 0, sparseVector._storage.Indices, 0, _storage.ValueCount * 4);
					sparseVector._storage.Values = new double[_storage.ValueCount];
					Array.Copy(_storage.Values, 0, sparseVector._storage.Values, 0, _storage.ValueCount);
				}
				LinearAlgebraControl.Provider.ScaleArray(scalar, sparseVector._storage.Values, sparseVector._storage.Values);
			}
			else
			{
				result.Clear();
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					result.At(_storage.Indices[i], scalar * _storage.Values[i]);
				}
			}
		}

		protected override double DoDotProduct(Vector<double> other)
		{
			double num = 0.0;
			if (this == other)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					num += _storage.Values[i] * _storage.Values[i];
				}
			}
			else
			{
				for (int j = 0; j < _storage.ValueCount; j++)
				{
					num += _storage.Values[j] * other.At(_storage.Indices[j]);
				}
			}
			return num;
		}

		protected override void DoModulus(double divisor, Vector<double> result)
		{
			if (this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] = Euclid.Modulus(_storage.Values[i], divisor);
				}
				return;
			}
			result.Clear();
			for (int j = 0; j < _storage.ValueCount; j++)
			{
				result.At(_storage.Indices[j], Euclid.Modulus(_storage.Values[j], divisor));
			}
		}

		protected override void DoRemainder(double divisor, Vector<double> result)
		{
			if (this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] %= divisor;
				}
				return;
			}
			result.Clear();
			for (int j = 0; j < _storage.ValueCount; j++)
			{
				result.At(_storage.Indices[j], _storage.Values[j] % divisor);
			}
		}

		public static SparseVector operator +(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Add(rightSide);
		}

		public static SparseVector operator -(SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Negate();
		}

		public static SparseVector operator -(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Subtract(rightSide);
		}

		public static SparseVector operator *(SparseVector leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Multiply(rightSide);
		}

		public static SparseVector operator *(double leftSide, SparseVector rightSide)
		{
			if (rightSide == null)
			{
				throw new ArgumentNullException("rightSide");
			}
			return (SparseVector)rightSide.Multiply(leftSide);
		}

		public static double operator *(SparseVector leftSide, SparseVector rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return leftSide.DotProduct(rightSide);
		}

		public static SparseVector operator /(SparseVector leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Divide(rightSide);
		}

		public static SparseVector operator %(SparseVector leftSide, double rightSide)
		{
			if (leftSide == null)
			{
				throw new ArgumentNullException("leftSide");
			}
			return (SparseVector)leftSide.Remainder(rightSide);
		}

		public override int AbsoluteMinimumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			double num2 = Math.Abs(_storage.Values[num]);
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				double num3 = Math.Abs(_storage.Values[i]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return _storage.Indices[num];
		}

		public override int AbsoluteMaximumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			double num2 = Math.Abs(_storage.Values[num]);
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				double num3 = Math.Abs(_storage.Values[i]);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return _storage.Indices[num];
		}

		public override int MaximumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			double num2 = _storage.Values[0];
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				if (num2 < _storage.Values[i])
				{
					num = i;
					num2 = _storage.Values[i];
				}
			}
			return _storage.Indices[num];
		}

		public override int MinimumIndex()
		{
			if (_storage.ValueCount == 0)
			{
				return 0;
			}
			int num = 0;
			double num2 = _storage.Values[0];
			for (int i = 1; i < _storage.ValueCount; i++)
			{
				if (num2 > _storage.Values[i])
				{
					num = i;
					num2 = _storage.Values[i];
				}
			}
			return _storage.Indices[num];
		}

		public override double Sum()
		{
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += _storage.Values[i];
			}
			return num;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += Math.Abs(_storage.Values[i]);
			}
			return num;
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, _storage.ValueCount, (int i) => Math.Abs(_storage.Values[i]), Math.Max, 0.0);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (_storage.ValueCount == 0)
			{
				return 0.0;
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < _storage.ValueCount; i++)
			{
				num += Math.Pow(Math.Abs(_storage.Values[i]), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		protected override void DoPointwiseMultiply(Vector<double> other, Vector<double> result)
		{
			if (this == other && this == result)
			{
				for (int i = 0; i < _storage.ValueCount; i++)
				{
					_storage.Values[i] *= _storage.Values[i];
				}
			}
			else
			{
				base.DoPointwiseMultiply(other, result);
			}
		}

		public static SparseVector Parse(string value, IFormatProvider formatProvider = null)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				throw new FormatException();
			}
			if (value.StartsWith("(", StringComparison.Ordinal))
			{
				if (!value.EndsWith(")", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			if (value.StartsWith("[", StringComparison.Ordinal))
			{
				if (!value.EndsWith("]", StringComparison.Ordinal))
				{
					throw new FormatException();
				}
				value = value.Substring(1, value.Length - 2).Trim();
			}
			List<double> list = (from t in value.Split(new string[3]
				{
					formatProvider.GetTextInfo().ListSeparator,
					" ",
					"\t"
				}, StringSplitOptions.RemoveEmptyEntries)
				select double.Parse(t, NumberStyles.Any, formatProvider)).ToList();
			if (list.Count == 0)
			{
				throw new FormatException();
			}
			return new SparseVector(SparseVectorStorage<double>.OfEnumerable(list));
		}

		public static bool TryParse(string value, out SparseVector result)
		{
			return TryParse(value, null, out result);
		}

		public static bool TryParse(string value, IFormatProvider formatProvider, out SparseVector result)
		{
			try
			{
				result = Parse(value, formatProvider);
				return true;
			}
			catch (ArgumentNullException)
			{
				result = null;
				return false;
			}
			catch (FormatException)
			{
				result = null;
				return false;
			}
		}

		public override string ToTypeString()
		{
			return FormattableString.Invariant($"SparseVector {base.Count}-Double {(double)NonZerosCount / (double)base.Count:P2} Filled");
		}
	}
	[Serializable]
	public abstract class Vector : Vector<double>
	{
		protected Vector(VectorStorage<double> storage)
			: base(storage)
		{
		}

		public override void CoerceZero(double threshold)
		{
			MapInplace((double x) => (!(Math.Abs(x) < threshold)) ? x : 0.0);
		}

		protected sealed override void DoConjugate(Vector<double> result)
		{
			if (this != result)
			{
				CopyTo(result);
			}
		}

		protected override void DoNegate(Vector<double> result)
		{
			Map((double x) => 0.0 - x, result);
		}

		protected override void DoAdd(double scalar, Vector<double> result)
		{
			Map((double x) => x + scalar, result, Zeros.Include);
		}

		protected override void DoAdd(Vector<double> other, Vector<double> result)
		{
			Map2((double x, double y) => x + y, other, result);
		}

		protected override void DoSubtract(double scalar, Vector<double> result)
		{
			Map((double x) => x - scalar, result, Zeros.Include);
		}

		protected override void DoSubtract(Vector<double> other, Vector<double> result)
		{
			Map2((double x, double y) => x - y, other, result);
		}

		protected override void DoMultiply(double scalar, Vector<double> result)
		{
			Map((double x) => x * scalar, result);
		}

		protected override void DoDivide(double divisor, Vector<double> result)
		{
			Map((double x) => x / divisor, result, (divisor == 0.0) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoDivideByThis(double dividend, Vector<double> result)
		{
			Map((double x) => dividend / x, result, Zeros.Include);
		}

		protected override void DoPointwiseMultiply(Vector<double> other, Vector<double> result)
		{
			Map2((double x, double y) => x * y, other, result);
		}

		protected override void DoPointwiseDivide(Vector<double> divisor, Vector<double> result)
		{
			Map2((double x, double y) => x / y, divisor, result, Zeros.Include);
		}

		protected override void DoPointwisePower(double exponent, Vector<double> result)
		{
			Map((double x) => Math.Pow(x, exponent), result, (!(exponent > 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwisePower(Vector<double> exponent, Vector<double> result)
		{
			Map2(Math.Pow, exponent, result, Zeros.Include);
		}

		protected override void DoPointwiseModulus(Vector<double> divisor, Vector<double> result)
		{
			Map2(Euclid.Modulus, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseRemainder(Vector<double> divisor, Vector<double> result)
		{
			Map2(Euclid.Remainder, divisor, result, Zeros.Include);
		}

		protected override void DoPointwiseExp(Vector<double> result)
		{
			Map(Math.Exp, result, Zeros.Include);
		}

		protected override void DoPointwiseLog(Vector<double> result)
		{
			Map(Math.Log, result, Zeros.Include);
		}

		protected override void DoPointwiseAbs(Vector<double> result)
		{
			Map(Math.Abs, result);
		}

		protected override void DoPointwiseAcos(Vector<double> result)
		{
			Map(Math.Acos, result, Zeros.Include);
		}

		protected override void DoPointwiseAsin(Vector<double> result)
		{
			Map(Math.Asin, result);
		}

		protected override void DoPointwiseAtan(Vector<double> result)
		{
			Map(Math.Atan, result);
		}

		protected override void DoPointwiseAtan2(Vector<double> other, Vector<double> result)
		{
			Map2(Math.Atan2, other, result, Zeros.Include);
		}

		protected override void DoPointwiseAtan2(double scalar, Vector<double> result)
		{
			Map((double x) => Math.Atan2(x, scalar), result, Zeros.Include);
		}

		protected override void DoPointwiseCeiling(Vector<double> result)
		{
			Map(Math.Ceiling, result);
		}

		protected override void DoPointwiseCos(Vector<double> result)
		{
			Map(Math.Cos, result, Zeros.Include);
		}

		protected override void DoPointwiseCosh(Vector<double> result)
		{
			Map(Math.Cosh, result, Zeros.Include);
		}

		protected override void DoPointwiseFloor(Vector<double> result)
		{
			Map(Math.Floor, result);
		}

		protected override void DoPointwiseLog10(Vector<double> result)
		{
			Map(Math.Log10, result, Zeros.Include);
		}

		protected override void DoPointwiseRound(Vector<double> result)
		{
			Map(Math.Round, result);
		}

		protected override void DoPointwiseSign(Vector<double> result)
		{
			Map((double x) => Math.Sign(x), result);
		}

		protected override void DoPointwiseSin(Vector<double> result)
		{
			Map(Math.Sin, result);
		}

		protected override void DoPointwiseSinh(Vector<double> result)
		{
			Map(Math.Sinh, result);
		}

		protected override void DoPointwiseSqrt(Vector<double> result)
		{
			Map(Math.Sqrt, result);
		}

		protected override void DoPointwiseTan(Vector<double> result)
		{
			Map(Math.Tan, result);
		}

		protected override void DoPointwiseTanh(Vector<double> result)
		{
			Map(Math.Tanh, result);
		}

		protected override double DoDotProduct(Vector<double> other)
		{
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += At(i) * other.At(i);
			}
			return num;
		}

		protected sealed override double DoConjugateDotProduct(Vector<double> other)
		{
			return DoDotProduct(other);
		}

		protected override void DoModulus(double divisor, Vector<double> result)
		{
			Map((double x) => Euclid.Modulus(x, divisor), result, Zeros.Include);
		}

		protected override void DoModulusByThis(double dividend, Vector<double> result)
		{
			Map((double x) => Euclid.Modulus(dividend, x), result, Zeros.Include);
		}

		protected override void DoRemainder(double divisor, Vector<double> result)
		{
			Map((double x) => Euclid.Remainder(x, divisor), result, Zeros.Include);
		}

		protected override void DoRemainderByThis(double dividend, Vector<double> result)
		{
			Map((double x) => Euclid.Remainder(dividend, x), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(double scalar, Vector<double> result)
		{
			Map((double x) => Math.Min(scalar, x), result, (!(scalar >= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseMaximum(double scalar, Vector<double> result)
		{
			Map((double x) => Math.Max(scalar, x), result, (!(scalar <= 0.0)) ? Zeros.Include : Zeros.AllowSkip);
		}

		protected override void DoPointwiseAbsoluteMinimum(double scalar, Vector<double> result)
		{
			double absolute = Math.Abs(scalar);
			Map((double x) => Math.Min(absolute, Math.Abs(x)), result);
		}

		protected override void DoPointwiseAbsoluteMaximum(double scalar, Vector<double> result)
		{
			double absolute = Math.Abs(scalar);
			Map((double x) => Math.Max(absolute, Math.Abs(x)), result, Zeros.Include);
		}

		protected override void DoPointwiseMinimum(Vector<double> other, Vector<double> result)
		{
			Map2(Math.Min, other, result);
		}

		protected override void DoPointwiseMaximum(Vector<double> other, Vector<double> result)
		{
			Map2(Math.Max, other, result);
		}

		protected override void DoPointwiseAbsoluteMinimum(Vector<double> other, Vector<double> result)
		{
			Map2((double x, double y) => Math.Min(Math.Abs(x), Math.Abs(y)), other, result);
		}

		protected override void DoPointwiseAbsoluteMaximum(Vector<double> other, Vector<double> result)
		{
			Map2((double x, double y) => Math.Max(Math.Abs(x), Math.Abs(y)), other, result);
		}

		public override double AbsoluteMinimum()
		{
			return Math.Abs(At(AbsoluteMinimumIndex()));
		}

		public override int AbsoluteMinimumIndex()
		{
			int num = 0;
			double num2 = Math.Abs(At(num));
			for (int i = 1; i < base.Count; i++)
			{
				double num3 = Math.Abs(At(i));
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override double AbsoluteMaximum()
		{
			return Math.Abs(At(AbsoluteMaximumIndex()));
		}

		public override int AbsoluteMaximumIndex()
		{
			int num = 0;
			double num2 = Math.Abs(At(num));
			for (int i = 1; i < base.Count; i++)
			{
				double num3 = Math.Abs(At(i));
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override double Sum()
		{
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += At(i);
			}
			return num;
		}

		public override double L1Norm()
		{
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += Math.Abs(At(i));
			}
			return num;
		}

		public override double L2Norm()
		{
			return Math.Sqrt(DoDotProduct(this));
		}

		public override double InfinityNorm()
		{
			return CommonParallel.Aggregate(0, base.Count, (int i) => Math.Abs(At(i)), Math.Max, 0.0);
		}

		public override double Norm(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			if (p == 1.0)
			{
				return L1Norm();
			}
			if (p == 2.0)
			{
				return L2Norm();
			}
			if (double.IsPositiveInfinity(p))
			{
				return InfinityNorm();
			}
			double num = 0.0;
			for (int i = 0; i < base.Count; i++)
			{
				num += Math.Pow(Math.Abs(At(i)), p);
			}
			return Math.Pow(num, 1.0 / p);
		}

		public override int MaximumIndex()
		{
			int num = 0;
			double num2 = At(num);
			for (int i = 1; i < base.Count; i++)
			{
				double num3 = At(i);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override int MinimumIndex()
		{
			int num = 0;
			double num2 = At(num);
			for (int i = 1; i < base.Count; i++)
			{
				double num3 = At(i);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			return num;
		}

		public override Vector<double> Normalize(double p)
		{
			if (p < 0.0)
			{
				throw new ArgumentOutOfRangeException("p");
			}
			double num = Norm(p);
			Vector<double> vector = Clone();
			if (num == 0.0)
			{
				return vector;
			}
			vector.Multiply(1.0 / num, vector);
			return vector;
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Double.Solvers
{
	public sealed class BiCgStab : IIterativeSolver<double>
	{
		private static void CalculateTrueResidual(Matrix<double> matrix, Vector<double> residual, Vector<double> x, Vector<double> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1.0, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<double> matrix, Vector<double> input, Vector<double> result, Iterator<double> iterator, IPreconditioner<double> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<double>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<double>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector, result, input);
			Vector<double> vector = denseVector.Clone();
			DenseVector denseVector2 = new DenseVector(denseVector.Count);
			DenseVector denseVector3 = new DenseVector(denseVector.Count);
			DenseVector denseVector4 = new DenseVector(denseVector.Count);
			DenseVector denseVector5 = new DenseVector(denseVector.Count);
			DenseVector denseVector6 = new DenseVector(denseVector.Count);
			DenseVector denseVector7 = new DenseVector(denseVector.Count);
			DenseVector denseVector8 = new DenseVector(denseVector.Count);
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			int num4 = 0;
			while (iterator.DetermineStatus(num4, result, input, denseVector) == IterationStatus.Continue)
			{
				double num5 = num;
				num = vector.DotProduct(denseVector);
				if (num.AlmostEqualNumbersBetween(0.0, 1L))
				{
					throw new NumericalBreakdownException();
				}
				if (num4 != 0)
				{
					double scalar = num / num5 * (num2 / num3);
					denseVector4.Multiply(0.0 - num3, denseVector7);
					denseVector2.Add(denseVector7, denseVector8);
					denseVector8.CopyTo(denseVector2);
					denseVector2.Multiply(scalar, denseVector2);
					denseVector2.Add(denseVector, denseVector8);
					denseVector8.CopyTo(denseVector2);
				}
				else
				{
					denseVector.CopyTo(denseVector2);
				}
				preconditioner.Approximate(denseVector2, denseVector3);
				matrix.Multiply(denseVector3, denseVector4);
				num2 = num * 1.0 / vector.DotProduct(denseVector4);
				denseVector4.Multiply(0.0 - num2, denseVector7);
				denseVector.Add(denseVector7, denseVector5);
				denseVector3.Multiply(num2, denseVector7);
				denseVector7.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector7);
				denseVector7.Add(result, denseVector8);
				denseVector8.CopyTo(denseVector7);
				if (iterator.DetermineStatus(num4, denseVector7, input, denseVector5) != 0)
				{
					denseVector7.CopyTo(result);
					CalculateTrueResidual(matrix, denseVector, result, input);
					if (iterator.DetermineStatus(num4, result, input, denseVector) != 0)
					{
						break;
					}
					num4++;
					continue;
				}
				preconditioner.Approximate(denseVector5, denseVector6);
				matrix.Multiply(denseVector6, denseVector7);
				num3 = denseVector7.DotProduct(denseVector5) / denseVector7.DotProduct(denseVector7);
				denseVector7.Multiply(0.0 - num3, denseVector);
				denseVector.Add(denseVector5, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector6.Multiply(num3, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				denseVector3.Multiply(num2, denseVector7);
				result.Add(denseVector7, denseVector8);
				denseVector8.CopyTo(result);
				if (num3.AlmostEqualNumbersBetween(0.0, 1L))
				{
					throw new NumericalBreakdownException();
				}
				if (iterator.DetermineStatus(num4, result, input, denseVector) != 0)
				{
					CalculateTrueResidual(matrix, denseVector, result, input);
				}
				num4++;
			}
		}
	}
	public sealed class CompositeSolver : IIterativeSolver<double>
	{
		private readonly List<Tuple<IIterativeSolver<double>, IPreconditioner<double>>> _solvers;

		public CompositeSolver(IEnumerable<IIterativeSolverSetup<double>> solvers)
		{
			_solvers = solvers.Select((IIterativeSolverSetup<double> setup) => new Tuple<IIterativeSolver<double>, IPreconditioner<double>>(setup.CreateSolver(), setup.CreatePreconditioner() ?? new UnitPreconditioner<double>())).ToList();
		}

		public void Solve(Matrix<double> matrix, Vector<double> input, Vector<double> result, Iterator<double> iterator, IPreconditioner<double> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (iterator == null)
			{
				iterator = new Iterator<double>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<double>();
			}
			Vector<double> vector = input.Clone();
			Vector<double> vector2 = result.Clone();
			foreach (Tuple<IIterativeSolver<double>, IPreconditioner<double>> solver in _solvers)
			{
				IterationStatus status;
				try
				{
					iterator.Reset();
					solver.Item1.Solve(matrix, vector, vector2, iterator, solver.Item2 ?? preconditioner);
					status = iterator.Status;
				}
				catch (Exception)
				{
					input.CopyTo(vector);
					continue;
				}
				switch (status)
				{
				case IterationStatus.Converged:
					vector2.CopyTo(result);
					return;
				case IterationStatus.StoppedWithoutConvergence:
					vector2.CopyTo(result);
					break;
				default:
					input.CopyTo(vector);
					break;
				}
			}
		}
	}
	public sealed class DiagonalPreconditioner : IPreconditioner<double>
	{
		private double[] _inverseDiagonals;

		internal DiagonalMatrix DiagonalEntries()
		{
			DiagonalMatrix diagonalMatrix = new DiagonalMatrix(_inverseDiagonals.Length);
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				diagonalMatrix[i, i] = 1.0 / _inverseDiagonals[i];
			}
			return diagonalMatrix;
		}

		public void Initialize(Matrix<double> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_inverseDiagonals = new double[matrix.RowCount];
			for (int i = 0; i < matrix.RowCount; i++)
			{
				_inverseDiagonals[i] = 1.0 / matrix[i, i];
			}
		}

		public void Approximate(Vector<double> rhs, Vector<double> lhs)
		{
			if (_inverseDiagonals == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _inverseDiagonals.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			for (int i = 0; i < _inverseDiagonals.Length; i++)
			{
				lhs[i] = rhs[i] * _inverseDiagonals[i];
			}
		}
	}
	public sealed class GpBiCg : IIterativeSolver<double>
	{
		private int _numberOfBiCgStabSteps = 1;

		private int _numberOfGpbiCgSteps = 4;

		public int NumberOfBiCgStabSteps
		{
			get
			{
				return _numberOfBiCgStabSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfBiCgStabSteps = value;
			}
		}

		public int NumberOfGpBiCgSteps
		{
			get
			{
				return _numberOfGpbiCgSteps;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfGpbiCgSteps = value;
			}
		}

		private static void CalculateTrueResidual(Matrix<double> matrix, Vector<double> residual, Vector<double> x, Vector<double> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1.0, residual);
			residual.Add(b, residual);
		}

		private bool ShouldRunBiCgStabSteps(int iterationNumber)
		{
			int num = iterationNumber % (_numberOfBiCgStabSteps + _numberOfGpbiCgSteps);
			if (num >= 0)
			{
				return num < _numberOfBiCgStabSteps;
			}
			return false;
		}

		public void Solve(Matrix<double> matrix, Vector<double> input, Vector<double> result, Iterator<double> iterator, IPreconditioner<double> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<double>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<double>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			double scalar = 0.0;
			DenseVector denseVector3 = DenseVector.OfVector(denseVector2);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			DenseVector denseVector12 = new DenseVector(denseVector2.Count);
			DenseVector denseVector13 = new DenseVector(denseVector2.Count);
			DenseVector denseVector14 = new DenseVector(denseVector2.Count);
			DenseVector denseVector15 = new DenseVector(denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				denseVector8.Subtract(denseVector10, denseVector13);
				denseVector13.Multiply(scalar, denseVector14);
				denseVector2.Add(denseVector14, denseVector8);
				preconditioner.Approximate(denseVector8, denseVector13);
				matrix.Multiply(denseVector13, denseVector9);
				double num = denseVector3.DotProduct(denseVector2) / denseVector3.DotProduct(denseVector9);
				denseVector9.Subtract(denseVector6, denseVector13);
				denseVector4.Subtract(denseVector2, denseVector11);
				denseVector13.Multiply(num, denseVector14);
				denseVector11.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector11);
				denseVector4.CopyTo(denseVector5);
				denseVector9.Multiply(0.0 - num, denseVector14);
				denseVector2.Add(denseVector14, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector13);
				matrix.Multiply(denseVector13, denseVector7);
				double num2 = denseVector7.DotProduct(denseVector7);
				if (num2.AlmostEqualNumbersBetween(0.0, 1L))
				{
					num2 = 1.0;
				}
				double num3 = denseVector7.DotProduct(denseVector4);
				double num4;
				double num5;
				if ((_numberOfBiCgStabSteps == 0 && i == 0) || ShouldRunBiCgStabSteps(i))
				{
					num4 = num3 / num2;
					num5 = 0.0;
				}
				else
				{
					double num6 = denseVector11.DotProduct(denseVector11);
					if (num6.AlmostEqualNumbersBetween(0.0, 1L))
					{
						num6 = 1.0;
					}
					double num7 = denseVector11.DotProduct(denseVector4);
					double num8 = denseVector7.DotProduct(denseVector11);
					double num9 = num2 * num6 - num8 * num8;
					num4 = (num6 * num3 - num7 * num8) / num9;
					num5 = (num2 * num7 - num8 * num3) / num9;
				}
				denseVector10.Multiply(scalar, denseVector14);
				denseVector5.Add(denseVector14, denseVector13);
				denseVector13.Subtract(denseVector2, denseVector15);
				denseVector15.CopyTo(denseVector13);
				denseVector13.Multiply(num5, denseVector13);
				denseVector9.Multiply(num4, denseVector14);
				denseVector13.Add(denseVector14, denseVector10);
				denseVector12.Multiply(num5, denseVector12);
				denseVector10.Multiply(0.0 - num, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector2.Multiply(num4, denseVector14);
				denseVector12.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector12);
				denseVector8.Multiply(num, denseVector14);
				denseVector.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector.Add(denseVector12, denseVector15);
				denseVector15.CopyTo(denseVector);
				denseVector2.CopyTo(denseVector5);
				denseVector11.Multiply(0.0 - num5, denseVector14);
				denseVector4.Add(denseVector14, denseVector2);
				denseVector7.Multiply(0.0 - num4, denseVector14);
				denseVector2.Add(denseVector14, denseVector15);
				denseVector15.CopyTo(denseVector2);
				scalar = ((!num4.AlmostEqualNumbersBetween(0.0, 1L)) ? (num / num4 * denseVector3.DotProduct(denseVector2) / denseVector3.DotProduct(denseVector5)) : 0.0);
				denseVector9.Multiply(scalar, denseVector14);
				denseVector7.Add(denseVector14, denseVector6);
				preconditioner.Approximate(denseVector, result);
				if (iterator.DetermineStatus(i, result, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, result, input);
				}
			}
		}
	}
	public sealed class ILU0Preconditioner : IPreconditioner<double>
	{
		private SparseMatrix _decompositionLU;

		internal Matrix<double> UpperTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = i; j < _decompositionLU.ColumnCount; j++)
				{
					sparseMatrix[i, j] = _decompositionLU[i, j];
				}
			}
			return sparseMatrix;
		}

		internal Matrix<double> LowerTriangle()
		{
			SparseMatrix sparseMatrix = new SparseMatrix(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j <= i; j++)
				{
					if (i == j)
					{
						sparseMatrix[i, j] = 1.0;
					}
					else
					{
						sparseMatrix[i, j] = _decompositionLU[i, j];
					}
				}
			}
			return sparseMatrix;
		}

		public void Initialize(Matrix<double> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			_decompositionLU = SparseMatrix.OfMatrix(matrix);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				for (int j = 0; j < i; j++)
				{
					if (_decompositionLU[i, j] == 0.0)
					{
						continue;
					}
					double num = _decompositionLU[i, j] / _decompositionLU[j, j];
					_decompositionLU[i, j] = num;
					if (_decompositionLU[j, i] != 0.0)
					{
						_decompositionLU[i, i] -= num * _decompositionLU[j, i];
					}
					for (int k = j + 1; k < _decompositionLU.RowCount; k++)
					{
						if (k != i && _decompositionLU[i, k] != 0.0)
						{
							_decompositionLU[i, k] -= num * _decompositionLU[j, k];
						}
					}
				}
			}
		}

		public void Approximate(Vector<double> rhs, Vector<double> lhs)
		{
			if (_decompositionLU == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _decompositionLU.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			DenseVector denseVector = new DenseVector(_decompositionLU.RowCount);
			for (int i = 0; i < _decompositionLU.RowCount; i++)
			{
				denseVector.Clear();
				_decompositionLU.Row(i, denseVector);
				double num = 0.0;
				for (int j = 0; j < i; j++)
				{
					num += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - num;
			}
			for (int num2 = _decompositionLU.RowCount - 1; num2 > -1; num2--)
			{
				_decompositionLU.Row(num2, denseVector);
				double num3 = 0.0;
				for (int num4 = _decompositionLU.RowCount - 1; num4 > num2; num4--)
				{
					num3 += denseVector[num4] * lhs[num4];
				}
				lhs[num2] = 1.0 / denseVector[num2] * (lhs[num2] - num3);
			}
		}
	}
	public sealed class ILUTPPreconditioner : IPreconditioner<double>
	{
		public const double DefaultFillLevel = 200.0;

		public const double DefaultDropTolerance = 0.0001;

		private SparseMatrix _upper;

		private SparseMatrix _lower;

		private int[] _pivots;

		private double _fillLevel = 200.0;

		private double _dropTolerance = 0.0001;

		private double _pivotTolerance;

		public double FillLevel
		{
			get
			{
				return _fillLevel;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_fillLevel = value;
			}
		}

		public double DropTolerance
		{
			get
			{
				return _dropTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dropTolerance = value;
			}
		}

		public double PivotTolerance
		{
			get
			{
				return _pivotTolerance;
			}
			set
			{
				if (value < 0.0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_pivotTolerance = value;
			}
		}

		public ILUTPPreconditioner()
		{
		}

		public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance)
		{
			if (fillLevel < 0.0)
			{
				throw new ArgumentOutOfRangeException("fillLevel");
			}
			if (dropTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("dropTolerance");
			}
			if (pivotTolerance < 0.0)
			{
				throw new ArgumentOutOfRangeException("pivotTolerance");
			}
			_fillLevel = fillLevel;
			_dropTolerance = dropTolerance;
			_pivotTolerance = pivotTolerance;
		}

		internal Matrix<double> UpperTriangle()
		{
			return _upper.Clone();
		}

		internal Matrix<double> LowerTriangle()
		{
			return _lower.Clone();
		}

		internal int[] Pivots()
		{
			int[] array = new int[_pivots.Length];
			for (int i = 0; i < _pivots.Length; i++)
			{
				array[i] = _pivots[i];
			}
			return array;
		}

		public void Initialize(Matrix<double> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			SparseMatrix sparseMatrix = (matrix as SparseMatrix) ?? SparseMatrix.OfMatrix(matrix);
			_lower = new SparseMatrix(sparseMatrix.RowCount);
			_upper = new SparseMatrix(sparseMatrix.RowCount);
			_pivots = new int[sparseMatrix.RowCount];
			for (int i = 0; i < _pivots.Length; i++)
			{
				_pivots[i] = i;
			}
			DenseVector denseVector = new DenseVector(sparseMatrix.RowCount);
			DenseVector denseVector2 = new DenseVector(sparseMatrix.ColumnCount);
			int[] array = new int[sparseMatrix.RowCount];
			int num = (int)_fillLevel * sparseMatrix.NonZerosCount;
			for (int j = 0; j < sparseMatrix.RowCount; j++)
			{
				sparseMatrix.Row(j, denseVector);
				PivotRow(denseVector);
				double num2 = denseVector.InfinityNorm();
				for (int k = 0; k < j; k++)
				{
					if (denseVector[k] == 0.0)
					{
						continue;
					}
					denseVector[k] /= _upper[k, k];
					if (Math.Abs(denseVector[k]) < _dropTolerance)
					{
						denseVector[k] = 0.0;
					}
					if (denseVector[k] != 0.0)
					{
						_upper.Row(k, denseVector2);
						for (int l = 0; l <= k; l++)
						{
							denseVector2[l] = 0.0;
						}
						denseVector2.Multiply(denseVector[k], denseVector2);
						denseVector.Subtract(denseVector2, denseVector);
					}
				}
				for (int m = j; m < sparseMatrix.RowCount; m++)
				{
					if (Math.Abs(denseVector[m]) <= _dropTolerance * num2)
					{
						denseVector[m] = 0.0;
					}
				}
				int num3 = num / (sparseMatrix.RowCount - j + 1);
				int num4 = num3 / 2;
				FindLargestItems(0, j - 1, array, denseVector);
				int num5 = 0;
				int num6 = 0;
				for (int n = 0; n < j; n++)
				{
					if (num6 > num4)
					{
						break;
					}
					if (array[n] == -1)
					{
						break;
					}
					_lower[j, array[n]] = denseVector[array[n]];
					num6++;
					num5++;
				}
				FindLargestItems(j + 1, sparseMatrix.RowCount - 1, array, denseVector);
				num4 = num3 - num5;
				int num7 = 0;
				num6 = 0;
				for (int num8 = 0; num8 < sparseMatrix.RowCount - j; num8++)
				{
					if (num6 > num4 - 1)
					{
						break;
					}
					if (array[num8] == -1)
					{
						break;
					}
					_upper[j, array[num8]] = denseVector[array[num8]];
					num6++;
					num7++;
				}
				_upper[j, j] = denseVector[j];
				if (j + 1 < sparseMatrix.RowCount - 1 && Math.Abs(denseVector[j]) < _pivotTolerance * Math.Abs(denseVector[array[0]]))
				{
					SwapColumns(_upper, j, array[0]);
					int num9 = _pivots[j];
					_pivots[j] = _pivots[array[0]];
					_pivots[array[0]] = num9;
				}
				num -= num5 + num7;
			}
			for (int num10 = 0; num10 < _lower.RowCount; num10++)
			{
				_lower[num10, num10] = 1.0;
			}
		}

		private void PivotRow(Vector<double> row)
		{
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			for (int i = 0; i < row.Count; i++)
			{
				if (_pivots[i] != i && !PivotMapFound(dictionary, i))
				{
					dictionary.Add(_pivots[i], i);
					double value = row[i];
					row[i] = row[_pivots[i]];
					row[_pivots[i]] = value;
				}
			}
		}

		private bool PivotMapFound(Dictionary<int, int> knownPivots, int currentItem)
		{
			if (knownPivots.ContainsKey(_pivots[currentItem]) && knownPivots[_pivots[currentItem]].Equals(currentItem))
			{
				return true;
			}
			if (knownPivots.ContainsKey(currentItem) && knownPivots[currentItem].Equals(_pivots[currentItem]))
			{
				return true;
			}
			return false;
		}

		private static void SwapColumns(Matrix<double> matrix, int firstColumn, int secondColumn)
		{
			for (int i = 0; i < matrix.RowCount; i++)
			{
				double value = matrix[i, firstColumn];
				matrix[i, firstColumn] = matrix[i, secondColumn];
				matrix[i, secondColumn] = value;
			}
		}

		private static void FindLargestItems(int lowerBound, int upperBound, int[] sortedIndices, Vector<double> values)
		{
			for (int i = 0; i < upperBound + 1 - lowerBound; i++)
			{
				sortedIndices[i] = lowerBound + i;
			}
			for (int j = upperBound + 1 - lowerBound; j < sortedIndices.Length; j++)
			{
				sortedIndices[j] = -1;
			}
			ILUTPElementSorter.SortDoubleIndicesDecreasing(0, upperBound - lowerBound, sortedIndices, values);
		}

		public void Approximate(Vector<double> rhs, Vector<double> lhs)
		{
			if (_upper == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (lhs.Count != rhs.Count || lhs.Count != _upper.RowCount)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "rhs");
			}
			DenseVector denseVector = new DenseVector(_lower.RowCount);
			for (int i = 0; i < _lower.RowCount; i++)
			{
				_lower.Row(i, denseVector);
				double num = 0.0;
				for (int j = 0; j < i; j++)
				{
					num += denseVector[j] * lhs[j];
				}
				lhs[i] = rhs[i] - num;
			}
			for (int num2 = _upper.RowCount - 1; num2 > -1; num2--)
			{
				_upper.Row(num2, denseVector);
				double num3 = 0.0;
				for (int num4 = _upper.RowCount - 1; num4 > num2; num4--)
				{
					num3 += denseVector[num4] * lhs[num4];
				}
				lhs[num2] = 1.0 / denseVector[num2] * (lhs[num2] - num3);
			}
			Vector<double> vector = lhs.Clone();
			Pivot(vector, lhs);
		}

		private void Pivot(Vector<double> vector, Vector<double> result)
		{
			for (int i = 0; i < _pivots.Length; i++)
			{
				result[i] = vector[_pivots[i]];
			}
		}
	}
	internal static class ILUTPElementSorter
	{
		public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, int[] sortedIndices, Vector<double> values)
		{
			if (lowerBound > 0)
			{
				for (int i = 0; i < upperBound - lowerBound + 1; i++)
				{
					Exchange(sortedIndices, i, i + lowerBound);
				}
				upperBound -= lowerBound;
				lowerBound = 0;
			}
			HeapSortDoublesIndices(lowerBound, upperBound, sortedIndices, values);
		}

		private static void HeapSortDoublesIndices(int lowerBound, int upperBound, int[] sortedIndices, Vector<double> values)
		{
			int start = (upperBound - lowerBound + 1) / 2 - 1 + lowerBound;
			int num = upperBound - lowerBound + 1 - 1 + lowerBound;
			BuildDoubleIndexHeap(start, upperBound - lowerBound + 1, sortedIndices, values);
			while (num >= lowerBound)
			{
				Exchange(sortedIndices, num, lowerBound);
				SiftDoubleIndices(sortedIndices, values, lowerBound, num);
				num--;
			}
		}

		private static void BuildDoubleIndexHeap(int start, int count, int[] sortedIndices, Vector<double> values)
		{
			while (start >= 0)
			{
				SiftDoubleIndices(sortedIndices, values, start, count);
				start--;
			}
		}

		private static void SiftDoubleIndices(int[] sortedIndices, Vector<double> values, int begin, int count)
		{
			int num = begin;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[sortedIndices[num2]] > values[sortedIndices[num2 + 1]])
				{
					num2++;
				}
				if (values[sortedIndices[num]] <= values[sortedIndices[num2]])
				{
					break;
				}
				Exchange(sortedIndices, num, num2);
				num = num2;
			}
		}

		public static void SortIntegersDecreasing(int[] values)
		{
			HeapSortIntegers(values, values.Length);
		}

		private static void HeapSortIntegers(int[] values, int count)
		{
			int start = count / 2 - 1;
			int num = count - 1;
			BuildHeap(values, start, count);
			while (num >= 0)
			{
				Exchange(values, num, 0);
				Sift(values, 0, num);
				num--;
			}
		}

		private static void BuildHeap(int[] values, int start, int count)
		{
			while (start >= 0)
			{
				Sift(values, start, count);
				start--;
			}
		}

		private static void Sift(int[] values, int start, int count)
		{
			int num = start;
			while (num * 2 < count)
			{
				int num2 = num * 2;
				if (num2 < count - 1 && values[num2] > values[num2 + 1])
				{
					num2++;
				}
				if (values[num] > values[num2])
				{
					Exchange(values, num, num2);
					num = num2;
					continue;
				}
				break;
			}
		}

		private static void Exchange(int[] values, int first, int second)
		{
			int num = values[first];
			values[first] = values[second];
			values[second] = num;
		}
	}
	public sealed class MILU0Preconditioner : IPreconditioner<double>
	{
		private double[] _alu;

		private int[] _jlu;

		private int[] _diag;

		public bool UseModified { get; set; }

		public bool IsInitialized { get; private set; }

		public MILU0Preconditioner(bool modified = true)
		{
			UseModified = modified;
		}

		public void Initialize(Matrix<double> matrix)
		{
			if (!(matrix.Storage is SparseCompressedRowMatrixStorage<double> sparseCompressedRowMatrixStorage))
			{
				throw new ArgumentException("Matrix must be in sparse storage format", "matrix");
			}
			int rowCount = sparseCompressedRowMatrixStorage.RowCount;
			if (rowCount != sparseCompressedRowMatrixStorage.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			double[] values = sparseCompressedRowMatrixStorage.Values;
			int[] columnIndices = sparseCompressedRowMatrixStorage.ColumnIndices;
			int[] rowPointers = sparseCompressedRowMatrixStorage.RowPointers;
			_alu = new double[rowPointers[rowCount] + 1];
			_jlu = new int[rowPointers[rowCount] + 1];
			_diag = new int[rowCount];
			int num = Compute(rowCount, values, columnIndices, rowPointers, _alu, _jlu, _diag, UseModified);
			if (num > -1)
			{
				throw new NumericalBreakdownException("Zero pivot encountered on row " + num + " during ILU process");
			}
			IsInitialized = true;
		}

		public void Approximate(Vector<double> input, Vector<double> result)
		{
			if (_alu == null)
			{
				throw new ArgumentException("The requested matrix does not exist.");
			}
			if (result.Count != input.Count || result.Count != _diag.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			int num = _diag.Length;
			for (int i = 0; i < num; i++)
			{
				result[i] = input[i];
				for (int j = _jlu[i]; j < _diag[i]; j++)
				{
					result[i] -= _alu[j] * result[_jlu[j]];
				}
			}
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				for (int k = _diag[num2]; k < _jlu[num2 + 1]; k++)
				{
					result[num2] -= _alu[k] * result[_jlu[k]];
				}
				result[num2] = _alu[num2] * result[num2];
			}
		}

		private int Compute(int n, double[] a, int[] ja, int[] ia, double[] alu, int[] jlu, int[] ju, bool modified)
		{
			int[] array = new int[n];
			int num = (jlu[0] = n + 1);
			for (int i = 0; i < n; i++)
			{
				array[i] = -1;
			}
			for (int i = 0; i < n; i++)
			{
				int num2 = num;
				for (int j = ia[i]; j < ia[i + 1]; j++)
				{
					int num3 = ja[j];
					if (num3 == i)
					{
						alu[i] = a[j];
						array[num3] = i;
						ju[i] = num;
					}
					else
					{
						alu[num] = a[j];
						jlu[num] = ja[j];
						array[num3] = num;
						num++;
					}
				}
				jlu[i + 1] = num;
				double num4 = 0.0;
				for (int j = num2; j < ju[i]; j++)
				{
					int num5 = jlu[j];
					double num6 = (alu[j] *= alu[num5]);
					for (int k = ju[num5]; k < jlu[num5 + 1]; k++)
					{
						int num7 = array[jlu[k]];
						if (num7 != -1)
						{
							alu[num7] -= num6 * alu[k];
						}
						else
						{
							num4 += num6 * alu[k];
						}
					}
				}
				if (modified)
				{
					alu[i] -= num4;
				}
				if (alu[i] == 0.0)
				{
					return i;
				}
				alu[i] = 1.0 / alu[i];
				array[i] = -1;
				for (int k = num2; k < num; k++)
				{
					array[jlu[k]] = -1;
				}
			}
			return -1;
		}
	}
	public sealed class MlkBiCgStab : IIterativeSolver<double>
	{
		private const int DefaultNumberOfStartingVectors = 50;

		private IList<Vector<double>> _startingVectors;

		private int _numberOfStartingVectors = 50;

		public int NumberOfStartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _numberOfStartingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value <= 1)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberOfStartingVectors = value;
			}
		}

		public IList<Vector<double>> StartingVectors
		{
			[DebuggerStepThrough]
			get
			{
				return _startingVectors;
			}
			[DebuggerStepThrough]
			set
			{
				if (value == null || value.Count == 0)
				{
					_startingVectors = null;
				}
				else
				{
					_startingVectors = value;
				}
			}
		}

		public void ResetNumberOfStartingVectors()
		{
			_numberOfStartingVectors = 50;
		}

		private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			return Math.Min(maximumNumberOfStartingVectors, numberOfVariables - 1);
		}

		private static IList<Vector<double>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables)
		{
			int columns = NumberOfStartingVectorsToCreate(maximumNumberOfStartingVectors, numberOfVariables);
			Normal normal = new Normal();
			DenseMatrix denseMatrix = new DenseMatrix(numberOfVariables, columns);
			for (int i = 0; i < denseMatrix.ColumnCount; i++)
			{
				double[] column = normal.Samples().Take(denseMatrix.RowCount).ToArray();
				denseMatrix.SetColumn(i, column);
			}
			Matrix<double> q = denseMatrix.GramSchmidt().Q;
			List<Vector<double>> list = new List<Vector<double>>(q.ColumnCount);
			for (int j = 0; j < q.ColumnCount; j++)
			{
				list.Add(q.Column(j));
				list[j].Multiply(1.0 / list[j].L2Norm(), list[j]);
			}
			return list;
		}

		private static Vector<double>[] CreateVectorArray(int arraySize, int vectorSize)
		{
			Vector<double>[] array = new Vector<double>[arraySize];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new DenseVector(vectorSize);
			}
			return array;
		}

		private static void CalculateTrueResidual(Matrix<double> matrix, Vector<double> residual, Vector<double> x, Vector<double> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1.0, residual);
			residual.Add(b, residual);
		}

		public void Solve(Matrix<double> matrix, Vector<double> input, Vector<double> result, Iterator<double> iterator, IPreconditioner<double> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<double>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<double>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			bool flag = false;
			if (_startingVectors != null && _startingVectors.Count <= NumberOfStartingVectorsToCreate(_numberOfStartingVectors, input.Count) && _startingVectors[0].Count == input.Count)
			{
				flag = true;
			}
			_startingVectors = (flag ? _startingVectors : CreateStartingVectors(_numberOfStartingVectors, input.Count));
			int count = _startingVectors.Count;
			DenseVector denseVector2 = new DenseVector(matrix.RowCount);
			CalculateTrueResidual(matrix, denseVector2, denseVector, input);
			double[] array = new double[count];
			DenseVector denseVector3 = new DenseVector(denseVector2.Count);
			DenseVector denseVector4 = new DenseVector(denseVector2.Count);
			DenseVector denseVector5 = new DenseVector(denseVector2.Count);
			DenseVector denseVector6 = new DenseVector(denseVector2.Count);
			DenseVector denseVector7 = new DenseVector(denseVector2.Count);
			DenseVector denseVector8 = new DenseVector(denseVector2.Count);
			DenseVector denseVector9 = new DenseVector(denseVector2.Count);
			DenseVector denseVector10 = new DenseVector(denseVector2.Count);
			DenseVector denseVector11 = new DenseVector(denseVector2.Count);
			Vector<double>[] array2 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			Vector<double>[] array3 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			denseVector2.CopyTo(array3[count - 1]);
			Vector<double>[] array4 = CreateVectorArray(_startingVectors.Count, denseVector2.Count);
			for (int i = 0; iterator.DetermineStatus(i, denseVector, input, denseVector2) == IterationStatus.Continue; i++)
			{
				preconditioner.Approximate(array3[count - 1], denseVector3);
				matrix.Multiply(denseVector3, array4[count - 1]);
				array[count - 1] = _startingVectors[0].DotProduct(array4[count - 1]);
				if (array[count - 1].AlmostEqualNumbersBetween(0.0, 1L))
				{
					throw new NumericalBreakdownException();
				}
				double num = _startingVectors[0].DotProduct(denseVector2) / array[count - 1];
				array4[count - 1].Multiply(0.0 - num, denseVector6);
				denseVector2.Add(denseVector6, denseVector4);
				preconditioner.Approximate(denseVector4, denseVector7);
				denseVector7.CopyTo(denseVector5);
				matrix.Multiply(denseVector7, denseVector6);
				double num2 = denseVector6.DotProduct(denseVector6);
				if (num2.AlmostEqualNumbersBetween(0.0, 1L))
				{
					num2 = 1.0;
				}
				num2 = (0.0 - denseVector4.DotProduct(denseVector6)) / num2;
				denseVector4.CopyTo(denseVector2);
				denseVector6.Multiply(num2, denseVector6);
				denseVector2.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector2);
				denseVector5.Multiply(0.0 - num2, denseVector6);
				denseVector.Add(denseVector6, denseVector8);
				denseVector8.CopyTo(denseVector);
				denseVector3.Multiply(num, denseVector3);
				denseVector.Add(denseVector3, denseVector8);
				denseVector8.CopyTo(denseVector);
				if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
				{
					CalculateTrueResidual(matrix, denseVector2, denseVector, input);
					if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
					{
						break;
					}
				}
				for (int j = 0; j < count; j++)
				{
					denseVector4.CopyTo(denseVector9);
					denseVector2.CopyTo(denseVector10);
					denseVector11.Clear();
					double scalar;
					if (i >= 1)
					{
						for (int k = j; k < count - 1; k++)
						{
							scalar = (0.0 - _startingVectors[k + 1].DotProduct(denseVector9)) / array[k];
							array2[k].Multiply(scalar, denseVector6);
							denseVector9.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector9);
							array3[k].Multiply(scalar, denseVector6);
							denseVector10.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector10);
							array4[k].Multiply(scalar, denseVector6);
							denseVector11.Add(denseVector6, denseVector8);
							denseVector8.CopyTo(denseVector11);
						}
					}
					scalar = num2 * array[count - 1];
					if (scalar.AlmostEqualNumbersBetween(0.0, 1L))
					{
						throw new NumericalBreakdownException();
					}
					denseVector11.Multiply(num2, denseVector8);
					denseVector2.Add(denseVector8, denseVector6);
					scalar = (0.0 - _startingVectors[0].DotProduct(denseVector6)) / scalar;
					array3[count - 1].Multiply(scalar, denseVector6);
					denseVector10.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector10);
					array4[count - 1].Multiply(scalar, denseVector6);
					denseVector11.Add(denseVector6, denseVector8);
					denseVector8.CopyTo(denseVector11);
					denseVector11.Multiply(num2, denseVector11);
					denseVector2.Add(denseVector11, denseVector9);
					for (int l = 0; l < j - 1; l++)
					{
						scalar = (0.0 - _startingVectors[l + 1].DotProduct(denseVector9)) / array[l];
						array2[l].Multiply(scalar, denseVector6);
						denseVector9.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector9);
						array3[l].Multiply(scalar, denseVector6);
						denseVector10.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector10);
					}
					denseVector9.Subtract(denseVector4, array2[j]);
					denseVector10.Add(denseVector11, array3[j]);
					if (j < count - 1)
					{
						array[j] = _startingVectors[j + 1].DotProduct(array2[j]);
						if (array[j].AlmostEqualNumbersBetween(0.0, 1L))
						{
							throw new NumericalBreakdownException();
						}
						num = _startingVectors[j + 1].DotProduct(denseVector4) / array[j];
						array2[j].Multiply(0.0 - num, denseVector6);
						denseVector4.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector4);
						preconditioner.Approximate(array3[j], denseVector3);
						denseVector3.Multiply(num2 * num, denseVector6);
						denseVector.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector);
						matrix.Multiply(denseVector3, array4[j]);
						array4[j].Multiply((0.0 - num2) * num, denseVector6);
						denseVector2.Add(denseVector6, denseVector8);
						denseVector8.CopyTo(denseVector2);
						if (iterator.DetermineStatus(i, denseVector, input, denseVector2) != 0)
						{
							CalculateTrueResidual(matrix, denseVector2, denseVector, input);
						}
					}
				}
			}
			denseVector.CopyTo(result);
		}
	}
	public sealed class TFQMR : IIterativeSolver<double>
	{
		private static void CalculateTrueResidual(Matrix<double> matrix, Vector<double> residual, Vector<double> x, Vector<double> b)
		{
			matrix.Multiply(x, residual);
			residual.Multiply(-1.0, residual);
			residual.Add(b, residual);
		}

		private static bool IsEven(int number)
		{
			return number % 2 == 0;
		}

		public void Solve(Matrix<double> matrix, Vector<double> input, Vector<double> result, Iterator<double> iterator, IPreconditioner<double> preconditioner)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.", "matrix");
			}
			if (result.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != matrix.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, matrix);
			}
			if (iterator == null)
			{
				iterator = new Iterator<double>();
			}
			if (preconditioner == null)
			{
				preconditioner = new UnitPreconditioner<double>();
			}
			preconditioner.Initialize(matrix);
			DenseVector denseVector = new DenseVector(input.Count);
			DenseVector other = DenseVector.OfVector(input);
			DenseVector denseVector2 = new DenseVector(input.Count);
			DenseVector denseVector3 = new DenseVector(input.Count);
			DenseVector denseVector4 = new DenseVector(input.Count);
			DenseVector denseVector5 = DenseVector.OfVector(input);
			DenseVector denseVector6 = new DenseVector(input.Count);
			DenseVector denseVector7 = new DenseVector(input.Count);
			DenseVector denseVector8 = DenseVector.OfVector(input);
			DenseVector denseVector9 = new DenseVector(input.Count);
			DenseVector denseVector10 = new DenseVector(input.Count);
			DenseVector denseVector11 = new DenseVector(input.Count);
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = input.L2Norm();
			double num5 = num4 * num4;
			preconditioner.Approximate(denseVector8, denseVector9);
			matrix.Multiply(denseVector9, denseVector4);
			denseVector4.CopyTo(denseVector3);
			for (int i = 0; iterator.DetermineStatus(i, result, input, denseVector5) == IterationStatus.Continue; i++)
			{
				if (IsEven(i))
				{
					double num6 = denseVector4.DotProduct(other);
					if (num6.AlmostEqualNumbersBetween(0.0, 1L))
					{
						iterator.Cancel();
						break;
					}
					num = num5 / num6;
					denseVector4.Multiply(0.0 - num, denseVector10);
					denseVector8.Add(denseVector10, denseVector7);
					preconditioner.Approximate(denseVector7, denseVector9);
					matrix.Multiply(denseVector9, denseVector2);
				}
				DenseVector obj = (IsEven(i) ? denseVector3 : denseVector2);
				DenseVector denseVector12 = (IsEven(i) ? denseVector8 : denseVector7);
				obj.Multiply(0.0 - num, denseVector10);
				denseVector5.Add(denseVector10, denseVector11);
				denseVector11.CopyTo(denseVector5);
				denseVector.Multiply(num3 * num3 * num2 / num, denseVector9);
				denseVector12.Add(denseVector9, denseVector);
				num3 = denseVector5.L2Norm() / num4;
				double num7 = 1.0 / Math.Sqrt(1.0 + num3 * num3);
				num4 *= num3 * num7;
				num2 = num7 * num7 * num;
				denseVector.Multiply(num2, denseVector10);
				denseVector6.Add(denseVector10, denseVector11);
				denseVector11.CopyTo(denseVector6);
				if (iterator.DetermineStatus(i, result, input, denseVector5) != 0)
				{
					preconditioner.Approximate(denseVector6, result);
					CalculateTrueResidual(matrix, denseVector9, result, input);
					if (iterator.DetermineStatus(i, result, input, denseVector9) != 0)
					{
						break;
					}
				}
				if (!IsEven(i))
				{
					if (num5.AlmostEqualNumbersBetween(0.0, 1L))
					{
						iterator.Cancel();
						break;
					}
					double num8 = denseVector5.DotProduct(other);
					double scalar = num8 / num5;
					num5 = num8;
					denseVector7.Multiply(scalar, denseVector10);
					denseVector5.Add(denseVector10, denseVector8);
					preconditioner.Approximate(denseVector8, denseVector9);
					matrix.Multiply(denseVector9, denseVector3);
					denseVector4.Multiply(scalar, denseVector10);
					denseVector2.Add(denseVector10, denseVector9);
					denseVector9.Multiply(scalar, denseVector10);
					denseVector3.Add(denseVector10, denseVector4);
				}
				preconditioner.Approximate(denseVector6, result);
			}
		}
	}
}
namespace MathNet.Numerics.LinearAlgebra.Double.Factorization
{
	internal abstract class Cholesky : Cholesky<double>
	{
		public override double Determinant
		{
			get
			{
				double num = 1.0;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					double num2 = base.Factor.At(i, i);
					num *= num2 * num2;
				}
				return num;
			}
		}

		public override double DeterminantLn
		{
			get
			{
				double num = 0.0;
				for (int i = 0; i < base.Factor.RowCount; i++)
				{
					num += 2.0 * Math.Log(base.Factor.At(i, i));
				}
				return num;
			}
		}

		protected Cholesky(Matrix<double> factor)
			: base(factor)
		{
		}
	}
	internal sealed class DenseCholesky : Cholesky
	{
		public static DenseCholesky Create(DenseMatrix matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix.Values, denseMatrix.RowCount);
			return new DenseCholesky(denseMatrix);
		}

		private DenseCholesky(Matrix<double> factor)
			: base(factor)
		{
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Buffer.BlockCopy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length * 8);
				DenseMatrix denseMatrix3 = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix3.Values, denseMatrix3.RowCount, denseMatrix2.Values, denseMatrix2.ColumnCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Buffer.BlockCopy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length * 8);
				DenseMatrix denseMatrix = (DenseMatrix)base.Factor;
				LinearAlgebraControl.Provider.CholeskySolveFactored(denseMatrix.Values, denseMatrix.RowCount, denseVector2.Values, 1);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense vectors at the moment.");
		}

		public override void Factorize(Matrix<double> matrix)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			if (matrix is DenseMatrix denseMatrix)
			{
				DenseMatrix denseMatrix2 = (DenseMatrix)base.Factor;
				Buffer.BlockCopy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length * 8);
				LinearAlgebraControl.Provider.CholeskyFactor(denseMatrix2.Values, denseMatrix2.RowCount);
				return;
			}
			throw new NotSupportedException("Can only do Cholesky factorization for dense matrices at the moment.");
		}
	}
	internal sealed class DenseEvd : Evd
	{
		public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			DenseMatrix denseMatrix = new DenseMatrix(rowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(rowCount);
			MathNet.Numerics.LinearAlgebra.Complex.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Complex.DenseVector(rowCount);
			bool isSymmetric;
			switch (symmetricity)
			{
			case Symmetricity.Symmetric:
			case Symmetricity.Hermitian:
				isSymmetric = true;
				break;
			case Symmetricity.Asymmetric:
				isSymmetric = false;
				break;
			default:
				isSymmetric = matrix.IsSymmetric();
				break;
			}
			LinearAlgebraControl.Provider.EigenDecomp(isSymmetric, rowCount, matrix.Values, denseMatrix.Values, denseVector.Values, denseMatrix2.Values);
			return new DenseEvd(denseMatrix, denseVector, denseMatrix2, isSymmetric);
		}

		private DenseEvd(Matrix<double> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<double> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				double[] array = new double[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						double num = 0.0;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								num += ((DenseMatrix)base.EigenVectors).Values[j * count + k] * input.At(k, i);
							}
							num /= base.EigenValues[j].Real;
						}
						array[j] = num;
					}
					for (int l = 0; l < count; l++)
					{
						double num2 = 0.0;
						for (int m = 0; m < count; m++)
						{
							num2 += ((DenseMatrix)base.EigenVectors).Values[m * count + l] * array[m];
						}
						result.At(l, i, num2);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				double[] array = new double[count];
				for (int i = 0; i < count; i++)
				{
					double num = 0.0;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							num += ((DenseMatrix)base.EigenVectors).Values[i * count + j] * input[j];
						}
						num /= base.EigenValues[i].Real;
					}
					array[i] = num;
				}
				for (int k = 0; k < count; k++)
				{
					double num = 0.0;
					for (int l = 0; l < count; l++)
					{
						num += ((DenseMatrix)base.EigenVectors).Values[l * count + k] * array[l];
					}
					result[k] = num;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class DenseGramSchmidt : GramSchmidt
	{
		public static DenseGramSchmidt Create(Matrix<double> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount, matrix.ColumnCount);
			Factorize(denseMatrix.Values, denseMatrix.RowCount, denseMatrix.ColumnCount, denseMatrix2.Values);
			return new DenseGramSchmidt(denseMatrix, denseMatrix2);
		}

		private DenseGramSchmidt(Matrix<double> q, Matrix<double> rFull)
			: base(q, rFull)
		{
		}

		private static void Factorize(double[] q, int rowsQ, int columnsQ, double[] r)
		{
			for (int i = 0; i < columnsQ; i++)
			{
				double num = 0.0;
				for (int j = 0; j < rowsQ; j++)
				{
					num += q[i * rowsQ + j] * q[i * rowsQ + j];
				}
				num = Math.Sqrt(num);
				if (num == 0.0)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				r[i * columnsQ + i] = num;
				for (int k = 0; k < rowsQ; k++)
				{
					q[i * rowsQ + k] /= num;
				}
				for (int l = i + 1; l < columnsQ; l++)
				{
					int num2 = i;
					int num3 = l;
					double num4 = 0.0;
					for (int m = 0; m < rowsQ; m++)
					{
						num4 += q[num2 * rowsQ + m] * q[num3 * rowsQ + m];
					}
					r[l * columnsQ + i] = num4;
					for (int n = 0; n < rowsQ; n++)
					{
						q[l * rowsQ + n] -= q[i * rowsQ + n] * num4;
					}
				}
			}
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, null, denseVector.Values, 1, denseVector2.Values, QRMethod.Thin);
				return;
			}
			throw new NotSupportedException("Can only do GramSchmidt factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseLU : LU
	{
		public static DenseLU Create(DenseMatrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int[] array = new int[matrix.RowCount];
			DenseMatrix denseMatrix = (DenseMatrix)matrix.Clone();
			LinearAlgebraControl.Provider.LUFactor(denseMatrix.Values, denseMatrix.RowCount, array);
			return new DenseLU(denseMatrix, array);
		}

		private DenseLU(Matrix<double> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				Buffer.BlockCopy(denseMatrix.Values, 0, denseMatrix2.Values, 0, denseMatrix.Values.Length * 8);
				DenseMatrix denseMatrix3 = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(input.ColumnCount, denseMatrix3.Values, denseMatrix3.RowCount, Pivots, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				Buffer.BlockCopy(denseVector.Values, 0, denseVector2.Values, 0, denseVector.Values.Length * 8);
				DenseMatrix denseMatrix = (DenseMatrix)Factors;
				LinearAlgebraControl.Provider.LUSolveFactored(1, denseMatrix.Values, denseMatrix.RowCount, Pivots, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do LU factorization for dense vectors at the moment.");
		}

		public override Matrix<double> Inverse()
		{
			DenseMatrix denseMatrix = (DenseMatrix)Factors.Clone();
			LinearAlgebraControl.Provider.LUInverseFactored(denseMatrix.Values, denseMatrix.RowCount, Pivots);
			return denseMatrix;
		}
	}
	internal sealed class DenseQR : QR
	{
		private double[] Tau { get; set; }

		public static DenseQR Create(DenseMatrix matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			double[] tau = new double[Math.Min(matrix.RowCount, matrix.ColumnCount)];
			Matrix<double> matrix2;
			Matrix<double> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = new DenseMatrix(matrix.RowCount);
				LinearAlgebraControl.Provider.QRFactor(((DenseMatrix)matrix2).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix3).Values, tau);
			}
			else
			{
				matrix3 = matrix.Clone();
				matrix2 = new DenseMatrix(matrix.ColumnCount);
				LinearAlgebraControl.Provider.ThinQRFactor(((DenseMatrix)matrix3).Values, matrix.RowCount, matrix.ColumnCount, ((DenseMatrix)matrix2).Values, tau);
			}
			return new DenseQR(matrix3, matrix2, method, tau);
		}

		private DenseQR(Matrix<double> q, Matrix<double> rFull, QRMethod method, double[] tau)
			: base(q, rFull, method)
		{
			Tau = tau;
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.QRSolveFactored(((DenseMatrix)base.Q).Values, ((DenseMatrix)FullR).Values, base.Q.RowCount, FullR.ColumnCount, Tau, denseVector.Values, 1, denseVector2.Values, Method);
				return;
			}
			throw new NotSupportedException("Can only do QR factorization for dense vectors at the moment.");
		}
	}
	internal sealed class DenseSvd : Svd
	{
		public static DenseSvd Create(DenseMatrix matrix, bool computeVectors)
		{
			DenseVector denseVector = new DenseVector(Math.Min(matrix.RowCount, matrix.ColumnCount));
			DenseMatrix denseMatrix = new DenseMatrix(matrix.RowCount);
			DenseMatrix denseMatrix2 = new DenseMatrix(matrix.ColumnCount);
			LinearAlgebraControl.Provider.SingularValueDecomposition(computeVectors, ((DenseMatrix)matrix.Clone()).Values, matrix.RowCount, matrix.ColumnCount, denseVector.Values, denseMatrix.Values, denseMatrix2.Values);
			return new DenseSvd(denseVector, denseMatrix, denseMatrix2, computeVectors);
		}

		private DenseSvd(Vector<double> s, Matrix<double> u, Matrix<double> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input is DenseMatrix denseMatrix && result is DenseMatrix denseMatrix2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseMatrix.Values, input.ColumnCount, denseMatrix2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense matrices at the moment.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			if (input is DenseVector denseVector && result is DenseVector denseVector2)
			{
				LinearAlgebraControl.Provider.SvdSolveFactored(base.U.RowCount, base.VT.ColumnCount, ((DenseVector)base.S).Values, ((DenseMatrix)base.U).Values, ((DenseMatrix)base.VT).Values, denseVector.Values, 1, denseVector2.Values);
				return;
			}
			throw new NotSupportedException("Can only do SVD factorization for dense vectors at the moment.");
		}
	}
	internal abstract class Evd : Evd<double>
	{
		public override double Determinant
		{
			get
			{
				System.Numerics.Complex one = System.Numerics.Complex.One;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					one *= base.EigenValues[i];
					if (base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						return 0.0;
					}
				}
				return one.Magnitude;
			}
		}

		public override int Rank
		{
			get
			{
				int num = 0;
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (!base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						num++;
					}
				}
				return num;
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < base.EigenValues.Count; i++)
				{
					if (base.EigenValues[i].AlmostEqual(System.Numerics.Complex.Zero))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected Evd(Matrix<double> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<double> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}
	}
	internal abstract class GramSchmidt : GramSchmidt<double>
	{
		public override double Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				double num = 1.0;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					num *= FullR.At(i, i);
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0.0))
					{
						return 0.0;
					}
				}
				return Convert.ToSingle(Math.Abs(num));
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0.0))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected GramSchmidt(Matrix<double> q, Matrix<double> rFull)
			: base(q, rFull)
		{
		}
	}
	internal abstract class LU : LU<double>
	{
		public override double Determinant
		{
			get
			{
				double num = 1.0;
				for (int i = 0; i < Factors.RowCount; i++)
				{
					num = ((Pivots[i] == i) ? (num * Factors.At(i, i)) : (num * (0.0 - Factors.At(i, i))));
				}
				return num;
			}
		}

		protected LU(Matrix<double> factors, int[] pivots)
			: base(factors, pivots)
		{
		}
	}
	internal abstract class QR : QR<double>
	{
		public override double Determinant
		{
			get
			{
				if (FullR.RowCount != FullR.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				double num = 1.0;
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					num *= FullR.At(i, i);
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0.0))
					{
						return 0.0;
					}
				}
				return Math.Abs(num);
			}
		}

		public override bool IsFullRank
		{
			get
			{
				for (int i = 0; i < FullR.ColumnCount; i++)
				{
					if (Math.Abs(FullR.At(i, i)).AlmostEqual(0.0))
					{
						return false;
					}
				}
				return true;
			}
		}

		protected QR(Matrix<double> q, Matrix<double> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}
	}
	internal abstract class Svd : Svd<double>
	{
		public override int Rank
		{
			get
			{
				double tolerance = base.S.Maximum().EpsilonOf() * (double)Math.Max(base.U.RowCount, base.VT.RowCount);
				return base.S.Count((double t) => Math.Abs(t) > tolerance);
			}
		}

		public override double L2Norm => Math.Abs(base.S[0]);

		public override double ConditionNumber
		{
			get
			{
				int index = Math.Min(base.U.RowCount, base.VT.ColumnCount) - 1;
				return Math.Abs(base.S[0]) / Math.Abs(base.S[index]);
			}
		}

		public override double Determinant
		{
			get
			{
				if (base.U.RowCount != base.VT.ColumnCount)
				{
					throw new ArgumentException("Matrix must be square.");
				}
				double num = 1.0;
				foreach (double item in (IEnumerable<double>)base.S)
				{
					num *= item;
					if (Math.Abs(item).AlmostEqual(0.0))
					{
						return 0.0;
					}
				}
				return Math.Abs(num);
			}
		}

		protected Svd(Vector<double> s, Matrix<double> u, Matrix<double> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}
	}
	internal sealed class UserCholesky : Cholesky
	{
		private static void DoCholesky(Matrix<double> factor)
		{
			if (factor.RowCount != factor.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			double[] array = new double[factor.RowCount];
			for (int i = 0; i < factor.RowCount; i++)
			{
				double num = factor.At(i, i);
				if (num > 0.0)
				{
					num = Math.Sqrt(num);
					factor.At(i, i, num);
					array[i] = num;
					for (int j = i + 1; j < factor.RowCount; j++)
					{
						factor.At(j, i, factor.At(j, i) / num);
						array[j] = factor.At(j, i);
					}
					DoCholeskyStep(factor, factor.RowCount, i + 1, factor.RowCount, array, Control.MaxDegreeOfParallelism);
					for (int k = i + 1; k < factor.RowCount; k++)
					{
						factor.At(i, k, 0.0);
					}
					continue;
				}
				throw new ArgumentException("Matrix must be positive definite.");
			}
		}

		public static UserCholesky Create(Matrix<double> matrix)
		{
			Matrix<double> factor = matrix.Clone();
			DoCholesky(factor);
			return new UserCholesky(factor);
		}

		public override void Factorize(Matrix<double> matrix)
		{
			if (matrix.RowCount != base.Factor.RowCount || matrix.ColumnCount != base.Factor.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(matrix, base.Factor);
			}
			matrix.CopyTo(base.Factor);
			DoCholesky(base.Factor);
		}

		private UserCholesky(Matrix<double> factor)
			: base(factor)
		{
		}

		private static void DoCholeskyStep(Matrix<double> data, int rowDim, int firstCol, int colLimit, double[] multipliers, int availableCores)
		{
			int num = colLimit - firstCol;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = firstCol + num / 3;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					DoCholeskyStep(data, rowDim, firstCol, tmpSplit, multipliers, tmpCores);
				}, delegate
				{
					DoCholeskyStep(data, rowDim, tmpSplit, colLimit, multipliers, tmpCores);
				});
				return;
			}
			for (int i = firstCol; i < colLimit; i++)
			{
				double num2 = multipliers[i];
				for (int j = i; j < rowDim; j++)
				{
					data.At(j, i, data.At(j, i) - multipliers[j] * num2);
				}
			}
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != base.Factor.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < result.ColumnCount; i++)
			{
				for (int j = 0; j < rowCount; j++)
				{
					double num = result.At(j, i);
					for (int num2 = j - 1; num2 >= 0; num2--)
					{
						num -= base.Factor.At(j, num2) * result.At(num2, i);
					}
					result.At(j, i, num / base.Factor.At(j, j));
				}
				for (int num3 = rowCount - 1; num3 >= 0; num3--)
				{
					double num = result.At(num3, i);
					for (int k = num3 + 1; k < rowCount; k++)
					{
						num -= base.Factor.At(k, num3) * result.At(k, i);
					}
					result.At(num3, i, num / base.Factor.At(num3, num3));
				}
			}
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != base.Factor.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, base.Factor);
			}
			input.CopyTo(result);
			int rowCount = base.Factor.RowCount;
			for (int i = 0; i < rowCount; i++)
			{
				double num = result[i];
				for (int num2 = i - 1; num2 >= 0; num2--)
				{
					num -= base.Factor.At(i, num2) * result[num2];
				}
				result[i] = num / base.Factor.At(i, i);
			}
			for (int num3 = rowCount - 1; num3 >= 0; num3--)
			{
				double num = result[num3];
				for (int j = num3 + 1; j < rowCount; j++)
				{
					num -= base.Factor.At(j, num3) * result[j];
				}
				result[num3] = num / base.Factor.At(num3, num3);
			}
		}
	}
	internal sealed class UserEvd : Evd
	{
		public static UserEvd Create(Matrix<double> matrix, Symmetricity symmetricity)
		{
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			Matrix<double> matrix2 = Matrix<double>.Build.SameAs(matrix, rowCount, rowCount, fullyMutable: true);
			Matrix<double> matrix3 = Matrix<double>.Build.SameAs(matrix, rowCount, rowCount);
			MathNet.Numerics.LinearAlgebra.Complex.DenseVector denseVector = new MathNet.Numerics.LinearAlgebra.Complex.DenseVector(rowCount);
			bool flag;
			switch (symmetricity)
			{
			case Symmetricity.Symmetric:
			case Symmetricity.Hermitian:
				flag = true;
				break;
			case Symmetricity.Asymmetric:
				flag = false;
				break;
			default:
				flag = matrix.IsSymmetric();
				break;
			}
			double[] array = new double[rowCount];
			double[] array2 = new double[rowCount];
			if (flag)
			{
				matrix.CopyTo(matrix2);
				array = matrix2.Row(rowCount - 1).ToArray();
				SymmetricTridiagonalize(matrix2, array, array2, rowCount);
				SymmetricDiagonalize(matrix2, array, array2, rowCount);
			}
			else
			{
				double[,] matrixH = matrix.ToArray();
				NonsymmetricReduceToHessenberg(matrix2, matrixH, rowCount);
				NonsymmetricReduceHessenberToRealSchur(matrix2, matrixH, array, array2, rowCount);
			}
			for (int i = 0; i < rowCount; i++)
			{
				matrix3.At(i, i, array[i]);
				if (array2[i] > 0.0)
				{
					matrix3.At(i, i + 1, array2[i]);
				}
				else if (array2[i] < 0.0)
				{
					matrix3.At(i, i - 1, array2[i]);
				}
			}
			for (int j = 0; j < rowCount; j++)
			{
				denseVector[j] = new System.Numerics.Complex(array[j], array2[j]);
			}
			return new UserEvd(matrix2, denseVector, matrix3, flag);
		}

		private UserEvd(Matrix<double> eigenVectors, Vector<System.Numerics.Complex> eigenValues, Matrix<double> blockDiagonal, bool isSymmetric)
			: base(eigenVectors, eigenValues, blockDiagonal, isSymmetric)
		{
		}

		private static void SymmetricTridiagonalize(Matrix<double> eigenVectors, double[] d, double[] e, int order)
		{
			for (int num = order - 1; num > 0; num--)
			{
				double num2 = 0.0;
				double num3 = 0.0;
				for (int i = 0; i < num; i++)
				{
					num2 += Math.Abs(d[i]);
				}
				if (num2 == 0.0)
				{
					e[num] = d[num - 1];
					for (int j = 0; j < num; j++)
					{
						d[j] = eigenVectors.At(num - 1, j);
						eigenVectors.At(num, j, 0.0);
						eigenVectors.At(j, num, 0.0);
					}
				}
				else
				{
					for (int k = 0; k < num; k++)
					{
						d[k] /= num2;
						num3 += d[k] * d[k];
					}
					double num4 = d[num - 1];
					double num5 = Math.Sqrt(num3);
					if (num4 > 0.0)
					{
						num5 = 0.0 - num5;
					}
					e[num] = num2 * num5;
					num3 -= num4 * num5;
					d[num - 1] = num4 - num5;
					for (int l = 0; l < num; l++)
					{
						e[l] = 0.0;
					}
					for (int m = 0; m < num; m++)
					{
						num4 = d[m];
						eigenVectors.At(m, num, num4);
						num5 = e[m] + eigenVectors.At(m, m) * num4;
						for (int n = m + 1; n <= num - 1; n++)
						{
							num5 += eigenVectors.At(n, m) * d[n];
							e[n] += eigenVectors.At(n, m) * num4;
						}
						e[m] = num5;
					}
					num4 = 0.0;
					for (int num6 = 0; num6 < num; num6++)
					{
						e[num6] /= num3;
						num4 += e[num6] * d[num6];
					}
					double num7 = num4 / (num3 + num3);
					for (int num8 = 0; num8 < num; num8++)
					{
						e[num8] -= num7 * d[num8];
					}
					for (int num9 = 0; num9 < num; num9++)
					{
						num4 = d[num9];
						num5 = e[num9];
						for (int num10 = num9; num10 <= num - 1; num10++)
						{
							eigenVectors.At(num10, num9, eigenVectors.At(num10, num9) - num4 * e[num10] - num5 * d[num10]);
						}
						d[num9] = eigenVectors.At(num - 1, num9);
						eigenVectors.At(num, num9, 0.0);
					}
				}
				d[num] = num3;
			}
			for (int num11 = 0; num11 < order - 1; num11++)
			{
				eigenVectors.At(order - 1, num11, eigenVectors.At(num11, num11));
				eigenVectors.At(num11, num11, 1.0);
				double num12 = d[num11 + 1];
				if (num12 != 0.0)
				{
					for (int num13 = 0; num13 <= num11; num13++)
					{
						d[num13] = eigenVectors.At(num13, num11 + 1) / num12;
					}
					for (int num14 = 0; num14 <= num11; num14++)
					{
						double num15 = 0.0;
						for (int num16 = 0; num16 <= num11; num16++)
						{
							num15 += eigenVectors.At(num16, num11 + 1) * eigenVectors.At(num16, num14);
						}
						for (int num17 = 0; num17 <= num11; num17++)
						{
							eigenVectors.At(num17, num14, eigenVectors.At(num17, num14) - num15 * d[num17]);
						}
					}
				}
				for (int num18 = 0; num18 <= num11; num18++)
				{
					eigenVectors.At(num18, num11 + 1, 0.0);
				}
			}
			for (int num19 = 0; num19 < order; num19++)
			{
				d[num19] = eigenVectors.At(order - 1, num19);
				eigenVectors.At(order - 1, num19, 0.0);
			}
			eigenVectors.At(order - 1, order - 1, 1.0);
			e[0] = 0.0;
		}

		private static void SymmetricDiagonalize(Matrix<double> eigenVectors, double[] d, double[] e, int order)
		{
			for (int i = 1; i < order; i++)
			{
				e[i - 1] = e[i];
			}
			e[order - 1] = 0.0;
			double num = 0.0;
			double num2 = 0.0;
			double doublePrecision = Precision.DoublePrecision;
			for (int j = 0; j < order; j++)
			{
				num2 = Math.Max(num2, Math.Abs(d[j]) + Math.Abs(e[j]));
				int k;
				for (k = j; k < order && !(Math.Abs(e[k]) <= doublePrecision * num2); k++)
				{
				}
				if (k > j)
				{
					int num3 = 0;
					do
					{
						num3++;
						double num4 = d[j];
						double num5 = (d[j + 1] - num4) / (2.0 * e[j]);
						double num6 = SpecialFunctions.Hypotenuse(num5, 1.0);
						if (num5 < 0.0)
						{
							num6 = 0.0 - num6;
						}
						d[j] = e[j] / (num5 + num6);
						d[j + 1] = e[j] * (num5 + num6);
						double num7 = d[j + 1];
						double num8 = num4 - d[j];
						for (int l = j + 2; l < order; l++)
						{
							d[l] -= num8;
						}
						num += num8;
						num5 = d[k];
						double num9 = 1.0;
						double num10 = num9;
						double num11 = num9;
						double num12 = e[j + 1];
						double num13 = 0.0;
						double num14 = 0.0;
						for (int num15 = k - 1; num15 >= j; num15--)
						{
							num11 = num10;
							num10 = num9;
							num14 = num13;
							num4 = num9 * e[num15];
							num8 = num9 * num5;
							num6 = SpecialFunctions.Hypotenuse(num5, e[num15]);
							e[num15 + 1] = num13 * num6;
							num13 = e[num15] / num6;
							num9 = num5 / num6;
							num5 = num9 * d[num15] - num13 * num4;
							d[num15 + 1] = num8 + num13 * (num9 * num4 + num13 * d[num15]);
							for (int m = 0; m < order; m++)
							{
								num8 = eigenVectors.At(m, num15 + 1);
								eigenVectors.At(m, num15 + 1, num13 * eigenVectors.At(m, num15) + num9 * num8);
								eigenVectors.At(m, num15, num9 * eigenVectors.At(m, num15) - num13 * num8);
							}
						}
						num5 = (0.0 - num13) * num14 * num11 * num12 * e[j] / num7;
						e[j] = num13 * num5;
						d[j] = num9 * num5;
						if (num3 >= 1000)
						{
							throw new NonConvergenceException();
						}
					}
					while (Math.Abs(e[j]) > doublePrecision * num2);
				}
				d[j] += num;
				e[j] = 0.0;
			}
			for (int n = 0; n < order - 1; n++)
			{
				int num16 = n;
				double num17 = d[n];
				for (int num18 = n + 1; num18 < order; num18++)
				{
					if (d[num18] < num17)
					{
						num16 = num18;
						num17 = d[num18];
					}
				}
				if (num16 != n)
				{
					d[num16] = d[n];
					d[n] = num17;
					for (int num19 = 0; num19 < order; num19++)
					{
						num17 = eigenVectors.At(num19, n);
						eigenVectors.At(num19, n, eigenVectors.At(num19, num16));
						eigenVectors.At(num19, num16, num17);
					}
				}
			}
		}

		private static void NonsymmetricReduceToHessenberg(Matrix<double> eigenVectors, double[,] matrixH, int order)
		{
			double[] array = new double[order];
			for (int i = 1; i < order - 1; i++)
			{
				double num = 0.0;
				for (int j = i; j < order; j++)
				{
					num += Math.Abs(matrixH[j, i - 1]);
				}
				if (num == 0.0)
				{
					continue;
				}
				double num2 = 0.0;
				for (int num3 = order - 1; num3 >= i; num3--)
				{
					array[num3] = matrixH[num3, i - 1] / num;
					num2 += array[num3] * array[num3];
				}
				double num4 = Math.Sqrt(num2);
				if (array[i] > 0.0)
				{
					num4 = 0.0 - num4;
				}
				num2 -= array[i] * num4;
				array[i] -= num4;
				for (int k = i; k < order; k++)
				{
					double num5 = 0.0;
					for (int num6 = order - 1; num6 >= i; num6--)
					{
						num5 += array[num6] * matrixH[num6, k];
					}
					num5 /= num2;
					for (int l = i; l < order; l++)
					{
						matrixH[l, k] -= num5 * array[l];
					}
				}
				for (int m = 0; m < order; m++)
				{
					double num7 = 0.0;
					for (int num8 = order - 1; num8 >= i; num8--)
					{
						num7 += array[num8] * matrixH[m, num8];
					}
					num7 /= num2;
					for (int n = i; n < order; n++)
					{
						matrixH[m, n] -= num7 * array[n];
					}
				}
				array[i] = num * array[i];
				matrixH[i, i - 1] = num * num4;
			}
			for (int num9 = 0; num9 < order; num9++)
			{
				for (int num10 = 0; num10 < order; num10++)
				{
					eigenVectors.At(num9, num10, (num9 == num10) ? 1.0 : 0.0);
				}
			}
			for (int num11 = order - 2; num11 >= 1; num11--)
			{
				if (matrixH[num11, num11 - 1] != 0.0)
				{
					for (int num12 = num11 + 1; num12 < order; num12++)
					{
						array[num12] = matrixH[num12, num11 - 1];
					}
					for (int num13 = num11; num13 < order; num13++)
					{
						double num14 = 0.0;
						for (int num15 = num11; num15 < order; num15++)
						{
							num14 += array[num15] * eigenVectors.At(num15, num13);
						}
						num14 = num14 / array[num11] / matrixH[num11, num11 - 1];
						for (int num16 = num11; num16 < order; num16++)
						{
							eigenVectors.At(num16, num13, eigenVectors.At(num16, num13) + num14 * array[num16]);
						}
					}
				}
			}
		}

		private static void NonsymmetricReduceHessenberToRealSchur(Matrix<double> eigenVectors, double[,] matrixH, double[] d, double[] e, int order)
		{
			int num = order - 1;
			double doublePrecision = Precision.DoublePrecision;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = 0.0;
			double num7 = 0.0;
			double num8 = 0.0;
			for (int i = 0; i < order; i++)
			{
				for (int j = Math.Max(i - 1, 0); j < order; j++)
				{
					num8 += Math.Abs(matrixH[i, j]);
				}
			}
			int num9 = 0;
			while (num >= 0)
			{
				int num10;
				for (num10 = num; num10 > 0; num10--)
				{
					num6 = Math.Abs(matrixH[num10 - 1, num10 - 1]) + Math.Abs(matrixH[num10, num10]);
					if (num6 == 0.0)
					{
						num6 = num8;
					}
					if (Math.Abs(matrixH[num10, num10 - 1]) < doublePrecision * num6)
					{
						break;
					}
				}
				if (num10 == num)
				{
					matrixH[num, num] += num2;
					d[num] = matrixH[num, num];
					e[num] = 0.0;
					num--;
					num9 = 0;
					continue;
				}
				double num12;
				double num11;
				if (num10 == num - 1)
				{
					num11 = matrixH[num, num - 1] * matrixH[num - 1, num];
					num3 = (matrixH[num - 1, num - 1] - matrixH[num, num]) / 2.0;
					num4 = num3 * num3 + num11;
					num7 = Math.Sqrt(Math.Abs(num4));
					matrixH[num, num] += num2;
					matrixH[num - 1, num - 1] += num2;
					num12 = matrixH[num, num];
					if (num4 >= 0.0)
					{
						num7 = ((!(num3 >= 0.0)) ? (num3 - num7) : (num3 + num7));
						d[num - 1] = num12 + num7;
						d[num] = d[num - 1];
						if (num7 != 0.0)
						{
							d[num] = num12 - num11 / num7;
						}
						e[num - 1] = 0.0;
						e[num] = 0.0;
						num12 = matrixH[num, num - 1];
						num6 = Math.Abs(num12) + Math.Abs(num7);
						num3 = num12 / num6;
						num4 = num7 / num6;
						num5 = Math.Sqrt(num3 * num3 + num4 * num4);
						num3 /= num5;
						num4 /= num5;
						for (int k = num - 1; k < order; k++)
						{
							num7 = matrixH[num - 1, k];
							matrixH[num - 1, k] = num4 * num7 + num3 * matrixH[num, k];
							matrixH[num, k] = num4 * matrixH[num, k] - num3 * num7;
						}
						for (int l = 0; l <= num; l++)
						{
							num7 = matrixH[l, num - 1];
							matrixH[l, num - 1] = num4 * num7 + num3 * matrixH[l, num];
							matrixH[l, num] = num4 * matrixH[l, num] - num3 * num7;
						}
						for (int m = 0; m < order; m++)
						{
							num7 = eigenVectors.At(m, num - 1);
							eigenVectors.At(m, num - 1, num4 * num7 + num3 * eigenVectors.At(m, num));
							eigenVectors.At(m, num, num4 * eigenVectors.At(m, num) - num3 * num7);
						}
					}
					else
					{
						d[num - 1] = num12 + num3;
						d[num] = num12 + num3;
						e[num - 1] = num7;
						e[num] = 0.0 - num7;
					}
					num -= 2;
					num9 = 0;
					continue;
				}
				num12 = matrixH[num, num];
				double num13 = 0.0;
				num11 = 0.0;
				if (num10 < num)
				{
					num13 = matrixH[num - 1, num - 1];
					num11 = matrixH[num, num - 1] * matrixH[num - 1, num];
				}
				if (num9 == 10)
				{
					num2 += num12;
					for (int n = 0; n <= num; n++)
					{
						matrixH[n, n] -= num12;
					}
					num6 = Math.Abs(matrixH[num, num - 1]) + Math.Abs(matrixH[num - 1, num - 2]);
					num12 = (num13 = 0.75 * num6);
					num11 = -0.4375 * num6 * num6;
				}
				if (num9 == 30)
				{
					num6 = (num13 - num12) / 2.0;
					num6 = num6 * num6 + num11;
					if (num6 > 0.0)
					{
						num6 = Math.Sqrt(num6);
						if (num13 < num12)
						{
							num6 = 0.0 - num6;
						}
						num6 = num12 - num11 / ((num13 - num12) / 2.0 + num6);
						for (int num14 = 0; num14 <= num; num14++)
						{
							matrixH[num14, num14] -= num6;
						}
						num2 += num6;
						num12 = (num13 = (num11 = 0.964));
					}
				}
				num9++;
				int num15;
				for (num15 = num - 2; num15 >= num10; num15--)
				{
					num7 = matrixH[num15, num15];
					num5 = num12 - num7;
					num6 = num13 - num7;
					num3 = (num5 * num6 - num11) / matrixH[num15 + 1, num15] + matrixH[num15, num15 + 1];
					num4 = matrixH[num15 + 1, num15 + 1] - num7 - num5 - num6;
					num5 = matrixH[num15 + 2, num15 + 1];
					num6 = Math.Abs(num3) + Math.Abs(num4) + Math.Abs(num5);
					num3 /= num6;
					num4 /= num6;
					num5 /= num6;
					if (num15 == num10 || Math.Abs(matrixH[num15, num15 - 1]) * (Math.Abs(num4) + Math.Abs(num5)) < doublePrecision * (Math.Abs(num3) * (Math.Abs(matrixH[num15 - 1, num15 - 1]) + Math.Abs(num7) + Math.Abs(matrixH[num15 + 1, num15 + 1]))))
					{
						break;
					}
				}
				for (int num16 = num15 + 2; num16 <= num; num16++)
				{
					matrixH[num16, num16 - 2] = 0.0;
					if (num16 > num15 + 2)
					{
						matrixH[num16, num16 - 3] = 0.0;
					}
				}
				for (int num17 = num15; num17 <= num - 1; num17++)
				{
					bool flag = num17 != num - 1;
					if (num17 != num15)
					{
						num3 = matrixH[num17, num17 - 1];
						num4 = matrixH[num17 + 1, num17 - 1];
						num5 = (flag ? matrixH[num17 + 2, num17 - 1] : 0.0);
						num12 = Math.Abs(num3) + Math.Abs(num4) + Math.Abs(num5);
						if (num12 != 0.0)
						{
							num3 /= num12;
							num4 /= num12;
							num5 /= num12;
						}
					}
					if (num12 == 0.0)
					{
						break;
					}
					num6 = Math.Sqrt(num3 * num3 + num4 * num4 + num5 * num5);
					if (num3 < 0.0)
					{
						num6 = 0.0 - num6;
					}
					if (num6 == 0.0)
					{
						continue;
					}
					if (num17 != num15)
					{
						matrixH[num17, num17 - 1] = (0.0 - num6) * num12;
					}
					else if (num10 != num15)
					{
						matrixH[num17, num17 - 1] = 0.0 - matrixH[num17, num17 - 1];
					}
					num3 += num6;
					num12 = num3 / num6;
					num13 = num4 / num6;
					num7 = num5 / num6;
					num4 /= num3;
					num5 /= num3;
					for (int num18 = num17; num18 < order; num18++)
					{
						num3 = matrixH[num17, num18] + num4 * matrixH[num17 + 1, num18];
						if (flag)
						{
							num3 += num5 * matrixH[num17 + 2, num18];
							matrixH[num17 + 2, num18] -= num3 * num7;
						}
						matrixH[num17, num18] -= num3 * num12;
						matrixH[num17 + 1, num18] -= num3 * num13;
					}
					for (int num19 = 0; num19 <= Math.Min(num, num17 + 3); num19++)
					{
						num3 = num12 * matrixH[num19, num17] + num13 * matrixH[num19, num17 + 1];
						if (flag)
						{
							num3 += num7 * matrixH[num19, num17 + 2];
							matrixH[num19, num17 + 2] -= num3 * num5;
						}
						matrixH[num19, num17] -= num3;
						matrixH[num19, num17 + 1] -= num3 * num4;
					}
					for (int num20 = 0; num20 < order; num20++)
					{
						num3 = num12 * eigenVectors.At(num20, num17) + num13 * eigenVectors.At(num20, num17 + 1);
						if (flag)
						{
							num3 += num7 * eigenVectors.At(num20, num17 + 2);
							eigenVectors.At(num20, num17 + 2, eigenVectors.At(num20, num17 + 2) - num3 * num5);
						}
						eigenVectors.At(num20, num17, eigenVectors.At(num20, num17) - num3);
						eigenVectors.At(num20, num17 + 1, eigenVectors.At(num20, num17 + 1) - num3 * num4);
					}
				}
			}
			if (num8 == 0.0)
			{
				return;
			}
			for (num = order - 1; num >= 0; num--)
			{
				num3 = d[num];
				num4 = e[num];
				if (num4 == 0.0)
				{
					int num21 = num;
					matrixH[num, num] = 1.0;
					for (int num22 = num - 1; num22 >= 0; num22--)
					{
						double num11 = matrixH[num22, num22] - num3;
						num5 = 0.0;
						for (int num23 = num21; num23 <= num; num23++)
						{
							num5 += matrixH[num22, num23] * matrixH[num23, num];
						}
						if (e[num22] < 0.0)
						{
							num7 = num11;
							num6 = num5;
						}
						else
						{
							num21 = num22;
							double num24;
							if (e[num22] == 0.0)
							{
								if (num11 != 0.0)
								{
									matrixH[num22, num] = (0.0 - num5) / num11;
								}
								else
								{
									matrixH[num22, num] = (0.0 - num5) / (doublePrecision * num8);
								}
							}
							else
							{
								double num12 = matrixH[num22, num22 + 1];
								double num13 = matrixH[num22 + 1, num22];
								num4 = (d[num22] - num3) * (d[num22] - num3) + e[num22] * e[num22];
								num24 = (matrixH[num22, num] = (num12 * num6 - num7 * num5) / num4);
								if (Math.Abs(num12) > Math.Abs(num7))
								{
									matrixH[num22 + 1, num] = (0.0 - num5 - num11 * num24) / num12;
								}
								else
								{
									matrixH[num22 + 1, num] = (0.0 - num6 - num13 * num24) / num7;
								}
							}
							num24 = Math.Abs(matrixH[num22, num]);
							if (doublePrecision * num24 * num24 > 1.0)
							{
								for (int num25 = num22; num25 <= num; num25++)
								{
									matrixH[num25, num] /= num24;
								}
							}
						}
					}
				}
				else if (num4 < 0.0)
				{
					int num26 = num - 1;
					if (Math.Abs(matrixH[num, num - 1]) > Math.Abs(matrixH[num - 1, num]))
					{
						matrixH[num - 1, num - 1] = num4 / matrixH[num, num - 1];
						matrixH[num - 1, num] = (0.0 - (matrixH[num, num] - num3)) / matrixH[num, num - 1];
					}
					else
					{
						System.Numerics.Complex complex = Cdiv(0.0, 0.0 - matrixH[num - 1, num], matrixH[num - 1, num - 1] - num3, num4);
						matrixH[num - 1, num - 1] = complex.Real;
						matrixH[num - 1, num] = complex.Imaginary;
					}
					matrixH[num, num - 1] = 0.0;
					matrixH[num, num] = 1.0;
					for (int num27 = num - 2; num27 >= 0; num27--)
					{
						double num28 = 0.0;
						double num29 = 0.0;
						for (int num30 = num26; num30 <= num; num30++)
						{
							num28 += matrixH[num27, num30] * matrixH[num30, num - 1];
							num29 += matrixH[num27, num30] * matrixH[num30, num];
						}
						double num11 = matrixH[num27, num27] - num3;
						if (e[num27] < 0.0)
						{
							num7 = num11;
							num5 = num28;
							num6 = num29;
						}
						else
						{
							num26 = num27;
							if (e[num27] == 0.0)
							{
								System.Numerics.Complex complex2 = Cdiv(0.0 - num28, 0.0 - num29, num11, num4);
								matrixH[num27, num - 1] = complex2.Real;
								matrixH[num27, num] = complex2.Imaginary;
							}
							else
							{
								double num12 = matrixH[num27, num27 + 1];
								double num13 = matrixH[num27 + 1, num27];
								double num31 = (d[num27] - num3) * (d[num27] - num3) + e[num27] * e[num27] - num4 * num4;
								double num32 = (d[num27] - num3) * 2.0 * num4;
								if (num31 == 0.0 && num32 == 0.0)
								{
									num31 = doublePrecision * num8 * (Math.Abs(num11) + Math.Abs(num4) + Math.Abs(num12) + Math.Abs(num13) + Math.Abs(num7));
								}
								System.Numerics.Complex complex3 = Cdiv(num12 * num5 - num7 * num28 + num4 * num29, num12 * num6 - num7 * num29 - num4 * num28, num31, num32);
								matrixH[num27, num - 1] = complex3.Real;
								matrixH[num27, num] = complex3.Imaginary;
								if (Math.Abs(num12) > Math.Abs(num7) + Math.Abs(num4))
								{
									matrixH[num27 + 1, num - 1] = (0.0 - num28 - num11 * matrixH[num27, num - 1] + num4 * matrixH[num27, num]) / num12;
									matrixH[num27 + 1, num] = (0.0 - num29 - num11 * matrixH[num27, num] - num4 * matrixH[num27, num - 1]) / num12;
								}
								else
								{
									complex3 = Cdiv(0.0 - num5 - num13 * matrixH[num27, num - 1], 0.0 - num6 - num13 * matrixH[num27, num], num7, num4);
									matrixH[num27 + 1, num - 1] = complex3.Real;
									matrixH[num27 + 1, num] = complex3.Imaginary;
								}
							}
							double num24 = Math.Max(Math.Abs(matrixH[num27, num - 1]), Math.Abs(matrixH[num27, num]));
							if (doublePrecision * num24 * num24 > 1.0)
							{
								for (int num33 = num27; num33 <= num; num33++)
								{
									matrixH[num33, num - 1] /= num24;
									matrixH[num33, num] /= num24;
								}
							}
						}
					}
				}
			}
			for (int num34 = order - 1; num34 >= 0; num34--)
			{
				for (int num35 = 0; num35 < order; num35++)
				{
					num7 = 0.0;
					for (int num36 = 0; num36 <= num34; num36++)
					{
						num7 += eigenVectors.At(num35, num36) * matrixH[num36, num34];
					}
					eigenVectors.At(num35, num34, num7);
				}
			}
		}

		private static System.Numerics.Complex Cdiv(double xreal, double ximag, double yreal, double yimag)
		{
			if (Math.Abs(yimag) < Math.Abs(yreal))
			{
				return new System.Numerics.Complex((xreal + ximag * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)), (ximag - xreal * (yimag / yreal)) / (yreal + yimag * (yimag / yreal)));
			}
			return new System.Numerics.Complex((ximag + xreal * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)), (0.0 - xreal + ximag * (yreal / yimag)) / (yimag + yreal * (yreal / yimag)));
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.EigenValues.Count != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.EigenValues.Count != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				double[] array = new double[count];
				for (int i = 0; i < count; i++)
				{
					for (int j = 0; j < count; j++)
					{
						double num = 0.0;
						if (j < count)
						{
							for (int k = 0; k < count; k++)
							{
								num += base.EigenVectors.At(k, j) * input.At(k, i);
							}
							num /= base.EigenValues[j].Real;
						}
						array[j] = num;
					}
					for (int l = 0; l < count; l++)
					{
						double num2 = 0.0;
						for (int m = 0; m < count; m++)
						{
							num2 += base.EigenVectors.At(l, m) * array[m];
						}
						result.At(l, i, num2);
					}
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (base.EigenValues.Count != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.EigenValues.Count != result.Count)
			{
				throw new ArgumentException("Matrix dimensions must agree.");
			}
			if (base.IsSymmetric)
			{
				int count = base.EigenValues.Count;
				double[] array = new double[count];
				for (int i = 0; i < count; i++)
				{
					double num = 0.0;
					if (i < count)
					{
						for (int j = 0; j < count; j++)
						{
							num += base.EigenVectors.At(j, i) * input[j];
						}
						num /= base.EigenValues[i].Real;
					}
					array[i] = num;
				}
				for (int k = 0; k < count; k++)
				{
					double num = 0.0;
					for (int l = 0; l < count; l++)
					{
						num += base.EigenVectors.At(k, l) * array[l];
					}
					result[k] = num;
				}
				return;
			}
			throw new ArgumentException("Matrix must be symmetric.");
		}
	}
	internal sealed class UserGramSchmidt : GramSchmidt
	{
		public static UserGramSchmidt Create(Matrix<double> matrix)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			Matrix<double> matrix2 = matrix.Clone();
			Matrix<double> matrix3 = Matrix<double>.Build.SameAs(matrix, matrix.ColumnCount, matrix.ColumnCount, fullyMutable: true);
			for (int i = 0; i < matrix2.ColumnCount; i++)
			{
				double num = matrix2.Column(i).L2Norm();
				if (num == 0.0)
				{
					throw new ArgumentException("Matrix must not be rank deficient.");
				}
				matrix3.At(i, i, num);
				for (int j = 0; j < matrix2.RowCount; j++)
				{
					matrix2.At(j, i, matrix2.At(j, i) / num);
				}
				for (int k = i + 1; k < matrix2.ColumnCount; k++)
				{
					double num2 = matrix2.Column(i).DotProduct(matrix2.Column(k));
					matrix3.At(i, k, num2);
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						double value = matrix2.At(l, k) - matrix2.At(l, i) * num2;
						matrix2.At(l, k, value);
					}
				}
			}
			return new UserGramSchmidt(matrix2, matrix3);
		}

		private UserGramSchmidt(Matrix<double> q, Matrix<double> rFull)
			: base(q, rFull)
		{
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.Q.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.Q.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<double> matrix = input.Clone();
			double[] array = new double[base.Q.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < base.Q.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < base.Q.ColumnCount; k++)
				{
					double num = 0.0;
					for (int l = 0; l < base.Q.RowCount; l++)
					{
						num += base.Q.At(l, k) * array[l];
					}
					matrix.At(k, i, num);
				}
			}
			for (int num2 = base.Q.ColumnCount - 1; num2 >= 0; num2--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num2, m, matrix.At(num2, m) / FullR.At(num2, num2));
				}
				for (int n = 0; n < num2; n++)
				{
					for (int num3 = 0; num3 < input.ColumnCount; num3++)
					{
						matrix.At(n, num3, matrix.At(n, num3) - matrix.At(num2, num3) * FullR.At(n, num2));
					}
				}
			}
			for (int num4 = 0; num4 < FullR.ColumnCount; num4++)
			{
				for (int num5 = 0; num5 < input.ColumnCount; num5++)
				{
					result.At(num4, num5, matrix.At(num4, num5));
				}
			}
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (base.Q.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.Q.ColumnCount != result.Count)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(base.Q, result);
			}
			Vector<double> vector = input.Clone();
			double[] array = new double[base.Q.RowCount];
			for (int i = 0; i < base.Q.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < base.Q.ColumnCount; j++)
			{
				double num = 0.0;
				for (int k = 0; k < base.Q.RowCount; k++)
				{
					num += base.Q.At(k, j) * array[k];
				}
				vector[j] = num;
			}
			for (int num2 = base.Q.ColumnCount - 1; num2 >= 0; num2--)
			{
				vector[num2] /= FullR.At(num2, num2);
				for (int l = 0; l < num2; l++)
				{
					vector[l] -= vector[num2] * FullR.At(l, num2);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserLU : LU
	{
		public static UserLU Create(Matrix<double> matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (matrix.RowCount != matrix.ColumnCount)
			{
				throw new ArgumentException("Matrix must be square.");
			}
			int rowCount = matrix.RowCount;
			Matrix<double> matrix2 = matrix.Clone();
			int[] array = new int[rowCount];
			for (int i = 0; i < rowCount; i++)
			{
				array[i] = i;
			}
			double[] array2 = new double[rowCount];
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = 0; k < rowCount; k++)
				{
					array2[k] = matrix2.At(k, j);
				}
				for (int l = 0; l < rowCount; l++)
				{
					int num = Math.Min(l, j);
					double num2 = 0.0;
					for (int m = 0; m < num; m++)
					{
						num2 += matrix2.At(l, m) * array2[m];
					}
					array2[l] -= num2;
					matrix2.At(l, j, array2[l]);
				}
				int num3 = j;
				for (int n = j + 1; n < rowCount; n++)
				{
					if (Math.Abs(array2[n]) > Math.Abs(array2[num3]))
					{
						num3 = n;
					}
				}
				if (num3 != j)
				{
					for (int num4 = 0; num4 < rowCount; num4++)
					{
						double value = matrix2.At(num3, num4);
						matrix2.At(num3, num4, matrix2.At(j, num4));
						matrix2.At(j, num4, value);
					}
					array[j] = num3;
				}
				if ((j < rowCount) & (matrix2.At(j, j) != 0.0))
				{
					for (int num5 = j + 1; num5 < rowCount; num5++)
					{
						matrix2.At(num5, j, matrix2.At(num5, j) / matrix2.At(j, j));
					}
				}
			}
			return new UserLU(matrix2, array);
		}

		private UserLU(Matrix<double> factors, int[] pivots)
			: base(factors, pivots)
		{
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (result.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (result.ColumnCount != input.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (input.RowCount != Factors.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int row = Pivots[i];
					for (int j = 0; j < result.ColumnCount; j++)
					{
						double value = result.At(row, j);
						result.At(row, j, result.At(i, j));
						result.At(i, j, value);
					}
				}
			}
			int rowCount = Factors.RowCount;
			for (int k = 0; k < rowCount; k++)
			{
				for (int l = k + 1; l < rowCount; l++)
				{
					for (int m = 0; m < result.ColumnCount; m++)
					{
						double num = result.At(k, m) * Factors.At(l, k);
						result.At(l, m, result.At(l, m) - num);
					}
				}
			}
			for (int num2 = rowCount - 1; num2 >= 0; num2--)
			{
				for (int n = 0; n < result.ColumnCount; n++)
				{
					result.At(num2, n, result.At(num2, n) / Factors.At(num2, num2));
				}
				for (int num3 = 0; num3 < num2; num3++)
				{
					for (int num4 = 0; num4 < result.ColumnCount; num4++)
					{
						double num5 = result.At(num2, num4) * Factors.At(num3, num2);
						result.At(num3, num4, result.At(num3, num4) - num5);
					}
				}
			}
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			if (input.Count != result.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (input.Count != Factors.RowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(input, Factors);
			}
			input.CopyTo(result);
			for (int i = 0; i < Pivots.Length; i++)
			{
				if (Pivots[i] != i)
				{
					int index = Pivots[i];
					double value = result[index];
					result[index] = result[i];
					result[i] = value;
				}
			}
			int rowCount = Factors.RowCount;
			for (int j = 0; j < rowCount; j++)
			{
				for (int k = j + 1; k < rowCount; k++)
				{
					result[k] -= result[j] * Factors.At(k, j);
				}
			}
			for (int num = rowCount - 1; num >= 0; num--)
			{
				result[num] /= Factors.At(num, num);
				for (int l = 0; l < num; l++)
				{
					result[l] -= result[num] * Factors.At(l, num);
				}
			}
		}

		public override Matrix<double> Inverse()
		{
			int rowCount = Factors.RowCount;
			Matrix<double> matrix = Matrix<double>.Build.SameAs(Factors, rowCount, rowCount);
			for (int i = 0; i < rowCount; i++)
			{
				matrix.At(i, i, 1.0);
			}
			return Solve(matrix);
		}
	}
	internal sealed class UserQR : QR
	{
		public static UserQR Create(Matrix<double> matrix, QRMethod method = QRMethod.Full)
		{
			if (matrix.RowCount < matrix.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(matrix);
			}
			int num = Math.Min(matrix.RowCount, matrix.ColumnCount);
			double[][] array = new double[num][];
			Matrix<double> matrix2;
			Matrix<double> matrix3;
			if (method == QRMethod.Full)
			{
				matrix2 = matrix.Clone();
				matrix3 = Matrix<double>.Build.SameAs(matrix, matrix.RowCount, matrix.RowCount, fullyMutable: true);
				for (int i = 0; i < matrix.RowCount; i++)
				{
					matrix3.At(i, i, 1.0);
				}
				for (int j = 0; j < num; j++)
				{
					array[j] = GenerateColumn(matrix2, j, j);
					ComputeQR(array[j], matrix2, j, matrix.RowCount, j + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					ComputeQR(array[num2], matrix3, num2, matrix.RowCount, num2, matrix.RowCount, Control.MaxDegreeOfParallelism);
				}
			}
			else
			{
				matrix3 = matrix.Clone();
				for (int k = 0; k < num; k++)
				{
					array[k] = GenerateColumn(matrix3, k, k);
					ComputeQR(array[k], matrix3, k, matrix.RowCount, k + 1, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
				matrix2 = matrix3.SubMatrix(0, matrix.ColumnCount, 0, matrix.ColumnCount);
				matrix3.Clear();
				for (int l = 0; l < matrix.ColumnCount; l++)
				{
					matrix3.At(l, l, 1.0);
				}
				for (int num3 = num - 1; num3 >= 0; num3--)
				{
					ComputeQR(array[num3], matrix3, num3, matrix.RowCount, num3, matrix.ColumnCount, Control.MaxDegreeOfParallelism);
				}
			}
			return new UserQR(matrix3, matrix2, method);
		}

		private UserQR(Matrix<double> q, Matrix<double> rFull, QRMethod method)
			: base(q, rFull, method)
		{
		}

		private static double[] GenerateColumn(Matrix<double> a, int row, int column)
		{
			int num = a.RowCount - row;
			double[] array = new double[num];
			for (int i = row; i < a.RowCount; i++)
			{
				array[i - row] = a.At(i, row);
				a.At(i, row, 0.0);
			}
			double d = array.Sum((double t) => t * t);
			d = Math.Sqrt(d);
			if (row == a.RowCount - 1 || d == 0.0)
			{
				a.At(row, column, 0.0 - array[0]);
				array[0] = 1.4142135623730951;
				return array;
			}
			double num2 = 1.0 / d;
			if (array[0] < 0.0)
			{
				num2 *= -1.0;
			}
			a.At(row, column, -1.0 / num2);
			for (int j = 0; j < num; j++)
			{
				array[j] *= num2;
			}
			array[0] += 1.0;
			double num3 = Math.Sqrt(1.0 / array[0]);
			for (int k = 0; k < num; k++)
			{
				array[k] *= num3;
			}
			return array;
		}

		private static void ComputeQR(double[] u, Matrix<double> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores)
		{
			if (rowDim < rowStart || columnDim < columnStart)
			{
				return;
			}
			int num = columnDim - columnStart;
			if (availableCores > 1 && num > 200)
			{
				int tmpSplit = columnStart + num / 2;
				int tmpCores = availableCores / 2;
				CommonParallel.Invoke(delegate
				{
					ComputeQR(u, a, rowStart, rowDim, columnStart, tmpSplit, tmpCores);
				}, delegate
				{
					ComputeQR(u, a, rowStart, rowDim, tmpSplit, columnDim, tmpCores);
				});
				return;
			}
			for (int i = columnStart; i < columnDim; i++)
			{
				double num2 = 0.0;
				for (int j = rowStart; j < rowDim; j++)
				{
					num2 += u[j - rowStart] * a.At(j, i);
				}
				for (int k = rowStart; k < rowDim; k++)
				{
					a.At(k, i, a.At(k, i) - u[k - rowStart] * num2);
				}
			}
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (FullR.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (FullR.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			Matrix<double> matrix = input.Clone();
			double[] array = new double[FullR.RowCount];
			for (int i = 0; i < input.ColumnCount; i++)
			{
				for (int j = 0; j < FullR.RowCount; j++)
				{
					array[j] = matrix.At(j, i);
				}
				for (int k = 0; k < FullR.RowCount; k++)
				{
					double num = 0.0;
					for (int l = 0; l < FullR.RowCount; l++)
					{
						num += base.Q.At(l, k) * array[l];
					}
					matrix.At(k, i, num);
				}
			}
			for (int num2 = FullR.ColumnCount - 1; num2 >= 0; num2--)
			{
				for (int m = 0; m < input.ColumnCount; m++)
				{
					matrix.At(num2, m, matrix.At(num2, m) / FullR.At(num2, num2));
				}
				for (int n = 0; n < num2; n++)
				{
					for (int num3 = 0; num3 < input.ColumnCount; num3++)
					{
						matrix.At(n, num3, matrix.At(n, num3) - matrix.At(num2, num3) * FullR.At(n, num2));
					}
				}
			}
			for (int num4 = 0; num4 < FullR.ColumnCount; num4++)
			{
				for (int num5 = 0; num5 < matrix.ColumnCount; num5++)
				{
					result.At(num4, num5, matrix.At(num4, num5));
				}
			}
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (FullR.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (FullR.ColumnCount != result.Count)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(FullR, result);
			}
			Vector<double> vector = input.Clone();
			double[] array = new double[FullR.RowCount];
			for (int i = 0; i < FullR.RowCount; i++)
			{
				array[i] = vector[i];
			}
			for (int j = 0; j < FullR.RowCount; j++)
			{
				double num = 0.0;
				for (int k = 0; k < FullR.RowCount; k++)
				{
					num += base.Q.At(k, j) * array[k];
				}
				vector[j] = num;
			}
			for (int num2 = FullR.ColumnCount - 1; num2 >= 0; num2--)
			{
				vector[num2] /= FullR.At(num2, num2);
				for (int l = 0; l < num2; l++)
				{
					vector[l] -= vector[num2] * FullR.At(l, num2);
				}
			}
			for (int m = 0; m < FullR.ColumnCount; m++)
			{
				result[m] = vector[m];
			}
		}
	}
	internal sealed class UserSvd : Svd
	{
		public static UserSvd Create(Matrix<double> matrix, bool computeVectors)
		{
			int num = Math.Min(matrix.RowCount + 1, matrix.ColumnCount);
			Matrix<double> matrix2 = matrix.Clone();
			Vector<double> vector = Vector<double>.Build.SameAs(matrix2, num);
			Matrix<double> matrix3 = Matrix<double>.Build.SameAs(matrix2, matrix2.RowCount, matrix2.RowCount, fullyMutable: true);
			Matrix<double> matrix4 = Matrix<double>.Build.SameAs(matrix2, matrix2.ColumnCount, matrix2.ColumnCount, fullyMutable: true);
			double[] array = new double[matrix2.ColumnCount];
			double[] array2 = new double[matrix2.RowCount];
			int rowCount = matrix2.RowCount;
			int num2 = Math.Min(matrix2.RowCount - 1, matrix2.ColumnCount);
			int num3 = Math.Max(0, Math.Min(matrix2.ColumnCount - 2, matrix2.RowCount));
			int num4 = Math.Max(num2, num3);
			for (int i = 0; i < num4; i++)
			{
				int num5 = i + 1;
				if (i < num2)
				{
					double num7 = (vector[i] = Dnrm2Column(matrix2, matrix2.RowCount, i, i));
					if (vector[i] != 0.0)
					{
						if (matrix2.At(i, i) != 0.0)
						{
							vector[i] = Dsign(vector[i], matrix2.At(i, i));
						}
						DscalColumn(matrix2, matrix2.RowCount, i, i, 1.0 / vector[i]);
						matrix2.At(i, i, 1.0 + matrix2.At(i, i));
					}
					vector[i] = 0.0 - vector[i];
				}
				for (int j = num5; j < matrix2.ColumnCount; j++)
				{
					if (i < num2 && vector[i] != 0.0)
					{
						double num8 = (0.0 - Ddot(matrix2, matrix2.RowCount, i, j, i)) / matrix2.At(i, i);
						for (int k = i; k < matrix2.RowCount; k++)
						{
							matrix2.At(k, j, matrix2.At(k, j) + num8 * matrix2.At(k, i));
						}
					}
					array[j] = matrix2.At(i, j);
				}
				if (computeVectors && i < num2)
				{
					for (int l = i; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, i, matrix2.At(l, i));
					}
				}
				if (i >= num3)
				{
					continue;
				}
				double num9 = (array[i] = Dnrm2Vector(array, num5));
				if (array[i] != 0.0)
				{
					if (array[num5] != 0.0)
					{
						array[i] = Dsign(array[i], array[num5]);
					}
					DscalVector(array, num5, 1.0 / array[i]);
					array[num5] = 1.0 + array[num5];
				}
				array[i] = 0.0 - array[i];
				if (num5 < matrix2.RowCount && array[i] != 0.0)
				{
					for (int l = num5; l < matrix2.RowCount; l++)
					{
						array2[l] = 0.0;
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						for (int m = num5; m < matrix2.RowCount; m++)
						{
							array2[m] += array[j] * matrix2.At(m, j);
						}
					}
					for (int j = num5; j < matrix2.ColumnCount; j++)
					{
						double num10 = (0.0 - array[j]) / array[num5];
						for (int n = num5; n < matrix2.RowCount; n++)
						{
							matrix2.At(n, j, matrix2.At(n, j) + num10 * array2[n]);
						}
					}
				}
				if (computeVectors)
				{
					for (int l = num5; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, array[l]);
					}
				}
			}
			int num11 = Math.Min(matrix2.ColumnCount, matrix2.RowCount + 1);
			int num12 = num2 + 1;
			int num13 = num3 + 1;
			if (num2 < matrix2.ColumnCount)
			{
				vector[num12 - 1] = matrix2.At(num12 - 1, num12 - 1);
			}
			if (matrix2.RowCount < num11)
			{
				vector[num11 - 1] = 0.0;
			}
			if (num13 < num11)
			{
				array[num13 - 1] = matrix2.At(num13 - 1, num11 - 1);
			}
			array[num11 - 1] = 0.0;
			if (computeVectors)
			{
				for (int j = num12 - 1; j < rowCount; j++)
				{
					for (int l = 0; l < matrix2.RowCount; l++)
					{
						matrix3.At(l, j, 0.0);
					}
					matrix3.At(j, j, 1.0);
				}
				for (int i = num2 - 1; i >= 0; i--)
				{
					if (vector[i] != 0.0)
					{
						for (int j = i + 1; j < rowCount; j++)
						{
							double num8 = (0.0 - Ddot(matrix3, matrix2.RowCount, i, j, i)) / matrix3.At(i, i);
							for (int num14 = i; num14 < matrix2.RowCount; num14++)
							{
								matrix3.At(num14, j, matrix3.At(num14, j) + num8 * matrix3.At(num14, i));
							}
						}
						DscalColumn(matrix3, matrix2.RowCount, i, i, -1.0);
						matrix3.At(i, i, 1.0 + matrix3.At(i, i));
						for (int l = 0; l < i; l++)
						{
							matrix3.At(l, i, 0.0);
						}
					}
					else
					{
						for (int l = 0; l < matrix2.RowCount; l++)
						{
							matrix3.At(l, i, 0.0);
						}
						matrix3.At(i, i, 1.0);
					}
				}
			}
			if (computeVectors)
			{
				for (int i = matrix2.ColumnCount - 1; i >= 0; i--)
				{
					int num5 = i + 1;
					if (i < num3 && array[i] != 0.0)
					{
						for (int j = num5; j < matrix2.ColumnCount; j++)
						{
							double num8 = (0.0 - Ddot(matrix4, matrix2.ColumnCount, i, j, num5)) / matrix4.At(num5, i);
							for (int num15 = i; num15 < matrix2.ColumnCount; num15++)
							{
								matrix4.At(num15, j, matrix4.At(num15, j) + num8 * matrix4.At(num15, i));
							}
						}
					}
					for (int l = 0; l < matrix2.ColumnCount; l++)
					{
						matrix4.At(l, i, 0.0);
					}
					matrix4.At(i, i, 1.0);
				}
			}
			for (int l = 0; l < num11; l++)
			{
				if (vector[l] != 0.0)
				{
					double num8 = vector[l];
					double num16 = vector[l] / num8;
					vector[l] = num8;
					if (l < num11 - 1)
					{
						array[l] /= num16;
					}
					if (computeVectors)
					{
						DscalColumn(matrix3, matrix2.RowCount, l, 0, num16);
					}
				}
				if (l == num11 - 1)
				{
					break;
				}
				if (array[l] != 0.0)
				{
					double num8 = array[l];
					double num16 = num8 / array[l];
					array[l] = num8;
					vector[l + 1] *= num16;
					if (computeVectors)
					{
						DscalColumn(matrix4, matrix2.ColumnCount, l + 1, 0, num16);
					}
				}
			}
			int num17 = num11;
			int num18 = 0;
			while (num11 > 0)
			{
				if (num18 >= 1000)
				{
					throw new NonConvergenceException();
				}
				int i;
				for (i = num11 - 2; i >= 0; i--)
				{
					double num19 = Math.Abs(vector[i]) + Math.Abs(vector[i + 1]);
					if ((num19 + Math.Abs(array[i])).AlmostEqualRelative(num19, 15))
					{
						array[i] = 0.0;
						break;
					}
				}
				int num20;
				if (i == num11 - 2)
				{
					num20 = 4;
				}
				else
				{
					int num21;
					for (num21 = num11 - 1; num21 > i; num21--)
					{
						double num19 = 0.0;
						if (num21 != num11 - 1)
						{
							num19 += Math.Abs(array[num21]);
						}
						if (num21 != i + 1)
						{
							num19 += Math.Abs(array[num21 - 1]);
						}
						if ((num19 + Math.Abs(vector[num21])).AlmostEqualRelative(num19, 15))
						{
							vector[num21] = 0.0;
							break;
						}
					}
					if (num21 == i)
					{
						num20 = 3;
					}
					else if (num21 == num11 - 1)
					{
						num20 = 1;
					}
					else
					{
						num20 = 2;
						i = num21;
					}
				}
				i++;
				double c;
				double s;
				switch (num20)
				{
				case 1:
				{
					double da = array[num11 - 2];
					array[num11 - 2] = 0.0;
					for (int num31 = i; num31 < num11 - 1; num31++)
					{
						int num30 = num11 - 2 - num31 + i;
						double da2 = vector[num30];
						Drotg(ref da2, ref da, out c, out s);
						vector[num30] = da2;
						if (num30 != i)
						{
							da = (0.0 - s) * array[num30 - 1];
							array[num30 - 1] = c * array[num30 - 1];
						}
						if (computeVectors)
						{
							Drot(matrix4, matrix2.ColumnCount, num30, num11 - 1, c, s);
						}
					}
					break;
				}
				case 2:
				{
					double da = array[i - 1];
					array[i - 1] = 0.0;
					for (int num30 = i; num30 < num11; num30++)
					{
						double da2 = vector[num30];
						Drotg(ref da2, ref da, out c, out s);
						vector[num30] = da2;
						da = (0.0 - s) * array[num30];
						array[num30] = c * array[num30];
						if (computeVectors)
						{
							Drot(matrix3, matrix2.RowCount, num30, i - 1, c, s);
						}
					}
					break;
				}
				case 3:
				{
					double val = 0.0;
					val = Math.Max(val, Math.Abs(vector[num11 - 1]));
					val = Math.Max(val, Math.Abs(vector[num11 - 2]));
					val = Math.Max(val, Math.Abs(array[num11 - 2]));
					val = Math.Max(val, Math.Abs(vector[i]));
					val = Math.Max(val, Math.Abs(array[i]));
					double num22 = vector[num11 - 1] / val;
					double num23 = vector[num11 - 2] / val;
					double num24 = array[num11 - 2] / val;
					double num25 = vector[i] / val;
					double num26 = array[i] / val;
					double num27 = ((num23 + num22) * (num23 - num22) + num24 * num24) / 2.0;
					double num28 = num22 * num24 * (num22 * num24);
					double num29 = 0.0;
					if (num27 != 0.0 || num28 != 0.0)
					{
						num29 = Math.Sqrt(num27 * num27 + num28);
						if (num27 < 0.0)
						{
							num29 = 0.0 - num29;
						}
						num29 = num28 / (num27 + num29);
					}
					double da = (num25 + num22) * (num25 - num22) + num29;
					double db = num25 * num26;
					for (int num30 = i; num30 < num11 - 1; num30++)
					{
						Drotg(ref da, ref db, out c, out s);
						if (num30 != i)
						{
							array[num30 - 1] = da;
						}
						da = c * vector[num30] + s * array[num30];
						array[num30] = c * array[num30] - s * vector[num30];
						db = s * vector[num30 + 1];
						vector[num30 + 1] = c * vector[num30 + 1];
						if (computeVectors)
						{
							Drot(matrix4, matrix2.ColumnCount, num30, num30 + 1, c, s);
						}
						Drotg(ref da, ref db, out c, out s);
						vector[num30] = da;
						da = c * array[num30] + s * vector[num30 + 1];
						vector[num30 + 1] = (0.0 - s) * array[num30] + c * vector[num30 + 1];
						db = s * array[num30 + 1];
						array[num30 + 1] = c * array[num30 + 1];
						if (computeVectors && num30 < matrix2.RowCount)
						{
							Drot(matrix3, matrix2.RowCount, num30, num30 + 1, c, s);
						}
					}
					array[num11 - 2] = da;
					num18++;
					break;
				}
				case 4:
					if (vector[i] < 0.0)
					{
						vector[i] = 0.0 - vector[i];
						if (computeVectors)
						{
							DscalColumn(matrix4, matrix2.ColumnCount, i, 0, -1.0);
						}
					}
					for (; i != num17 - 1 && !(vector[i] >= vector[i + 1]); i++)
					{
						double num8 = vector[i];
						vector[i] = vector[i + 1];
						vector[i + 1] = num8;
						if (computeVectors && i < matrix2.ColumnCount)
						{
							Dswap(matrix4, matrix2.ColumnCount, i, i + 1);
						}
						if (computeVectors && i < matrix2.RowCount)
						{
							Dswap(matrix3, matrix2.RowCount, i, i + 1);
						}
					}
					num18 = 0;
					num11--;
					break;
				}
			}
			if (computeVectors)
			{
				matrix4 = matrix4.Transpose();
			}
			if (matrix2.RowCount < matrix2.ColumnCount)
			{
				num--;
				Vector<double> vector2 = Vector<double>.Build.SameAs(matrix2, num);
				for (int l = 0; l < num; l++)
				{
					vector2[l] = vector[l];
				}
				vector = vector2;
			}
			return new UserSvd(vector, matrix3, matrix4, computeVectors);
		}

		private UserSvd(Vector<double> s, Matrix<double> u, Matrix<double> vt, bool vectorsComputed)
			: base(s, u, vt, vectorsComputed)
		{
		}

		private static double Dsign(double z1, double z2)
		{
			return Math.Abs(z1) * (z2 / Math.Abs(z2));
		}

		private static void Dswap(Matrix<double> a, int rowCount, int columnA, int columnB)
		{
			for (int i = 0; i < rowCount; i++)
			{
				double value = a.At(i, columnA);
				a.At(i, columnA, a.At(i, columnB));
				a.At(i, columnB, value);
			}
		}

		private static void DscalColumn(Matrix<double> a, int rowCount, int column, int rowStart, double z)
		{
			for (int i = rowStart; i < rowCount; i++)
			{
				a.At(i, column, a.At(i, column) * z);
			}
		}

		private static void DscalVector(double[] a, int start, double z)
		{
			for (int i = start; i < a.Length; i++)
			{
				a[i] *= z;
			}
		}

		private static void Drotg(ref double da, ref double db, out double c, out double s)
		{
			double num = db;
			double num2 = Math.Abs(da);
			double num3 = Math.Abs(db);
			if (num2 > num3)
			{
				num = da;
			}
			double num4 = num2 + num3;
			double num5;
			double num6;
			if (num4 == 0.0)
			{
				c = 1.0;
				s = 0.0;
				num5 = 0.0;
				num6 = 0.0;
			}
			else
			{
				double num7 = da / num4;
				double num8 = db / num4;
				num5 = num4 * Math.Sqrt(num7 * num7 + num8 * num8);
				if (num < 0.0)
				{
					num5 = 0.0 - num5;
				}
				c = da / num5;
				s = db / num5;
				num6 = 1.0;
				if (num2 > num3)
				{
					num6 = s;
				}
				if (num3 >= num2 && c != 0.0)
				{
					num6 = 1.0 / c;
				}
			}
			da = num5;
			db = num6;
		}

		private static double Dnrm2Column(Matrix<double> a, int rowCount, int column, int rowStart)
		{
			double num = 0.0;
			for (int i = rowStart; i < rowCount; i++)
			{
				num += a.At(i, column) * a.At(i, column);
			}
			return Math.Sqrt(num);
		}

		private static double Dnrm2Vector(double[] a, int rowStart)
		{
			double num = 0.0;
			for (int i = rowStart; i < a.Length; i++)
			{
				num += a[i] * a[i];
			}
			return Math.Sqrt(num);
		}

		private static double Ddot(Matrix<double> a, int rowCount, int columnA, int columnB, int rowStart)
		{
			double num = 0.0;
			for (int i = rowStart; i < rowCount; i++)
			{
				num += a.At(i, columnB) * a.At(i, columnA);
			}
			return num;
		}

		private static void Drot(Matrix<double> a, int rowCount, int columnA, int columnB, double c, double s)
		{
			for (int i = 0; i < rowCount; i++)
			{
				double value = c * a.At(i, columnA) + s * a.At(i, columnB);
				double value2 = c * a.At(i, columnB) - s * a.At(i, columnA);
				a.At(i, columnB, value2);
				a.At(i, columnA, value);
			}
		}

		public override void Solve(Matrix<double> input, Matrix<double> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (input.ColumnCount != result.ColumnCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			if (base.U.RowCount != input.RowCount)
			{
				throw new ArgumentException("Matrix row dimensions must agree.");
			}
			if (base.VT.ColumnCount != result.RowCount)
			{
				throw new ArgumentException("Matrix column dimensions must agree.");
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			int columnCount = input.ColumnCount;
			double[] array = new double[base.VT.ColumnCount];
			for (int i = 0; i < columnCount; i++)
			{
				for (int j = 0; j < base.VT.ColumnCount; j++)
				{
					double num2 = 0.0;
					if (j < num)
					{
						for (int k = 0; k < base.U.RowCount; k++)
						{
							num2 += base.U.At(k, j) * input.At(k, i);
						}
						num2 /= base.S[j];
					}
					array[j] = num2;
				}
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					double num3 = 0.0;
					for (int m = 0; m < base.VT.ColumnCount; m++)
					{
						num3 += base.VT.At(m, l) * array[m];
					}
					result.At(l, i, num3);
				}
			}
		}

		public override void Solve(Vector<double> input, Vector<double> result)
		{
			if (!VectorsComputed)
			{
				throw new InvalidOperationException("The singular vectors were not computed.");
			}
			if (base.U.RowCount != input.Count)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (base.VT.ColumnCount != result.Count)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentException>(base.VT, result);
			}
			int num = Math.Min(base.U.RowCount, base.VT.ColumnCount);
			double[] array = new double[base.VT.ColumnCount];
			for (int i = 0; i < base.VT.ColumnCount; i++)
			{
				double num2 = 0.0;
				if (i < num)
				{
					for (int j = 0; j < base.U.RowCount; j++)
					{
						num2 += base.U.At(j, i) * input[j];
					}
					num2 /= base.S[i];
				}
				array[i] = num2;
			}
			for (int k = 0; k < base.VT.ColumnCount; k++)
			{
				double num2 = 0.0;
				for (int l = 0; l < base.VT.ColumnCount; l++)
				{
					num2 += base.VT.At(l, k) * array[l];
				}
				result[k] = num2;
			}
		}
	}
}
namespace MathNet.Numerics.Interpolation
{
	public class Barycentric : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _y;

		private readonly double[] _w;

		bool IInterpolation.SupportsDifferentiation => false;

		bool IInterpolation.SupportsIntegration => false;

		public Barycentric(double[] x, double[] y, double[] w)
		{
			if (x.Length != y.Length || x.Length != w.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 1)
			{
				throw new ArgumentException("The given array is too small. It must be at least 1 long.", "x");
			}
			_x = x;
			_y = y;
			_w = w;
		}

		public static Barycentric InterpolatePolynomialEquidistantSorted(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 1)
			{
				throw new ArgumentException("The given array is too small. It must be at least 1 long.", "x");
			}
			double[] array = new double[x.Length];
			array[0] = 1.0;
			for (int i = 1; i < array.Length; i++)
			{
				array[i] = (0.0 - array[i - 1] * (double)(array.Length - i)) / (double)i;
			}
			return new Barycentric(x, y, array);
		}

		public static Barycentric InterpolatePolynomialEquidistantInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolatePolynomialEquidistantSorted(x, y);
		}

		public static Barycentric InterpolatePolynomialEquidistant(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolatePolynomialEquidistantInplace(x.ToArray(), y.ToArray());
		}

		public static Barycentric InterpolatePolynomialEquidistant(double leftBound, double rightBound, IEnumerable<double> y)
		{
			double[] array = (y as double[]) ?? y.ToArray();
			return InterpolatePolynomialEquidistantSorted(Generate.LinearSpaced(array.Length, leftBound, rightBound), array);
		}

		public static Barycentric InterpolateRationalFloaterHormannSorted(double[] x, double[] y, int order)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 1)
			{
				throw new ArgumentException("The given array is too small. It must be at least 1 long.", "x");
			}
			if (0 > order || x.Length <= order)
			{
				throw new ArgumentOutOfRangeException("order");
			}
			double[] array = new double[x.Length];
			double num = (((order & 1) == 1) ? (-1.0) : 1.0);
			for (int i = 0; i < x.Length; i++)
			{
				double num2 = 0.0;
				for (int j = Math.Max(i - order, 0); j <= Math.Min(i, array.Length - 1 - order); j++)
				{
					double num3 = 1.0;
					for (int k = j; k <= j + order; k++)
					{
						if (k != i)
						{
							num3 /= Math.Abs(x[i] - x[k]);
						}
					}
					num2 += num3;
				}
				array[i] = num * num2;
				num = 0.0 - num;
			}
			return new Barycentric(x, y, array);
		}

		public static Barycentric InterpolateRationalFloaterHormannInplace(double[] x, double[] y, int order)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateRationalFloaterHormannSorted(x, y, order);
		}

		public static Barycentric InterpolateRationalFloaterHormann(IEnumerable<double> x, IEnumerable<double> y, int order)
		{
			return InterpolateRationalFloaterHormannInplace(x.ToArray(), y.ToArray(), order);
		}

		public static Barycentric InterpolateRationalFloaterHormannSorted(double[] x, double[] y)
		{
			return InterpolateRationalFloaterHormannSorted(x, y, Math.Min(3, x.Length - 1));
		}

		public static Barycentric InterpolateRationalFloaterHormannInplace(double[] x, double[] y)
		{
			return InterpolateRationalFloaterHormannInplace(x, y, Math.Min(3, x.Length - 1));
		}

		public static Barycentric InterpolateRationalFloaterHormann(IEnumerable<double> x, IEnumerable<double> y)
		{
			double[] array = x.ToArray();
			int order = Math.Min(3, array.Length - 1);
			return InterpolateRationalFloaterHormannInplace(array, y.ToArray(), order);
		}

		public double Interpolate(double t)
		{
			if (_x.Length == 1)
			{
				return _y[0];
			}
			int num = 0;
			double num2 = t - _x[0];
			for (int i = 1; i < _x.Length; i++)
			{
				if (Math.Abs(t - _x[i]) < Math.Abs(num2))
				{
					num2 = t - _x[i];
					num = i;
				}
			}
			if (num2 == 0.0)
			{
				return _y[num];
			}
			if (Math.Abs(num2) > 1E-150)
			{
				num = -1;
				num2 = 1.0;
			}
			double num3 = 0.0;
			double num4 = 0.0;
			for (int j = 0; j < _x.Length; j++)
			{
				if (j != num)
				{
					double num5 = num2 * _w[j] / (t - _x[j]);
					num3 += num5 * _y[j];
					num4 += num5;
				}
				else
				{
					double num6 = _w[j];
					num3 += num6 * _y[j];
					num4 += num6;
				}
			}
			return num3 / num4;
		}

		double IInterpolation.Differentiate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Differentiate2(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double a, double b)
		{
			throw new NotSupportedException();
		}
	}
	public class BulirschStoerRationalInterpolation : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _y;

		bool IInterpolation.SupportsDifferentiation => false;

		bool IInterpolation.SupportsIntegration => false;

		public BulirschStoerRationalInterpolation(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 1)
			{
				throw new ArgumentException("The given array is too small. It must be at least 1 long.", "x");
			}
			_x = x;
			_y = y;
		}

		public static BulirschStoerRationalInterpolation InterpolateSorted(double[] x, double[] y)
		{
			return new BulirschStoerRationalInterpolation(x, y);
		}

		public static BulirschStoerRationalInterpolation InterpolateInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateSorted(x, y);
		}

		public static BulirschStoerRationalInterpolation Interpolate(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateInplace(x.ToArray(), y.ToArray());
		}

		public double Interpolate(double t)
		{
			int num = _x.Length;
			double[] array = new double[num];
			double[] array2 = new double[num];
			int num2 = 0;
			double num3 = Math.Abs(t - _x[0]);
			for (int i = 0; i < num; i++)
			{
				double num4 = Math.Abs(t - _x[i]);
				if (num4.AlmostEqual(0.0))
				{
					return _y[i];
				}
				if (num4 < num3)
				{
					num2 = i;
					num3 = num4;
				}
				array[i] = _y[i];
				array2[i] = _y[i] + 1E-25;
			}
			double num5 = _y[num2];
			for (int j = 1; j < num; j++)
			{
				for (int k = 0; k < num - j; k++)
				{
					double num6 = _x[k + j] - t;
					double num7 = (_x[k] - t) * array2[k] / num6;
					double num8 = num7 - array[k + 1];
					if (num8.AlmostEqual(0.0))
					{
						return double.NaN;
					}
					num8 = (array[k + 1] - array2[k]) / num8;
					array2[k] = array[k + 1] * num8;
					array[k] = num7 * num8;
				}
				num5 += ((2 * num2 < num - j) ? array[num2] : array2[--num2]);
			}
			return num5;
		}

		double IInterpolation.Differentiate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Differentiate2(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double a, double b)
		{
			throw new NotSupportedException();
		}
	}
	public class CubicSpline : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _c0;

		private readonly double[] _c1;

		private readonly double[] _c2;

		private readonly double[] _c3;

		private readonly Lazy<double[]> _indefiniteIntegral;

		bool IInterpolation.SupportsDifferentiation => true;

		bool IInterpolation.SupportsIntegration => true;

		public CubicSpline(double[] x, double[] c0, double[] c1, double[] c2, double[] c3)
		{
			if (x.Length != c0.Length + 1 || x.Length != c1.Length + 1 || x.Length != c2.Length + 1 || x.Length != c3.Length + 1)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			_x = x;
			_c0 = c0;
			_c1 = c1;
			_c2 = c2;
			_c3 = c3;
			_indefiniteIntegral = new Lazy<double[]>(ComputeIndefiniteIntegral);
		}

		public static CubicSpline InterpolateHermiteSorted(double[] x, double[] y, double[] firstDerivatives)
		{
			if (x.Length != y.Length || x.Length != firstDerivatives.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			double[] array = new double[x.Length - 1];
			double[] array2 = new double[x.Length - 1];
			double[] array3 = new double[x.Length - 1];
			double[] array4 = new double[x.Length - 1];
			for (int i = 0; i < array2.Length; i++)
			{
				double num = x[i + 1] - x[i];
				double num2 = num * num;
				array[i] = y[i];
				array2[i] = firstDerivatives[i];
				array3[i] = (3.0 * (y[i + 1] - y[i]) / num - 2.0 * firstDerivatives[i] - firstDerivatives[i + 1]) / num;
				array4[i] = (2.0 * (y[i] - y[i + 1]) / num + firstDerivatives[i] + firstDerivatives[i + 1]) / num2;
			}
			return new CubicSpline(x, array, array2, array3, array4);
		}

		public static CubicSpline InterpolateHermiteInplace(double[] x, double[] y, double[] firstDerivatives)
		{
			if (x.Length != y.Length || x.Length != firstDerivatives.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			Sorting.Sort(x, y, firstDerivatives);
			return InterpolateHermiteSorted(x, y, firstDerivatives);
		}

		public static CubicSpline InterpolateHermite(IEnumerable<double> x, IEnumerable<double> y, IEnumerable<double> firstDerivatives)
		{
			return InterpolateHermiteInplace(x.ToArray(), y.ToArray(), firstDerivatives.ToArray());
		}

		public static CubicSpline InterpolateAkimaSorted(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 5)
			{
				throw new ArgumentException("The given array is too small. It must be at least 5 long.", "x");
			}
			double[] array = new double[x.Length - 1];
			double[] array2 = new double[x.Length - 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
			}
			for (int j = 1; j < array2.Length; j++)
			{
				array2[j] = Math.Abs(array[j] - array[j - 1]);
			}
			double[] array3 = new double[x.Length];
			for (int k = 2; k < array3.Length - 2; k++)
			{
				array3[k] = ((array2[k - 1].AlmostEqual(0.0) && array2[k + 1].AlmostEqual(0.0)) ? (((x[k + 1] - x[k]) * array[k - 1] + (x[k] - x[k - 1]) * array[k]) / (x[k + 1] - x[k - 1])) : ((array2[k + 1] * array[k - 1] + array2[k - 1] * array[k]) / (array2[k + 1] + array2[k - 1])));
			}
			array3[0] = DifferentiateThreePoint(x, y, 0, 0, 1, 2);
			array3[1] = DifferentiateThreePoint(x, y, 1, 0, 1, 2);
			array3[x.Length - 2] = DifferentiateThreePoint(x, y, x.Length - 2, x.Length - 3, x.Length - 2, x.Length - 1);
			array3[x.Length - 1] = DifferentiateThreePoint(x, y, x.Length - 1, x.Length - 3, x.Length - 2, x.Length - 1);
			return InterpolateHermiteSorted(x, y, array3);
		}

		public static CubicSpline InterpolateAkimaInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateAkimaSorted(x, y);
		}

		public static CubicSpline InterpolateAkima(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateAkimaInplace(x.ToArray(), y.ToArray());
		}

		public static CubicSpline InterpolatePchipSorted(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 3)
			{
				throw new ArgumentException("The given array is too small. It must be at least 3 long.", "x");
			}
			double[] array = new double[x.Length - 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
			}
			double[] array2 = new double[x.Length];
			double num = x[1] - x[0];
			bool flag = array[0].AlmostEqual(0.0);
			for (int j = 1; j < x.Length - 1; j++)
			{
				double num2 = x[j + 1] - x[j];
				bool num3 = array[j].AlmostEqual(0.0);
				if (num3 || flag || Math.Sign(array[j]) != Math.Sign(array[j - 1]))
				{
					array2[j] = 0.0;
				}
				else
				{
					double num4 = 2.0 * num2 + num;
					double num5 = num2 + 2.0 * num;
					array2[j] = (num4 + num5) / (num4 / array[j - 1] + num5 / array[j]);
				}
				num = num2;
				flag = num3;
			}
			array2[0] = PchipEndPoints(x[1] - x[0], x[2] - x[1], array[0], array[1]);
			array2[array2.Length - 1] = PchipEndPoints(x[x.Length - 1] - x[x.Length - 2], x[x.Length - 2] - x[x.Length - 3], array[array.Length - 1], array[array.Length - 2]);
			return InterpolateHermiteSorted(x, y, array2);
		}

		private static double PchipEndPoints(double h0, double h1, double m0, double m1)
		{
			double num = ((2.0 * h0 + h1) * m0 - h0 * m1) / (h0 + h1);
			if (Math.Sign(num) != Math.Sign(m0))
			{
				return 0.0;
			}
			if (Math.Sign(m0) != Math.Sign(m1) && Math.Abs(num) > 3.0 * Math.Abs(m0))
			{
				return 3.0 * m0;
			}
			return num;
		}

		public static CubicSpline InterpolatePchipInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolatePchipSorted(x, y);
		}

		public static CubicSpline InterpolatePchip(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolatePchipInplace(x.ToArray(), y.ToArray());
		}

		public static CubicSpline InterpolateBoundariesSorted(double[] x, double[] y, SplineBoundaryCondition leftBoundaryCondition, double leftBoundary, SplineBoundaryCondition rightBoundaryCondition, double rightBoundary)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			int num = x.Length;
			if (num == 2 && leftBoundaryCondition == SplineBoundaryCondition.ParabolicallyTerminated && rightBoundaryCondition == SplineBoundaryCondition.ParabolicallyTerminated)
			{
				leftBoundaryCondition = SplineBoundaryCondition.SecondDerivative;
				leftBoundary = 0.0;
				rightBoundaryCondition = SplineBoundaryCondition.SecondDerivative;
				rightBoundary = 0.0;
			}
			if (leftBoundaryCondition == SplineBoundaryCondition.Natural)
			{
				leftBoundaryCondition = SplineBoundaryCondition.SecondDerivative;
				leftBoundary = 0.0;
			}
			if (rightBoundaryCondition == SplineBoundaryCondition.Natural)
			{
				rightBoundaryCondition = SplineBoundaryCondition.SecondDerivative;
				rightBoundary = 0.0;
			}
			double[] array = new double[num];
			double[] array2 = new double[num];
			double[] array3 = new double[num];
			double[] array4 = new double[num];
			switch (leftBoundaryCondition)
			{
			case SplineBoundaryCondition.ParabolicallyTerminated:
				array[0] = 0.0;
				array2[0] = 1.0;
				array3[0] = 1.0;
				array4[0] = 2.0 * (y[1] - y[0]) / (x[1] - x[0]);
				break;
			case SplineBoundaryCondition.FirstDerivative:
				array[0] = 0.0;
				array2[0] = 1.0;
				array3[0] = 0.0;
				array4[0] = leftBoundary;
				break;
			case SplineBoundaryCondition.SecondDerivative:
				array[0] = 0.0;
				array2[0] = 2.0;
				array3[0] = 1.0;
				array4[0] = 3.0 * ((y[1] - y[0]) / (x[1] - x[0])) - 0.5 * leftBoundary * (x[1] - x[0]);
				break;
			default:
				throw new NotSupportedException("Invalid Left Boundary Condition.");
			}
			for (int i = 1; i < x.Length - 1; i++)
			{
				array[i] = x[i + 1] - x[i];
				array2[i] = 2.0 * (x[i + 1] - x[i - 1]);
				array3[i] = x[i] - x[i - 1];
				array4[i] = 3.0 * (y[i] - y[i - 1]) / (x[i] - x[i - 1]) * (x[i + 1] - x[i]) + 3.0 * (y[i + 1] - y[i]) / (x[i + 1] - x[i]) * (x[i] - x[i - 1]);
			}
			switch (rightBoundaryCondition)
			{
			case SplineBoundaryCondition.ParabolicallyTerminated:
				array[num - 1] = 1.0;
				array2[num - 1] = 1.0;
				array3[num - 1] = 0.0;
				array4[num - 1] = 2.0 * (y[num - 1] - y[num - 2]) / (x[num - 1] - x[num - 2]);
				break;
			case SplineBoundaryCondition.FirstDerivative:
				array[num - 1] = 0.0;
				array2[num - 1] = 1.0;
				array3[num - 1] = 0.0;
				array4[num - 1] = rightBoundary;
				break;
			case SplineBoundaryCondition.SecondDerivative:
				array[num - 1] = 1.0;
				array2[num - 1] = 2.0;
				array3[num - 1] = 0.0;
				array4[num - 1] = 3.0 * (y[num - 1] - y[num - 2]) / (x[num - 1] - x[num - 2]) + 0.5 * rightBoundary * (x[num - 1] - x[num - 2]);
				break;
			default:
				throw new NotSupportedException("Invalid Right Boundary Condition.");
			}
			double[] firstDerivatives = SolveTridiagonal(array, array2, array3, array4);
			return InterpolateHermiteSorted(x, y, firstDerivatives);
		}

		public static CubicSpline InterpolateBoundariesInplace(double[] x, double[] y, SplineBoundaryCondition leftBoundaryCondition, double leftBoundary, SplineBoundaryCondition rightBoundaryCondition, double rightBoundary)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateBoundariesSorted(x, y, leftBoundaryCondition, leftBoundary, rightBoundaryCondition, rightBoundary);
		}

		public static CubicSpline InterpolateBoundaries(IEnumerable<double> x, IEnumerable<double> y, SplineBoundaryCondition leftBoundaryCondition, double leftBoundary, SplineBoundaryCondition rightBoundaryCondition, double rightBoundary)
		{
			return InterpolateBoundariesInplace(x.ToArray(), y.ToArray(), leftBoundaryCondition, leftBoundary, rightBoundaryCondition, rightBoundary);
		}

		public static CubicSpline InterpolateNaturalSorted(double[] x, double[] y)
		{
			return InterpolateBoundariesSorted(x, y, SplineBoundaryCondition.SecondDerivative, 0.0, SplineBoundaryCondition.SecondDerivative, 0.0);
		}

		public static CubicSpline InterpolateNaturalInplace(double[] x, double[] y)
		{
			return InterpolateBoundariesInplace(x, y, SplineBoundaryCondition.SecondDerivative, 0.0, SplineBoundaryCondition.SecondDerivative, 0.0);
		}

		public static CubicSpline InterpolateNatural(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateBoundaries(x, y, SplineBoundaryCondition.SecondDerivative, 0.0, SplineBoundaryCondition.SecondDerivative, 0.0);
		}

		private static double DifferentiateThreePoint(double[] xx, double[] yy, int indexT, int index0, int index1, int index2)
		{
			double num = yy[index0];
			double num2 = yy[index1];
			double num3 = yy[index2];
			double num4 = xx[indexT] - xx[index0];
			double num5 = xx[index1] - xx[index0];
			double num6 = xx[index2] - xx[index0];
			double num7 = (num3 - num - num6 / num5 * (num2 - num)) / (num6 * (num6 - num5));
			double num8 = (num2 - num - num7 * num5 * num5) / num5;
			return 2.0 * num7 * num4 + num8;
		}

		private static double[] SolveTridiagonal(double[] a, double[] b, double[] c, double[] d)
		{
			for (int i = 1; i < a.Length; i++)
			{
				double num = a[i] / b[i - 1];
				b[i] -= num * c[i - 1];
				d[i] -= num * d[i - 1];
			}
			double[] array = new double[a.Length];
			array[array.Length - 1] = d[d.Length - 1] / b[b.Length - 1];
			for (int num2 = array.Length - 2; num2 >= 0; num2--)
			{
				array[num2] = (d[num2] - c[num2] * array[num2 + 1]) / b[num2];
			}
			return array;
		}

		public double Interpolate(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return _c0[num] + num2 * (_c1[num] + num2 * (_c2[num] + num2 * _c3[num]));
		}

		public double Differentiate(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return _c1[num] + num2 * (2.0 * _c2[num] + num2 * 3.0 * _c3[num]);
		}

		public double Differentiate2(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return 2.0 * _c2[num] + num2 * 6.0 * _c3[num];
		}

		public double Integrate(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return _indefiniteIntegral.Value[num] + num2 * (_c0[num] + num2 * (_c1[num] / 2.0 + num2 * (_c2[num] / 3.0 + num2 * _c3[num] / 4.0)));
		}

		public double Integrate(double a, double b)
		{
			return Integrate(b) - Integrate(a);
		}

		private double[] ComputeIndefiniteIntegral()
		{
			double[] array = new double[_c1.Length];
			for (int i = 0; i < array.Length - 1; i++)
			{
				double num = _x[i + 1] - _x[i];
				array[i + 1] = array[i] + num * (_c0[i] + num * (_c1[i] / 2.0 + num * (_c2[i] / 3.0 + num * _c3[i] / 4.0)));
			}
			return array;
		}

		private int LeftSegmentIndex(double t)
		{
			int num = Array.BinarySearch(_x, t);
			if (num < 0)
			{
				num = ~num - 1;
			}
			return Math.Min(Math.Max(num, 0), _x.Length - 2);
		}
	}
	public interface IInterpolation
	{
		bool SupportsDifferentiation { get; }

		bool SupportsIntegration { get; }

		double Interpolate(double t);

		double Differentiate(double t);

		double Differentiate2(double t);

		double Integrate(double t);

		double Integrate(double a, double b);
	}
	public class LinearSpline : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _c0;

		private readonly double[] _c1;

		private readonly Lazy<double[]> _indefiniteIntegral;

		bool IInterpolation.SupportsDifferentiation => true;

		bool IInterpolation.SupportsIntegration => true;

		public LinearSpline(double[] x, double[] c0, double[] c1)
		{
			if ((x.Length != c0.Length + 1 && x.Length != c0.Length) || x.Length != c1.Length + 1)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			_x = x;
			_c0 = c0;
			_c1 = c1;
			_indefiniteIntegral = new Lazy<double[]>(ComputeIndefiniteIntegral);
		}

		public static LinearSpline InterpolateSorted(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			double[] array = new double[x.Length - 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
			}
			return new LinearSpline(x, y, array);
		}

		public static LinearSpline InterpolateInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateSorted(x, y);
		}

		public static LinearSpline Interpolate(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateInplace(x.ToArray(), y.ToArray());
		}

		public double Interpolate(double t)
		{
			int num = LeftSegmentIndex(t);
			return _c0[num] + (t - _x[num]) * _c1[num];
		}

		public double Differentiate(double t)
		{
			int num = LeftSegmentIndex(t);
			return _c1[num];
		}

		public double Differentiate2(double t)
		{
			return 0.0;
		}

		public double Integrate(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return _indefiniteIntegral.Value[num] + num2 * (_c0[num] + num2 * _c1[num] / 2.0);
		}

		public double Integrate(double a, double b)
		{
			return Integrate(b) - Integrate(a);
		}

		private double[] ComputeIndefiniteIntegral()
		{
			double[] array = new double[_c1.Length];
			for (int i = 0; i < array.Length - 1; i++)
			{
				double num = _x[i + 1] - _x[i];
				array[i + 1] = array[i] + num * (_c0[i] + num * _c1[i] / 2.0);
			}
			return array;
		}

		private int LeftSegmentIndex(double t)
		{
			int num = Array.BinarySearch(_x, t);
			if (num < 0)
			{
				num = ~num - 1;
			}
			return Math.Min(Math.Max(num, 0), _x.Length - 2);
		}
	}
	public class LogLinear : IInterpolation
	{
		private readonly LinearSpline _spline;

		bool IInterpolation.SupportsDifferentiation => true;

		bool IInterpolation.SupportsIntegration => false;

		public LogLinear(double[] x, double[] logy)
		{
			_spline = LinearSpline.InterpolateSorted(x, logy);
		}

		public static LogLinear InterpolateSorted(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double[] logy = new double[y.Length];
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					logy[i] = Math.Log(y[i]);
				}
			});
			return new LogLinear(x, logy);
		}

		public static LogLinear InterpolateInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					y[i] = Math.Log(y[i]);
				}
			});
			return new LogLinear(x, y);
		}

		public static LogLinear Interpolate(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateInplace(x.ToArray(), y.ToArray());
		}

		public double Interpolate(double t)
		{
			return Math.Exp(_spline.Interpolate(t));
		}

		public double Differentiate(double t)
		{
			return Interpolate(t) * _spline.Differentiate(t);
		}

		public double Differentiate2(double t)
		{
			double num = _spline.Differentiate(t);
			double num2 = _spline.Differentiate2(t);
			return Differentiate(t) * num + Interpolate(t) * num2;
		}

		double IInterpolation.Integrate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double a, double b)
		{
			throw new NotSupportedException();
		}
	}
	public class NevillePolynomialInterpolation : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _y;

		bool IInterpolation.SupportsDifferentiation => true;

		bool IInterpolation.SupportsIntegration => false;

		public NevillePolynomialInterpolation(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 1)
			{
				throw new ArgumentException("The given array is too small. It must be at least 1 long.", "x");
			}
			for (int i = 1; i < x.Length; i++)
			{
				if (x[i] == x[i - 1])
				{
					throw new ArgumentException("All sample points should be unique.", "x");
				}
			}
			_x = x;
			_y = y;
		}

		public static NevillePolynomialInterpolation InterpolateSorted(double[] x, double[] y)
		{
			return new NevillePolynomialInterpolation(x, y);
		}

		public static NevillePolynomialInterpolation InterpolateInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateSorted(x, y);
		}

		public static NevillePolynomialInterpolation Interpolate(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateInplace(x.ToArray(), y.ToArray());
		}

		public double Interpolate(double t)
		{
			double[] array = new double[_y.Length];
			_y.CopyTo(array, 0);
			for (int i = 1; i < array.Length; i++)
			{
				for (int j = 0; j < array.Length - i; j++)
				{
					double num = t - _x[j + i];
					double num2 = _x[j] - t;
					double num3 = _x[j] - _x[j + i];
					array[j] = (num * array[j] + num2 * array[j + 1]) / num3;
				}
			}
			return array[0];
		}

		public double Differentiate(double t)
		{
			double[] array = new double[_y.Length];
			double[] array2 = new double[_y.Length];
			_y.CopyTo(array, 0);
			for (int i = 1; i < array.Length; i++)
			{
				for (int j = 0; j < array.Length - i; j++)
				{
					double num = t - _x[j + i];
					double num2 = _x[j] - t;
					double num3 = _x[j] - _x[j + i];
					array2[j] = (num * array2[j] + array[j] + num2 * array2[j + 1] - array[j + 1]) / num3;
					array[j] = (num * array[j] + num2 * array[j + 1]) / num3;
				}
			}
			return array2[0];
		}

		public double Differentiate2(double t)
		{
			double[] array = new double[_y.Length];
			double[] array2 = new double[_y.Length];
			double[] array3 = new double[_y.Length];
			_y.CopyTo(array, 0);
			for (int i = 1; i < array.Length; i++)
			{
				for (int j = 0; j < array.Length - i; j++)
				{
					double num = t - _x[j + i];
					double num2 = _x[j] - t;
					double num3 = _x[j] - _x[j + i];
					array3[j] = (num * array3[j] + num2 * array3[j + 1] + 2.0 * array2[j] - 2.0 * array2[j + 1]) / num3;
					array2[j] = (num * array2[j] + array[j] + num2 * array2[j + 1] - array[j + 1]) / num3;
					array[j] = (num * array[j] + num2 * array[j + 1]) / num3;
				}
			}
			return array3[0];
		}

		double IInterpolation.Integrate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double a, double b)
		{
			throw new NotSupportedException();
		}
	}
	public class QuadraticSpline : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _c0;

		private readonly double[] _c1;

		private readonly double[] _c2;

		private readonly Lazy<double[]> _indefiniteIntegral;

		bool IInterpolation.SupportsDifferentiation => true;

		bool IInterpolation.SupportsIntegration => true;

		public QuadraticSpline(double[] x, double[] c0, double[] c1, double[] c2)
		{
			if (x.Length != c0.Length + 1 || x.Length != c1.Length + 1 || x.Length != c2.Length + 1)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 2)
			{
				throw new ArgumentException("The given array is too small. It must be at least 2 long.", "x");
			}
			_x = x;
			_c0 = c0;
			_c1 = c1;
			_c2 = c2;
			_indefiniteIntegral = new Lazy<double[]>(ComputeIndefiniteIntegral);
		}

		public double Interpolate(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return _c0[num] + num2 * (_c1[num] + num2 * _c2[num]);
		}

		public double Differentiate(double t)
		{
			int num = LeftSegmentIndex(t);
			return _c1[num] + (t - _x[num]) * 2.0 * _c2[num];
		}

		public double Differentiate2(double t)
		{
			int num = LeftSegmentIndex(t);
			return 2.0 * _c2[num];
		}

		public double Integrate(double t)
		{
			int num = LeftSegmentIndex(t);
			double num2 = t - _x[num];
			return _indefiniteIntegral.Value[num] + num2 * (_c0[num] + num2 * (_c1[num] / 2.0 + num2 * _c2[num] / 3.0));
		}

		public double Integrate(double a, double b)
		{
			return Integrate(b) - Integrate(a);
		}

		private double[] ComputeIndefiniteIntegral()
		{
			double[] array = new double[_c1.Length];
			for (int i = 0; i < array.Length - 1; i++)
			{
				double num = _x[i + 1] - _x[i];
				array[i + 1] = array[i] + num * (_c0[i] + num * (_c1[i] / 2.0 + num * _c2[i] / 3.0));
			}
			return array;
		}

		private int LeftSegmentIndex(double t)
		{
			int num = Array.BinarySearch(_x, t);
			if (num < 0)
			{
				num = ~num - 1;
			}
			return Math.Min(Math.Max(num, 0), _x.Length - 2);
		}
	}
	public enum SplineBoundaryCondition
	{
		Natural,
		ParabolicallyTerminated,
		FirstDerivative,
		SecondDerivative
	}
	public class StepInterpolation : IInterpolation
	{
		private readonly double[] _x;

		private readonly double[] _y;

		private readonly Lazy<double[]> _indefiniteIntegral;

		bool IInterpolation.SupportsDifferentiation => true;

		bool IInterpolation.SupportsIntegration => true;

		public StepInterpolation(double[] x, double[] sy)
		{
			if (x.Length != sy.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			if (x.Length < 1)
			{
				throw new ArgumentException("The given array is too small. It must be at least 1 long.", "x");
			}
			_x = x;
			_y = sy;
			_indefiniteIntegral = new Lazy<double[]>(ComputeIndefiniteIntegral);
		}

		public static StepInterpolation InterpolateSorted(double[] x, double[] y)
		{
			return new StepInterpolation(x, y);
		}

		public static StepInterpolation InterpolateInplace(double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			return InterpolateSorted(x, y);
		}

		public static StepInterpolation Interpolate(IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateInplace(x.ToArray(), y.ToArray());
		}

		public double Interpolate(double t)
		{
			if (t < _x[0])
			{
				return 0.0;
			}
			int num = LeftBracketIndex(t);
			return _y[num];
		}

		public double Differentiate(double t)
		{
			if (Array.BinarySearch(_x, t) >= 0)
			{
				return double.NaN;
			}
			return 0.0;
		}

		public double Differentiate2(double t)
		{
			return Differentiate(t);
		}

		public double Integrate(double t)
		{
			if (t <= _x[0])
			{
				return 0.0;
			}
			int num = LeftBracketIndex(t);
			double num2 = t - _x[num];
			return _indefiniteIntegral.Value[num] + num2 * _y[num];
		}

		public double Integrate(double a, double b)
		{
			return Integrate(b) - Integrate(a);
		}

		private double[] ComputeIndefiniteIntegral()
		{
			double[] array = new double[_x.Length];
			for (int i = 0; i < array.Length - 1; i++)
			{
				array[i + 1] = array[i] + (_x[i + 1] - _x[i]) * _y[i];
			}
			return array;
		}

		private int LeftBracketIndex(double t)
		{
			int num = Array.BinarySearch(_x, t);
			if (num < 0)
			{
				return ~num - 1;
			}
			return num;
		}
	}
	public class TransformedInterpolation : IInterpolation
	{
		private readonly IInterpolation _interpolation;

		private readonly Func<double, double> _transform;

		bool IInterpolation.SupportsDifferentiation => false;

		bool IInterpolation.SupportsIntegration => false;

		public TransformedInterpolation(IInterpolation interpolation, Func<double, double> transform)
		{
			_interpolation = interpolation;
			_transform = transform;
		}

		public static TransformedInterpolation InterpolateSorted(Func<double, double> transform, Func<double, double> transformInverse, double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			double[] yhat = new double[y.Length];
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					yhat[i] = transformInverse(y[i]);
				}
			});
			return new TransformedInterpolation(LinearSpline.InterpolateSorted(x, yhat), transform);
		}

		public static TransformedInterpolation InterpolateInplace(Func<double, double> transform, Func<double, double> transformInverse, double[] x, double[] y)
		{
			if (x.Length != y.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.");
			}
			Sorting.Sort(x, y);
			CommonParallel.For(0, y.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					y[i] = transformInverse(y[i]);
				}
			});
			return new TransformedInterpolation(LinearSpline.InterpolateSorted(x, y), transform);
		}

		public static TransformedInterpolation Interpolate(Func<double, double> transform, Func<double, double> transformInverse, IEnumerable<double> x, IEnumerable<double> y)
		{
			return InterpolateInplace(transform, transformInverse, x.ToArray(), y.ToArray());
		}

		public double Interpolate(double t)
		{
			return _transform(_interpolation.Interpolate(t));
		}

		double IInterpolation.Differentiate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Differentiate2(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double t)
		{
			throw new NotSupportedException();
		}

		double IInterpolation.Integrate(double a, double b)
		{
			throw new NotSupportedException();
		}
	}
}
namespace MathNet.Numerics.Integration
{
	public static class DoubleExponentialTransformation
	{
		private const int NumberOfMaximumLevels = 10;

		private static readonly double[][] PrecomputedAbscissas = new double[7][]
		{
			new double[4] { 0.0, 0.9513679640727469, 0.9999774771924616, 0.999999999999957 },
			new double[3] { 0.6742714922484359, 0.9975148564572244, 0.9999999888756649 },
			new double[6] { 0.3772097381640342, 0.8595690586898966, 0.9870405605073769, 0.9996882640283532, 0.9999992047371147, 0.9999999999528565 },
			new double[12]
			{
				0.19435700332493544, 0.5391467053879677, 0.7806074389832003, 0.9148792632645746, 0.9739668681956775, 0.9940555066314022, 0.9990651964557858, 0.999909384695144, 0.9999953160412205, 0.9999998927816124,
				0.9999999991427051, 0.9999999999982322
			},
			new double[24]
			{
				0.09792388528783233, 0.2878799327427159, 0.46125354393958573, 0.610273657500639, 0.7310180347925616, 0.8233170055064024, 0.8898914027842602, 0.9351608575219846, 0.9641121642235473, 0.9814548266773352,
				0.9911269924416988, 0.9961086654375085, 0.9984542087676977, 0.9994514344352746, 0.9998288220728749, 0.9999538710056279, 0.9999894820148185, 0.9999980171405954, 0.9999996988941526, 0.9999999642390809,
				0.9999999967871991, 0.9999999997897329, 0.9999999999903939, 0.9999999999997081
			},
			new double[48]
			{
				0.049055967305077885, 0.14641798429058794, 0.24156631953888366, 0.33314226457763807, 0.41995211127844717, 0.5010133893793091, 0.5755844906351517, 0.6431767589852047, 0.703550005147142, 0.75669390863373,
				0.8027987413432413, 0.8422192463507568, 0.8754353976304087, 0.9030132815135739, 0.9255686340686127, 0.9437347860527572, 0.9581360227102137, 0.9693667328969173, 0.977976235186665, 0.9844588311674308,
				0.9892484310901339, 0.9927169971968273, 0.9951760261553274, 0.9968803181281919, 0.9980333363154338, 0.9987935342988059, 0.9992811119217919, 0.9995847503515176, 0.9997679715995609, 0.9998748650487803,
				0.9999350199250824, 0.9999675930679435, 0.9999845199022708, 0.9999929378766629, 0.9999969324491904, 0.9999987354718659, 0.9999995070057195, 0.9999998188937128, 0.9999999375540783, 0.9999999798745032,
				0.9999999939641342, 0.999999998323362, 0.9999999995707878, 0.9999999998992777, 0.9999999999784553, 0.9999999999958246, 0.9999999999992715, 0.9999999999998863
			},
			new double[96]
			{
				0.02453976357464916, 0.07352512298567129, 0.12222912220155764, 0.17046797238201053, 0.218063473469712, 0.26484507658344797, 0.310651780552846, 0.35533382516507456, 0.3987541504672378, 0.44078959903390086,
				0.48133184611690505, 0.5202880506912302, 0.5575812282607783, 0.5931503535919531, 0.6269502080510428, 0.6589509917433501, 0.6891377250616677, 0.7175094674873241, 0.7440783835473473, 0.7688686867682466,
				0.7919154923761421, 0.8132636085029739, 0.8329662939194109, 0.8510840079878488, 0.867683175775646, 0.882834988244669, 0.896614254280076, 0.9090983181630204, 0.9203660530319528, 0.9304969379971534,
				0.9395702239332747, 0.9476641906151531, 0.9548554958050227, 0.9612186151511164, 0.9668253703123558, 0.9717445415654873, 0.9760415602565767, 0.9797782758006157, 0.9830127914811011, 0.9857993630252835,
				0.9881883538007427, 0.9902262404675277, 0.9919556630026776, 0.993415513169264, 0.9946410557125112, 0.9956640768169531, 0.9965130546402537, 0.9972133470434688, 0.9977873919589065, 0.9982549161719962,
				0.9986331486406774, 0.9989370348335121, 0.999179448934886, 0.9993714011409377, 0.9995222376512172, 0.9996398313456004, 0.9997307615198084, 0.9998004814311384, 0.9998534727731114, 0.9998933865475925,
				0.9999231701292893, 0.9999451806144587, 0.9999612848078566, 0.9999729464252323, 0.9999813012701207, 0.9999872212820007, 0.9999913684483449, 0.9999942396276167, 0.9999962033471662, 0.9999975296238052,
				0.9999984138109648, 0.9999989954106899, 0.9999993727073354, 0.9999996139885502, 0.9999997660233324, 0.9999998603712146, 0.9999999180047947, 0.9999999526426645, 0.999999973113236, 0.9999999850030763,
				0.999999991786456, 0.9999999955856336, 0.9999999976732368, 0.9999999987979835, 0.9999999993917769, 0.9999999996987544, 0.9999999998540561, 0.9999999999308884, 0.9999999999680332, 0.9999999999855688,
				0.9999999999936463, 0.9999999999972741, 0.9999999999988612, 0.9999999999995373, 0.9999999999998171, 0.9999999999999298
			}
		};

		private static readonly double[][] PrecomputedWeights = new double[7][]
		{
			new double[4]
			{
				Math.PI / 2.0,
				0.23002239451478868,
				0.00026620051375271693,
				1.3581784274539091E-12
			},
			new double[3] { 0.9659765794123012, 0.018343166989927842, 2.143120455694304E-07 },
			new double[6] { 1.3896147592472563, 0.531078275428054, 0.0763857435708323, 0.0029025177479013137, 1.198370136317072E-05, 1.1631165814255782E-09 },
			new double[12]
			{
				1.5232837186347052, 1.193463025849157, 0.7374378483615478, 0.36046141846934365, 0.13742210773316774, 0.03917500549360078, 0.007742601026064241, 0.0009499468042834687, 6.248255924074409E-05, 1.826332059371066E-06,
				1.868728226873641E-08, 4.9378538776631926E-11
			},
			new double[24]
			{
				1.55877335553333, 1.4660144267169657, 1.297475750424978, 1.0816349854900704, 0.8501728564566201, 0.6304051351647437, 0.44083323627385823, 0.2902406793124542, 0.1793244121107283, 0.1034321542233329,
				0.05528968374224058, 0.027133510013712003, 0.012083543599157953, 0.004816298143928463, 0.0016908739981426396, 0.0005133938240679033, 0.00013205234125609976, 2.8110164327940134E-05, 4.82371820326155E-06, 6.477756603592972E-07,
				6.58351851271834E-08, 4.876006097424062E-09, 2.5216347918530147E-10, 8.675931414979604E-12
			},
			new double[48]
			{
				1.5677814313072218, 1.5438811161769592, 1.4972262225410362, 1.4300083548722997, 1.3452788847662516, 1.2467012074518578, 1.1382722433763053, 1.0240449331118116, 0.9078793791548954, 0.7932427008205167,
				0.6830685163442638, 0.5796781030877877, 0.4847580912147554, 0.3993847415257171, 0.3240825396115289, 0.2589046395140535, 0.20352399885860176, 0.15732620348436616, 0.11949741128869593, 0.08910313924094146,
				0.0651555334325362, 0.046668208054846616, 0.03269873272660903, 0.022379471063648477, 0.01493783509605013, 0.00970722373939169, 0.0061300376320830305, 0.0037542509774318345, 0.0022250827064786427, 0.0012733279447082382,
				0.0007018595156842423, 0.0003716669362167776, 0.0001885644297670032, 9.139081749071013E-05, 4.21831838417576E-05, 1.8481813599879218E-05, 7.659575852520317E-06, 2.9916615878138786E-06, 1.0968835125901265E-06, 3.759541186236063E-07,
				1.199244278290277E-07, 3.543477717142195E-08, 9.649888896108964E-09, 2.409177325647594E-09, 5.482835779709498E-10, 1.130605534749468E-10, 2.098933540451147E-11, 3.4841937670261058E-12
			},
			new double[96]
			{
				1.5700420292795931, 1.564021403773232, 1.552053169845412, 1.5342817381543035, 1.5109197230741698, 1.482243297885538, 1.4485862549613227, 1.410332971446259, 1.3679105116808965, 1.3217801174437729,
				1.2724283455378627, 1.2203581095793583, 1.1660798699324346, 1.1101031939653403, 1.0529288799552667, 0.9950418040461327, 0.9369046127456679, 0.8789523455527821, 0.8215880352669647, 0.7651792989089561,
				0.710055901205469, 0.6565082461316275, 0.6047867305784036, 0.5551018780036335, 0.5076251588319081, 0.46249039805536774, 0.4197956684450155, 0.37960556938665163, 0.34195379592301683, 0.30684590941791695,
				0.2742622296890681, 0.24416077786983992, 0.21648020911729618, 0.1911426841334275, 0.16805663794826917, 0.14711941325785693, 0.12821973363120098, 0.11123999898874452, 0.09605839186518947, 0.08255078811070174,
				0.070592469906867, 0.0600596423586363, 0.050830757572570474, 0.042787652157725675, 0.035816505604196434, 0.029808628117310127, 0.024661087314753284, 0.020277183817500124, 0.016566786254247574, 0.013446536605285732,
				0.010839937168255907, 0.008677330749539181, 0.006895785969066003, 0.005438899797623999, 0.004256529599017858, 0.0033044669940348304, 0.002544065767529173, 0.0019418357759843675, 0.0014690143599429791, 0.0011011261134519384,
				0.0008175410133246949, 0.0006010398799114742, 0.00043739495615911686, 0.000314972091860212, 0.0002243596520500855, 0.00015802788400701192, 0.00011002112846666697, 7.568399658620148E-05, 5.1421497447658804E-05, 3.44921247593432E-05,
				2.2832118109036146E-05, 1.4908514031870609E-05, 9.598194128378471E-06, 6.089910032094904E-06, 3.8061983264644897E-06, 2.3421667208528095E-06, 1.4183067155493917E-06, 8.447375638485986E-07, 4.94582887027542E-07, 2.8449923659159806E-07,
				1.6069394579076225E-07, 8.907139514024239E-08, 4.842095019807237E-08, 2.5799568229535894E-08, 1.3464645522302038E-08, 6.8784610955899E-09, 3.437185674465009E-09, 1.6788897682161906E-09, 8.009978447972966E-10, 3.729950184305279E-10,
				1.6939457789411648E-10, 7.496739757381822E-11, 3.2304464333252366E-11, 1.3542512912336275E-11, 5.518236946817489E-12, 2.1835922099233607E-12
			}
		};

		public static double Integrate(Func<double, double> f, double intervalBegin, double intervalEnd, double targetRelativeError)
		{
			return NewtonCotesTrapeziumRule.IntegrateAdaptiveTransformedOdd(f, intervalBegin, intervalEnd, Enumerable.Range(0, 10).Select(EvaluateAbcissas), Enumerable.Range(0, 10).Select(EvaluateWeights), 1.0, targetRelativeError);
		}

		public static Complex ContourIntegrate(Func<double, Complex> f, double intervalBegin, double intervalEnd, double targetRelativeError)
		{
			return NewtonCotesTrapeziumRule.ContourIntegrateAdaptiveTransformedOdd(f, intervalBegin, intervalEnd, Enumerable.Range(0, 10).Select(EvaluateAbcissas), Enumerable.Range(0, 10).Select(EvaluateWeights), 1.0, targetRelativeError);
		}

		private static double[] EvaluateAbcissas(int level)
		{
			if (level < PrecomputedAbscissas.Length)
			{
				return PrecomputedAbscissas[level];
			}
			double num = ((level <= 1) ? 1.0 : (1.0 / (double)(2 << level - 2)));
			double num2 = ((level == 0) ? 0.0 : (1.0 / (double)(2 << level - 1)));
			int num3 = ((level == 0) ? 4 : (3 << level - 1));
			double num4 = 0.0;
			double[] array = new double[num3];
			for (int i = 0; i < array.Length; i++)
			{
				double value = num2 + num4;
				num4 += num;
				array[i] = Math.Tanh(Math.PI / 2.0 * Math.Sinh(value));
			}
			return array;
		}

		private static double[] EvaluateWeights(int level)
		{
			if (level < PrecomputedWeights.Length)
			{
				return PrecomputedWeights[level];
			}
			double num = ((level <= 1) ? 1.0 : (1.0 / (double)(2 << level - 2)));
			double num2 = ((level == 0) ? 0.0 : (1.0 / (double)(2 << level - 1)));
			int num3 = ((level == 0) ? 4 : (3 << level - 1));
			double num4 = 0.0;
			double[] array = new double[num3];
			for (int i = 0; i < array.Length; i++)
			{
				double value = num2 + num4;
				num4 += num;
				double num5 = Math.Tanh(Math.PI / 2.0 * Math.Sinh(value));
				array[i] = Math.PI / 2.0 * (1.0 - num5 * num5) * Math.Cosh(value);
			}
			return array;
		}
	}
	public class GaussKronrodRule
	{
		private readonly GaussPointPair gaussKronrodPoint;

		public int Order => gaussKronrodPoint.Order;

		public double[] KronrodAbscissas => gaussKronrodPoint.Abscissas.Clone() as double[];

		public double[] KronrodWeights => gaussKronrodPoint.Weights.Clone() as double[];

		public double[] GaussWeights => gaussKronrodPoint.SecondWeights.Clone() as double[];

		public GaussKronrodRule(int order)
		{
			gaussKronrodPoint = GaussKronrodPointFactory.GetGaussPoint(order);
		}

		public static double Integrate(Func<double, double> f, double intervalBegin, double intervalEnd, out double error, out double L1Norm, double targetRelativeError = 1E-10, int maximumDepth = 15, int order = 15)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (intervalBegin > intervalEnd)
			{
				return 0.0 - Integrate(f, intervalEnd, intervalBegin, out error, out L1Norm, targetRelativeError, maximumDepth, order);
			}
			GaussPointPair gaussPoint = GaussKronrodPointFactory.GetGaussPoint(order);
			if (intervalBegin < double.MinValue && intervalEnd > double.MaxValue)
			{
				return recursive_adaptive_integrate((double t) => f(t / (1.0 - t * t)) * (1.0 + t * t) / ((1.0 - t * t) * (1.0 - t * t)), -1.0, 1.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
			}
			if (intervalEnd > double.MaxValue)
			{
				return recursive_adaptive_integrate((double s) => 2.0 * s * f(intervalBegin + s / (1.0 - s) * (s / (1.0 - s))) / ((1.0 - s) * (1.0 - s) * (1.0 - s)), 0.0, 1.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
			}
			if (intervalBegin < double.MinValue)
			{
				return recursive_adaptive_integrate((double s) => -2.0 * s * f(intervalEnd - s / (1.0 + s) * (s / (1.0 + s))) / ((1.0 + s) * (1.0 + s) * (1.0 + s)), -1.0, 0.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
			}
			return recursive_adaptive_integrate((double t) => f((intervalEnd - intervalBegin) / 4.0 * t * (3.0 - t * t) + (intervalEnd + intervalBegin) / 2.0) * 3.0 * (intervalEnd - intervalBegin) / 4.0 * (1.0 - t * t), -1.0, 1.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
		}

		public static Complex ContourIntegrate(Func<double, Complex> f, double intervalBegin, double intervalEnd, out double error, out double L1Norm, double targetRelativeError = 1E-10, int maximumDepth = 15, int order = 15)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (intervalBegin > intervalEnd)
			{
				return -ContourIntegrate(f, intervalEnd, intervalBegin, out error, out L1Norm, targetRelativeError, maximumDepth, order);
			}
			GaussPointPair gaussPoint = GaussKronrodPointFactory.GetGaussPoint(order);
			if (intervalBegin < double.MinValue && intervalEnd > double.MaxValue)
			{
				return contour_recursive_adaptive_integrate((double t) => f(t / (1.0 - t * t)) * (1.0 + t * t) / ((1.0 - t * t) * (1.0 - t * t)), -1.0, 1.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
			}
			if (intervalEnd > double.MaxValue)
			{
				return contour_recursive_adaptive_integrate((double s) => 2.0 * s * f(intervalBegin + s / (1.0 - s) * (s / (1.0 - s))) / ((1.0 - s) * (1.0 - s) * (1.0 - s)), 0.0, 1.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
			}
			if (intervalBegin < double.MinValue)
			{
				return contour_recursive_adaptive_integrate((double s) => -2.0 * s * f(intervalEnd - s / (1.0 + s) * (s / (1.0 + s))) / ((1.0 + s) * (1.0 + s) * (1.0 + s)), -1.0, 0.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
			}
			return contour_recursive_adaptive_integrate((double t) => f((intervalEnd - intervalBegin) / 4.0 * t * (3.0 - t * t) + (intervalEnd + intervalBegin) / 2.0) * 3 * (intervalEnd - intervalBegin) / 4 * (1.0 - t * t), -1.0, 1.0, maximumDepth, targetRelativeError, 0.0, out error, out L1Norm, gaussPoint);
		}

		private static double integrate_non_adaptive_m1_1(Func<double, double> f, out double error, out double pL1, GaussPointPair gaussKronrodPoint)
		{
			int num = 2;
			int num2 = 1;
			int num3 = (gaussKronrodPoint.Order - 1) / 2;
			double num4 = 0.0;
			double num5 = 0.0;
			double[] abscissas = gaussKronrodPoint.Abscissas;
			double[] weights = gaussKronrodPoint.Weights;
			double[] secondWeights = gaussKronrodPoint.SecondWeights;
			if ((num3 & 1) == 1)
			{
				double num6 = f(0.0);
				num4 = num6 * weights[0];
				num5 += num6 * secondWeights[0];
			}
			else
			{
				double num6 = f(0.0);
				num4 = num6 * weights[0];
				num = 1;
				num2 = 2;
			}
			double num7 = Math.Abs(num4);
			for (int i = num; i < abscissas.Length; i += 2)
			{
				double num6 = f(abscissas[i]);
				double num8 = f(0.0 - abscissas[i]);
				num4 += (num6 + num8) * weights[i];
				num7 += (Math.Abs(num6) + Math.Abs(num8)) * weights[i];
				num5 += (num6 + num8) * secondWeights[i / 2];
			}
			for (int j = num2; j < abscissas.Length; j += 2)
			{
				double num6 = f(abscissas[j]);
				double num8 = f(0.0 - abscissas[j]);
				num4 += (num6 + num8) * weights[j];
				num7 += (Math.Abs(num6) + Math.Abs(num8)) * weights[j];
			}
			pL1 = num7;
			error = Math.Max(Math.Abs(num4 - num5), Math.Abs(num4 * Precision.MachineEpsilon * 2.0));
			return num4;
		}

		private static Complex contour_integrate_non_adaptive_m1_1(Func<double, Complex> f, out double error, out double pL1, GaussPointPair gaussKronrodPoint)
		{
			int num = 2;
			int num2 = 1;
			int number = (gaussKronrodPoint.Order - 1) / 2;
			Complex complex = default(Complex);
			Complex complex2 = default(Complex);
			double[] abscissas = gaussKronrodPoint.Abscissas;
			double[] weights = gaussKronrodPoint.Weights;
			double[] secondWeights = gaussKronrodPoint.SecondWeights;
			if (number.IsOdd())
			{
				Complex complex3 = f(0.0);
				complex = complex3 * weights[0];
				complex2 += complex3 * secondWeights[0];
			}
			else
			{
				Complex complex3 = f(0.0);
				complex = complex3 * weights[0];
				num = 1;
				num2 = 2;
			}
			double num3 = Complex.Abs(complex);
			for (int i = num; i < abscissas.Length; i += 2)
			{
				Complex complex3 = f(abscissas[i]);
				Complex complex4 = f(0.0 - abscissas[i]);
				complex += (complex3 + complex4) * weights[i];
				num3 += (Complex.Abs(complex3) + Complex.Abs(complex4)) * weights[i];
				complex2 += (complex3 + complex4) * secondWeights[i / 2];
			}
			for (int j = num2; j < abscissas.Length; j += 2)
			{
				Complex complex3 = f(abscissas[j]);
				Complex complex4 = f(0.0 - abscissas[j]);
				complex += (complex3 + complex4) * weights[j];
				num3 += (Complex.Abs(complex3) + Complex.Abs(complex4)) * weights[j];
			}
			pL1 = num3;
			error = Math.Max(Complex.Abs(complex - complex2), Complex.Abs(complex * Precision.MachineEpsilon * 2.0));
			return complex;
		}

		private static double recursive_adaptive_integrate(Func<double, double> f, double a, double b, int max_levels, double rel_tol, double abs_tol, out double error, out double L1, GaussPointPair gaussKronrodPoint)
		{
			double mean = (b + a) / 2.0;
			double scale = (b - a) / 2.0;
			double error2;
			double num = integrate_non_adaptive_m1_1((double x) => f(scale * x + mean), out error2, out L1, gaussKronrodPoint);
			double num2 = scale * num;
			double num3 = Math.Abs(num2 * rel_tol);
			if (abs_tol == 0.0)
			{
				abs_tol = num3;
			}
			if (max_levels > 0 && num3 < error2 && abs_tol < error2)
			{
				double num4 = (a + b) / 2.0;
				num2 = recursive_adaptive_integrate(f, a, num4, max_levels - 1, rel_tol, abs_tol / 2.0, out error, out L1, gaussKronrodPoint);
				num2 += recursive_adaptive_integrate(f, num4, b, max_levels - 1, rel_tol, abs_tol / 2.0, out error2, out var L2, gaussKronrodPoint);
				error += error2;
				L1 += L2;
				return num2;
			}
			L1 *= scale;
			error = error2;
			return num2;
		}

		private static Complex contour_recursive_adaptive_integrate(Func<double, Complex> f, double a, double b, int max_levels, double rel_tol, double abs_tol, out double error, out double L1, GaussPointPair gaussKronrodPoint)
		{
			double mean = (b + a) / 2.0;
			double scale = (b - a) / 2.0;
			double error2;
			Complex complex = contour_integrate_non_adaptive_m1_1((double x) => f(scale * x + mean), out error2, out L1, gaussKronrodPoint);
			Complex complex2 = scale * complex;
			double num = Complex.Abs(complex2 * rel_tol);
			if (abs_tol == 0.0)
			{
				abs_tol = num;
			}
			if (max_levels > 0 && num < error2 && abs_tol < error2)
			{
				double num2 = (a + b) / 2.0;
				complex2 = contour_recursive_adaptive_integrate(f, a, num2, max_levels - 1, rel_tol, abs_tol / 2.0, out error, out L1, gaussKronrodPoint);
				complex2 += contour_recursive_adaptive_integrate(f, num2, b, max_levels - 1, rel_tol, abs_tol / 2.0, out error2, out var L2, gaussKronrodPoint);
				error += error2;
				L1 += L2;
				return complex2;
			}
			L1 *= scale;
			error = error2;
			return complex2;
		}
	}
	public class GaussLegendreRule
	{
		private readonly GaussPoint _gaussLegendrePoint;

		public double[] Abscissas => _gaussLegendrePoint.Abscissas.Clone() as double[];

		public double[] Weights => _gaussLegendrePoint.Weights.Clone() as double[];

		public int Order => _gaussLegendrePoint.Order;

		public double IntervalBegin => _gaussLegendrePoint.IntervalBegin;

		public double IntervalEnd => _gaussLegendrePoint.IntervalEnd;

		public GaussLegendreRule(double intervalBegin, double intervalEnd, int order)
		{
			_gaussLegendrePoint = GaussLegendrePointFactory.GetGaussPoint(intervalBegin, intervalEnd, order);
		}

		public double GetAbscissa(int index)
		{
			return _gaussLegendrePoint.Abscissas[index];
		}

		public double GetWeight(int index)
		{
			return _gaussLegendrePoint.Weights[index];
		}

		public static double Integrate(Func<double, double> f, double invervalBegin, double invervalEnd, int order)
		{
			GaussPoint gaussPoint = GaussLegendrePointFactory.GetGaussPoint(order);
			int num = order + 1 >> 1;
			double num2 = 0.5 * (invervalEnd - invervalBegin);
			double num3 = 0.5 * (invervalEnd + invervalBegin);
			double num4;
			if (order.IsOdd())
			{
				num4 = gaussPoint.Weights[0] * f(num3);
				for (int i = 1; i < num; i++)
				{
					double num5 = num2 * gaussPoint.Abscissas[i];
					num4 += gaussPoint.Weights[i] * (f(num3 + num5) + f(num3 - num5));
				}
			}
			else
			{
				num4 = 0.0;
				for (int i = 0; i < num; i++)
				{
					double num5 = num2 * gaussPoint.Abscissas[i];
					num4 += gaussPoint.Weights[i] * (f(num3 + num5) + f(num3 - num5));
				}
			}
			return num2 * num4;
		}

		public static Complex ContourIntegrate(Func<double, Complex> f, double invervalBegin, double invervalEnd, int order)
		{
			GaussPoint gaussPoint = GaussLegendrePointFactory.GetGaussPoint(order);
			int num = order + 1 >> 1;
			double num2 = 0.5 * (invervalEnd - invervalBegin);
			double num3 = 0.5 * (invervalEnd + invervalBegin);
			Complex complex;
			if (order.IsOdd())
			{
				complex = gaussPoint.Weights[0] * f(num3);
				for (int i = 1; i < num; i++)
				{
					double num4 = num2 * gaussPoint.Abscissas[i];
					complex += gaussPoint.Weights[i] * (f(num3 + num4) + f(num3 - num4));
				}
			}
			else
			{
				complex = 0.0;
				for (int i = 0; i < num; i++)
				{
					double num4 = num2 * gaussPoint.Abscissas[i];
					complex += gaussPoint.Weights[i] * (f(num3 + num4) + f(num3 - num4));
				}
			}
			return num2 * complex;
		}

		public static double Integrate(Func<double, double, double> f, double invervalBeginA, double invervalEndA, double invervalBeginB, double invervalEndB, int order)
		{
			GaussPoint gaussPoint = GaussLegendrePointFactory.GetGaussPoint(order);
			int num = order + 1 >> 1;
			double num2 = 0.5 * (invervalEndA - invervalBeginA);
			double num3 = 0.5 * (invervalEndA + invervalBeginA);
			double num4 = 0.5 * (invervalEndB - invervalBeginB);
			double num5 = 0.5 * (invervalEndB + invervalBeginB);
			double num6;
			if (order.IsOdd())
			{
				num6 = gaussPoint.Weights[0] * gaussPoint.Weights[0] * f(num3, num5);
				int i = 1;
				double num7 = 0.0;
				for (; i < num; i++)
				{
					double num8 = num4 * gaussPoint.Abscissas[i];
					num7 += gaussPoint.Weights[i] * (f(num3, num5 + num8) + f(num3, num5 - num8));
				}
				num6 += gaussPoint.Weights[0] * num7;
				int j = 1;
				num7 = 0.0;
				for (; j < num; j++)
				{
					double num9 = num2 * gaussPoint.Abscissas[j];
					num7 += gaussPoint.Weights[j] * (f(num3 + num9, num5) + f(num3 - num9, num5));
				}
				num6 += gaussPoint.Weights[0] * num7;
				for (j = 1; j < num; j++)
				{
					double num9 = num2 * gaussPoint.Abscissas[j];
					for (i = 1; i < num; i++)
					{
						double num8 = num4 * gaussPoint.Abscissas[i];
						num6 += gaussPoint.Weights[j] * gaussPoint.Weights[i] * (f(num3 + num9, num5 + num8) + f(num9 + num3, num5 - num8) + f(num3 - num9, num5 + num8) + f(num3 - num9, num5 - num8));
					}
				}
			}
			else
			{
				num6 = 0.0;
				for (int j = 0; j < num; j++)
				{
					double num9 = num2 * gaussPoint.Abscissas[j];
					for (int i = 0; i < num; i++)
					{
						double num8 = num4 * gaussPoint.Abscissas[i];
						num6 += gaussPoint.Weights[j] * gaussPoint.Weights[i] * (f(num3 + num9, num5 + num8) + f(num9 + num3, num5 - num8) + f(num3 - num9, num5 + num8) + f(num3 - num9, num5 - num8));
					}
				}
			}
			return num4 * num2 * num6;
		}
	}
	public static class NewtonCotesTrapeziumRule
	{
		public static double IntegrateTwoPoint(Func<double, double> f, double intervalBegin, double intervalEnd)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			return (intervalEnd - intervalBegin) / 2.0 * (f(intervalBegin) + f(intervalEnd));
		}

		public static Complex ContourIntegrateTwoPoint(Func<double, Complex> f, double intervalBegin, double intervalEnd)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			return (intervalEnd - intervalBegin) / 2.0 * (f(intervalBegin) + f(intervalEnd));
		}

		public static double IntegrateComposite(Func<double, double> f, double intervalBegin, double intervalEnd, int numberOfPartitions)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (numberOfPartitions <= 0)
			{
				throw new ArgumentOutOfRangeException("numberOfPartitions", "Value must be positive (and not zero).");
			}
			double num = (intervalEnd - intervalBegin) / (double)numberOfPartitions;
			double num2 = num;
			double num3 = 0.5 * (f(intervalBegin) + f(intervalEnd));
			for (int i = 0; i < numberOfPartitions - 1; i++)
			{
				num3 += f(intervalBegin + num2);
				num2 += num;
			}
			return num * num3;
		}

		public static Complex ContourIntegrateComposite(Func<double, Complex> f, double intervalBegin, double intervalEnd, int numberOfPartitions)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (numberOfPartitions <= 0)
			{
				throw new ArgumentOutOfRangeException("numberOfPartitions", "Value must be positive (and not zero).");
			}
			double num = (intervalEnd - intervalBegin) / (double)numberOfPartitions;
			double num2 = num;
			Complex complex = 0.5 * (f(intervalBegin) + f(intervalEnd));
			for (int i = 0; i < numberOfPartitions - 1; i++)
			{
				complex += f(intervalBegin + num2);
				num2 += num;
			}
			return num * complex;
		}

		public static double IntegrateAdaptive(Func<double, double> f, double intervalBegin, double intervalEnd, double targetError)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			int num = 1;
			double num2 = intervalEnd - intervalBegin;
			double num3 = 0.5 * num2 * (f(intervalBegin) + f(intervalEnd));
			for (int i = 0; i < 20; i++)
			{
				double num4 = 0.0;
				for (int j = 0; j < num; j++)
				{
					num4 += f(intervalBegin + ((double)j + 0.5) * num2);
				}
				num4 *= num2;
				num3 = 0.5 * (num3 + num4);
				num2 *= 0.5;
				num *= 2;
				if (num3.AlmostEqualRelative(num4, targetError))
				{
					break;
				}
			}
			return num3;
		}

		public static Complex ContourIntegrateAdaptive(Func<double, Complex> f, double intervalBegin, double intervalEnd, double targetError)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			int num = 1;
			double num2 = intervalEnd - intervalBegin;
			Complex complex = 0.5 * num2 * (f(intervalBegin) + f(intervalEnd));
			for (int i = 0; i < 20; i++)
			{
				Complex complex2 = 0;
				for (int j = 0; j < num; j++)
				{
					complex2 += f(intervalBegin + ((double)j + 0.5) * num2);
				}
				complex2 *= (Complex)num2;
				complex = 0.5 * (complex + complex2);
				num2 *= 0.5;
				num *= 2;
				if (complex.AlmostEqualRelative(complex2, targetError))
				{
					break;
				}
			}
			return complex;
		}

		public static double IntegrateAdaptiveTransformedOdd(Func<double, double> f, double intervalBegin, double intervalEnd, IEnumerable<double[]> levelAbscissas, IEnumerable<double[]> levelWeights, double levelOneStep, double targetRelativeError)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (levelAbscissas == null)
			{
				throw new ArgumentNullException("levelAbscissas");
			}
			if (levelWeights == null)
			{
				throw new ArgumentNullException("levelWeights");
			}
			double num = 0.5 * (intervalEnd - intervalBegin);
			double num2 = 0.5 * (intervalEnd + intervalBegin);
			targetRelativeError /= 5.0 * num;
			using IEnumerator<double[]> enumerator = levelAbscissas.GetEnumerator();
			using IEnumerator<double[]> enumerator2 = levelWeights.GetEnumerator();
			double num3 = levelOneStep;
			enumerator.MoveNext();
			enumerator2.MoveNext();
			double[] current = enumerator.Current;
			double[] current2 = enumerator2.Current;
			double num4 = f(num2) * current2[0];
			for (int i = 1; i < current.Length; i++)
			{
				num4 += current2[i] * (f(num * current[i] + num2) + f(0.0 - num * current[i] + num2));
			}
			num4 *= num3;
			double d = double.MaxValue;
			int num5 = 1;
			while (enumerator.MoveNext() && enumerator2.MoveNext())
			{
				double[] current3 = enumerator.Current;
				double[] current4 = enumerator2.Current;
				double num6 = 0.0;
				for (int j = 0; j < current3.Length; j++)
				{
					num6 += current4[j] * (f(num * current3[j] + num2) + f(0.0 - num * current3[j] + num2));
				}
				num6 *= num3;
				num4 = 0.5 * (num4 + num6);
				num3 *= 0.5;
				double num7 = Math.Abs(num4 - num6);
				if (num5 == 1)
				{
					d = num7;
				}
				else
				{
					double num8 = Math.Log(num7) / Math.Log(d);
					d = num7;
					if (num8 > 1.9 && num8 < 2.1)
					{
						num7 = Math.Sqrt(num7);
					}
					if (num4.AlmostEqualNormRelative(num6, num7, targetRelativeError))
					{
						break;
					}
				}
				num5++;
			}
			return num4 * num;
		}

		public static Complex ContourIntegrateAdaptiveTransformedOdd(Func<double, Complex> f, double intervalBegin, double intervalEnd, IEnumerable<double[]> levelAbscissas, IEnumerable<double[]> levelWeights, double levelOneStep, double targetRelativeError)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (levelAbscissas == null)
			{
				throw new ArgumentNullException("levelAbscissas");
			}
			if (levelWeights == null)
			{
				throw new ArgumentNullException("levelWeights");
			}
			double num = 0.5 * (intervalEnd - intervalBegin);
			double num2 = 0.5 * (intervalEnd + intervalBegin);
			targetRelativeError /= 5.0 * num;
			using IEnumerator<double[]> enumerator = levelAbscissas.GetEnumerator();
			using IEnumerator<double[]> enumerator2 = levelWeights.GetEnumerator();
			double num3 = levelOneStep;
			enumerator.MoveNext();
			enumerator2.MoveNext();
			double[] current = enumerator.Current;
			double[] current2 = enumerator2.Current;
			Complex complex = f(num2) * current2[0];
			for (int i = 1; i < current.Length; i++)
			{
				complex += current2[i] * (f(num * current[i] + num2) + f(0.0 - num * current[i] + num2));
			}
			complex *= (Complex)num3;
			double d = double.MaxValue;
			int num4 = 1;
			while (enumerator.MoveNext() && enumerator2.MoveNext())
			{
				double[] current3 = enumerator.Current;
				double[] current4 = enumerator2.Current;
				Complex complex2 = 0;
				for (int j = 0; j < current3.Length; j++)
				{
					complex2 += current4[j] * (f(num * current3[j] + num2) + f(0.0 - num * current3[j] + num2));
				}
				complex2 *= (Complex)num3;
				complex = 0.5 * (complex + complex2);
				num3 *= 0.5;
				double num5 = Complex.Abs(complex - complex2);
				if (num4 == 1)
				{
					d = num5;
				}
				else
				{
					double num6 = Math.Log(num5) / Math.Log(d);
					d = num5;
					if (num6 > 1.9 && num6 < 2.1)
					{
						num5 = Math.Sqrt(num5);
					}
					if (complex.Real.AlmostEqualNormRelative(complex2.Real, num5, targetRelativeError) && complex.Imaginary.AlmostEqualNormRelative(complex2.Imaginary, num5, targetRelativeError))
					{
						break;
					}
				}
				num4++;
			}
			return complex * num;
		}
	}
	public static class SimpsonRule
	{
		public static double IntegrateThreePoint(Func<double, double> f, double intervalBegin, double intervalEnd)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			double arg = (intervalEnd + intervalBegin) / 2.0;
			return (intervalEnd - intervalBegin) / 6.0 * (f(intervalBegin) + f(intervalEnd) + 4.0 * f(arg));
		}

		public static double IntegrateComposite(Func<double, double> f, double intervalBegin, double intervalEnd, int numberOfPartitions)
		{
			if (f == null)
			{
				throw new ArgumentNullException("f");
			}
			if (numberOfPartitions <= 0)
			{
				throw new ArgumentOutOfRangeException("numberOfPartitions", "Value must be positive (and not zero).");
			}
			if (numberOfPartitions.IsOdd())
			{
				throw new ArgumentException("Value must be even.", "numberOfPartitions");
			}
			double num = (intervalEnd - intervalBegin) / (double)numberOfPartitions;
			double num2 = num / 3.0;
			double num3 = num;
			int num4 = 4;
			double num5 = f(intervalBegin) + f(intervalEnd);
			for (int i = 0; i < numberOfPartitions - 1; i++)
			{
				num5 += (double)num4 * f(intervalBegin + num3);
				num4 = 6 - num4;
				num3 += num;
			}
			return num2 * num5;
		}
	}
}
namespace MathNet.Numerics.Integration.GaussRule
{
	internal static class GaussKronrodPoint
	{
		internal static readonly Dictionary<int, GaussPointPair> PreComputed = new Dictionary<int, GaussPointPair>
		{
			{
				15,
				new GaussPointPair(15, new double[8] { 0.0, 0.20778495500789848, 0.4058451513773972, 0.5860872354676911, 0.7415311855993945, 0.8648644233597691, 0.9491079123427585, 0.9914553711208126 }, new double[8] { 0.20948214108472782, 0.20443294007529889, 0.19035057806478542, 0.1690047266392679, 0.14065325971552592, 0.10479001032225019, 0.06309209262997856, 0.022935322010529224 }, 7, new double[4] { 0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697 })
			},
			{
				21,
				new GaussPointPair(21, new double[11]
				{
					0.0, 0.14887433898163122, 0.2943928627014602, 0.4333953941292472, 0.5627571346686047, 0.6794095682990244, 0.7808177265864169, 0.8650633666889845, 0.9301574913557082, 0.9739065285171717,
					0.9956571630258081
				}, new double[11]
				{
					0.1494455540029169, 0.14773910490133849, 0.14277593857706009, 0.13470921731147334, 0.12349197626206584, 0.10938715880229764, 0.0931254545836976, 0.07503967481091996, 0.054755896574351995, 0.032558162307964725,
					0.011694638867371874
				}, 10, new double[5] { 0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814 })
			},
			{
				31,
				new GaussPointPair(31, new double[16]
				{
					0.0, 0.1011420669187175, 0.20119409399743451, 0.29918000715316884, 0.3941513470775634, 0.4850818636402397, 0.5709721726085388, 0.650996741297417, 0.7244177313601701, 0.790418501442466,
					0.8482065834104272, 0.8972645323440819, 0.937273392400706, 0.9677390756791391, 0.9879925180204854, 0.9980022986933971
				}, new double[16]
				{
					0.10133000701479154, 0.10076984552387559, 0.09917359872179196, 0.09664272698362368, 0.09312659817082532, 0.08856444305621176, 0.08308050282313302, 0.07684968075772038, 0.06985412131872826, 0.06200956780067064,
					0.05348152469092809, 0.04458975132476488, 0.03534636079137585, 0.02546084732671532, 0.015007947329316122, 0.005377479872923349
				}, 15, new double[8] { 0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727 })
			},
			{
				41,
				new GaussPointPair(41, new double[21]
				{
					0.0, 0.07652652113349734, 0.15260546524092267, 0.22778585114164507, 0.301627868114913, 0.37370608871541955, 0.4435931752387251, 0.5108670019508271, 0.5751404468197103, 0.636053680726515,
					0.6932376563347514, 0.7463319064601508, 0.7950414288375512, 0.8391169718222188, 0.878276811252282, 0.912234428251326, 0.9408226338317548, 0.9639719272779138, 0.9815078774502503, 0.9931285991850949,
					0.9988590315882777
				}, new double[21]
				{
					0.07660071191799965, 0.07637786767208074, 0.07570449768455667, 0.07458287540049918, 0.07303069033278667, 0.07105442355344407, 0.06864867292852161, 0.06583459713361842, 0.06265323755478117, 0.05911140088063957,
					0.05519510534828599, 0.05094457392372869, 0.04643482186749767, 0.041668873327973685, 0.036600169758200796, 0.0312873067770328, 0.02588213360495116, 0.020388373461266523, 0.014626169256971253, 0.008600269855642943,
					0.0030735837185205317
				}, 20, new double[10] { 0.15275338713072584, 0.14917298647260374, 0.14209610931838204, 0.13168863844917664, 0.11819453196151841, 0.10193011981724044, 0.08327674157670475, 0.06267204833410907, 0.04060142980038694, 0.017614007139152118 })
			},
			{
				51,
				new GaussPointPair(51, new double[26]
				{
					0.0, 0.06154448300568508, 0.1228646926107104, 0.1837189394210489, 0.24386688372098844, 0.30308953893110785, 0.36117230580938786, 0.4178853821930377, 0.473002731445715, 0.5263252843347191,
					0.577662930241223, 0.6268100990103174, 0.6735663684734684, 0.7177664068130843, 0.7592592630373576, 0.7978737979985001, 0.833442628760834, 0.8658470652932756, 0.8949919978782753, 0.9207471152817016,
					0.9429745712289743, 0.9616149864258425, 0.9766639214595175, 0.9880357945340772, 0.9955569697904981, 0.9992621049926098
				}, new double[26]
				{
					0.061580818067832936, 0.061471189871425316, 0.061128509717053046, 0.06053945537604586, 0.05972034032417406, 0.058689680022394206, 0.057437116361567835, 0.055950811220412316, 0.05425112988854549, 0.05236288580640747,
					0.05027767908071567, 0.04798253713883671, 0.04550291304992179, 0.04287284502017005, 0.04008382550403238, 0.03711627148341554, 0.034002130274329335, 0.030792300167387487, 0.02747531758785174, 0.024009945606953215,
					0.020435371145882834, 0.0168478177091283, 0.013236229195571676, 0.009473973386174152, 0.005561932135356714, 0.001987383892330316
				}, 25, new double[13]
				{
					0.12317605372671545, 0.12224244299031004, 0.11945576353578477, 0.11485825914571164, 0.10851962447426365, 0.10053594906705064, 0.09102826198296365, 0.08014070033500102, 0.06803833381235691, 0.054904695975835194,
					0.040939156701306316, 0.026354986615032137, 0.011393798501026288
				})
			},
			{
				61,
				new GaussPointPair(61, new double[31]
				{
					0.0, 0.0514718425553177, 0.10280693796673702, 0.15386991360858354, 0.20452511668230988, 0.25463692616788985, 0.30407320227362505, 0.3527047255308781, 0.4004012548303944, 0.44703376953808915,
					0.49248046786177857, 0.5366241481420199, 0.5793452358263617, 0.6205261829892429, 0.6600610641266269, 0.6978504947933158, 0.7337900624532268, 0.7677774321048262, 0.799727835821839, 0.8295657623827684,
					0.8572052335460612, 0.8825605357920527, 0.9055733076999078, 0.9262000474292743, 0.94437444474856, 0.9600218649683075, 0.9731163225011262, 0.9836681232797472, 0.9916309968704046, 0.9968934840746495,
					0.9994844100504906
				}, new double[31]
				{
					0.05149472942945157, 0.05142612853745902, 0.051221547849258774, 0.05088179589874961, 0.05040592140278235, 0.04979568342707421, 0.04905543455502978, 0.04818586175708713, 0.04718554656929915, 0.04605923827100699,
					0.04481480013316266, 0.04345253970135607, 0.041969810215164244, 0.040374538951535956, 0.038678945624727595, 0.03688236465182123, 0.034979338028060025, 0.03298144705748372, 0.030907257562387762, 0.02875404876504129,
					0.0265099548823331, 0.0241911620780806, 0.021828035821609193, 0.019414141193942382, 0.01692088918905327, 0.014369729507045804, 0.011823015253496341, 0.009273279659517764, 0.0066307039159312926, 0.003890461127099884,
					0.0013890136986770077
				}, 30, new double[15]
				{
					0.10285265289355884, 0.1017623897484055, 0.09959342058679527, 0.09636873717464425, 0.09212252223778612, 0.08689978720108298, 0.08075589522942021, 0.0737559747377052, 0.06597422988218049, 0.057493156217619065,
					0.04840267283059405, 0.03879919256962705, 0.02878470788332337, 0.01846646831109096, 0.007968192496166605
				})
			}
		};

		internal static GaussPointPair Generate(int order, double eps)
		{
			int num = (order - 1) / 2;
			int num2 = ((!num.IsOdd()) ? 1 : 0);
			int num3 = (num.IsOdd() ? 1 : 0);
			GaussPoint gaussPoint = GaussLegendrePointFactory.GetGaussPoint(num);
			double[] abscissas = gaussPoint.Abscissas;
			double[] weights = gaussPoint.Weights;
			double[] a = StieltjesP(num + 1);
			double[] array = new double[num.IsOdd() ? ((num - 1) / 2 + 1) : (num / 2 + 1)];
			for (int i = 1; i <= num + 1; i += 2)
			{
				double num4 = (1.0 - (1.0 - 1.0 / (double)num) / (double)(8 * num * num)) * Math.Cos(((double)i - 0.5) * Math.PI / (2.0 * (double)num + 1.0));
				double num5 = 0.0;
				int num6 = 1;
				do
				{
					Tuple<double, double> tuple = LegendreSeries(a, num4);
					num5 = tuple.Item1 / tuple.Item2;
					num4 -= num5;
					num6++;
				}
				while (Math.Abs(num5) > eps && num6 < 100);
				if (Math.Abs(num4) < Precision.MachineEpsilon)
				{
					num4 = 0.0;
				}
				array[(i - 1) / 2] = num4;
			}
			double[] array2 = new double[abscissas.Length + array.Length];
			abscissas.CopyTo(array2, 0);
			array.CopyTo(array2, abscissas.Length);
			array2 = array2.OrderBy((double v) => v).ToArray();
			double[] array3 = new double[abscissas.Length + array.Length];
			for (int j = num2; j < array2.Length; j += 2)
			{
				double num7 = array2[j];
				Tuple<double, double> tuple2 = LegendreSeries(a, num7);
				double item = LegendreP(num, num7).Item2;
				double num8 = 2.0 / ((1.0 - num7 * num7) * item * item);
				array3[j] = num8 + 2.0 / (((double)num + 1.0) * item * tuple2.Item1);
			}
			for (int k = num3; k < array2.Length; k += 2)
			{
				double x = array2[k];
				Tuple<double, double> tuple3 = LegendreSeries(a, x);
				Tuple<double, double> tuple4 = LegendreP(num, x);
				array3[k] = 2.0 / (((double)num + 1.0) * tuple4.Item1 * tuple3.Item2);
			}
			return new GaussPointPair(order, array2, array3, num, weights);
		}

		internal static double[] StieltjesP(int order)
		{
			switch (order)
			{
			case 1:
				return new double[2] { 0.0, 1.0 };
			case 2:
				return new double[3] { -0.4, 0.0, 1.0 };
			case 3:
				return new double[4]
				{
					0.0,
					-9.0 / 14.0,
					0.0,
					1.0
				};
			case 4:
				return new double[5]
				{
					14.0 / 891.0,
					0.0,
					-20.0 / 27.0,
					0.0,
					1.0
				};
			case 5:
				return new double[6]
				{
					0.0,
					0.010727908455181182,
					0.0,
					-35.0 / 44.0,
					0.0,
					1.0
				};
			default:
			{
				int num = order - 1;
				int num2 = (num.IsOdd() ? 1 : 0);
				int num3 = (num.IsOdd() ? ((num - 1) / 2 + 2) : (num / 2 + 1));
				double[] array = new double[num3 + 1];
				array[num3] = 1.0;
				for (int i = 1; i < num3; i++)
				{
					double num4 = 1.0;
					array[num3 - i] = 0.0;
					for (int j = num3 + 1 - i; j <= num3; j++)
					{
						double num5 = (num - num2 + 2 * (j + i - 1)) * (num + num2 + 2 * (i - j + 1)) * (num - 1 - num2 + 2 * (j - i)) * (2 * (i + j - 1) - 1 - num2 - num);
						double num6 = (num - num2 + 2 * (j - i)) * (2 * (i + j - 1) - num2 - num) * (num + 1 + num2 + 2 * (i - j)) * (num - 1 - num2 + 2 * (j + i));
						num4 = num4 * num5 / num6;
						array[num3 - i] -= array[j] * num4;
					}
				}
				double[] array2 = new double[2 * num3 - num2];
				for (int k = 1; k < array.Length; k++)
				{
					array2[2 * k - 1 - num2] = array[k];
				}
				return array2;
			}
			}
		}

		internal static Tuple<double, double> LegendreSeries(double[] a, double x)
		{
			if (a.Length == 1)
			{
				return new Tuple<double, double>(a[0], 0.0);
			}
			if (a.Length == 2)
			{
				return new Tuple<double, double>(a[0] + a[1] * x, a[1]);
			}
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = 0.0;
			for (int num6 = a.Length - 1; num6 >= 1; num6--)
			{
				num = a[num6] + (2.0 * (double)num6 + 1.0) / ((double)num6 + 1.0) * x * num2 - ((double)num6 + 1.0) / ((double)num6 + 2.0) * num3;
				double num7 = (2.0 * (double)num6 + 1.0) / ((double)num6 + 1.0) * (num2 + x * num4) - ((double)num6 + 1.0) / ((double)num6 + 2.0) * num5;
				num3 = num2;
				num2 = num;
				num5 = num4;
				num4 = num7;
			}
			double item = a[0] + num2 * x - 0.5 * num3;
			double item2 = num2 + num4 * x - 0.5 * num5;
			return new Tuple<double, double>(item, item2);
		}

		internal static Tuple<double, double> LegendreP(int order, double x)
		{
			switch (order)
			{
			case 0:
				return new Tuple<double, double>(1.0, 0.0);
			case 1:
				return new Tuple<double, double>(x, 1.0);
			default:
			{
				double num = 0.0;
				double num2 = 1.0;
				double num3 = 0.0;
				double num4 = 0.0;
				double num5 = 0.0;
				double num6 = 0.0;
				for (int i = 1; i <= order; i++)
				{
					num = (2.0 * (double)i - 1.0) / (double)i * x * num2 - ((double)i - 1.0) / (double)i * num3;
					num4 = (2.0 * (double)i - 1.0) / (double)i * (num2 + x * num5) - ((double)i - 1.0) / (double)i * num6;
					num3 = num2;
					num2 = num;
					num6 = num5;
					num5 = num4;
				}
				double item = num;
				double item2 = num4;
				return new Tuple<double, double>(item, item2);
			}
			}
		}
	}
	internal static class GaussKronrodPointFactory
	{
		[ThreadStatic]
		private static GaussPointPair gaussKronrodPoint;

		public static GaussPointPair GetGaussPoint(int order)
		{
			if ((gaussKronrodPoint == null || gaussKronrodPoint.Order != order) && !GaussKronrodPoint.PreComputed.TryGetValue(order, out gaussKronrodPoint))
			{
				gaussKronrodPoint = GaussKronrodPoint.Generate(order, 1E-10);
			}
			return gaussKronrodPoint;
		}
	}
	internal static class GaussLegendrePoint
	{
		internal static readonly Dictionary<int, GaussPoint> PreComputed = new Dictionary<int, GaussPoint>
		{
			{
				2,
				new GaussPoint(2, new double[1] { 0.5773502691896257 }, new double[1] { 1.0 })
			},
			{
				4,
				new GaussPoint(4, new double[2] { 0.33998104358485626, 0.8611363115940526 }, new double[2] { 0.6521451548625461, 0.34785484513745385 })
			},
			{
				6,
				new GaussPoint(6, new double[3] { 0.2386191860831969, 0.6612093864662645, 0.932469514203152 }, new double[3] { 0.46791393457269104, 0.3607615730481386, 0.17132449237917036 })
			},
			{
				8,
				new GaussPoint(8, new double[4] { 0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363 }, new double[4] { 0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626 })
			},
			{
				10,
				new GaussPoint(10, new double[5] { 0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717 }, new double[5] { 0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814 })
			},
			{
				12,
				new GaussPoint(12, new double[6] { 0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192 }, new double[6] { 0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183 })
			},
			{
				14,
				new GaussPoint(14, new double[7] { 0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123 }, new double[7] { 0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186 })
			},
			{
				16,
				new GaussPoint(16, new double[8] { 0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499 }, new double[8] { 0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096 })
			},
			{
				18,
				new GaussPoint(18, new double[9] { 0.0847750130417353, 0.2518862256915055, 0.41175116146284263, 0.5597708310739475, 0.6916870430603532, 0.8037049589725231, 0.8926024664975557, 0.9558239495713977, 0.9915651684209309 }, new double[9] { 0.1691423829631436, 0.16427648374583273, 0.15468467512626524, 0.14064291467065065, 0.12255520671147846, 0.10094204410628717, 0.07642573025488905, 0.0497145488949698, 0.02161601352648331 })
			},
			{
				20,
				new GaussPoint(20, new double[10] { 0.07652652113349734, 0.22778585114164507, 0.37370608871541955, 0.5108670019508271, 0.636053680726515, 0.7463319064601508, 0.8391169718222188, 0.912234428251326, 0.9639719272779138, 0.9931285991850949 }, new double[10] { 0.15275338713072584, 0.14917298647260374, 0.14209610931838204, 0.13168863844917664, 0.11819453196151841, 0.10193011981724044, 0.08327674157670475, 0.06267204833410907, 0.04060142980038694, 0.017614007139152118 })
			},
			{
				32,
				new GaussPoint(32, new double[16]
				{
					0.04830766568773832, 0.1444719615827965, 0.23928736225213706, 0.33186860228212767, 0.42135127613063533, 0.5068999089322294, 0.5877157572407623, 0.6630442669302152, 0.7321821187402897, 0.7944837959679424,
					0.84936761373257, 0.8963211557660521, 0.9349060759377397, 0.9647622555875064, 0.9856115115452684, 0.9972638618494816
				}, new double[16]
				{
					0.0965400885147278, 0.09563872007927486, 0.09384439908080457, 0.09117387869576389, 0.08765209300440381, 0.08331192422694675, 0.07819389578707031, 0.0723457941088485, 0.06582222277636185, 0.058684093478535544,
					0.050998059262376175, 0.04283589802222668, 0.03427386291302143, 0.02539206530926206, 0.01627439473090567, 0.007018610009470096
				})
			},
			{
				64,
				new GaussPoint(64, new double[32]
				{
					0.024350292663424433, 0.07299312178779904, 0.12146281929612056, 0.16964442042399283, 0.21742364374000708, 0.2646871622087674, 0.31132287199021097, 0.3572201583376681, 0.4022701579639916, 0.4463660172534641,
					0.48940314570705296, 0.5312794640198946, 0.571895646202634, 0.6111553551723933, 0.6489654712546573, 0.6852363130542333, 0.7198818501716109, 0.7528199072605319, 0.7839723589433414, 0.8132653151227975,
					0.8406292962525803, 0.8659993981540928, 0.8893154459951141, 0.9105221370785028, 0.9295691721319396, 0.9464113748584028, 0.9610087996520538, 0.973326827789911, 0.983336253884626, 0.9910133714767443,
					0.9963401167719553, 0.9993050417357722
				}, new double[32]
				{
					0.048690957009139724, 0.04857546744150343, 0.048344762234802954, 0.04799938859645831, 0.04754016571483031, 0.04696818281621002, 0.046284796581314416, 0.04549162792741814, 0.044590558163756566, 0.04358372452932345,
					0.04247351512365359, 0.04126256324262353, 0.03995374113272034, 0.038550153178615626, 0.03705512854024005, 0.035472213256882386, 0.033805161837141606, 0.03205792835485155, 0.030234657072402478, 0.028339672614259483,
					0.02637746971505466, 0.024352702568710874, 0.022270173808383253, 0.02013482315353021, 0.017951715775697343, 0.015726030476024718, 0.013463047896718643, 0.011168139460131128, 0.008846759826363947, 0.006504457968978363,
					0.004147033260562468, 0.001783280721696433
				})
			},
			{
				96,
				new GaussPoint(96, new double[48]
				{
					0.01627674484960297, 0.04881298513604973, 0.08129749546442556, 0.11369585011066592, 0.14597371465489695, 0.17809688236761861, 0.2100313104605672, 0.24174315616384, 0.27319881259104917, 0.30436494435449635,
					0.3352085228926254, 0.3656968614723136, 0.3957976498289086, 0.42547898840730053, 0.454709422167743, 0.48345797392059636, 0.5116941771546677, 0.5393881083243575, 0.5665104185613972, 0.593032364777572,
					0.6189258401254686, 0.6441634037849671, 0.6687183100439161, 0.6925645366421715, 0.7156768123489676, 0.7380306437444001, 0.7596023411766475, 0.7803690438674332, 0.8003087441391408, 0.8194003107379316,
					0.8376235112281871, 0.8549590334346014, 0.8713885059092965, 0.8868945174024204, 0.9014606353158523, 0.9150714231208981, 0.9277124567223087, 0.9393703397527552, 0.9500327177844377, 0.9596882914487426,
					0.9683268284632642, 0.9759391745851365, 0.9825172635630147, 0.9880541263296237, 0.9925439003237626, 0.9959818429872093, 0.9983643758631817, 0.9996895038832307
				}, new double[48]
				{
					0.03255061449236317, 0.032516118713868836, 0.03244716371406427, 0.03234382256857593, 0.03220620479403025, 0.032034456231992664, 0.03182875889441101, 0.03158933077072717, 0.031316425596861354, 0.031010332586313836,
					0.030671376123669148, 0.030299915420827595, 0.029896344136328384, 0.029461089958167905, 0.028994614150555237, 0.028497411065085385, 0.027970007616848334, 0.027412962726029243, 0.02682686672559176, 0.026212340735672413,
					0.02557003600534936, 0.02490063322248361, 0.024204841792364692, 0.02348339908592622, 0.022737069658329372, 0.02196664443874435, 0.0211729398921913, 0.020356797154333323, 0.01951908114014502, 0.018660679627411466,
					0.01778250231604526, 0.016885479864245174, 0.015970562902562293, 0.015038721026994937, 0.01409094177231486, 0.013128229566961573, 0.01215160467108832, 0.011162102099838499, 0.010160770535008416, 0.009148671230783386,
					0.008126876925698759, 0.007096470791153865, 0.006058545504235961, 0.005014202742927518, 0.003964554338444687, 0.0029107318179349465, 0.0018539607889469217, 0.0007967920655520124
				})
			},
			{
				100,
				new GaussPoint(100, new double[50]
				{
					0.015628984421543084, 0.046871682421591634, 0.07806858281343663, 0.10918920358006111, 0.14020313723611397, 0.17108008053860327, 0.201789864095736, 0.23230248184497396, 0.2625881203715035, 0.292617188038472,
					0.32236034390052914, 0.3517885263724217, 0.38087298162462996, 0.40958529167830154, 0.4378974021720315, 0.46578164977335806, 0.49321078920819095, 0.520158019881763, 0.5465970120650941, 0.5725019326213812,
					0.5978474702471788, 0.6226088602037078, 0.6467619085141293, 0.670283015603141, 0.693149199355802, 0.7153381175730564, 0.7368280898020207, 0.7575981185197072, 0.7776279096494955, 0.7968978923903145,
					0.8153892383391762, 0.8330838798884008, 0.8499645278795913, 0.8660146884971647, 0.8812186793850184, 0.895561644970727, 0.9090295709825297, 0.921609298145334, 0.9332885350430795, 0.944055870136256,
					0.9539007829254917, 0.9628136542558156, 0.9707857757637063, 0.9778093584869183, 0.983877540706057, 0.9889843952429918, 0.9931249370374434, 0.9962951347331251, 0.9984919506395958, 0.9997137267734413
				}, new double[50]
				{
					0.031255423453863354, 0.031224884254849358, 0.031163835696209907, 0.031072337427566515, 0.030950478850490987, 0.03079837903115259, 0.030616186583980447, 0.03040407952645482, 0.030162265105169145, 0.029890979593332832,
					0.029590488059912642, 0.029261084110638276, 0.0289030896011252, 0.028516854322395098, 0.028102755659101173, 0.02766119822079239, 0.02719261344657688, 0.026697459183570964, 0.026176219239545676, 0.025629402910208116,
					0.02505754448157959, 0.024461202707957052, 0.023840960265968207, 0.023197423185254123, 0.022531220256336273, 0.021843002416247388, 0.021133442112527642, 0.020403232646209433, 0.019653087494435305, 0.018883739613374903,
					0.018095940722128116, 0.017290460568323583, 0.016468086176145213, 0.015629621077546004, 0.014775884527441302, 0.013907710703718773, 0.013025947892971542, 0.012131457662979498, 0.011225114023185977, 0.01030780257486897,
					0.009380419653694457, 0.00844387146966897, 0.007499073255464711, 0.006546948450845322, 0.005588428003865515, 0.0046244500634221196, 0.0036559612013263754, 0.0026839253715534826, 0.0017093926535181052, 0.0007346344905056717
				})
			},
			{
				128,
				new GaussPoint(128, new double[64]
				{
					0.012223698960615764, 0.03666379096873349, 0.06108196960413957, 0.08546364050451549, 0.10979423112764375, 0.13405919946118777, 0.15824404271422493, 0.18233430598533718, 0.2063155909020792, 0.23017356422666,
					0.2538939664226943, 0.2774626201779044, 0.3008654388776772, 0.32408843502441337, 0.3471177285976355, 0.369939555349859, 0.39254027503326744, 0.414906379552275, 0.43702450103710416, 0.4588814198335522,
					0.48046407240417205, 0.5017595591361445, 0.5227551520511755, 0.5434383024128103, 0.5637966482266181, 0.5838180216287631, 0.6034904561585486, 0.6228021939105849, 0.6417416925623075, 0.660297632272646,
					0.6784589224477192, 0.6962147083695144, 0.7135543776835874, 0.7304675667419088, 0.746944166797062, 0.7629743300440948, 0.7785484755064119, 0.7936572947621933, 0.8082917575079137, 0.8224431169556439,
					0.8361029150609068, 0.8492629875779689, 0.8619154689395485, 0.8740527969580318, 0.8856677173453972, 0.8967532880491582, 0.9073028834017568, 0.9173101980809605, 0.9267692508789478, 0.9356743882779164,
					0.9440202878302202, 0.9518019613412644, 0.9590147578536999, 0.9656543664319652, 0.9717168187471366, 0.9771984914639074, 0.9820961084357185, 0.9864067427245862, 0.9901278184917344, 0.9932571129002129,
					0.9957927585349812, 0.997733248625514, 0.9990774599773758, 0.9998248879471319
				}, new double[64]
				{
					0.024446180196262518, 0.024431569097850044, 0.02440235563384958, 0.024358557264690626, 0.024300200167971867, 0.02422731922281525, 0.024139957989019287, 0.024038168681024052, 0.023922012136703457, 0.023791557781003402,
					0.023646883584447616, 0.02348807601653591, 0.02331522999406276, 0.023128448824387027, 0.022927844143686846, 0.02271353585023646, 0.022485652032744968, 0.022244328893799764, 0.02198971066846049, 0.021721949538052076,
					0.02144120553920846, 0.02114764646822135, 0.02084144778075115, 0.02052279248696007, 0.020191871042130043, 0.01984888123283086, 0.019494028058706602, 0.019127523609950944, 0.01874958694054471, 0.01836044393733134,
					0.017960327185008687, 0.017549475827117706, 0.01712813542311138, 0.016696557801589205, 0.016255000909785187, 0.015803728659399347, 0.015343010768865144, 0.014873122602147314, 0.014394345004166847, 0.013906964132951985,
					0.013411271288616333, 0.012907562739267348, 0.012396139543950923, 0.01187730737274028, 0.011351376324080417, 0.010818660739503076, 0.010279479015832158, 0.009734153415006806, 0.009183009871660874, 0.00862637779861675,
					0.008064589890486059, 0.0074979819256347285, 0.006926892566898814, 0.006351663161707189, 0.005772637542865698, 0.00519016183267633, 0.004604584256702955, 0.004016254983738642, 0.0034255260409102157, 0.0028327514714579912,
					0.0022382884309626186, 0.0016425030186690294, 0.0010458126793403489, 0.00044938096029209035
				})
			},
			{
				256,
				new GaussPoint(256, new double[128]
				{
					0.006123912375189529, 0.018370818478813666, 0.03061496877997903, 0.0428545265363791, 0.05508765569463398, 0.0673125211657164, 0.07952728910023296, 0.09173012716351955, 0.1039192048105094, 0.1160926935603328,
					0.1282487672706071, 0.14038560241137588, 0.1525013783386564, 0.16459427756755385, 0.176662486044902, 0.18870419342138883, 0.20071759332312666, 0.21270088362262596, 0.22465226670913196, 0.23656994975828402,
					0.24845214500105667, 0.2602970699919425, 0.2721029478763366, 0.28386800765708176, 0.29559048446013564, 0.3072686197993191, 0.3189006618401063, 0.33048486566241697, 0.34201949352237165, 0.35350281511297,
					0.364933107823654, 0.3763086569987164, 0.38762775619451556, 0.3988887074354591, 0.41008982146871653, 0.4212294180176238, 0.4323058260337413, 0.44331738394752734, 0.45426243991759, 0.46513935207847934,
					0.4759464887869833, 0.48668222886689033, 0.49734496185218147, 0.507933088228616, 0.5184450196736745, 0.5288791792948223, 0.5392340018660592, 0.5495079340627186, 0.5596994346944811, 0.5698069749365687,
					0.579829038559083, 0.5897641221544543, 0.5996107353629683, 0.6093674010963339, 0.6190326557592613, 0.628605049469015, 0.6380831462729114, 0.6474655243637248, 0.6567507762929732, 0.6659375091820485,
					0.6750243449311628, 0.684009920426076, 0.692892887742577, 0.7016719143486851, 0.7103456833045433, 0.7189128934599714, 0.7273722596496521, 0.7357225128859178, 0.7439624005491116, 0.752090686575492,
					0.7601061516426555, 0.7680075933524456, 0.7757938264113258, 0.7834636828081838, 0.791016011989546, 0.7984496810321707, 0.8057635748129987, 0.8129565961764316, 0.8200276660989171, 0.8269757238508125,
					0.8337997271555049, 0.8404986523457627, 0.8470714945172962, 0.853517267679503, 0.8598350049033764, 0.8660237584665545, 0.8720825999954883, 0.8780106206047066, 0.8838069310331583, 0.8894706617776109,
					0.8950009632230845, 0.9003970057703036, 0.9056579799601446, 0.9107830965950651, 0.9157715868574904, 0.9206227024251465, 0.9253357155833162, 0.9299099193340057, 0.9343446275020031, 0.9386391748378148,
					0.9427929171174625, 0.9468052312391275, 0.9506755153166283, 0.9544031887697162, 0.9579876924111781, 0.9614284885307322, 0.9647250609757064, 0.9678769152284895, 0.970883578480743, 0.9737445997043704,
					0.9764595497192342, 0.979028021257622, 0.9814496290254644, 0.9837240097603155, 0.985850822286126, 0.9878297475648606, 0.9896604887450652, 0.9913427712075831, 0.9928763426088221, 0.9942609729224097,
					0.9954964544810964, 0.9965826020233816, 0.9975192527567208, 0.9983062664730065, 0.9989435258434088, 0.9994309374662614, 0.9997684374092631, 0.9999560500189922
				}, new double[128]
				{
					0.012247671640289755, 0.01224583436974792, 0.0122421601042728, 0.012236649395040157, 0.01222930306871028, 0.012220122227303969, 0.01220910824803724, 0.012196262783114713, 0.012181587759481772, 0.012165085378535502,
					0.01214675811579446, 0.01212660872052732, 0.012104640215340462, 0.012080855895724545, 0.01205525932956015, 0.012027854356582572, 0.011998645087805812, 0.011967635904905894, 0.011934831459563562, 0.01190023667276649,
					0.011863856734071079, 0.011825697100823977, 0.011785763497343426, 0.01174406191406055, 0.011700598606620741, 0.011655380094945243, 0.011608413162253107, 0.011559704854043635, 0.011509262477039497, 0.01145709359809064,
					0.011403206043039186, 0.011347607895545493, 0.01129030749587551, 0.011231313439649669, 0.01117063457655345, 0.011108280009009843, 0.0110442590908139, 0.01097858142572957, 0.01091125686604904, 0.010842295511114796,
					0.010771707705804627, 0.010699504038979785, 0.01062569534189656, 0.010550292686581482, 0.010473307384170403, 0.010394750983211729, 0.010314635267934014, 0.01023297225647822, 0.010149774199094866, 0.010065053576306384,
					0.009978823097034911, 0.009891095696695829, 0.009801884535257328, 0.00971120299526628, 0.009619064679840727, 0.009525483410629285, 0.009430473225737753, 0.00933404837762327, 0.009236223330956302, 0.009137012760450806,
					0.009036431548662873, 0.008934494783758207, 0.00883121775724875, 0.008726615961698807, 0.008620705088401015, 0.00851350102502249, 0.008405019853221537, 0.008295277846235226, 0.00818429146643827, 0.008072077362873499,
					0.007958652368754348, 0.007844033498939713, 0.007728237947381556, 0.0076112830845456595, 0.007493186454805884, 0.007373965773812346, 0.007253638925833914, 0.00713222396107539, 0.007009739092969823, 0.0068862026954463204,
					0.0067616333001737985, 0.006636049593781065, 0.0065094704150536606, 0.006381914752107881, 0.006253401739542401, 0.006123950655567933, 0.005993580919115339, 0.005862312086922653, 0.005730163850601437, 0.0055971560336829105,
					0.00546330858864431, 0.005328641593915931, 0.005193175250869281, 0.005056929880786843, 0.004919925921813866, 0.004782183925892691, 0.00464372455568006, 0.004504568581447897, 0.004364736877968057, 0.004224250421381536,
					0.0040831302860526685, 0.003941397641408833, 0.003799073748766258, 0.0036561799581425023, 0.0035127377050563073, 0.003368768507315551, 0.003224293961794198, 0.0030793357411993375, 0.002933915590829717, 0.002788055325327707,
					0.0026417768254274904, 0.002495102034703707, 0.002348052956327312, 0.0022006516498399107, 0.002052920227966143, 0.0019048808534997185, 0.00175655573633073, 0.0016079671307493272, 0.0014591373333107333, 0.0013100886819025046,
					0.0011608435575677248, 0.0010114243932084406, 0.000861853701420089, 0.0007121541634733207, 0.0005623489540314098, 0.0004124632544261763, 0.0002625349442964459, 0.00011278901782227218
				})
			},
			{
				512,
				new GaussPoint(512, new double[256]
				{
					0.003064962185159396, 0.00919477138643291, 0.015324235084898186, 0.021453122959774876, 0.027581204711919785, 0.03370825007248059, 0.03983402881154845, 0.04595831074680906, 0.05208086575219207, 0.05820146376651824,
					0.06431987480214424, 0.0704358689536047, 0.07654921640625105, 0.08265968744488716, 0.08876705246240103, 0.09487108196839254, 0.10097154659779678, 0.10706821711950266, 0.11316086444496654, 0.1192492596368204,
					0.12533317391747448, 0.13141237867771371, 0.13748664548528805, 0.14355574609349603, 0.14961945244976127, 0.15567753670420187, 0.1617297712181921, 0.16777592857291612, 0.17381578157791344, 0.17984910327961592,
					0.1858756669698757, 0.19189524619448403, 0.19790761476168048, 0.20391254675065237, 0.20990981652002394, 0.21589919871633503, 0.22188046828250904, 0.22785340046630959, 0.23381777082878588, 0.23977335525270618,
					0.24571992995097924, 0.25165727147506334, 0.25758515672336263, 0.2635033629496103, 0.2694116677712386, 0.27530984917773504, 0.28119768553898467, 0.28707495561359797, 0.29294143855722443, 0.2987969139308507,
					0.30464116170908423, 0.31047396228842045, 0.31629509649549487, 0.3221043455953188, 0.3279014912994984, 0.33368631577443714, 0.339458601649521, 0.3452181320252867, 0.3509646904815714, 0.3566980610856456,
					0.36241802840032644, 0.3681243774920731, 0.37381689393906337, 0.37949536383925053, 0.3851595738184011, 0.3908093110381125, 0.39644436320381055, 0.40206451857272696, 0.40766956596185555, 0.41325929475588763,
					0.4188334949151263, 0.42439195698337867, 0.4299344720958266, 0.43546083198687474, 0.4409708289979767, 0.4464642560854375, 0.4519409068281941, 0.4574005754355713, 0.4628430567550148, 0.46826814627980007,
					0.47367564015671665, 0.47906533519372846, 0.48443702886760864, 0.4897905193315499, 0.49512560542274864, 0.5004420866699644, 0.5057397633010522, 0.5110184362504699, 0.5162779071667575, 0.5215179784199908,
					0.5267384531092077, 0.5319391350698066, 0.5371198288809178, 0.5422803398727462, 0.5474204741338866, 0.5525400385186102, 0.557638840654122, 0.562716688947789, 0.5677733925943407, 0.5728087615830374,
					0.5778226067048111, 0.5828147395593745, 0.5877849725623008, 0.5927331189520721, 0.5976589927970977, 0.6025624090026994, 0.6074431833180683, 0.612301132343187, 0.6171360735357212, 0.6219478252178794,
					0.6267362065832393, 0.6315010377035416, 0.6362421395354517, 0.6409593339272864, 0.645652443625709, 0.6503212922823893, 0.6549657044606303, 0.6595855056419603, 0.6641805222326905, 0.6687505815704384,
					0.6732955119306152, 0.6778151425328788, 0.6823093035475509, 0.6867778261019991, 0.6912205422869816, 0.695637285162957, 0.7000278887663572, 0.7043921881158238, 0.7087300192184071, 0.7130412190757285,
					0.7173256256901053, 0.7215830780706379, 0.7258134162392593, 0.7300164812367466, 0.734192115128693, 0.7383401610114442, 0.7424604630179923, 0.7465528663238341, 0.7506172171527881, 0.7546533627827725,
					0.7586611515515449, 0.7626404328624002, 0.7665910571898299, 0.7705128760851405, 0.7744057421820317, 0.7782695092021338, 0.7821040319605042, 0.785909166371083, 0.7896847694521072, 0.793430699331483,
					0.7971468152521175, 0.8008329775772071, 0.8044890477954846, 0.8081148885264243, 0.8117103635254043, 0.8152753376888249, 0.8188096770591868, 0.8223132488301236, 0.8257859213513925, 0.8292275641338213,
					0.8326380478542114, 0.8360172443601974, 0.8393650266750627, 0.8426812690025105, 0.8459658467313906, 0.8492186364403826, 0.8524395159026327, 0.8556283640903465, 0.8587850611793374, 0.861909488553529,
					0.8650015288094115, 0.8680610657604539, 0.8710879844414698, 0.8740821711129373, 0.8770435132652723, 0.8799718996230571, 0.882867220149221, 0.8857293660491754, 0.8885582297749018, 0.8913537050289927,
					0.8941156867686465, 0.8968440712096138, 0.8995387558300979, 0.9021996393746068, 0.904826621857758, 0.9074196045680355, 0.9099784900714992, 0.912503182215446, 0.9149935861320229, 0.9174496082417911,
					0.9198711562572436, 0.9222581391862719, 0.9246104673355856, 0.9269280523140828, 0.9292108070361711, 0.9314586457250403, 0.9336714839158854, 0.9358492384590805, 0.9379918275233031, 0.9400991705986094,
					0.9421711884994589, 0.9442078033676905, 0.946208938675448, 0.9481745192280551, 0.9501044711668419, 0.9519987219719198, 0.953857200464906, 0.9556798368115988, 0.9574665625246019, 0.9592173104658972,
					0.9609320148493677, 0.9626106112432703, 0.964253036572656, 0.9658592291217407, 0.9674291285362238, 0.9689626758255566, 0.9704598133651587, 0.9719204848985836, 0.9733446355396325, 0.974732211774417,
					0.9760831614633703, 0.9773974338432059, 0.9786749795288263, 0.9799157505151782, 0.9811197001790571, 0.9822867832808596, 0.983416955966284, 0.9845101757679784, 0.9855664016071379, 0.9865855937950492,
					0.9875677140345829, 0.988512725421635, 0.9894205924465157, 0.9902912809952868, 0.9911247583510481, 0.9919209931951715, 0.9926799556084865, 0.9934016170724148, 0.9940859504700559, 0.9947329300872282,
					0.9953425316134658, 0.9959147321429772, 0.9964495101755774, 0.9969468456176038, 0.9974067197828498, 0.9978291153935629, 0.9982140165816128, 0.9985614088900397, 0.9988712792754494, 0.9991436161123782,
					0.9993784092025992, 0.9995756497983108, 0.9997353306710427, 0.9998574463699794, 0.9999419946068456, 0.9999889909843819
				}, new double[256]
				{
					0.006129905175405786, 0.006129674838036499, 0.006129214171953084, 0.0061285231944655325, 0.006127601931538023, 0.0061264504177879365, 0.006125068696484565, 0.0061234568195474804, 0.006121614847544583, 0.006119542849689829,
					0.0061172409038406286, 0.006114709096494917, 0.00611194752278791, 0.0061089562864885235, 0.006105735499995479, 0.006102285284333078, 0.006098605769146653, 0.006094697092697698, 0.006090559401858673, 0.006086192852107484,
					0.006081597607521643, 0.006076773840772098, 0.006071721733116751, 0.006066441474393642, 0.0060609332630138174, 0.006055197305953877, 0.00604923381874819, 0.006043043025480804, 0.00603662515877702, 0.006029980459794651,
					0.006023109178214963, 0.006016011572233293, 0.006008687908549342, 0.006001138462357161, 0.005993363517334803, 0.0059853633656336705, 0.005977138307867531, 0.005968688653101226, 0.005960014718839055, 0.0059511168310128456,
					0.005941995323969708, 0.005932650540459467, 0.00592308283162179, 0.005913292556972986, 0.005903280084392497, 0.005893045790109079, 0.005882590058686662, 0.0058719132830099005, 0.005861015864269407, 0.005849898211946682,
					0.005838560743798723, 0.005827003885842332, 0.005815228072338101, 0.005803233745774101, 0.005791021356849247, 0.005778591364456372, 0.005765944235664974, 0.005753080445703675, 0.005740000477942355, 0.005726704823873997,
					0.005713193983096209, 0.00569946846329246, 0.005685528780213001, 0.005671375457655483, 0.0056570090274452745, 0.00564243002941548, 0.005627639011386654, 0.005612636529146217, 0.00559742314642757, 0.005581999434888912,
					0.005566365974091761, 0.005550523351479171, 0.0055344721623536665, 0.005518213009854868, 0.005501746504936828, 0.005485073266345076, 0.0054681939205933686, 0.0054511091019401456, 0.0054338194523647, 0.005416325621543051,
					0.005398628266823536, 0.005380728053202108, 0.005362625653297345, 0.0053443217473251835, 0.005325817023073349, 0.005307112175875518, 0.005288207908585191, 0.005269104931549276, 0.0052498039625814025, 0.005230305726934945,
					0.005210610957275773, 0.005190720393654719, 0.005170634783479774, 0.005150354881487996, 0.005129881449717156, 0.005109215257477103, 0.005088357081320852, 0.00506730770501541, 0.00504606791951232, 0.005024638522917945,
					0.005003020320463474, 0.004981214124474668, 0.004959220754341334, 0.0049370410364865365, 0.004914675804335544, 0.004892125898284511, 0.0048693921656689, 0.004846475460731643, 0.004823376644591041, 0.004800096585208407,
					0.0047766361573554515, 0.004752996242581413, 0.004729177729179931, 0.0047051815121556696, 0.004681008493190686, 0.004656659580610546, 0.004632135689350198, 0.004607437740919592, 0.004582566663369048, 0.00455752339125439,
					0.004532308865601825, 0.004506924033872585, 0.004481369849927326, 0.004455647273990282, 0.004429757272613187, 0.004403700818638955, 0.004377478891165124, 0.004351092475507066, 0.004324542563160961, 0.0042978301517665445,
					0.004270956245069616, 0.004243921852884324, 0.004216727991055221, 0.004189375681419093, 0.004161865951766562, 0.0041341998358034645, 0.004106378373112013, 0.004078402609111728, 0.004050273595020158, 0.004021992387813378,
					0.003993560050186275, 0.003964977650512609, 0.003936246262804879, 0.003907366966673955, 0.003878340847288517, 0.003849168995334278, 0.003819852506972998, 0.0037903924838012964, 0.003760790032809257, 0.003731046266338834,
					0.0037011623020420533, 0.0036711392628390144, 0.0036409782768756986, 0.0036106804774815745, 0.003580247003127014, 0.0035496789973805134, 0.0035189776088657204, 0.0034881439912182763, 0.0034571793030424647, 0.003426084707867677,
					0.0033948613741046916, 0.00336351047500177, 0.003332033188600568, 0.0033004306976918752, 0.0032687041897711644, 0.003236854856993974, 0.0032048838961311115, 0.0031727925085236813, 0.003140581900037946, 0.003108253281020012,
					0.003075807866250352, 0.0030432468748981577, 0.003010571530475527, 0.0029777830607914902, 0.002944882697905876, 0.0029118716780830124, 0.0028787512417452737, 0.0028455226334264724, 0.002812187101725092, 0.0027787458992573726,
					0.002745200282610239, 0.0027115515122940878, 0.002677800852695418, 0.0026439495720293237, 0.0026099989422918393, 0.0025759502392121414, 0.002541804742204615, 0.002507563734320775, 0.002473228502201058, 0.0024388003360264737,
					0.002404280529470125, 0.002369670379648598, 0.0023349711870732236, 0.0023001842556012067, 0.0022653108923866346, 0.0022303524078313604, 0.002195310115535763, 0.0021601853322493884, 0.002124979377821473, 0.0020896935751513472,
					0.0020543292501387315, 0.0020188877316339115, 0.00198337035138781, 0.0019477784440019431, 0.0019121133468782765, 0.0018763764001689719, 0.0018405689467260314, 0.0018046923320508429, 0.0017687479042436242, 0.0017327370139527706,
					0.0016966610143241089, 0.0016605212609500561, 0.0016243191118186897, 0.0015880559272627268, 0.0015517330699084185, 0.0015153519046243599, 0.0014789137984702173, 0.001442420120645377, 0.0014058722424375165, 0.0013692715371711026,
					0.001332619380155819, 0.0012959171486349257, 0.001259166221733556, 0.001222367980406954, 0.0011855238073886607, 0.0011486350871386503, 0.001111703205791433, 0.0010747295511041248, 0.0010377155124045075, 0.001000662480539091,
					0.0009635718478212057, 0.0009264450079791583, 0.0008892833561045005, 0.000852088288600481, 0.000814861203130782, 0.0007776034985686973, 0.0007403165749469819, 0.0007030018334087412, 0.0006656606761599344, 0.0006282945064244359,
					0.000590904728403223, 0.0005534927472403895, 0.0005160599690007675, 0.0004786078006679509, 0.00044113765017954055, 0.0004036509265333199, 0.00036614904003562685, 0.0003286334028523334, 0.0002911054302514885, 0.00025356654357058654,
					0.00021601817797699087, 0.0001784618055459533, 0.0001408990173881985, 0.00010333190349691323, 6.57657316592402E-05, 2.825263737393469E-05
				})
			},
			{
				1024,
				new GaussPoint(1024, new double[512]
				{
					0.0015332313560626385, 0.0045996796509132605, 0.007666084694075486, 0.01073241765154228, 0.01379864968998444, 0.016864751977021728, 0.019930695681493978, 0.022996451973732214, 0.026061992025829733, 0.029127287011913174,
					0.032192308108413586, 0.03525702649433746, 0.038321413351537714, 0.04138543986498472, 0.04444907722303722, 0.04751229661771325, 0.050575069244961066, 0.05363736630492994, 0.05669915900224101, 0.059760418546258035,
					0.0628211161513581, 0.06588122303720233, 0.0689407104290065, 0.0719995495578116, 0.07505771166075438, 0.07811516798133776, 0.0811718897697013, 0.08422784828289152, 0.08728301478513213, 0.09033736054809431,
					0.0933908568511668, 0.09644347498172594, 0.09949518623540578, 0.10254596191636782, 0.10559577333757099, 0.10864459182104134, 0.11169238869814169, 0.11473913530984124, 0.11778480300698502, 0.12082936315056332,
					0.12387278711198098, 0.12691504627332656, 0.1299561120276415, 0.13299595577918905, 0.1360345489437232, 0.1390718629487574, 0.14210786923383342, 0.14514253925078968, 0.1481758444640298, 0.15120775635079087,
					0.15423824640141184, 0.15726728611960133, 0.1602948470227058, 0.16332090064197727, 0.166345418522841, 0.16936837222516316, 0.1723897333235182, 0.1754094734074561, 0.1784275640817696, 0.1814439769667611,
					0.1844586836985096, 0.18747165592913745, 0.19048286532707678, 0.19349228357733605, 0.19649988238176616, 0.19950563345932665, 0.2025095085463516, 0.20551147939681544, 0.2085115177825984, 0.21150959549375217,
					0.21450568433876496, 0.2174997561448267, 0.220491782758094, 0.22348173604395472, 0.22646958788729266, 0.22945531019275192, 0.23243887488500103, 0.23542025390899704, 0.23839941923024918, 0.24137634283508258,
					0.24435099673090174, 0.24732335294645358, 0.25029338353209063, 0.2532610605600337, 0.25622635612463474, 0.2591892423426388, 0.2621496913534467, 0.2651076753193767, 0.26806316642592637, 0.27101613688203413,
					0.2739665589203406, 0.27691440479744966, 0.2798596467941893, 0.2828022572158723, 0.2857422083925568, 0.2886794726793061, 0.2916140224564491, 0.29454583012983954, 0.29747486813111584, 0.30040110891796024,
					0.3033245249743575, 0.30624508881085416, 0.30916277296481653, 0.3120775500006892, 0.31498939251025304, 0.3178982731128827, 0.3208041644558044, 0.3237070392143528, 0.32660687009222816, 0.3295036298217529,
					0.33239729116412814, 0.3352878269096896, 0.3381752098781638, 0.3410594129189233, 0.34394040891124206, 0.3468181707645508, 0.3496926714186912, 0.35256388384417087, 0.3554317810424171, 0.35829633604603106,
					0.3611575219190411, 0.3640153117571563, 0.3668696786880191, 0.3697205958714585, 0.37256803649974196, 0.37541197379782765, 0.37825238102361636, 0.3810892314682028, 0.3839224984561267, 0.38675215534562385,
					0.38957817552887647, 0.39240053243226336, 0.39521919951661, 0.3980341502774379, 0.4008453582452138, 0.40365279698559875, 0.40645644009969667, 0.40925626122430225, 0.4120522340321493, 0.41484433223215805,
					0.4176325295696824, 0.4204167998267569, 0.423197116822343, 0.4259734544125758, 0.4287457864910092, 0.4315140869888618, 0.43427832987526205, 0.4370384891574928, 0.4397945388812359, 0.4425464531308161,
					0.44529420602944486, 0.44803777173946374, 0.4507771244625871, 0.45351223844014493, 0.45624308795332497, 0.4589696473234145, 0.4616918909120419, 0.4644097931214176, 0.4671233283945751, 0.46983247121561084,
					0.4725371961099244, 0.47523747764445795, 0.4779332904279356, 0.48062460911110183, 0.4833114083869601, 0.4859936629910107, 0.48867134770148846, 0.4913444373395997, 0.4940129067697591, 0.4966767308998263,
					0.49933588468134116, 0.5019903431097602, 0.5046400812246908, 0.507285074110127, 0.5099252968946826, 0.5125607247518258, 0.5151913329001124, 0.5178170966034189, 0.5204379911711752, 0.5230539919585964,
					0.5256650743669147, 0.5282712138436112, 0.530872385882646, 0.5334685660246892, 0.5360597298573503, 0.5386458530154088, 0.541226911181042, 0.5438028800840546, 0.5463737355021069, 0.5489394532609416,
					0.5515000092346126, 0.5540553793457105, 0.5566055395655898, 0.5591504659145947, 0.5616901344622843, 0.5642245213276582, 0.5667536026793804, 0.5692773547360035, 0.571795753766193, 0.5743087760889496,
					0.5768163980738323, 0.5793185961411806, 0.5818153467623364, 0.5843066264598643, 0.5867924118077738, 0.5892726794317383, 0.591747406009316, 0.5942165682701681, 0.5966801429962784, 0.5991381070221715,
					0.6015904372351302, 0.6040371105754135, 0.6064781040364728, 0.6089133946651687, 0.6113429595619866, 0.613766775881252, 0.6161848208313454, 0.6185970716749167, 0.6210035057290989, 0.6234041003657216,
					0.6257988330115231, 0.6281876811483634, 0.630570622313436, 0.6329476340994783, 0.6353186941549832, 0.6376837801844086, 0.6400428699483877, 0.6423959412639373, 0.644742972004667, 0.6470839401009875,
					0.6494188235403172, 0.65174760036729, 0.6540702486839614, 0.6563867466500144, 0.6586970724829653, 0.6610012044583676, 0.6632991209100174, 0.6655908002301564, 0.667876220869675, 0.6701553613383155,
					0.672428200204874, 0.6746947160974015, 0.6769548877034052, 0.6792086937700489, 0.681456113104353, 0.6836971245733933, 0.6859317071045004, 0.6881598396854568, 0.690381501364696, 0.6925966712514979,
					0.6948053285161866, 0.6970074523903251, 0.6992030221669115, 0.7013920172005735, 0.7035744169077619, 0.7057502007669451, 0.7079193483188013, 0.7100818391664115, 0.7122376529754508, 0.7143867694743797,
					0.7165291684546352, 0.71866482977082, 0.7207937333408926, 0.7229158591463559, 0.7250311872324454, 0.727139697708317, 0.7292413707472337, 0.7313361865867526, 0.7334241255289101, 0.7355051679404074,
					0.7375792942527953, 0.7396464849626581, 0.7417067206317964, 0.7437599818874112, 0.7458062494222848, 0.7478455039949627, 0.749877726429935, 0.7519028976178163, 0.7539209985155253, 0.755932010146464,
					0.7579359136006965, 0.759932690035126, 0.7619223206736728, 0.7639047868074506, 0.7658800697949419, 0.7678481510621742, 0.7698090121028939, 0.7717626344787407, 0.7737089998194209, 0.7756480898228799,
					0.777579886255475, 0.779504370952146, 0.7814215258165864, 0.7833313328214137, 0.7852337740083386, 0.7871288314883342, 0.7890164874418039, 0.7908967241187492, 0.7927695238389364, 0.7946348689920631,
					0.7964927420379235, 0.7983431255065738, 0.8001860019984957, 0.8020213541847606, 0.8038491648071928, 0.805669416678531, 0.8074820926825905, 0.8092871757744238, 0.8110846489804812, 0.8128744953987702,
					0.8146566981990144, 0.816431240622812, 0.8181981059837932, 0.8199572776677768, 0.8217087391329272, 0.8234524739099092, 0.8251884656020433, 0.8269166978854597, 0.828637154509252, 0.8303498192956295,
					0.8320546761400698, 0.8337517090114703, 0.8354409019522987, 0.8371222390787428, 0.8387957045808606, 0.8404612827227282, 0.8421189578425884, 0.8437687143529972, 0.8454105367409712, 0.847044409568133,
					0.8486703174708565, 0.8502882451604115, 0.8518981774231068, 0.8535000991204343, 0.8550939951892107, 0.856679850641719, 0.85825765056585, 0.859827380125242, 0.8613890245594206, 0.8629425691839373,
					0.864487999390508, 0.8660253006471499, 0.867554458498318, 0.8690754585650419, 0.8705882865450599, 0.8720929282129546, 0.8735893694202854, 0.8750775960957229, 0.8765575942451802, 0.8780293499519449,
					0.8794928493768098, 0.8809480787582035, 0.882395024412319, 0.8838336727332431, 0.8852640101930838, 0.886686023342098, 0.8880996988088177, 0.8895050233001756, 0.8909019836016303, 0.8922905665772906,
					0.8936707591700388, 0.895042548401654, 0.8964059213729331, 0.8977608652638133, 0.8991073673334917, 0.900445414920546, 0.9017749954430525, 0.9030960963987054, 0.9044087053649336, 0.9057128099990178,
					0.9070083980382072, 0.9082954572998335, 0.9095739756814265, 0.9108439411608276, 0.9121053417963026, 0.9133581657266545, 0.9146024011713345, 0.9158380364305532, 0.91706505988539, 0.9182834599979034,
					0.9194932253112384, 0.9206943444497352, 0.921886806119035, 0.9230705991061873, 0.924245712279755, 0.9254121345899188, 0.9265698550685812, 0.92771886282947, 0.9288591470682402, 0.929990697062576,
					0.9311135021722909, 0.9322275518394288, 0.9333328355883627, 0.9344293430258929, 0.9355170638413453, 0.9365959878066681, 0.9376661047765279, 0.9387274046884055, 0.9397798775626901, 0.9408235135027729,
					0.941858302695141, 0.942884235409469, 0.9439013019987107, 0.9449094928991898, 0.9459087986306899, 0.9468992097965435, 0.9478807170837206, 0.9488533112629158, 0.9498169831886358, 0.9507717237992849,
					0.9517175241172499, 0.9526543752489854, 0.9535822683850969, 0.9545011948004233, 0.9554111458541198, 0.9563121129897385, 0.9572040877353089, 0.958087061703418, 0.9589610265912885, 0.9598259741808576,
					0.9606818963388538, 0.9615287850168734, 0.9623666322514564, 0.9631954301641612, 0.9640151709616388, 0.964825846935706, 0.965627450463418, 0.9664199740071397, 0.9672034101146173, 0.9679777514190476,
					0.9687429906391477, 0.9694991205792236, 0.9702461341292372, 0.9709840242648741, 0.9717127840476089, 0.9724324066247705, 0.9731428852296072, 0.9738442131813496, 0.9745363838852737, 0.9752193908327629,
					0.9758932276013692, 0.9765578878548735, 0.9772133653433457, 0.9778596539032024, 0.9784967474572661, 0.9791246400148212, 0.9797433256716714, 0.9803527986101944, 0.980953053099397, 0.9815440834949686,
					0.9821258842393351, 0.9826984498617104, 0.9832617749781478, 0.9838158542915914, 0.9843606825919249, 0.9848962547560215, 0.9854225657477916, 0.9859396106182301, 0.9864473845054632, 0.9869458826347941,
					0.9874351003187474, 0.9879150329571141, 0.988385676036994, 0.9888470251328386, 0.9892990759064927, 0.9897418241072349, 0.9901752655718179, 0.9905993962245077, 0.9910142120771213, 0.9914197092290653,
					0.9918158838673715, 0.9922027322667337, 0.9925802507895418, 0.9929484358859171, 0.9933072840937446, 0.9936567920387066, 0.9939969564343137, 0.9943277740819362, 0.9946492418708341, 0.9949613567781865,
					0.99526411586912, 0.9955575162967363, 0.9958415553021396, 0.9961162302144619, 0.9963815384508895, 0.9966374775166863, 0.9968840450052184, 0.9971212385979773, 0.9973490560646014, 0.9975674952628989,
					0.9977765541388681, 0.9979762307267186, 0.9981665231488915, 0.99834742961608, 0.9985189484272492, 0.9986810779696582, 0.9988338167188826, 0.9989771632388403, 0.9991111161818228, 0.9992356742885348,
					0.9993508363881507, 0.9994566013984001, 0.9995529683257071, 0.9996399362654382, 0.9997175044023747, 0.999785672011689, 0.9998444384611712, 0.999893803216942, 0.9999337658606178, 0.9999643261538894,
					0.9999854843850284, 0.9999972450545584
				}, new double[512]
				{
					0.0030664603092439083, 0.0030664314747171936, 0.0030663738059349007, 0.0030662873034393006, 0.0030661719680437935, 0.0030660278008329002, 0.003065854803162254, 0.0030656529766585846, 0.0030654223232197074, 0.003065162845014501,
					0.00306487454448289, 0.003064557424335821, 0.0030642114875552365, 0.003063836737394048, 0.003063433177376105, 0.0030630008112961606, 0.003062539643219838, 0.0030620496774835908, 0.003061530918694663, 0.0030609833717310454,
					0.0030604070417414287, 0.003059801934145157, 0.003059168054632175, 0.0030585054091629765, 0.0030578140039685463, 0.003057093845550303, 0.003056344940680037, 0.0030555672963998473, 0.003054760920022076, 0.0030539258191292374,
					0.0030530620015739485, 0.003052169475478856, 0.0030512482492365566, 0.003050298331509521, 0.0030493197312300123, 0.0030483124576, 0.0030472765200910755, 0.003046211928444362, 0.003045118692670423, 0.003043996823049169,
					0.003042846330129759, 0.003041667224730504, 0.0030404595179387623, 0.0030392232211108373, 0.003037958345871871, 0.003036664904115732, 0.003035342908004907, 0.003033992369970384, 0.003032613302711537, 0.0030312057191960043,
					0.0030297696326595704, 0.0030283050566060382, 0.0030268120048071025, 0.0030252904913022224, 0.0030237405303984864, 0.003022162136670481, 0.0030205553249601515, 0.003018920110376663, 0.0030172565082962582, 0.0030155645343621132,
					0.0030138442044841908, 0.0030120955348390886, 0.0030103185418698906, 0.0030085132422860094, 0.0030066796530630303, 0.0030048177914425516, 0.003002927674932023, 0.0030010093213045804, 0.002999062748598878, 0.0029970879751189203,
					0.0029950850194338896, 0.002993053900377969, 0.0029909946370501703, 0.002988907248814149, 0.002986791755298025, 0.0029846481763941986, 0.002982476532259162, 0.0029802768433133103, 0.0029780491302407487, 0.0029757934139891004,
					0.002973509715769306, 0.0029711980570554276, 0.0029688584595844443, 0.00296649094535605, 0.0029640955366324437, 0.0029616722559381234, 0.002959221126059671, 0.002956742170045542, 0.002954235411205844, 0.002951700873112122,
					0.0029491385795971333, 0.002946548554754626, 0.0029439308229391105, 0.002941285408765632, 0.002938612337109538, 0.0029359116331062443, 0.0029331833221509997, 0.0029304274298986464, 0.0029276439822633784, 0.0029248330054184994,
					0.0029219945257961746, 0.002919128570087184, 0.00291623516524067, 0.0029133143384638856, 0.0029103661172219363, 0.0029073905292375237, 0.002904387602490684, 0.0029013573652185262, 0.0028982998459149644, 0.0028952150733304507,
					0.0028921030764717066, 0.0028889638846014472, 0.0028857975272381085, 0.002882604034155569, 0.0028793834353828696, 0.0028761357612039303, 0.0028728610421572686, 0.002869559309035708, 0.0028662305928860913, 0.002862874925008989,
					0.0028594923369584034, 0.0028560828605414712, 0.002852646527818167, 0.0028491833711010014, 0.0028456934229547136, 0.0028421767161959702, 0.0028386332838930533, 0.002835063159365551, 0.002831466376184042, 0.0028278429681697845,
					0.0028241929693943926, 0.0028205164141795196, 0.002816813337096534, 0.002813083772966195, 0.002809327756858324, 0.0028055453240914763, 0.0028017365102326075, 0.0027979013510967404, 0.0027940398827466266, 0.00279015214149241,
					0.0027862381638912824, 0.002782297986747142, 0.002778331647110245, 0.0027743391822768605, 0.002770320629788917, 0.0027662760274336498, 0.0027622054132432476, 0.0027581088254944918, 0.0027539863027084, 0.0027498378836498605,
					0.0027456636073272707, 0.0027414635129921674, 0.0027372376401388603, 0.00273298602850406, 0.002728708718066502, 0.002724405749046575, 0.002720077161905938, 0.0027157229973471444, 0.002711343296313256, 0.0027069380999874587,
					0.0027025074497926765, 0.0026980513873911807, 0.0026935699546841987, 0.0026890631938115196, 0.002684531147151098, 0.0026799738573186566, 0.002675391367167283, 0.002670783719787031, 0.00266615095850451, 0.002661493126882482,
					0.002656810268719449, 0.002652102428049244, 0.0026473696491406138, 0.002642611976496806, 0.0026378294548551483, 0.002633022129186627, 0.0026281900446954677, 0.002623333246818706, 0.002618451781225764, 0.0026135456938180188,
					0.0026086150307283703, 0.002603659838320809, 0.0025986801631899797, 0.002593676052160743, 0.0025886475522877337, 0.002583594710854921, 0.002578517575375163, 0.0025734161935897586, 0.002568290613467999, 0.0025631408832067176,
					0.002557967051229837, 0.0025527691661879127, 0.0025475472769576745, 0.0025423014326415696, 0.0025370316825672995, 0.002531738076287356, 0.0025264206635785555, 0.0025210794944415704, 0.00251571461910046, 0.0025103260880021986,
					0.002504913951816198, 0.0024994782614338354, 0.0024940190679679708, 0.00248853642275247, 0.0024830303773417197, 0.0024775009835101424, 0.0024719482932517114, 0.00246637235877946, 0.002460773232524992, 0.0024551509671379883,
					0.002449505615485711, 0.0024438372306525066, 0.002438145865939308, 0.0024324315748631324, 0.002426694411156577, 0.002420934428767316, 0.0024151516818575907, 0.002409346224803704, 0.002403518112195504, 0.002397667398835876,
					0.0023917941397402216, 0.002385898390135948, 0.0023799802054619416, 0.002374039641368053, 0.0023680767537145684, 0.0023620915985716885, 0.0023560842322189993, 0.0023500547111449423, 0.0023440030920462854, 0.0023379294318275875,
					0.002331833787600665, 0.0023257162166840538, 0.0023195767766024714, 0.0023134155250862753, 0.0023072325200709197, 0.0023010278196964108, 0.002294801482306762, 0.0022885535664494425, 0.0022822841308748286, 0.002275993234535651,
					0.0022696809365864387, 0.002263347296382966, 0.002256992373481692, 0.002250616227639201, 0.00224421891881164, 0.002237800507154158, 0.002231361053020336, 0.0022249006169616213, 0.0022184192597267598, 0.0022119170422612226,
					0.002205394025706634, 0.0021988502714001953, 0.0021922858408741103, 0.002185700795855004, 0.002179095198263344, 0.002172469110212858, 0.0021658225940099497, 0.0021591557121531124, 0.002152468527332341, 0.0021457611024285443,
					0.0021390335005129517, 0.0021322857848465214, 0.002125518018879345, 0.0021187302662500516, 0.0021119225907852072, 0.002105095056498718, 0.0020982477275912257, 0.0020913806684495044, 0.002084493943645856, 0.0020775876179375025,
					0.002070661756265976, 0.0020637164237565114, 0.0020567516857174285, 0.0020497676076395243, 0.0020427642551954514, 0.0020357416942391048, 0.0020286999908050002, 0.002021639211107653, 0.0020145594215409584, 0.0020074606886775633,
					0.0020003430792682425, 0.0019932066602412718, 0.0019860514987017955, 0.0019788776619312, 0.001971685217386476, 0.001964474232699588, 0.0019572447756768373, 0.001949996914298224, 0.0019427307167168076, 0.0019354462512580664,
					0.0019281435864192558, 0.0019208227908687633, 0.0019134839334454627, 0.0019061270831580673, 0.0018987523091844808, 0.0018913596808711472, 0.0018839492677323979, 0.0018765211394497986, 0.0018690753658714941, 0.0018616120170115511,
					0.0018541311630493004, 0.0018466328743286767, 0.001839117221357557, 0.0018315842748070977, 0.0018240341055110701, 0.001816466784465195, 0.0018088823828264734, 0.001801280971912519, 0.0017936626232008873, 0.0017860274083284027,
					0.001778375399090486, 0.001770706667440478, 0.001763021285488964, 0.0017553193255030958, 0.0017476008599059108, 0.0017398659612756523, 0.0017321147023450871, 0.00172434715600082, 0.001716563395282611, 0.0017087634933826857,
					0.0017009475236450492, 0.0016931155595647951, 0.0016852676747874155, 0.0016774039431081073, 0.0016695244384710795, 0.001661629234968857, 0.0016537184068415843, 0.0016457920284763273, 0.0016378501744063736, 0.0016298929193105324,
					0.0016219203380124312, 0.0016139325054798132, 0.0016059294968238317, 0.0015979113872983443, 0.0015898782522992046, 0.001581830167363554, 0.0015737672081691113, 0.0015656894505334602, 0.0015575969704133379, 0.0015494898439039192,
					0.0015413681472381023, 0.0015332319567857911, 0.0015250813490531776, 0.0015169164006820224, 0.0015087371884489336, 0.0015005437892646454, 0.0014923362801732949, 0.001484114738351697, 0.0014758792411086194, 0.0014676298658840552,
					0.001459366690248495, 0.0014510897919021973, 0.001442799248674458, 0.0014344951385228783, 0.0014261775395326322, 0.0014178465299157315, 0.001409502188010291, 0.0014011445922797914, 0.0013927738213123423, 0.0013843899538199418,
					0.0013759930686377377, 0.0013675832447232858, 0.0013591605611558068, 0.0013507250971354437, 0.0013422769319825164, 0.0013338161451367763, 0.0013253428161566587, 0.001316857024718535, 0.0013083588506159643, 0.0012998483737589413,
					0.0012913256741731464, 0.0012827908319991929, 0.0012742439274918728, 0.0012656850410194028, 0.0012571142530626688, 0.001248531644214468, 0.0012399372951787519, 0.0012313312867698676, 0.0012227136999117976, 0.001214084615637398,
					0.0012054441150876388, 0.0011967922795108382, 0.0011881291902619004, 0.0011794549288015501, 0.0011707695766955664, 0.001162073215614016, 0.0011533659273304854, 0.001144647793721311, 0.0011359188967648107, 0.001127179318540512,
					0.0011184291412283803, 0.0011096684471080466, 0.001100897318558033, 0.0010921158380549794, 0.0010833240881728665, 0.0010745221515822403, 0.0010657101110494343, 0.0010568880494357914, 0.0010480560496968847, 0.0010392141948817376,
					0.0010303625681320424, 0.001021501252681379, 0.0010126303318544326, 0.0010037498890662086, 0.0009948600078212503, 0.000985960771712852, 0.000977052264422274, 0.000968134569717955, 0.0009592077714547255, 0.0009502719535730179,
					0.0009413272000980781, 0.0009323735951391754, 0.0009234112228888109, 0.0009144401676219266, 0.0009054605136951128, 0.0008964723455458144, 0.0008874757476915377, 0.0008784708047290547, 0.0008694576013336086, 0.0008604362222581168,
					0.0008514067523323745, 0.000842369276462257, 0.0008333238796289207, 0.0008242706468880049, 0.0008152096633688312, 0.0008061410142736039, 0.0007970647848766078, 0.0007879810605234072, 0.0007788899266300433, 0.0007697914686822301,
					0.000760685772234552, 0.0007515729229096584, 0.0007424530063974587, 0.0007333261084543169, 0.0007241923149022446, 0.000715051711628095, 0.0007059043845827542, 0.000696750419780334, 0.0006875899032973623, 0.0006784229212719745,
					0.0006692495599031031, 0.0006600699054496667, 0.0006508840442297606, 0.0006416920626198431, 0.0006324940470539251, 0.0006232900840227563, 0.0006140802600730122, 0.0006048646618064809, 0.0005956433758792484, 0.0005864164890008837,
					0.0005771840879336241, 0.0005679462594915593, 0.0005587030905398147, 0.0005494546679937357, 0.0005402010788180699, 0.0005309424100261499, 0.0005216787486790753, 0.0005124101818848943, 0.000503136796797785, 0.0004938586806172366,
					0.00048457592058722917, 0.0004752886039954145, 0.0004659968181722958, 0.0004567006504904071, 0.00044740018836349264, 0.000438095519245686, 0.00042878673063068894, 0.0004194739100509499, 0.000410157145076843, 0.0004008365233158463,
					0.00039151213241172064, 0.0003821840600436883, 0.00037285239392561214, 0.00036351722180517497, 0.0003541786314630598, 0.0003448367107121306, 0.00033549154739661435, 0.0003261432293912849, 0.00031679184460064856, 0.0003074374809581323,
					0.0002980802264252762, 0.00028872016899093015, 0.00027935739667045705, 0.0002699919975049447, 0.0002606240595604292, 0.0002512536709271339, 0.0002418809197187298, 0.00023250589407162537, 0.00022312868214429782, 0.0002137493721166826,
					0.00020436805218964659, 0.0001949848105845828, 0.000185599735543185, 0.0001762129153274925, 0.00016682443822034953, 0.0001574343925265139, 0.000148042866574808, 0.00013864994872198616, 0.00012925572735951552, 0.00011986029092546958,
					0.00011046372792574376, 0.0001010661269730276, 9.166757686136692E-05, 8.226816671645727E-05, 7.286798631902746E-05, 6.346712685980442E-05, 5.406568289394001E-05, 4.466375812857534E-05, 3.52614859871987E-05, 2.5859124676461857E-05,
					1.645772757989687E-05, 7.07007641018259E-06
				})
			},
			{
				3,
				new GaussPoint(3, new double[2] { 0.0, 0.7745966692414834 }, new double[2]
				{
					8.0 / 9.0,
					5.0 / 9.0
				})
			},
			{
				5,
				new GaussPoint(5, new double[3] { 0.0, 0.5384693101056831, 0.906179845938664 }, new double[3]
				{
					128.0 / 225.0,
					0.47862867049936647,
					0.23692688505618908
				})
			},
			{
				7,
				new GaussPoint(7, new double[4] { 0.0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585 }, new double[4] { 0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697 })
			},
			{
				9,
				new GaussPoint(9, new double[5] { 0.0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261 }, new double[5] { 0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441 })
			},
			{
				11,
				new GaussPoint(11, new double[6] { 0.0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057 }, new double[6] { 0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366 })
			},
			{
				13,
				new GaussPoint(13, new double[7] { 0.0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881 }, new double[7] { 0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588 })
			},
			{
				15,
				new GaussPoint(15, new double[8] { 0.0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854 }, new double[8] { 0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727 })
			},
			{
				17,
				new GaussPoint(17, new double[9] { 0.0, 0.17848418149584785, 0.3512317634538763, 0.5126905370864769, 0.6576711592166907, 0.7815140038968014, 0.8802391537269859, 0.9506755217687678, 0.9905754753144174 }, new double[9] { 0.17944647035620653, 0.17656270536699264, 0.16800410215645004, 0.15404576107681028, 0.13513636846852548, 0.11188384719340397, 0.08503614831717918, 0.0554595293739872, 0.02414830286854793 })
			},
			{
				19,
				new GaussPoint(19, new double[10] { 0.0, 0.16035864564022537, 0.31656409996362983, 0.46457074137596094, 0.600545304661681, 0.7209661773352294, 0.8227146565371428, 0.9031559036148179, 0.96020815213483, 0.9924068438435844 }, new double[10] { 0.1610544498487837, 0.15896884339395434, 0.15276604206585967, 0.1426067021736066, 0.12875396253933621, 0.11156664554733399, 0.09149002162245, 0.06904454273764123, 0.0448142267656996, 0.019461788229726478 })
			}
		};

		internal static GaussPoint Generate(int order, double eps)
		{
			double[] array = new double[1024]
			{
				0.0,
				0.0,
				0.5,
				0.6666666666666667,
				0.75,
				0.8,
				5.0 / 6.0,
				0.8571428571428572,
				0.875,
				8.0 / 9.0,
				0.9,
				0.9090909090909091,
				11.0 / 12.0,
				0.9230769230769231,
				13.0 / 14.0,
				14.0 / 15.0,
				0.9375,
				0.9411764705882353,
				17.0 / 18.0,
				0.9473684210526316,
				0.95,
				20.0 / 21.0,
				21.0 / 22.0,
				0.9565217391304348,
				23.0 / 24.0,
				0.96,
				25.0 / 26.0,
				0.962962962962963,
				27.0 / 28.0,
				0.9655172413793104,
				29.0 / 30.0,
				0.967741935483871,
				31.0 / 32.0,
				32.0 / 33.0,
				33.0 / 34.0,
				34.0 / 35.0,
				35.0 / 36.0,
				0.972972972972973,
				37.0 / 38.0,
				38.0 / 39.0,
				0.975,
				0.975609756097561,
				41.0 / 42.0,
				0.9767441860465116,
				43.0 / 44.0,
				44.0 / 45.0,
				45.0 / 46.0,
				0.9787234042553191,
				47.0 / 48.0,
				0.9795918367346939,
				0.98,
				50.0 / 51.0,
				51.0 / 52.0,
				0.9811320754716981,
				53.0 / 54.0,
				54.0 / 55.0,
				55.0 / 56.0,
				56.0 / 57.0,
				57.0 / 58.0,
				0.9830508474576272,
				59.0 / 60.0,
				0.9836065573770492,
				61.0 / 62.0,
				0.9841269841269842,
				63.0 / 64.0,
				64.0 / 65.0,
				65.0 / 66.0,
				0.9850746268656716,
				67.0 / 68.0,
				68.0 / 69.0,
				69.0 / 70.0,
				0.9859154929577465,
				71.0 / 72.0,
				0.9863013698630136,
				73.0 / 74.0,
				74.0 / 75.0,
				75.0 / 76.0,
				0.987012987012987,
				77.0 / 78.0,
				0.9873417721518988,
				0.9875,
				80.0 / 81.0,
				81.0 / 82.0,
				0.9879518072289156,
				83.0 / 84.0,
				84.0 / 85.0,
				85.0 / 86.0,
				86.0 / 87.0,
				87.0 / 88.0,
				0.9887640449438202,
				89.0 / 90.0,
				0.989010989010989,
				91.0 / 92.0,
				92.0 / 93.0,
				93.0 / 94.0,
				94.0 / 95.0,
				95.0 / 96.0,
				0.9896907216494846,
				97.0 / 98.0,
				98.0 / 99.0,
				0.99,
				0.9900990099009901,
				101.0 / 102.0,
				0.9902912621359223,
				103.0 / 104.0,
				104.0 / 105.0,
				105.0 / 106.0,
				0.9906542056074766,
				107.0 / 108.0,
				0.9908256880733946,
				109.0 / 110.0,
				110.0 / 111.0,
				111.0 / 112.0,
				0.9911504424778761,
				113.0 / 114.0,
				114.0 / 115.0,
				115.0 / 116.0,
				116.0 / 117.0,
				117.0 / 118.0,
				0.9915966386554622,
				119.0 / 120.0,
				0.9917355371900827,
				121.0 / 122.0,
				122.0 / 123.0,
				123.0 / 124.0,
				0.992,
				125.0 / 126.0,
				0.9921259842519685,
				127.0 / 128.0,
				128.0 / 129.0,
				129.0 / 130.0,
				0.9923664122137404,
				131.0 / 132.0,
				0.9924812030075187,
				133.0 / 134.0,
				134.0 / 135.0,
				135.0 / 136.0,
				0.9927007299270073,
				137.0 / 138.0,
				0.9928057553956835,
				139.0 / 140.0,
				140.0 / 141.0,
				141.0 / 142.0,
				0.993006993006993,
				143.0 / 144.0,
				144.0 / 145.0,
				145.0 / 146.0,
				146.0 / 147.0,
				147.0 / 148.0,
				0.9932885906040269,
				149.0 / 150.0,
				0.9933774834437086,
				151.0 / 152.0,
				152.0 / 153.0,
				153.0 / 154.0,
				154.0 / 155.0,
				155.0 / 156.0,
				0.9936305732484076,
				157.0 / 158.0,
				158.0 / 159.0,
				159.0 / 160.0,
				0.9937888198757764,
				161.0 / 162.0,
				0.9938650306748467,
				163.0 / 164.0,
				164.0 / 165.0,
				165.0 / 166.0,
				0.9940119760479041,
				167.0 / 168.0,
				0.9940828402366864,
				169.0 / 170.0,
				0.9941520467836258,
				171.0 / 172.0,
				0.9942196531791907,
				173.0 / 174.0,
				174.0 / 175.0,
				175.0 / 176.0,
				176.0 / 177.0,
				177.0 / 178.0,
				0.994413407821229,
				179.0 / 180.0,
				0.994475138121547,
				181.0 / 182.0,
				182.0 / 183.0,
				183.0 / 184.0,
				184.0 / 185.0,
				185.0 / 186.0,
				0.9946524064171123,
				187.0 / 188.0,
				188.0 / 189.0,
				189.0 / 190.0,
				0.9947643979057592,
				191.0 / 192.0,
				0.9948186528497409,
				193.0 / 194.0,
				194.0 / 195.0,
				195.0 / 196.0,
				0.9949238578680203,
				197.0 / 198.0,
				0.9949748743718593,
				0.995,
				200.0 / 201.0,
				201.0 / 202.0,
				0.9950738916256158,
				203.0 / 204.0,
				204.0 / 205.0,
				205.0 / 206.0,
				206.0 / 207.0,
				207.0 / 208.0,
				0.9952153110047847,
				209.0 / 210.0,
				0.995260663507109,
				211.0 / 212.0,
				212.0 / 213.0,
				213.0 / 214.0,
				214.0 / 215.0,
				215.0 / 216.0,
				0.9953917050691244,
				217.0 / 218.0,
				0.995433789954338,
				219.0 / 220.0,
				0.995475113122172,
				221.0 / 222.0,
				0.9955156950672646,
				223.0 / 224.0,
				224.0 / 225.0,
				225.0 / 226.0,
				0.9955947136563876,
				227.0 / 228.0,
				0.9956331877729258,
				229.0 / 230.0,
				230.0 / 231.0,
				231.0 / 232.0,
				0.9957081545064378,
				233.0 / 234.0,
				234.0 / 235.0,
				235.0 / 236.0,
				236.0 / 237.0,
				237.0 / 238.0,
				0.99581589958159,
				239.0 / 240.0,
				0.995850622406639,
				241.0 / 242.0,
				242.0 / 243.0,
				243.0 / 244.0,
				244.0 / 245.0,
				245.0 / 246.0,
				0.9959514170040485,
				247.0 / 248.0,
				248.0 / 249.0,
				0.996,
				0.9960159362549801,
				251.0 / 252.0,
				0.9960474308300395,
				253.0 / 254.0,
				254.0 / 255.0,
				255.0 / 256.0,
				0.9961089494163424,
				257.0 / 258.0,
				0.9961389961389961,
				259.0 / 260.0,
				260.0 / 261.0,
				261.0 / 262.0,
				0.9961977186311787,
				263.0 / 264.0,
				264.0 / 265.0,
				265.0 / 266.0,
				266.0 / 267.0,
				267.0 / 268.0,
				0.9962825278810409,
				269.0 / 270.0,
				0.996309963099631,
				271.0 / 272.0,
				272.0 / 273.0,
				273.0 / 274.0,
				274.0 / 275.0,
				275.0 / 276.0,
				0.9963898916967509,
				277.0 / 278.0,
				278.0 / 279.0,
				279.0 / 280.0,
				0.99644128113879,
				281.0 / 282.0,
				0.9964664310954063,
				283.0 / 284.0,
				284.0 / 285.0,
				285.0 / 286.0,
				0.9965156794425087,
				287.0 / 288.0,
				0.9965397923875432,
				289.0 / 290.0,
				290.0 / 291.0,
				291.0 / 292.0,
				0.9965870307167235,
				293.0 / 294.0,
				294.0 / 295.0,
				295.0 / 296.0,
				296.0 / 297.0,
				297.0 / 298.0,
				0.9966555183946488,
				299.0 / 300.0,
				0.9966777408637874,
				301.0 / 302.0,
				302.0 / 303.0,
				303.0 / 304.0,
				304.0 / 305.0,
				305.0 / 306.0,
				0.996742671009772,
				307.0 / 308.0,
				308.0 / 309.0,
				309.0 / 310.0,
				0.9967845659163987,
				311.0 / 312.0,
				0.9968051118210862,
				313.0 / 314.0,
				314.0 / 315.0,
				315.0 / 316.0,
				0.9968454258675079,
				317.0 / 318.0,
				0.9968652037617555,
				319.0 / 320.0,
				320.0 / 321.0,
				321.0 / 322.0,
				0.9969040247678018,
				323.0 / 324.0,
				324.0 / 325.0,
				325.0 / 326.0,
				326.0 / 327.0,
				327.0 / 328.0,
				0.9969604863221885,
				329.0 / 330.0,
				0.9969788519637462,
				331.0 / 332.0,
				332.0 / 333.0,
				333.0 / 334.0,
				334.0 / 335.0,
				335.0 / 336.0,
				0.9970326409495549,
				337.0 / 338.0,
				338.0 / 339.0,
				339.0 / 340.0,
				0.9970674486803519,
				341.0 / 342.0,
				0.9970845481049563,
				343.0 / 344.0,
				344.0 / 345.0,
				345.0 / 346.0,
				0.9971181556195965,
				347.0 / 348.0,
				0.997134670487106,
				349.0 / 350.0,
				350.0 / 351.0,
				351.0 / 352.0,
				0.9971671388101983,
				353.0 / 354.0,
				354.0 / 355.0,
				355.0 / 356.0,
				356.0 / 357.0,
				357.0 / 358.0,
				0.9972144846796658,
				359.0 / 360.0,
				0.997229916897507,
				361.0 / 362.0,
				362.0 / 363.0,
				363.0 / 364.0,
				364.0 / 365.0,
				365.0 / 366.0,
				0.997275204359673,
				367.0 / 368.0,
				368.0 / 369.0,
				369.0 / 370.0,
				0.9973045822102425,
				371.0 / 372.0,
				0.9973190348525469,
				373.0 / 374.0,
				374.0 / 375.0,
				375.0 / 376.0,
				0.9973474801061007,
				377.0 / 378.0,
				0.9973614775725593,
				379.0 / 380.0,
				380.0 / 381.0,
				381.0 / 382.0,
				0.9973890339425587,
				383.0 / 384.0,
				384.0 / 385.0,
				385.0 / 386.0,
				386.0 / 387.0,
				387.0 / 388.0,
				0.9974293059125964,
				389.0 / 390.0,
				0.9974424552429667,
				391.0 / 392.0,
				392.0 / 393.0,
				393.0 / 394.0,
				394.0 / 395.0,
				395.0 / 396.0,
				0.9974811083123426,
				397.0 / 398.0,
				0.9974937343358397,
				0.9975,
				0.9975062344139651,
				401.0 / 402.0,
				0.9975186104218362,
				403.0 / 404.0,
				404.0 / 405.0,
				405.0 / 406.0,
				0.9975429975429976,
				407.0 / 408.0,
				0.9975550122249389,
				409.0 / 410.0,
				410.0 / 411.0,
				411.0 / 412.0,
				0.9975786924939467,
				413.0 / 414.0,
				414.0 / 415.0,
				415.0 / 416.0,
				416.0 / 417.0,
				417.0 / 418.0,
				0.9976133651551312,
				419.0 / 420.0,
				0.997624703087886,
				421.0 / 422.0,
				422.0 / 423.0,
				423.0 / 424.0,
				424.0 / 425.0,
				425.0 / 426.0,
				0.9976580796252927,
				427.0 / 428.0,
				428.0 / 429.0,
				429.0 / 430.0,
				0.9976798143851509,
				431.0 / 432.0,
				0.9976905311778291,
				433.0 / 434.0,
				434.0 / 435.0,
				435.0 / 436.0,
				0.9977116704805492,
				437.0 / 438.0,
				0.9977220956719818,
				439.0 / 440.0,
				440.0 / 441.0,
				441.0 / 442.0,
				0.9977426636568849,
				443.0 / 444.0,
				444.0 / 445.0,
				445.0 / 446.0,
				446.0 / 447.0,
				447.0 / 448.0,
				0.9977728285077951,
				449.0 / 450.0,
				0.9977827050997783,
				451.0 / 452.0,
				452.0 / 453.0,
				453.0 / 454.0,
				454.0 / 455.0,
				455.0 / 456.0,
				0.9978118161925602,
				457.0 / 458.0,
				458.0 / 459.0,
				459.0 / 460.0,
				0.9978308026030369,
				461.0 / 462.0,
				0.9978401727861771,
				463.0 / 464.0,
				464.0 / 465.0,
				465.0 / 466.0,
				0.9978586723768736,
				467.0 / 468.0,
				0.997867803837953,
				469.0 / 470.0,
				470.0 / 471.0,
				471.0 / 472.0,
				0.9978858350951374,
				473.0 / 474.0,
				474.0 / 475.0,
				475.0 / 476.0,
				476.0 / 477.0,
				477.0 / 478.0,
				0.9979123173277662,
				479.0 / 480.0,
				0.997920997920998,
				481.0 / 482.0,
				482.0 / 483.0,
				483.0 / 484.0,
				484.0 / 485.0,
				485.0 / 486.0,
				0.997946611909651,
				487.0 / 488.0,
				488.0 / 489.0,
				489.0 / 490.0,
				0.9979633401221996,
				491.0 / 492.0,
				0.9979716024340771,
				493.0 / 494.0,
				494.0 / 495.0,
				495.0 / 496.0,
				0.9979879275653923,
				497.0 / 498.0,
				0.9979959919839679,
				0.998,
				500.0 / 501.0,
				501.0 / 502.0,
				0.9980119284294234,
				503.0 / 504.0,
				504.0 / 505.0,
				505.0 / 506.0,
				506.0 / 507.0,
				507.0 / 508.0,
				0.9980353634577603,
				509.0 / 510.0,
				0.9980430528375734,
				511.0 / 512.0,
				512.0 / 513.0,
				513.0 / 514.0,
				514.0 / 515.0,
				515.0 / 516.0,
				0.9980657640232108,
				517.0 / 518.0,
				518.0 / 519.0,
				519.0 / 520.0,
				0.9980806142034548,
				521.0 / 522.0,
				0.9980879541108987,
				523.0 / 524.0,
				524.0 / 525.0,
				525.0 / 526.0,
				0.9981024667931688,
				527.0 / 528.0,
				0.998109640831758,
				529.0 / 530.0,
				530.0 / 531.0,
				531.0 / 532.0,
				0.99812382739212,
				533.0 / 534.0,
				534.0 / 535.0,
				535.0 / 536.0,
				536.0 / 537.0,
				537.0 / 538.0,
				0.9981447124304267,
				539.0 / 540.0,
				0.9981515711645101,
				541.0 / 542.0,
				542.0 / 543.0,
				543.0 / 544.0,
				544.0 / 545.0,
				545.0 / 546.0,
				0.9981718464351006,
				547.0 / 548.0,
				548.0 / 549.0,
				549.0 / 550.0,
				0.9981851179673321,
				551.0 / 552.0,
				0.9981916817359855,
				553.0 / 554.0,
				554.0 / 555.0,
				555.0 / 556.0,
				0.9982046678635548,
				557.0 / 558.0,
				0.998211091234347,
				559.0 / 560.0,
				560.0 / 561.0,
				561.0 / 562.0,
				0.9982238010657194,
				563.0 / 564.0,
				564.0 / 565.0,
				565.0 / 566.0,
				0.998236331569665,
				567.0 / 568.0,
				0.9982425307557118,
				569.0 / 570.0,
				0.9982486865148862,
				571.0 / 572.0,
				572.0 / 573.0,
				573.0 / 574.0,
				574.0 / 575.0,
				575.0 / 576.0,
				0.9982668977469671,
				577.0 / 578.0,
				578.0 / 579.0,
				579.0 / 580.0,
				0.9982788296041308,
				581.0 / 582.0,
				0.9982847341337907,
				583.0 / 584.0,
				584.0 / 585.0,
				585.0 / 586.0,
				0.9982964224872232,
				587.0 / 588.0,
				0.99830220713073,
				589.0 / 590.0,
				590.0 / 591.0,
				591.0 / 592.0,
				0.9983136593591906,
				593.0 / 594.0,
				594.0 / 595.0,
				595.0 / 596.0,
				596.0 / 597.0,
				597.0 / 598.0,
				0.998330550918197,
				599.0 / 600.0,
				0.9983361064891847,
				601.0 / 602.0,
				602.0 / 603.0,
				603.0 / 604.0,
				604.0 / 605.0,
				605.0 / 606.0,
				0.9983525535420099,
				607.0 / 608.0,
				608.0 / 609.0,
				609.0 / 610.0,
				0.9983633387888707,
				611.0 / 612.0,
				0.99836867862969,
				613.0 / 614.0,
				614.0 / 615.0,
				615.0 / 616.0,
				0.9983792544570502,
				617.0 / 618.0,
				0.9983844911147012,
				619.0 / 620.0,
				620.0 / 621.0,
				621.0 / 622.0,
				0.9983948635634029,
				623.0 / 624.0,
				0.9984,
				625.0 / 626.0,
				626.0 / 627.0,
				627.0 / 628.0,
				0.9984101748807631,
				629.0 / 630.0,
				0.9984152139461173,
				631.0 / 632.0,
				632.0 / 633.0,
				633.0 / 634.0,
				634.0 / 635.0,
				635.0 / 636.0,
				0.9984301412872841,
				637.0 / 638.0,
				638.0 / 639.0,
				639.0 / 640.0,
				0.9984399375975039,
				641.0 / 642.0,
				0.9984447900466563,
				643.0 / 644.0,
				644.0 / 645.0,
				645.0 / 646.0,
				0.9984544049459042,
				647.0 / 648.0,
				0.9984591679506933,
				649.0 / 650.0,
				650.0 / 651.0,
				651.0 / 652.0,
				0.998468606431853,
				653.0 / 654.0,
				654.0 / 655.0,
				655.0 / 656.0,
				656.0 / 657.0,
				657.0 / 658.0,
				0.9984825493171472,
				659.0 / 660.0,
				0.9984871406959153,
				661.0 / 662.0,
				662.0 / 663.0,
				663.0 / 664.0,
				664.0 / 665.0,
				665.0 / 666.0,
				0.9985007496251874,
				667.0 / 668.0,
				668.0 / 669.0,
				669.0 / 670.0,
				0.9985096870342772,
				671.0 / 672.0,
				0.9985141158989599,
				673.0 / 674.0,
				674.0 / 675.0,
				675.0 / 676.0,
				0.9985228951255539,
				677.0 / 678.0,
				0.9985272459499264,
				679.0 / 680.0,
				680.0 / 681.0,
				681.0 / 682.0,
				0.9985358711566618,
				683.0 / 684.0,
				684.0 / 685.0,
				685.0 / 686.0,
				686.0 / 687.0,
				687.0 / 688.0,
				0.9985486211901307,
				689.0 / 690.0,
				0.9985528219971056,
				691.0 / 692.0,
				692.0 / 693.0,
				693.0 / 694.0,
				694.0 / 695.0,
				695.0 / 696.0,
				0.9985652797704447,
				697.0 / 698.0,
				698.0 / 699.0,
				699.0 / 700.0,
				0.9985734664764622,
				701.0 / 702.0,
				0.9985775248933144,
				703.0 / 704.0,
				704.0 / 705.0,
				705.0 / 706.0,
				0.9985855728429985,
				707.0 / 708.0,
				0.998589562764457,
				709.0 / 710.0,
				710.0 / 711.0,
				711.0 / 712.0,
				0.9985974754558204,
				713.0 / 714.0,
				714.0 / 715.0,
				715.0 / 716.0,
				716.0 / 717.0,
				717.0 / 718.0,
				0.9986091794158554,
				719.0 / 720.0,
				0.9986130374479889,
				721.0 / 722.0,
				722.0 / 723.0,
				723.0 / 724.0,
				724.0 / 725.0,
				725.0 / 726.0,
				0.9986244841815681,
				727.0 / 728.0,
				728.0 / 729.0,
				729.0 / 730.0,
				0.9986320109439124,
				731.0 / 732.0,
				0.9986357435197817,
				733.0 / 734.0,
				734.0 / 735.0,
				735.0 / 736.0,
				0.9986431478968792,
				737.0 / 738.0,
				0.9986468200270636,
				739.0 / 740.0,
				740.0 / 741.0,
				741.0 / 742.0,
				0.9986541049798116,
				743.0 / 744.0,
				744.0 / 745.0,
				745.0 / 746.0,
				746.0 / 747.0,
				747.0 / 748.0,
				0.9986648865153538,
				749.0 / 750.0,
				0.9986684420772304,
				751.0 / 752.0,
				752.0 / 753.0,
				753.0 / 754.0,
				754.0 / 755.0,
				755.0 / 756.0,
				0.9986789960369881,
				757.0 / 758.0,
				758.0 / 759.0,
				759.0 / 760.0,
				0.9986859395532195,
				761.0 / 762.0,
				0.9986893840104849,
				763.0 / 764.0,
				764.0 / 765.0,
				765.0 / 766.0,
				0.9986962190352021,
				767.0 / 768.0,
				0.9986996098829649,
				769.0 / 770.0,
				770.0 / 771.0,
				771.0 / 772.0,
				0.9987063389391979,
				773.0 / 774.0,
				774.0 / 775.0,
				775.0 / 776.0,
				776.0 / 777.0,
				777.0 / 778.0,
				0.9987163029525032,
				779.0 / 780.0,
				0.998719590268886,
				781.0 / 782.0,
				782.0 / 783.0,
				783.0 / 784.0,
				784.0 / 785.0,
				785.0 / 786.0,
				0.9987293519695044,
				787.0 / 788.0,
				788.0 / 789.0,
				789.0 / 790.0,
				0.9987357774968394,
				791.0 / 792.0,
				0.9987389659520807,
				793.0 / 794.0,
				794.0 / 795.0,
				795.0 / 796.0,
				0.998745294855709,
				797.0 / 798.0,
				0.9987484355444305,
				799.0 / 800.0,
				800.0 / 801.0,
				801.0 / 802.0,
				0.9987546699875467,
				803.0 / 804.0,
				804.0 / 805.0,
				805.0 / 806.0,
				806.0 / 807.0,
				807.0 / 808.0,
				0.9987639060568603,
				809.0 / 810.0,
				0.998766954377312,
				811.0 / 812.0,
				812.0 / 813.0,
				813.0 / 814.0,
				814.0 / 815.0,
				815.0 / 816.0,
				0.9987760097919217,
				817.0 / 818.0,
				818.0 / 819.0,
				819.0 / 820.0,
				0.9987819732034104,
				821.0 / 822.0,
				0.9987849331713244,
				823.0 / 824.0,
				824.0 / 825.0,
				825.0 / 826.0,
				0.9987908101571947,
				827.0 / 828.0,
				0.9987937273823885,
				829.0 / 830.0,
				830.0 / 831.0,
				831.0 / 832.0,
				0.9987995198079231,
				833.0 / 834.0,
				834.0 / 835.0,
				835.0 / 836.0,
				836.0 / 837.0,
				837.0 / 838.0,
				0.99880810488677,
				839.0 / 840.0,
				0.9988109393579072,
				841.0 / 842.0,
				842.0 / 843.0,
				843.0 / 844.0,
				844.0 / 845.0,
				845.0 / 846.0,
				0.9988193624557261,
				847.0 / 848.0,
				848.0 / 849.0,
				849.0 / 850.0,
				0.9988249118683902,
				851.0 / 852.0,
				0.9988276670574443,
				853.0 / 854.0,
				854.0 / 855.0,
				855.0 / 856.0,
				0.9988331388564761,
				857.0 / 858.0,
				0.9988358556461001,
				859.0 / 860.0,
				860.0 / 861.0,
				861.0 / 862.0,
				0.9988412514484357,
				863.0 / 864.0,
				864.0 / 865.0,
				865.0 / 866.0,
				866.0 / 867.0,
				867.0 / 868.0,
				0.998849252013809,
				869.0 / 870.0,
				0.9988518943742825,
				871.0 / 872.0,
				872.0 / 873.0,
				873.0 / 874.0,
				874.0 / 875.0,
				875.0 / 876.0,
				0.9988597491448119,
				877.0 / 878.0,
				878.0 / 879.0,
				879.0 / 880.0,
				0.9988649262202043,
				881.0 / 882.0,
				0.9988674971687429,
				883.0 / 884.0,
				884.0 / 885.0,
				885.0 / 886.0,
				0.9988726042841037,
				887.0 / 888.0,
				0.9988751406074241,
				889.0 / 890.0,
				890.0 / 891.0,
				891.0 / 892.0,
				0.9988801791713325,
				893.0 / 894.0,
				894.0 / 895.0,
				895.0 / 896.0,
				896.0 / 897.0,
				897.0 / 898.0,
				0.9988876529477196,
				899.0 / 900.0,
				0.9988901220865705,
				901.0 / 902.0,
				902.0 / 903.0,
				903.0 / 904.0,
				904.0 / 905.0,
				905.0 / 906.0,
				0.9988974641675854,
				907.0 / 908.0,
				908.0 / 909.0,
				909.0 / 910.0,
				0.9989023051591658,
				911.0 / 912.0,
				0.9989047097480832,
				913.0 / 914.0,
				914.0 / 915.0,
				915.0 / 916.0,
				0.9989094874591058,
				917.0 / 918.0,
				0.998911860718172,
				919.0 / 920.0,
				920.0 / 921.0,
				921.0 / 922.0,
				0.9989165763813651,
				923.0 / 924.0,
				924.0 / 925.0,
				925.0 / 926.0,
				926.0 / 927.0,
				927.0 / 928.0,
				0.9989235737351991,
				929.0 / 930.0,
				0.9989258861439313,
				931.0 / 932.0,
				932.0 / 933.0,
				933.0 / 934.0,
				934.0 / 935.0,
				935.0 / 936.0,
				0.9989327641408752,
				937.0 / 938.0,
				938.0 / 939.0,
				939.0 / 940.0,
				0.9989373007438895,
				941.0 / 942.0,
				0.9989395546129375,
				943.0 / 944.0,
				944.0 / 945.0,
				945.0 / 946.0,
				0.9989440337909187,
				947.0 / 948.0,
				0.9989462592202318,
				949.0 / 950.0,
				950.0 / 951.0,
				951.0 / 952.0,
				0.9989506820566632,
				953.0 / 954.0,
				954.0 / 955.0,
				955.0 / 956.0,
				956.0 / 957.0,
				957.0 / 958.0,
				0.9989572471324296,
				959.0 / 960.0,
				0.9989594172736732,
				961.0 / 962.0,
				962.0 / 963.0,
				963.0 / 964.0,
				964.0 / 965.0,
				965.0 / 966.0,
				0.9989658738366081,
				967.0 / 968.0,
				968.0 / 969.0,
				969.0 / 970.0,
				0.9989701338825953,
				971.0 / 972.0,
				0.998972250770812,
				973.0 / 974.0,
				974.0 / 975.0,
				975.0 / 976.0,
				0.9989764585465711,
				977.0 / 978.0,
				0.9989785495403473,
				979.0 / 980.0,
				980.0 / 981.0,
				981.0 / 982.0,
				0.9989827060020345,
				983.0 / 984.0,
				984.0 / 985.0,
				985.0 / 986.0,
				986.0 / 987.0,
				987.0 / 988.0,
				0.9989888776541962,
				989.0 / 990.0,
				0.9989909182643795,
				991.0 / 992.0,
				992.0 / 993.0,
				993.0 / 994.0,
				994.0 / 995.0,
				995.0 / 996.0,
				0.9989969909729187,
				997.0 / 998.0,
				998.0 / 999.0,
				0.999,
				0.999000999000999,
				0.999001996007984,
				0.9990029910269193,
				0.999003984063745,
				0.9990049751243781,
				0.9990059642147118,
				0.9990069513406157,
				0.9990079365079365,
				0.9990089197224975,
				0.999009900990099,
				0.9990108803165183,
				0.9990118577075099,
				0.9990128331688055,
				0.9990138067061144,
				0.9990147783251232,
				0.9990157480314961,
				0.9990167158308751,
				0.9990176817288802,
				0.9990186457311089,
				0.9990196078431373,
				0.9990205680705191,
				0.9990215264187867,
				0.9990224828934506
			};
			double num = 0.0;
			int num2 = order + 1 >> 1;
			double[] array2 = new double[num2];
			double[] array3 = new double[num2];
			double num3 = 1.0 - (1.0 - 1.0 / (double)order) / (8.0 * (double)order * (double)order);
			double num4 = 1.0 / (4.0 * (double)order + 2.0);
			for (int i = 1; i <= num2; i++)
			{
				int num5 = 0;
				double num6 = Math.Cos(Math.PI * (double)((i << 2) - 1) * num4) * num3;
				double num13;
				double num14;
				double value;
				double value2;
				do
				{
					double num7 = 1.0;
					double num8 = num6;
					if (order < 1024)
					{
						for (int j = 2; j <= order; j++)
						{
							double num9 = num7;
							num7 = num8;
							double num10 = num6 * num7;
							num8 = num10 + array[j] * (num10 - num9);
						}
					}
					else
					{
						for (int j = 2; j < 1024; j++)
						{
							double num9 = num7;
							num7 = num8;
							double num10 = num6 * num7;
							num8 = num10 + array[j] * (num10 - num9);
						}
						for (int j = 1024; j <= order; j++)
						{
							double num9 = num7;
							num7 = num8;
							double num10 = num6 * num7;
							double num11 = ((double)j - 1.0) / (double)j;
							num8 = num10 + num11 * (num10 - num9);
						}
					}
					double num12 = (num6 * num8 - num7) * (double)order / (num6 * num6 - 1.0);
					num13 = num6 - num8 / num12;
					num14 = 2.0 / ((1.0 - num13 * num13) * num12 * num12);
					if (num5 == 0)
					{
						num = 2.0 / ((1.0 - num6 * num6) * num12 * num12);
					}
					value = num6 - num13;
					value2 = num - num14;
					num6 = num13;
					num = num14;
					num5++;
				}
				while ((Math.Abs(value) > eps || Math.Abs(value2) > eps) && num5 < 100);
				int num15 = num2 - 1 - (i - 1);
				array2[num15] = num13;
				array3[num15] = num14;
			}
			return new GaussPoint(order, array2, array3);
		}
	}
	internal static class GaussLegendrePointFactory
	{
		[ThreadStatic]
		private static GaussPoint _gaussLegendrePoint;

		public static GaussPoint GetGaussPoint(int order)
		{
			if ((_gaussLegendrePoint == null || _gaussLegendrePoint.Order != order) && !GaussLegendrePoint.PreComputed.TryGetValue(order, out _gaussLegendrePoint))
			{
				_gaussLegendrePoint = GaussLegendrePoint.Generate(order, 1E-10);
			}
			return _gaussLegendrePoint;
		}

		public static GaussPoint GetGaussPoint(double intervalBegin, double intervalEnd, int order)
		{
			return Map(intervalBegin, intervalEnd, GetGaussPoint(order));
		}

		private static GaussPoint Map(double intervalBegin, double intervalEnd, GaussPoint gaussPoint)
		{
			double[] array = new double[gaussPoint.Order];
			double[] array2 = new double[gaussPoint.Order];
			double num = 0.5 * (intervalEnd - intervalBegin);
			double num2 = 0.5 * (intervalEnd + intervalBegin);
			int num3 = gaussPoint.Order + 1 >> 1;
			for (int i = 1; i <= num3; i++)
			{
				int num4 = gaussPoint.Order - i;
				int num5 = i - 1;
				int num6 = num3 - i;
				array[num4] = gaussPoint.Abscissas[num6] * num + num2;
				array[num5] = (0.0 - gaussPoint.Abscissas[num6]) * num + num2;
				array2[num4] = gaussPoint.Weights[num6] * num;
				array2[num5] = gaussPoint.Weights[num6] * num;
			}
			return new GaussPoint(intervalBegin, intervalEnd, gaussPoint.Order, array, array2);
		}
	}
	internal class GaussPoint
	{
		internal double[] Abscissas { get; private set; }

		internal double[] Weights { get; private set; }

		internal double IntervalBegin { get; private set; }

		internal double IntervalEnd { get; private set; }

		internal int Order { get; private set; }

		internal GaussPoint(double intervalBegin, double intervalEnd, int order, double[] abscissas, double[] weights)
		{
			Abscissas = abscissas;
			Weights = weights;
			IntervalBegin = intervalBegin;
			IntervalEnd = intervalEnd;
			Order = order;
		}

		internal GaussPoint(int order, double[] abscissas, double[] weights)
			: this(-1.0, 1.0, order, abscissas, weights)
		{
		}
	}
	internal class GaussPointPair
	{
		internal int Order { get; private set; }

		internal double[] Abscissas { get; private set; }

		internal double[] Weights { get; private set; }

		internal int SecondOrder { get; private set; }

		internal double[] SecondAbscissas { get; private set; }

		internal double[] SecondWeights { get; private set; }

		internal double IntervalBegin { get; private set; }

		internal double IntervalEnd { get; private set; }

		internal GaussPointPair(double intervalBegin, double intervalEnd, int order, double[] abscissas, double[] weights, int secondOrder, double[] secondAbscissas, double[] secondWeights)
		{
			IntervalBegin = intervalBegin;
			IntervalEnd = intervalEnd;
			Order = order;
			Abscissas = abscissas;
			Weights = weights;
			SecondOrder = secondOrder;
			SecondAbscissas = secondAbscissas;
			SecondWeights = secondWeights;
		}

		internal GaussPointPair(int order, double[] abscissas, double[] weights, int secondOrder, double[] secondWeights)
			: this(-1.0, 1.0, order, abscissas, weights, secondOrder, null, secondWeights)
		{
		}
	}
}
namespace MathNet.Numerics.IntegralTransforms
{
	public static class Fourier
	{
		public static void Forward(Complex32[] samples)
		{
			FourierTransformControl.Provider.Forward(samples, FourierTransformScaling.SymmetricScaling);
		}

		public static void Forward(Complex[] samples)
		{
			FourierTransformControl.Provider.Forward(samples, FourierTransformScaling.SymmetricScaling);
		}

		public static void Forward(Complex32[] samples, FourierOptions options)
		{
			switch (options)
			{
			case FourierOptions.AsymmetricScaling:
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.Forward(samples, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.Backward(samples, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.Backward(samples, FourierTransformScaling.NoScaling);
				break;
			default:
				FourierTransformControl.Provider.Forward(samples, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void Forward(Complex[] samples, FourierOptions options)
		{
			switch (options)
			{
			case FourierOptions.AsymmetricScaling:
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.Forward(samples, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.Backward(samples, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.Backward(samples, FourierTransformScaling.NoScaling);
				break;
			default:
				FourierTransformControl.Provider.Forward(samples, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void Forward(float[] real, float[] imaginary, FourierOptions options = FourierOptions.Default)
		{
			if (real.Length != imaginary.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			Complex32[] array = new Complex32[real.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Complex32(real[i], imaginary[i]);
			}
			Forward(array, options);
			for (int j = 0; j < array.Length; j++)
			{
				real[j] = array[j].Real;
				imaginary[j] = array[j].Imaginary;
			}
		}

		public static void Forward(double[] real, double[] imaginary, FourierOptions options = FourierOptions.Default)
		{
			if (real.Length != imaginary.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			Complex[] array = new Complex[real.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Complex(real[i], imaginary[i]);
			}
			Forward(array, options);
			for (int j = 0; j < array.Length; j++)
			{
				real[j] = array[j].Real;
				imaginary[j] = array[j].Imaginary;
			}
		}

		public static void ForwardReal(float[] data, int n, FourierOptions options = FourierOptions.Default)
		{
			int num = (n.IsEven() ? (n + 2) : (n + 1));
			if (data.Length < num)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {num} long.");
			}
			if ((options & FourierOptions.InverseExponent) == FourierOptions.InverseExponent)
			{
				throw new NotSupportedException();
			}
			if (options == FourierOptions.AsymmetricScaling || options == FourierOptions.NoScaling)
			{
				FourierTransformControl.Provider.ForwardReal(data, n, FourierTransformScaling.NoScaling);
			}
			else
			{
				FourierTransformControl.Provider.ForwardReal(data, n, FourierTransformScaling.SymmetricScaling);
			}
		}

		public static void ForwardReal(double[] data, int n, FourierOptions options = FourierOptions.Default)
		{
			int num = (n.IsEven() ? (n + 2) : (n + 1));
			if (data.Length < num)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {num} long.");
			}
			if ((options & FourierOptions.InverseExponent) == FourierOptions.InverseExponent)
			{
				throw new NotSupportedException();
			}
			if (options == FourierOptions.AsymmetricScaling || options == FourierOptions.NoScaling)
			{
				FourierTransformControl.Provider.ForwardReal(data, n, FourierTransformScaling.NoScaling);
			}
			else
			{
				FourierTransformControl.Provider.ForwardReal(data, n, FourierTransformScaling.SymmetricScaling);
			}
		}

		public static void ForwardMultiDim(Complex32[] samples, int[] dimensions, FourierOptions options = FourierOptions.Default)
		{
			switch (options)
			{
			case FourierOptions.AsymmetricScaling:
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.ForwardMultidim(samples, dimensions, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.BackwardMultidim(samples, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.BackwardMultidim(samples, dimensions, FourierTransformScaling.NoScaling);
				break;
			default:
				FourierTransformControl.Provider.ForwardMultidim(samples, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void ForwardMultiDim(Complex[] samples, int[] dimensions, FourierOptions options = FourierOptions.Default)
		{
			switch (options)
			{
			case FourierOptions.AsymmetricScaling:
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.ForwardMultidim(samples, dimensions, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.BackwardMultidim(samples, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.BackwardMultidim(samples, dimensions, FourierTransformScaling.NoScaling);
				break;
			default:
				FourierTransformControl.Provider.ForwardMultidim(samples, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void Forward2D(Complex32[] samplesRowWise, int rows, int columns, FourierOptions options = FourierOptions.Default)
		{
			ForwardMultiDim(samplesRowWise, new int[2] { rows, columns }, options);
		}

		public static void Forward2D(Complex[] samplesRowWise, int rows, int columns, FourierOptions options = FourierOptions.Default)
		{
			ForwardMultiDim(samplesRowWise, new int[2] { rows, columns }, options);
		}

		public static void Forward2D(Matrix<Complex32> samples, FourierOptions options = FourierOptions.Default)
		{
			Complex32[] array = samples.AsRowMajorArray();
			if (array != null)
			{
				ForwardMultiDim(array, new int[2] { samples.RowCount, samples.ColumnCount }, options);
				return;
			}
			Complex32[] array2 = samples.AsColumnMajorArray();
			if (array2 != null)
			{
				ForwardMultiDim(array2, new int[2] { samples.ColumnCount, samples.RowCount }, options);
			}
			else
			{
				array2 = samples.ToColumnMajorArray();
				ForwardMultiDim(array2, new int[2] { samples.ColumnCount, samples.RowCount }, options);
				new DenseColumnMajorMatrixStorage<Complex32>(samples.RowCount, samples.ColumnCount, array2).CopyToUnchecked(samples.Storage, ExistingData.Clear);
			}
		}

		public static void Forward2D(Matrix<Complex> samples, FourierOptions options = FourierOptions.Default)
		{
			Complex[] array = samples.AsRowMajorArray();
			if (array != null)
			{
				ForwardMultiDim(array, new int[2] { samples.RowCount, samples.ColumnCount }, options);
				return;
			}
			Complex[] array2 = samples.AsColumnMajorArray();
			if (array2 != null)
			{
				ForwardMultiDim(array2, new int[2] { samples.ColumnCount, samples.RowCount }, options);
			}
			else
			{
				array2 = samples.ToColumnMajorArray();
				ForwardMultiDim(array2, new int[2] { samples.ColumnCount, samples.RowCount }, options);
				new DenseColumnMajorMatrixStorage<Complex>(samples.RowCount, samples.ColumnCount, array2).CopyToUnchecked(samples.Storage, ExistingData.Clear);
			}
		}

		public static void Inverse(Complex32[] spectrum)
		{
			FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.SymmetricScaling);
		}

		public static void Inverse(Complex[] spectrum)
		{
			FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.SymmetricScaling);
		}

		public static void Inverse(Complex32[] spectrum, FourierOptions options)
		{
			switch (options)
			{
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.BackwardScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.Forward(spectrum, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.Forward(spectrum, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.Forward(spectrum, FourierTransformScaling.ForwardScaling);
				break;
			default:
				FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void Inverse(Complex[] spectrum, FourierOptions options)
		{
			switch (options)
			{
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.BackwardScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.Forward(spectrum, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.Forward(spectrum, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.Forward(spectrum, FourierTransformScaling.ForwardScaling);
				break;
			default:
				FourierTransformControl.Provider.Backward(spectrum, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void Inverse(float[] real, float[] imaginary, FourierOptions options = FourierOptions.Default)
		{
			if (real.Length != imaginary.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			Complex32[] array = new Complex32[real.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Complex32(real[i], imaginary[i]);
			}
			Inverse(array, options);
			for (int j = 0; j < array.Length; j++)
			{
				real[j] = array[j].Real;
				imaginary[j] = array[j].Imaginary;
			}
		}

		public static void Inverse(double[] real, double[] imaginary, FourierOptions options = FourierOptions.Default)
		{
			if (real.Length != imaginary.Length)
			{
				throw new ArgumentException("The array arguments must have the same length.");
			}
			Complex[] array = new Complex[real.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Complex(real[i], imaginary[i]);
			}
			Inverse(array, options);
			for (int j = 0; j < array.Length; j++)
			{
				real[j] = array[j].Real;
				imaginary[j] = array[j].Imaginary;
			}
		}

		public static void InverseReal(float[] data, int n, FourierOptions options = FourierOptions.Default)
		{
			int num = (n.IsEven() ? (n + 2) : (n + 1));
			if (data.Length < num)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {num} long.");
			}
			if ((options & FourierOptions.InverseExponent) == FourierOptions.InverseExponent)
			{
				throw new NotSupportedException();
			}
			switch (options)
			{
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.BackwardReal(data, n, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.BackwardReal(data, n, FourierTransformScaling.BackwardScaling);
				break;
			default:
				FourierTransformControl.Provider.BackwardReal(data, n, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void InverseReal(double[] data, int n, FourierOptions options = FourierOptions.Default)
		{
			int num = (n.IsEven() ? (n + 2) : (n + 1));
			if (data.Length < num)
			{
				throw new ArgumentException($"The given array is too small. It must be at least {num} long.");
			}
			if ((options & FourierOptions.InverseExponent) == FourierOptions.InverseExponent)
			{
				throw new NotSupportedException();
			}
			switch (options)
			{
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.BackwardReal(data, n, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.BackwardReal(data, n, FourierTransformScaling.BackwardScaling);
				break;
			default:
				FourierTransformControl.Provider.BackwardReal(data, n, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void InverseMultiDim(Complex32[] spectrum, int[] dimensions, FourierOptions options = FourierOptions.Default)
		{
			switch (options)
			{
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.BackwardMultidim(spectrum, dimensions, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.BackwardMultidim(spectrum, dimensions, FourierTransformScaling.BackwardScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.ForwardMultidim(spectrum, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.ForwardMultidim(spectrum, dimensions, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.ForwardMultidim(spectrum, dimensions, FourierTransformScaling.ForwardScaling);
				break;
			default:
				FourierTransformControl.Provider.BackwardMultidim(spectrum, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void InverseMultiDim(Complex[] spectrum, int[] dimensions, FourierOptions options = FourierOptions.Default)
		{
			switch (options)
			{
			case FourierOptions.NoScaling:
				FourierTransformControl.Provider.BackwardMultidim(spectrum, dimensions, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.BackwardMultidim(spectrum, dimensions, FourierTransformScaling.BackwardScaling);
				break;
			case FourierOptions.InverseExponent:
				FourierTransformControl.Provider.ForwardMultidim(spectrum, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			case FourierOptions.NumericalRecipes:
				FourierTransformControl.Provider.ForwardMultidim(spectrum, dimensions, FourierTransformScaling.NoScaling);
				break;
			case FourierOptions.InverseExponent | FourierOptions.AsymmetricScaling:
				FourierTransformControl.Provider.ForwardMultidim(spectrum, dimensions, FourierTransformScaling.ForwardScaling);
				break;
			default:
				FourierTransformControl.Provider.BackwardMultidim(spectrum, dimensions, FourierTransformScaling.SymmetricScaling);
				break;
			}
		}

		public static void Inverse2D(Complex32[] spectrumRowWise, int rows, int columns, FourierOptions options = FourierOptions.Default)
		{
			InverseMultiDim(spectrumRowWise, new int[2] { rows, columns }, options);
		}

		public static void Inverse2D(Complex[] spectrumRowWise, int rows, int columns, FourierOptions options = FourierOptions.Default)
		{
			InverseMultiDim(spectrumRowWise, new int[2] { rows, columns }, options);
		}

		public static void Inverse2D(Matrix<Complex32> spectrum, FourierOptions options = FourierOptions.Default)
		{
			Complex32[] array = spectrum.AsRowMajorArray();
			if (array != null)
			{
				InverseMultiDim(array, new int[2] { spectrum.RowCount, spectrum.ColumnCount }, options);
				return;
			}
			Complex32[] array2 = spectrum.AsColumnMajorArray();
			if (array2 != null)
			{
				InverseMultiDim(array2, new int[2] { spectrum.ColumnCount, spectrum.RowCount }, options);
			}
			else
			{
				array2 = spectrum.ToColumnMajorArray();
				InverseMultiDim(array2, new int[2] { spectrum.ColumnCount, spectrum.RowCount }, options);
				new DenseColumnMajorMatrixStorage<Complex32>(spectrum.RowCount, spectrum.ColumnCount, array2).CopyToUnchecked(spectrum.Storage, ExistingData.Clear);
			}
		}

		public static void Inverse2D(Matrix<Complex> spectrum, FourierOptions options = FourierOptions.Default)
		{
			Complex[] array = spectrum.AsRowMajorArray();
			if (array != null)
			{
				InverseMultiDim(array, new int[2] { spectrum.RowCount, spectrum.ColumnCount }, options);
				return;
			}
			Complex[] array2 = spectrum.AsColumnMajorArray();
			if (array2 != null)
			{
				InverseMultiDim(array2, new int[2] { spectrum.ColumnCount, spectrum.RowCount }, options);
			}
			else
			{
				array2 = spectrum.ToColumnMajorArray();
				InverseMultiDim(array2, new int[2] { spectrum.ColumnCount, spectrum.RowCount }, options);
				new DenseColumnMajorMatrixStorage<Complex>(spectrum.RowCount, spectrum.ColumnCount, array2).CopyToUnchecked(spectrum.Storage, ExistingData.Clear);
			}
		}

		[Obsolete("Use Forward instead. Will be dropped in version 5.0 and behave like Forward until then.")]
		public static Complex32[] NaiveForward(Complex32[] samples, FourierOptions options = FourierOptions.Default)
		{
			Complex32[] array = new Complex32[samples.Length];
			samples.Copy(array);
			Forward(array, options);
			return array;
		}

		[Obsolete("Use Forward instead. Will be dropped in version 5.0 and behave like Forward until then.")]
		public static Complex[] NaiveForward(Complex[] samples, FourierOptions options = FourierOptions.Default)
		{
			Complex[] array = new Complex[samples.Length];
			samples.Copy(array);
			Forward(array, options);
			return array;
		}

		[Obsolete("Use Inverse instead. Will be dropped in version 5.0 and behave like Inverse until then.")]
		public static Complex32[] NaiveInverse(Complex32[] spectrum, FourierOptions options = FourierOptions.Default)
		{
			Complex32[] array = new Complex32[spectrum.Length];
			spectrum.Copy(array);
			Inverse(array, options);
			return array;
		}

		[Obsolete("Use Inverse instead. Will be dropped in version 5.0 and behave like Inverse until then.")]
		public static Complex[] NaiveInverse(Complex[] spectrum, FourierOptions options = FourierOptions.Default)
		{
			Complex[] array = new Complex[spectrum.Length];
			spectrum.Copy(array);
			Inverse(array, options);
			return array;
		}

		[Obsolete("Use Forward instead. Will be dropped in version 5.0 and behave like Forward until then.")]
		public static void Radix2Forward(Complex32[] samples, FourierOptions options = FourierOptions.Default)
		{
			Forward(samples, options);
		}

		[Obsolete("Use Forward instead. Will be dropped in version 5.0 and behave like Forward until then.")]
		public static void Radix2Forward(Complex[] samples, FourierOptions options = FourierOptions.Default)
		{
			Forward(samples, options);
		}

		[Obsolete("Use Inverse instead. Will be dropped in version 5.0 and behave like Inverse until then.")]
		public static void Radix2Inverse(Complex32[] spectrum, FourierOptions options = FourierOptions.Default)
		{
			Inverse(spectrum, options);
		}

		[Obsolete("Use Inverse instead. Will be dropped in version 5.0 and behave like Inverse until then.")]
		public static void Radix2Inverse(Complex[] spectrum, FourierOptions options = FourierOptions.Default)
		{
			Inverse(spectrum, options);
		}

		[Obsolete("Use Forward instead. Will be dropped in version 5.0 and behave like Forward until then.")]
		public static void BluesteinForward(Complex32[] samples, FourierOptions options = FourierOptions.Default)
		{
			Forward(samples, options);
		}

		[Obsolete("Use Forward instead. Will be dropped in version 5.0 and behave like Forward until then.")]
		public static void BluesteinForward(Complex[] samples, FourierOptions options = FourierOptions.Default)
		{
			Forward(samples, options);
		}

		[Obsolete("Use Inverse instead. Will be dropped in version 5.0 and behave like Inverse until then.")]
		public static void BluesteinInverse(Complex32[] spectrum, FourierOptions options = FourierOptions.Default)
		{
			Inverse(spectrum, options);
		}

		[Obsolete("Use Inverse instead. Will be dropped in version 5.0 and behave like Inverse until then.")]
		public static void BluesteinInverse(Complex[] spectrum, FourierOptions options = FourierOptions.Default)
		{
			Inverse(spectrum, options);
		}

		public static double[] FrequencyScale(int length, double sampleRate)
		{
			double[] array = new double[length];
			double num = 0.0;
			double num2 = sampleRate / (double)length;
			int num3 = (length >> 1) + 1;
			for (int i = 0; i < num3; i++)
			{
				array[i] = num;
				num += num2;
			}
			num = (0.0 - num2) * (double)(num3 - 2);
			for (int j = num3; j < length; j++)
			{
				array[j] = num;
				num += num2;
			}
			return array;
		}
	}
	[Flags]
	public enum FourierOptions
	{
		InverseExponent = 1,
		AsymmetricScaling = 2,
		NoScaling = 4,
		Default = 0,
		Matlab = 2,
		NumericalRecipes = 5
	}
	public static class Hartley
	{
		public static double[] NaiveForward(double[] timeSpace, HartleyOptions options)
		{
			double[] array = Naive(timeSpace);
			ForwardScaleByOptions(options, array);
			return array;
		}

		public static double[] NaiveInverse(double[] frequencySpace, HartleyOptions options)
		{
			double[] array = Naive(frequencySpace);
			InverseScaleByOptions(options, array);
			return array;
		}

		private static void ForwardScaleByOptions(HartleyOptions options, double[] samples)
		{
			if ((options & HartleyOptions.NoScaling) != HartleyOptions.NoScaling && (options & HartleyOptions.AsymmetricScaling) != HartleyOptions.AsymmetricScaling)
			{
				double num = Math.Sqrt(1.0 / (double)samples.Length);
				for (int i = 0; i < samples.Length; i++)
				{
					samples[i] *= num;
				}
			}
		}

		private static void InverseScaleByOptions(HartleyOptions options, double[] samples)
		{
			if ((options & HartleyOptions.NoScaling) != HartleyOptions.NoScaling)
			{
				double num = 1.0 / (double)samples.Length;
				if ((options & HartleyOptions.AsymmetricScaling) != HartleyOptions.AsymmetricScaling)
				{
					num = Math.Sqrt(num);
				}
				for (int i = 0; i < samples.Length; i++)
				{
					samples[i] *= num;
				}
			}
		}

		internal static double[] Naive(double[] samples)
		{
			double w0 = Math.PI * 2.0 / (double)samples.Length;
			double[] spectrum = new double[samples.Length];
			CommonParallel.For(0, samples.Length, delegate(int u, int v)
			{
				for (int i = u; i < v; i++)
				{
					double num = w0 * (double)i;
					double num2 = 0.0;
					for (int j = 0; j < samples.Length; j++)
					{
						double num3 = (double)j * num;
						num2 += samples[j] * 1.4142135623730951 * Math.Cos(num3 - Math.PI / 4.0);
					}
					spectrum[i] = num2;
				}
			});
			return spectrum;
		}
	}
	[Flags]
	public enum HartleyOptions
	{
		AsymmetricScaling = 2,
		NoScaling = 4,
		Default = 0
	}
}
namespace MathNet.Numerics.Financial
{
	public static class AbsoluteReturnMeasures
	{
		public static double CompoundReturn(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			int num = 0;
			double num2 = 1.0;
			foreach (double datum in data)
			{
				num++;
				num2 *= 1.0 + datum;
			}
			if (num != 0)
			{
				return Math.Pow(num2, 1.0 / (double)num) - 1.0;
			}
			return double.NaN;
		}

		public static double GainMean(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return data.Where((double x) => x >= 0.0).Mean();
		}

		public static double LossMean(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return data.Where((double x) => x < 0.0).Mean();
		}
	}
	public static class AbsoluteRiskMeasures
	{
		public static double GainStandardDeviation(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return data.Where((double x) => x >= 0.0).StandardDeviation();
		}

		public static double LossStandardDeviation(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return data.Where((double x) => x < 0.0).StandardDeviation();
		}

		public static double DownsideDeviation(this IEnumerable<double> data, double minimalAcceptableReturn)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return data.Where((double x) => x < minimalAcceptableReturn).StandardDeviation();
		}

		public static double SemiDeviation(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			double mean = data.Mean();
			return data.Where((double x) => x < mean).StandardDeviation();
		}

		public static double GainLossRatio(this IEnumerable<double> data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			IEnumerable<double> data2 = data.Where((double x) => x >= 0.0);
			IEnumerable<double> data3 = data.Where((double x) => x < 0.0);
			return Math.Abs(data2.Mean() / data3.Mean());
		}
	}
}
namespace MathNet.Numerics.Distributions
{
	public class Bernoulli : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _p;

		public double P => _p;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _p;

		public double StdDev => Math.Sqrt(_p * (1.0 - _p));

		public double Variance => _p * (1.0 - _p);

		public double Entropy => 0.0 - _p * Math.Log(_p) - (1.0 - _p) * Math.Log(1.0 - _p);

		public double Skewness => (1.0 - 2.0 * _p) / Math.Sqrt(_p * (1.0 - _p));

		public int Minimum => 0;

		public int Maximum => 1;

		public int Mode
		{
			get
			{
				if (!(_p > 0.5))
				{
					return 0;
				}
				return 1;
			}
		}

		public int[] Modes
		{
			get
			{
				if (!(_p < 0.5))
				{
					if (P > 0.5)
					{
						return new int[1] { 1 };
					}
					return new int[2] { 0, 1 };
				}
				return new int[1];
			}
		}

		public double Median
		{
			get
			{
				if (!(_p < 0.5))
				{
					if (!(_p > 0.5))
					{
						return 0.5;
					}
					return 1.0;
				}
				return 0.0;
			}
		}

		public Bernoulli(double p)
		{
			if (!IsValidParameterSet(p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_p = p;
		}

		public Bernoulli(double p, System.Random randomSource)
		{
			if (!IsValidParameterSet(p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_p = p;
		}

		public override string ToString()
		{
			return $"Bernoulli(p = {_p})";
		}

		public static bool IsValidParameterSet(double p)
		{
			if (p >= 0.0)
			{
				return p <= 1.0;
			}
			return false;
		}

		public double Probability(int k)
		{
			return k switch
			{
				0 => 1.0 - _p, 
				1 => _p, 
				_ => 0.0, 
			};
		}

		public double ProbabilityLn(int k)
		{
			return k switch
			{
				0 => Math.Log(1.0 - _p), 
				1 => Math.Log(_p), 
				_ => double.NegativeInfinity, 
			};
		}

		public double CumulativeDistribution(double x)
		{
			if (x < 0.0)
			{
				return 0.0;
			}
			if (x >= 1.0)
			{
				return 1.0;
			}
			return 1.0 - _p;
		}

		public static double PMF(double p, int k)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return k switch
			{
				0 => 1.0 - p, 
				1 => p, 
				_ => 0.0, 
			};
		}

		public static double PMFLn(double p, int k)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return k switch
			{
				0 => Math.Log(1.0 - p), 
				1 => Math.Log(p), 
				_ => double.NegativeInfinity, 
			};
		}

		public static double CDF(double p, double x)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return 0.0;
			}
			if (x >= 1.0)
			{
				return 1.0;
			}
			return 1.0 - p;
		}

		private static int SampleUnchecked(System.Random rnd, double p)
		{
			if (rnd.NextDouble() < p)
			{
				return 1;
			}
			return 0;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double p)
		{
			double[] uniform = rnd.NextDoubles(values.Length);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = ((uniform[i] < p) ? 1 : 0);
				}
			});
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double p)
		{
			return from r in rnd.NextDoubleSequence()
				select (r < p) ? 1 : 0;
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _p);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _p);
		}

		public IEnumerable<int> Samples()
		{
			while (true)
			{
				yield return SampleUnchecked(_random, _p);
			}
		}

		public static int Sample(System.Random rnd, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, p);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, p);
		}

		public static void Samples(System.Random rnd, int[] values, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, p);
		}

		public static int Sample(double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, p);
		}

		public static IEnumerable<int> Samples(double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, p);
		}

		public static void Samples(int[] values, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, p);
		}
	}
	public class Beta : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _shapeA;

		private readonly double _shapeB;

		public double A => _shapeA;

		public double B => _shapeB;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (_shapeA == 0.0 && _shapeB == 0.0)
				{
					return 0.5;
				}
				if (_shapeA == 0.0)
				{
					return 0.0;
				}
				if (_shapeB == 0.0)
				{
					return 1.0;
				}
				if (double.IsPositiveInfinity(_shapeA) && double.IsPositiveInfinity(_shapeB))
				{
					return 0.5;
				}
				if (double.IsPositiveInfinity(_shapeA))
				{
					return 1.0;
				}
				if (double.IsPositiveInfinity(_shapeB))
				{
					return 0.0;
				}
				return _shapeA / (_shapeA + _shapeB);
			}
		}

		public double Variance => _shapeA * _shapeB / ((_shapeA + _shapeB) * (_shapeA + _shapeB) * (_shapeA + _shapeB + 1.0));

		public double StdDev => Math.Sqrt(_shapeA * _shapeB / ((_shapeA + _shapeB) * (_shapeA + _shapeB) * (_shapeA + _shapeB + 1.0)));

		public double Entropy
		{
			get
			{
				if (double.IsPositiveInfinity(_shapeA) || double.IsPositiveInfinity(_shapeB))
				{
					return 0.0;
				}
				if (_shapeA == 0.0 && _shapeB == 0.0)
				{
					return 0.0 - Math.Log(0.5);
				}
				if (_shapeA == 0.0 || _shapeB == 0.0)
				{
					return 0.0;
				}
				return SpecialFunctions.BetaLn(_shapeA, _shapeB) - (_shapeA - 1.0) * SpecialFunctions.DiGamma(_shapeA) - (_shapeB - 1.0) * SpecialFunctions.DiGamma(_shapeB) + (_shapeA + _shapeB - 2.0) * SpecialFunctions.DiGamma(_shapeA + _shapeB);
			}
		}

		public double Skewness
		{
			get
			{
				if (double.IsPositiveInfinity(_shapeA) && double.IsPositiveInfinity(_shapeB))
				{
					return 0.0;
				}
				if (double.IsPositiveInfinity(_shapeA))
				{
					return -2.0;
				}
				if (double.IsPositiveInfinity(_shapeB))
				{
					return 2.0;
				}
				if (_shapeA == 0.0 && _shapeB == 0.0)
				{
					return 0.0;
				}
				if (_shapeA == 0.0)
				{
					return 2.0;
				}
				if (_shapeB == 0.0)
				{
					return -2.0;
				}
				return 2.0 * (_shapeB - _shapeA) * Math.Sqrt(_shapeA + _shapeB + 1.0) / ((_shapeA + _shapeB + 2.0) * Math.Sqrt(_shapeA * _shapeB));
			}
		}

		public double Mode
		{
			get
			{
				if (_shapeA == 0.0 && _shapeB == 0.0)
				{
					return 0.5;
				}
				if (_shapeA == 0.0)
				{
					return 0.0;
				}
				if (_shapeB == 0.0)
				{
					return 1.0;
				}
				if (double.IsPositiveInfinity(_shapeA) && double.IsPositiveInfinity(_shapeB))
				{
					return 0.5;
				}
				if (double.IsPositiveInfinity(_shapeA))
				{
					return 1.0;
				}
				if (double.IsPositiveInfinity(_shapeB))
				{
					return 0.0;
				}
				if (_shapeA == 1.0 && _shapeB == 1.0)
				{
					return 0.5;
				}
				return (_shapeA - 1.0) / (_shapeA + _shapeB - 2.0);
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => 0.0;

		public double Maximum => 1.0;

		public Beta(double a, double b)
		{
			if (!IsValidParameterSet(a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_shapeA = a;
			_shapeB = b;
		}

		public Beta(double a, double b, System.Random randomSource)
		{
			if (!IsValidParameterSet(a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_shapeA = a;
			_shapeB = b;
		}

		public override string ToString()
		{
			return $"Beta( = {_shapeA},  = {_shapeB})";
		}

		public static bool IsValidParameterSet(double a, double b)
		{
			if (a >= 0.0)
			{
				return b >= 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_shapeA, _shapeB, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_shapeA, _shapeB, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_shapeA, _shapeB, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_shapeA, _shapeB, p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _shapeA, _shapeB);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _shapeA, _shapeB);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _shapeA, _shapeB);
		}

		internal static double SampleUnchecked(System.Random rnd, double a, double b)
		{
			double num = Gamma.SampleUnchecked(rnd, a, 1.0);
			double num2 = Gamma.SampleUnchecked(rnd, b, 1.0);
			return num / (num + num2);
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double a, double b)
		{
			double[] y = new double[values.Length];
			Gamma.SamplesUnchecked(rnd, values, a, 1.0);
			Gamma.SamplesUnchecked(rnd, y, b, 1.0);
			CommonParallel.For(0, values.Length, 4096, delegate(int aa, int bb)
			{
				for (int i = aa; i < bb; i++)
				{
					values[i] /= values[i] + y[i];
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double a, double b)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, a, b);
			}
		}

		public static double PDF(double a, double b, double x)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0 || x > 1.0)
			{
				return 0.0;
			}
			if (double.IsPositiveInfinity(a) && double.IsPositiveInfinity(b))
			{
				if (x != 0.5)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if (double.IsPositiveInfinity(a))
			{
				if (x != 1.0)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if (double.IsPositiveInfinity(b))
			{
				if (x != 0.0)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if (a == 0.0 && b == 0.0)
			{
				if (x == 0.0 || x == 1.0)
				{
					return double.PositiveInfinity;
				}
				return 0.0;
			}
			if (a == 0.0)
			{
				if (x != 0.0)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if (b == 0.0)
			{
				if (x != 1.0)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if (a == 1.0 && b == 1.0)
			{
				return 1.0;
			}
			if (a > 80.0 || b > 80.0)
			{
				return Math.Exp(PDFLn(a, b, x));
			}
			return SpecialFunctions.Gamma(a + b) / (SpecialFunctions.Gamma(a) * SpecialFunctions.Gamma(b)) * Math.Pow(x, a - 1.0) * Math.Pow(1.0 - x, b - 1.0);
		}

		public static double PDFLn(double a, double b, double x)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0 || x > 1.0)
			{
				return double.NegativeInfinity;
			}
			if (double.IsPositiveInfinity(a) && double.IsPositiveInfinity(b))
			{
				if (x != 0.5)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (double.IsPositiveInfinity(a))
			{
				if (x != 1.0)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (double.IsPositiveInfinity(b))
			{
				if (x != 0.0)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (a == 0.0 && b == 0.0)
			{
				if (x != 0.0 && x != 1.0)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (a == 0.0)
			{
				if (x != 0.0)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (b == 0.0)
			{
				if (x != 1.0)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (a == 1.0 && b == 1.0)
			{
				return 0.0;
			}
			double num = SpecialFunctions.GammaLn(a + b) - SpecialFunctions.GammaLn(a) - SpecialFunctions.GammaLn(b);
			double num2 = ((x != 0.0) ? ((a - 1.0) * Math.Log(x)) : ((a == 1.0) ? 0.0 : double.NegativeInfinity));
			double num3 = ((x != 1.0) ? ((b - 1.0) * Math.Log(1.0 - x)) : ((b == 1.0) ? 0.0 : double.NegativeInfinity));
			return num + num2 + num3;
		}

		public static double CDF(double a, double b, double x)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return 0.0;
			}
			if (x >= 1.0)
			{
				return 1.0;
			}
			if (double.IsPositiveInfinity(a) && double.IsPositiveInfinity(b))
			{
				if (!(x < 0.5))
				{
					return 1.0;
				}
				return 0.0;
			}
			if (double.IsPositiveInfinity(a))
			{
				if (!(x < 1.0))
				{
					return 1.0;
				}
				return 0.0;
			}
			if (double.IsPositiveInfinity(b))
			{
				if (!(x >= 0.0))
				{
					return 0.0;
				}
				return 1.0;
			}
			if (a == 0.0 && b == 0.0)
			{
				if (x >= 0.0 && x < 1.0)
				{
					return 0.5;
				}
				return 1.0;
			}
			if (a == 0.0)
			{
				return 1.0;
			}
			if (b == 0.0)
			{
				if (!(x >= 1.0))
				{
					return 0.0;
				}
				return 1.0;
			}
			if (a == 1.0 && b == 1.0)
			{
				return x;
			}
			return SpecialFunctions.BetaRegularized(a, b, x);
		}

		public static double InvCDF(double a, double b, double p)
		{
			if (a < 0.0 || b < 0.0 || p < 0.0 || p > 1.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Brent.FindRoot((double x) => SpecialFunctions.BetaRegularized(a, b, x) - p, 0.0, 1.0, 1E-12);
		}

		public static double Sample(System.Random rnd, double a, double b)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, a, b);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double a, double b)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, a, b);
		}

		public static void Samples(System.Random rnd, double[] values, double a, double b)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, a, b);
		}

		public static double Sample(double a, double b)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, a, b);
		}

		public static IEnumerable<double> Samples(double a, double b)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, a, b);
		}

		public static void Samples(double[] values, double a, double b)
		{
			if (a < 0.0 || b < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, a, b);
		}
	}
	public class BetaBinomial : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly int _n;

		private readonly double _a;

		private readonly double _b;

		public int N => _n;

		public double A => _a;

		public double B => _b;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => (double)_n * _a / (_a + _b);

		public double Variance => (double)_n * _a * _b * (_a + _b + (double)_n) / (Math.Pow(_a + _b, 2.0) * (_a + _b + 1.0));

		public double StdDev => Math.Sqrt((double)_n * _a * _b * (_a + _b + (double)_n) / (Math.Pow(_a + _b, 2.0) * (_a + _b + 1.0)));

		double IUnivariateDistribution.Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness => (_a + _b + (double)(2 * _n)) * (_b - _a) / (_a + _b + 2.0) * Math.Sqrt((1.0 + _a + _b) / ((double)_n * _a * _b * ((double)_n + _a + _b)));

		int IDiscreteDistribution.Mode
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		double IUnivariateDistribution.Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Minimum => 0;

		public int Maximum => int.MaxValue;

		public BetaBinomial(int n, double a, double b)
		{
			if (!IsValidParameterSet(n, a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_n = n;
			_a = a;
			_b = b;
		}

		public BetaBinomial(int n, double a, double b, System.Random randomSource)
		{
			if (!IsValidParameterSet(n, a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_n = n;
			_a = a;
			_b = b;
		}

		public override string ToString()
		{
			return $"BetaBinomial(n = {_n}, a = {_a}, b = {_b})";
		}

		public static bool IsValidParameterSet(int n, double a, double b)
		{
			if ((double)n >= 1.0 && a > 0.0)
			{
				return b > 0.0;
			}
			return false;
		}

		public static bool IsValidParameterSet(int n, double a, double b, int k)
		{
			if ((double)n >= 1.0 && a > 0.0 && b > 0.0 && k >= 0)
			{
				return k <= n;
			}
			return false;
		}

		public double Probability(int k)
		{
			return PMF(_n, _a, _b, k);
		}

		public double ProbabilityLn(int k)
		{
			return PMFLn(_n, _a, _b, k);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_n, _a, _b, (int)Math.Floor(x));
		}

		public static double PMF(int n, double a, double b, int k)
		{
			if (!IsValidParameterSet(n, a, b, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k > n)
			{
				return 0.0;
			}
			return Math.Exp(PMFLn(n, a, b, k));
		}

		public static double PMFLn(int n, double a, double b, int k)
		{
			if (!IsValidParameterSet(n, a, b, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.BinomialLn(n, k) + SpecialFunctions.BetaLn((double)k + a, (double)(n - k) + b) - SpecialFunctions.BetaLn(a, b);
		}

		public static double CDF(int n, double a, double b, int x)
		{
			if (!IsValidParameterSet(n, a, b, x))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double num = 0.0;
			for (int i = 0; i <= x; i++)
			{
				num += PMF(n, a, b, i);
			}
			return num;
		}

		private static int SampleUnchecked(System.Random rnd, int n, double a, double b)
		{
			double p = Beta.SampleUnchecked(rnd, a, b);
			return Binomial.SampleUnchecked(rnd, p, n);
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, int n, double a, double b)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, n, a, b);
			}
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, int n, double a, double b)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, n, a, b);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _n, _a, _b);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _n, _a, _b);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _n, _a, _b);
		}

		public int Sample(System.Random rnd, int n, double a, double b)
		{
			if (!IsValidParameterSet(n, a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, n, a, b);
		}

		public void Samples(System.Random rnd, int[] values, int n, double a, double b)
		{
			if (!IsValidParameterSet(n, a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, n, a, b);
		}

		public IEnumerable<int> Samples(int n, double a, double b)
		{
			if (!IsValidParameterSet(n, a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(_random, n, a, b);
		}

		public void Samples(int[] values, int n, double a, double b)
		{
			if (!IsValidParameterSet(n, a, b))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(_random, values, n, a, b);
		}
	}
	public class BetaScaled : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _shapeA;

		private readonly double _shapeB;

		private readonly double _location;

		private readonly double _scale;

		public double A => _shapeA;

		public double B => _shapeB;

		public double Location => _location;

		public double Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (double.IsPositiveInfinity(_shapeA) && double.IsPositiveInfinity(_shapeB))
				{
					return _location + 0.5 * _scale;
				}
				if (double.IsPositiveInfinity(_shapeA))
				{
					return _location + _scale;
				}
				if (double.IsPositiveInfinity(_shapeB))
				{
					return _location;
				}
				return (_shapeB * _location + _shapeA * (_location + _scale)) / (_shapeA + _shapeB);
			}
		}

		public double Variance
		{
			get
			{
				double num = _shapeA + _shapeB;
				return _shapeA * _shapeB * _scale * _scale / (num * num * (1.0 + num));
			}
		}

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness
		{
			get
			{
				if (double.IsPositiveInfinity(_shapeA) && double.IsPositiveInfinity(_shapeB))
				{
					return 0.0;
				}
				if (double.IsPositiveInfinity(_shapeA))
				{
					return -2.0 * _scale / Math.Sqrt(_shapeB * _scale * _scale);
				}
				if (double.IsPositiveInfinity(_shapeB))
				{
					return 2.0 * _scale / Math.Sqrt(_shapeA * _scale * _scale);
				}
				double num = _shapeA + _shapeB;
				double d = _shapeA * _shapeB * _scale * _scale / (num * num * (1.0 + num));
				return 2.0 * (_shapeB - _shapeA) * _scale / (num * (2.0 + num) * Math.Sqrt(d));
			}
		}

		public double Mode
		{
			get
			{
				if (double.IsPositiveInfinity(_shapeA) && double.IsPositiveInfinity(_shapeB))
				{
					return _location + 0.5 * _scale;
				}
				if (double.IsPositiveInfinity(_shapeA))
				{
					return _location + _scale;
				}
				if (double.IsPositiveInfinity(_shapeB))
				{
					return _location;
				}
				if (_shapeA == 1.0 && _shapeB == 1.0)
				{
					return _location + 0.5 * _scale;
				}
				return (_shapeA - 1.0) / (_shapeA + _shapeB - 2.0) * _scale + _location;
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => _location;

		public double Maximum => _location + _scale;

		public BetaScaled(double a, double b, double location, double scale)
		{
			if (!IsValidParameterSet(a, b, location, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_shapeA = a;
			_shapeB = b;
			_location = location;
			_scale = scale;
		}

		public BetaScaled(double a, double b, double location, double scale, System.Random randomSource)
		{
			if (!IsValidParameterSet(a, b, location, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_shapeA = a;
			_shapeB = b;
			_location = location;
			_scale = scale;
		}

		public static BetaScaled PERT(double min, double max, double likely, System.Random randomSource = null)
		{
			if (min > max || likely > max || likely < min)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double num = (min + max + 4.0 * likely) / 6.0;
			double num2 = ((num != likely) ? ((num - min) * (2.0 * likely - min - max) / ((likely - num) * (max - min))) : 3.0);
			double b = num2 * (max - num) / (num - min);
			return new BetaScaled(num2, b, min, max - min, randomSource);
		}

		public override string ToString()
		{
			return $"BetaScaled( = {_shapeA},  = {_shapeB},  = {_location},  = {_scale})";
		}

		public static bool IsValidParameterSet(double a, double b, double location, double scale)
		{
			if (a > 0.0 && b > 0.0 && scale > 0.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_shapeA, _shapeB, _location, _scale, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_shapeA, _shapeB, _location, _scale, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_shapeA, _shapeB, _location, _scale, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_shapeA, _shapeB, _location, _scale, p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _shapeA, _shapeB, _location, _scale);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _shapeA, _shapeB, _location, _scale);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _shapeA, _shapeB, _location, _scale);
		}

		private static double SampleUnchecked(System.Random rnd, double a, double b, double location, double scale)
		{
			return Beta.SampleUnchecked(rnd, a, b) * scale + location;
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double a, double b, double location, double scale)
		{
			Beta.SamplesUnchecked(rnd, values, a, b);
			CommonParallel.For(0, values.Length, 4096, delegate(int aa, int bb)
			{
				for (int i = aa; i < bb; i++)
				{
					values[i] = values[i] * scale + location;
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double a, double b, double location, double scale)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, a, b, location, scale);
			}
		}

		public static double PDF(double a, double b, double location, double scale, double x)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Beta.PDF(a, b, (x - location) / scale) / Math.Abs(scale);
		}

		public static double PDFLn(double a, double b, double location, double scale, double x)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Beta.PDFLn(a, b, (x - location) / scale) - Math.Log(Math.Abs(scale));
		}

		public static double CDF(double a, double b, double location, double scale, double x)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Beta.CDF(a, b, (x - location) / scale);
		}

		public static double InvCDF(double a, double b, double location, double scale, double p)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Beta.InvCDF(a, b, p) * scale + location;
		}

		public static double Sample(System.Random rnd, double a, double b, double location, double scale)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, a, b, location, scale);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double a, double b, double location, double scale)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, a, b, location, scale);
		}

		public static void Samples(System.Random rnd, double[] values, double a, double b, double location, double scale)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, a, b, location, scale);
		}

		public static double Sample(double a, double b, double location, double scale)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, a, b, location, scale);
		}

		public static IEnumerable<double> Samples(double a, double b, double location, double scale)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, a, b, location, scale);
		}

		public static void Samples(double[] values, double a, double b, double location, double scale)
		{
			if (!(a > 0.0) || !(b > 0.0) || !(scale > 0.0) || double.IsNaN(location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, a, b, location, scale);
		}
	}
	public class Binomial : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _p;

		private readonly int _trials;

		public double P => _p;

		public int N => _trials;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _p * (double)_trials;

		public double StdDev => Math.Sqrt(_p * (1.0 - _p) * (double)_trials);

		public double Variance => _p * (1.0 - _p) * (double)_trials;

		public double Entropy
		{
			get
			{
				if (_p == 0.0 || _p == 1.0)
				{
					return 0.0;
				}
				double num = 0.0;
				for (int i = 0; i <= _trials; i++)
				{
					double num2 = Probability(i);
					num -= num2 * Math.Log(num2);
				}
				return num;
			}
		}

		public double Skewness => (1.0 - 2.0 * _p) / Math.Sqrt((double)_trials * _p * (1.0 - _p));

		public int Minimum => 0;

		public int Maximum => _trials;

		public int Mode
		{
			get
			{
				if (_p == 1.0)
				{
					return _trials;
				}
				if (_p == 0.0)
				{
					return 0;
				}
				return (int)Math.Floor((double)(_trials + 1) * _p);
			}
		}

		public int[] Modes
		{
			get
			{
				if (_p == 1.0)
				{
					return new int[1] { _trials };
				}
				if (_p == 0.0)
				{
					return new int[1];
				}
				double num = (double)(_trials + 1) * _p;
				int num2 = (int)Math.Floor(num);
				if ((double)num2 != num)
				{
					return new int[1] { num2 };
				}
				return new int[2]
				{
					num2,
					num2 - 1
				};
			}
		}

		public double Median => Math.Floor(_p * (double)_trials);

		public Binomial(double p, int n)
		{
			if (!IsValidParameterSet(p, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_p = p;
			_trials = n;
		}

		public Binomial(double p, int n, System.Random randomSource)
		{
			if (!IsValidParameterSet(p, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_p = p;
			_trials = n;
		}

		public override string ToString()
		{
			return $"Binomial(p = {_p}, n = {_trials})";
		}

		public static bool IsValidParameterSet(double p, int n)
		{
			if (p >= 0.0 && p <= 1.0)
			{
				return n >= 0;
			}
			return false;
		}

		public double Probability(int k)
		{
			return PMF(_p, _trials, k);
		}

		public double ProbabilityLn(int k)
		{
			return PMFLn(_p, _trials, k);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_p, _trials, x);
		}

		public static double PMF(double p, int n, int k)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k < 0 || k > n)
			{
				return 0.0;
			}
			if (p == 0.0)
			{
				if (k != 0)
				{
					return 0.0;
				}
				return 1.0;
			}
			if (p == 1.0)
			{
				if (k != n)
				{
					return 0.0;
				}
				return 1.0;
			}
			return Math.Exp(SpecialFunctions.BinomialLn(n, k) + (double)k * Math.Log(p) + (double)(n - k) * Math.Log(1.0 - p));
		}

		public static double PMFLn(double p, int n, int k)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k < 0 || k > n)
			{
				return double.NegativeInfinity;
			}
			if (p == 0.0)
			{
				if (k != 0)
				{
					return double.NegativeInfinity;
				}
				return 0.0;
			}
			if (p == 1.0)
			{
				if (k != n)
				{
					return double.NegativeInfinity;
				}
				return 0.0;
			}
			return SpecialFunctions.BinomialLn(n, k) + (double)k * Math.Log(p) + (double)(n - k) * Math.Log(1.0 - p);
		}

		public static double CDF(double p, int n, double x)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return 0.0;
			}
			if (x > (double)n)
			{
				return 1.0;
			}
			double num = Math.Floor(x);
			return SpecialFunctions.BetaRegularized((double)n - num, num + 1.0, 1.0 - p);
		}

		internal static int SampleUnchecked(System.Random rnd, double p, int n)
		{
			int num = 0;
			for (int i = 0; i < n; i++)
			{
				num += ((rnd.NextDouble() < p) ? 1 : 0);
			}
			return num;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double p, int n)
		{
			double[] uniform = rnd.NextDoubles(values.Length * n);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					int num = i * n;
					int num2 = 0;
					for (int j = 0; j < n; j++)
					{
						num2 += ((uniform[num + j] < p) ? 1 : 0);
					}
					values[i] = num2;
				}
			});
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double p, int n)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, p, n);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _p, _trials);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _p, _trials);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _p, _trials);
		}

		public static int Sample(System.Random rnd, double p, int n)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, p, n);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double p, int n)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, p, n);
		}

		public static void Samples(System.Random rnd, int[] values, double p, int n)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, p, n);
		}

		public static int Sample(double p, int n)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, p, n);
		}

		public static IEnumerable<int> Samples(double p, int n)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, p, n);
		}

		public static void Samples(int[] values, double p, int n)
		{
			if (!(p >= 0.0) || !(p <= 1.0) || n < 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, p, n);
		}
	}
	public class Burr : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		public double a { get; }

		public double c { get; }

		public double k { get; }

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => 1.0 / SpecialFunctions.Gamma(k) * a * SpecialFunctions.Gamma(1.0 + 1.0 / c) * SpecialFunctions.Gamma(k - 1.0 / c);

		public double Variance => 1.0 / SpecialFunctions.Gamma(k) * Math.Pow(a, 2.0) * SpecialFunctions.Gamma(1.0 + 2.0 / c) * SpecialFunctions.Gamma(k - 2.0 / c) - Math.Pow(1.0 / SpecialFunctions.Gamma(k) * a * SpecialFunctions.Gamma(1.0 + 1.0 / c) * SpecialFunctions.Gamma(k - 1.0 / c), 2.0);

		public double StdDev => Math.Sqrt(Variance);

		public double Mode => a * Math.Pow((c - 1.0) / (c * k + 1.0), 1.0 / c);

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness
		{
			get
			{
				double mean = Mean;
				double variance = Variance;
				double stdDev = StdDev;
				return (GetMoment(3.0) - 3.0 * mean * variance - mean * mean * mean) / (stdDev * stdDev * stdDev);
			}
		}

		public double Median => a * Math.Pow(Math.Pow(2.0, 1.0 / k) - 1.0, 1.0 / c);

		public Burr(double a, double c, double k, System.Random randomSource = null)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			this.a = a;
			this.c = c;
			this.k = k;
		}

		public override string ToString()
		{
			return $"Burr(a = {a}, c = {c}, k = {k})";
		}

		public static bool IsValidParameterSet(double a, double c, double k)
		{
			if (a.IsFinite() && c.IsFinite() && k.IsFinite() && a > 0.0 && c > 0.0)
			{
				return k > 0.0;
			}
			return false;
		}

		public double Sample()
		{
			return SampleUnchecked(_random, a, c, k);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, a, c, k);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, a, c, k);
		}

		public static double Sample(System.Random rnd, double a, double c, double k)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, a, c, k);
		}

		public static void Samples(System.Random rnd, double[] values, double a, double c, double k)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, a, c, k);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double a, double c, double k)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, a, c, k);
		}

		internal static double SampleUnchecked(System.Random rnd, double a, double c, double k)
		{
			double num = 1.0 / k;
			double y = 1.0 / c;
			double num2 = rnd.NextDouble();
			return a * Math.Pow(Math.Pow(1.0 - num2, 0.0 - num) - 1.0, y);
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double a, double c, double k)
		{
			if (values.Length != 0)
			{
				double num = 1.0 / k;
				double y = 1.0 / c;
				double[] array = rnd.NextDoubles(values.Length);
				for (int i = 0; i < values.Length; i++)
				{
					values[i] = a * Math.Pow(Math.Pow(1.0 - array[i], 0.0 - num) - 1.0, y);
				}
			}
		}

		internal static IEnumerable<double> SamplesUnchecked(System.Random rnd, double a, double c, double k)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, a, c, k);
			}
		}

		public double GetMoment(double n)
		{
			if (n > k * c)
			{
				throw new ArgumentException("The chosen parameter set is invalid (probably some value is out of range).");
			}
			double num = n / c * SpecialFunctions.Gamma(n / c) * SpecialFunctions.Gamma(k - n / c);
			return Math.Pow(a, n) * num / SpecialFunctions.Gamma(k);
		}

		public double Density(double x)
		{
			return DensityImpl(a, c, k, x);
		}

		public double DensityLn(double x)
		{
			return DensityLnImpl(a, c, k, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CumulativeDistributionImpl(a, c, k, x);
		}

		public static double PDF(double a, double c, double k, double x)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DensityImpl(a, c, k, x);
		}

		public static double PDFLn(double a, double c, double k, double x)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DensityLnImpl(a, c, k, x);
		}

		public static double CDF(double a, double c, double k, double x)
		{
			if (!IsValidParameterSet(a, c, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return CumulativeDistributionImpl(a, c, k, x);
		}

		internal static double DensityImpl(double a, double c, double k, double x)
		{
			double num = k * c / a * Math.Pow(x / a, c - 1.0);
			double num2 = Math.Pow(1.0 + Math.Pow(x / a, c), k + 1.0);
			return num / num2;
		}

		internal static double DensityLnImpl(double a, double c, double k, double x)
		{
			return Math.Log(DensityImpl(a, c, k, x));
		}

		internal static double CumulativeDistributionImpl(double a, double c, double k, double x)
		{
			double num = Math.Pow(1.0 + Math.Pow(x / a, c), k);
			return 1.0 - 1.0 / num;
		}
	}
	public class Categorical : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double[] _pmfNormalized;

		private readonly double[] _cdfUnnormalized;

		public double[] P => (double[])_pmfNormalized.Clone();

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				double num = 0.0;
				for (int i = 0; i < _pmfNormalized.Length; i++)
				{
					num += (double)i * _pmfNormalized[i];
				}
				return num;
			}
		}

		public double StdDev => Math.Sqrt(Variance);

		public double Variance
		{
			get
			{
				double mean = Mean;
				double num = 0.0;
				for (int i = 0; i < _pmfNormalized.Length; i++)
				{
					double num2 = (double)i - mean;
					num += num2 * num2 * _pmfNormalized[i];
				}
				return num;
			}
		}

		public double Entropy => 0.0 - _pmfNormalized.Sum((double p) => p * Math.Log(p));

		public double Skewness
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Minimum => 0;

		public int Maximum => _pmfNormalized.Length - 1;

		public int Mode
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Median => InverseCumulativeDistribution(0.5);

		public Categorical(double[] probabilityMass)
			: this(probabilityMass, SystemRandomSource.Default)
		{
		}

		public Categorical(double[] probabilityMass, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_cdfUnnormalized = new double[probabilityMass.Length];
			_cdfUnnormalized[0] = probabilityMass[0];
			for (int i = 1; i < probabilityMass.Length; i++)
			{
				_cdfUnnormalized[i] = _cdfUnnormalized[i - 1] + probabilityMass[i];
			}
			double num = _cdfUnnormalized[_cdfUnnormalized.Length - 1];
			_pmfNormalized = new double[probabilityMass.Length];
			for (int j = 0; j < probabilityMass.Length; j++)
			{
				_pmfNormalized[j] = probabilityMass[j] / num;
			}
		}

		public Categorical(Histogram histogram)
		{
			if (histogram == null)
			{
				throw new ArgumentNullException("histogram");
			}
			double[] array = new double[histogram.BucketCount];
			for (int i = 0; i < histogram.BucketCount; i++)
			{
				array[i] = histogram[i].Count;
			}
			_random = SystemRandomSource.Default;
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(array))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_cdfUnnormalized = new double[array.Length];
			_cdfUnnormalized[0] = array[0];
			for (int j = 1; j < array.Length; j++)
			{
				_cdfUnnormalized[j] = _cdfUnnormalized[j - 1] + array[j];
			}
			double num = _cdfUnnormalized[_cdfUnnormalized.Length - 1];
			_pmfNormalized = new double[array.Length];
			for (int k = 0; k < array.Length; k++)
			{
				_pmfNormalized[k] = array[k] / num;
			}
		}

		public override string ToString()
		{
			return $"Categorical(Dimension = {_pmfNormalized.Length})";
		}

		public static bool IsValidProbabilityMass(double[] p)
		{
			double num = 0.0;
			foreach (double num2 in p)
			{
				if (num2 < 0.0 || double.IsNaN(num2))
				{
					return false;
				}
				num += num2;
			}
			return num > 0.0;
		}

		public static bool IsValidCumulativeDistribution(double[] cdf)
		{
			double num = 0.0;
			foreach (double num2 in cdf)
			{
				if (num2 < 0.0 || double.IsNaN(num2) || num2 < num)
				{
					return false;
				}
				num = num2;
			}
			return num > 0.0;
		}

		public double Probability(int k)
		{
			if (k < 0)
			{
				return 0.0;
			}
			if (k >= _pmfNormalized.Length)
			{
				return 0.0;
			}
			return _pmfNormalized[k];
		}

		public double ProbabilityLn(int k)
		{
			if (k < 0)
			{
				return 0.0;
			}
			if (k >= _pmfNormalized.Length)
			{
				return 0.0;
			}
			return Math.Log(_pmfNormalized[k]);
		}

		public double CumulativeDistribution(double x)
		{
			if (x < 0.0)
			{
				return 0.0;
			}
			if (x >= (double)_cdfUnnormalized.Length)
			{
				return 1.0;
			}
			return _cdfUnnormalized[(int)Math.Floor(x)] / _cdfUnnormalized[_cdfUnnormalized.Length - 1];
		}

		public int InverseCumulativeDistribution(double probability)
		{
			if (probability < 0.0 || probability > 1.0 || double.IsNaN(probability))
			{
				throw new ArgumentOutOfRangeException("probability");
			}
			double value = probability * _cdfUnnormalized[_cdfUnnormalized.Length - 1];
			int num = Array.BinarySearch(_cdfUnnormalized, value);
			if (num < 0)
			{
				num = ~num;
			}
			return num;
		}

		public static double PMF(double[] probabilityMass, int k)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k < 0)
			{
				return 0.0;
			}
			if (k >= probabilityMass.Length)
			{
				return 0.0;
			}
			return probabilityMass[k] / probabilityMass.Sum();
		}

		public static double PMFLn(double[] probabilityMass, int k)
		{
			return Math.Log(PMF(probabilityMass, k));
		}

		public static double CDF(double[] probabilityMass, double x)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return 0.0;
			}
			if (x >= (double)probabilityMass.Length)
			{
				return 1.0;
			}
			double[] array = ProbabilityMassToCumulativeDistribution(probabilityMass);
			return array[(int)Math.Floor(x)] / array[array.Length - 1];
		}

		public static int InvCDF(double[] probabilityMass, double probability)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (probability < 0.0 || probability > 1.0 || double.IsNaN(probability))
			{
				throw new ArgumentOutOfRangeException("probability");
			}
			double[] array = ProbabilityMassToCumulativeDistribution(probabilityMass);
			double value = probability * array[array.Length - 1];
			int num = Array.BinarySearch(array, value);
			if (num < 0)
			{
				num = ~num;
			}
			return num;
		}

		public static int InvCDFWithCumulativeDistribution(double[] cdfUnnormalized, double probability)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (probability < 0.0 || probability > 1.0 || double.IsNaN(probability))
			{
				throw new ArgumentOutOfRangeException("probability");
			}
			double value = probability * cdfUnnormalized[cdfUnnormalized.Length - 1];
			int num = Array.BinarySearch(cdfUnnormalized, value);
			if (num < 0)
			{
				num = ~num;
			}
			return num;
		}

		internal static double[] ProbabilityMassToCumulativeDistribution(double[] probabilityMass)
		{
			double[] array = new double[probabilityMass.Length];
			array[0] = probabilityMass[0];
			for (int i = 1; i < probabilityMass.Length; i++)
			{
				array[i] = array[i - 1] + probabilityMass[i];
			}
			return array;
		}

		internal static int SampleUnchecked(System.Random rnd, double[] cdfUnnormalized)
		{
			double num = rnd.NextDouble() * cdfUnnormalized[cdfUnnormalized.Length - 1];
			int i = 0;
			if (num == 0.0)
			{
				for (; 0.0 == cdfUnnormalized[i]; i++)
				{
				}
			}
			for (; num > cdfUnnormalized[i]; i++)
			{
			}
			return i;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double[] cdfUnnormalized)
		{
			double[] uniform = rnd.NextDoubles(values.Length);
			double w = cdfUnnormalized[cdfUnnormalized.Length - 1];
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					double num = uniform[i] * w;
					int j = 0;
					if (num == 0.0)
					{
						for (; 0.0 == cdfUnnormalized[j]; j++)
						{
						}
					}
					for (; num > cdfUnnormalized[j]; j++)
					{
					}
					values[i] = j;
				}
			});
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double[] cdfUnnormalized)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, cdfUnnormalized);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _cdfUnnormalized);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _cdfUnnormalized);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _cdfUnnormalized);
		}

		public static int Sample(System.Random rnd, double[] probabilityMass)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = ProbabilityMassToCumulativeDistribution(probabilityMass);
			return SampleUnchecked(rnd, cdfUnnormalized);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double[] probabilityMass)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = ProbabilityMassToCumulativeDistribution(probabilityMass);
			return SamplesUnchecked(rnd, cdfUnnormalized);
		}

		public static void Samples(System.Random rnd, int[] values, double[] probabilityMass)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = ProbabilityMassToCumulativeDistribution(probabilityMass);
			SamplesUnchecked(rnd, values, cdfUnnormalized);
		}

		public static int Sample(double[] probabilityMass)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = ProbabilityMassToCumulativeDistribution(probabilityMass);
			return SampleUnchecked(SystemRandomSource.Default, cdfUnnormalized);
		}

		public static IEnumerable<int> Samples(double[] probabilityMass)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = ProbabilityMassToCumulativeDistribution(probabilityMass);
			return SamplesUnchecked(SystemRandomSource.Default, cdfUnnormalized);
		}

		public static void Samples(int[] values, double[] probabilityMass)
		{
			if (Control.CheckDistributionParameters && !IsValidProbabilityMass(probabilityMass))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = ProbabilityMassToCumulativeDistribution(probabilityMass);
			SamplesUnchecked(SystemRandomSource.Default, values, cdfUnnormalized);
		}

		public static int SampleWithCumulativeDistribution(System.Random rnd, double[] cdfUnnormalized)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, cdfUnnormalized);
		}

		public static IEnumerable<int> SamplesWithCumulativeDistribution(System.Random rnd, double[] cdfUnnormalized)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, cdfUnnormalized);
		}

		public static void SamplesWithCumulativeDistribution(System.Random rnd, int[] values, double[] cdfUnnormalized)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, cdfUnnormalized);
		}

		public static int SampleWithCumulativeDistribution(double[] cdfUnnormalized)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, cdfUnnormalized);
		}

		public static IEnumerable<int> SamplesWithCumulativeDistribution(double[] cdfUnnormalized)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, cdfUnnormalized);
		}

		public static void SamplesWithCumulativeDistribution(int[] values, double[] cdfUnnormalized)
		{
			if (Control.CheckDistributionParameters && !IsValidCumulativeDistribution(cdfUnnormalized))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, cdfUnnormalized);
		}
	}
	public class Cauchy : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _location;

		private readonly double _scale;

		public double Location => _location;

		public double Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Variance
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double StdDev
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Entropy => Math.Log(Math.PI * 4.0 * _scale);

		public double Skewness
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Mode => _location;

		public double Median => _location;

		public double Minimum => double.NegativeInfinity;

		public double Maximum => double.PositiveInfinity;

		public Cauchy()
			: this(0.0, 1.0)
		{
		}

		public Cauchy(double location, double scale)
		{
			if (!IsValidParameterSet(location, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_location = location;
			_scale = scale;
		}

		public Cauchy(double location, double scale, System.Random randomSource)
		{
			if (!IsValidParameterSet(location, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_location = location;
			_scale = scale;
		}

		public override string ToString()
		{
			return $"Cauchy(x0 = {_location},  = {_scale})";
		}

		public static bool IsValidParameterSet(double location, double scale)
		{
			if (scale > 0.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		public double Density(double x)
		{
			return 1.0 / (Math.PI * _scale * (1.0 + (x - _location) / _scale * ((x - _location) / _scale)));
		}

		public double DensityLn(double x)
		{
			return 0.0 - Math.Log(Math.PI * _scale * (1.0 + (x - _location) / _scale * ((x - _location) / _scale)));
		}

		public double CumulativeDistribution(double x)
		{
			return 1.0 / Math.PI * Math.Atan((x - _location) / _scale) + 0.5;
		}

		public double InverseCumulativeDistribution(double p)
		{
			if (!(p <= 0.0))
			{
				if (!(p >= 1.0))
				{
					return _location + _scale * Math.Tan((p - 0.5) * Math.PI);
				}
				return double.PositiveInfinity;
			}
			return double.NegativeInfinity;
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _location, _scale);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _location, _scale);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _location, _scale);
		}

		private static double SampleUnchecked(System.Random rnd, double location, double scale)
		{
			return location + scale * Math.Tan(Math.PI * (rnd.NextDouble() - 0.5));
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double location, double scale)
		{
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = location + scale * Math.Tan(Math.PI * (values[i] - 0.5));
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double location, double scale)
		{
			while (true)
			{
				yield return location + scale * Math.Tan(Math.PI * (rnd.NextDouble() - 0.5));
			}
		}

		public static double PDF(double location, double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 / (Math.PI * scale * (1.0 + (x - location) / scale * ((x - location) / scale)));
		}

		public static double PDFLn(double location, double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 0.0 - Math.Log(Math.PI * scale * (1.0 + (x - location) / scale * ((x - location) / scale)));
		}

		public static double CDF(double location, double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Atan((x - location) / scale) / Math.PI + 0.5;
		}

		public static double InvCDF(double location, double scale, double p)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(p <= 0.0))
			{
				if (!(p >= 1.0))
				{
					return location + scale * Math.Tan((p - 0.5) * Math.PI);
				}
				return double.PositiveInfinity;
			}
			return double.NegativeInfinity;
		}

		public static double Sample(System.Random rnd, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, location, scale);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, location, scale);
		}

		public static void Samples(System.Random rnd, double[] values, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, location, scale);
		}

		public static double Sample(double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, location, scale);
		}

		public static IEnumerable<double> Samples(double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, location, scale);
		}

		public static void Samples(double[] values, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, location, scale);
		}
	}
	public class Chi : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _freedom;

		public double DegreesOfFreedom => _freedom;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => 1.4142135623730951 * (SpecialFunctions.Gamma((_freedom + 1.0) / 2.0) / SpecialFunctions.Gamma(_freedom / 2.0));

		public double Variance => _freedom - Mean * Mean;

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy => SpecialFunctions.GammaLn(_freedom / 2.0) + (_freedom - Math.Log(2.0) - (_freedom - 1.0) * SpecialFunctions.DiGamma(_freedom / 2.0)) / 2.0;

		public double Skewness
		{
			get
			{
				double stdDev = StdDev;
				return Mean * (1.0 - 2.0 * (stdDev * stdDev)) / (stdDev * stdDev * stdDev);
			}
		}

		public double Mode
		{
			get
			{
				if (_freedom < 1.0)
				{
					throw new NotSupportedException();
				}
				return Math.Sqrt(_freedom - 1.0);
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public Chi(double freedom)
		{
			if (!IsValidParameterSet(freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_freedom = freedom;
		}

		public Chi(double freedom, System.Random randomSource)
		{
			if (!IsValidParameterSet(freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_freedom = freedom;
		}

		public override string ToString()
		{
			return $"Chi(k = {_freedom})";
		}

		public static bool IsValidParameterSet(double freedom)
		{
			return freedom > 0.0;
		}

		public double Density(double x)
		{
			return PDF(_freedom, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_freedom, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_freedom, x);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, (int)_freedom);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, (int)_freedom);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, (int)_freedom);
		}

		private static double SampleUnchecked(System.Random rnd, int freedom)
		{
			double num = 0.0;
			for (int i = 0; i < freedom; i++)
			{
				num += Math.Pow(Normal.Sample(rnd, 0.0, 1.0), 2.0);
			}
			return Math.Sqrt(num);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, int freedom)
		{
			double[] standard = new double[values.Length * freedom];
			Normal.SamplesUnchecked(rnd, standard, 0.0, 1.0);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					int num = i * freedom;
					double num2 = 0.0;
					for (int j = 0; j < freedom; j++)
					{
						num2 += standard[num + j] * standard[num + j];
					}
					values[i] = Math.Sqrt(num2);
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, int freedom)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, freedom);
			}
		}

		public static double PDF(double freedom, double x)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(freedom) || double.IsPositiveInfinity(x) || x == 0.0)
			{
				return 0.0;
			}
			if (freedom > 160.0)
			{
				return Math.Exp(PDFLn(freedom, x));
			}
			return Math.Pow(2.0, 1.0 - freedom / 2.0) * Math.Pow(x, freedom - 1.0) * Math.Exp((0.0 - x) * x / 2.0) / SpecialFunctions.Gamma(freedom / 2.0);
		}

		public static double PDFLn(double freedom, double x)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(freedom) || double.IsPositiveInfinity(x) || x == 0.0)
			{
				return double.NegativeInfinity;
			}
			return (1.0 - freedom / 2.0) * Math.Log(2.0) + (freedom - 1.0) * Math.Log(x) - x * x / 2.0 - SpecialFunctions.GammaLn(freedom / 2.0);
		}

		public static double CDF(double freedom, double x)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(x))
			{
				return 1.0;
			}
			if (double.IsPositiveInfinity(freedom))
			{
				return 1.0;
			}
			return SpecialFunctions.GammaLowerRegularized(freedom / 2.0, x * x / 2.0);
		}

		public static double Sample(System.Random rnd, int freedom)
		{
			if (freedom <= 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, freedom);
		}

		public static IEnumerable<double> Samples(System.Random rnd, int freedom)
		{
			if (freedom <= 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, freedom);
		}

		public static void Samples(System.Random rnd, double[] values, int freedom)
		{
			if (freedom <= 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, freedom);
		}

		public static double Sample(int freedom)
		{
			if (freedom <= 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, freedom);
		}

		public static IEnumerable<double> Samples(int freedom)
		{
			if (freedom <= 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, freedom);
		}

		public static void Samples(double[] values, int freedom)
		{
			if (freedom <= 0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, freedom);
		}
	}
	public class ChiSquared : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _freedom;

		public double DegreesOfFreedom => _freedom;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _freedom;

		public double Variance => 2.0 * _freedom;

		public double StdDev => Math.Sqrt(2.0 * _freedom);

		public double Entropy => _freedom / 2.0 + Math.Log(2.0 * SpecialFunctions.Gamma(_freedom / 2.0)) + (1.0 - _freedom / 2.0) * SpecialFunctions.DiGamma(_freedom / 2.0);

		public double Skewness => Math.Sqrt(8.0 / _freedom);

		public double Mode => _freedom - 2.0;

		public double Median => _freedom - 2.0 / 3.0;

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public ChiSquared(double freedom)
		{
			if (!IsValidParameterSet(freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_freedom = freedom;
		}

		public ChiSquared(double freedom, System.Random randomSource)
		{
			if (!IsValidParameterSet(freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_freedom = freedom;
		}

		public override string ToString()
		{
			return $"ChiSquared(k = {_freedom})";
		}

		public static bool IsValidParameterSet(double freedom)
		{
			return freedom > 0.0;
		}

		public double Density(double x)
		{
			return PDF(_freedom, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_freedom, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_freedom, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_freedom, p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _freedom);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _freedom);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _freedom);
		}

		private static double SampleUnchecked(System.Random rnd, double freedom)
		{
			if (Math.Floor(freedom) == freedom && freedom < 2147483647.0)
			{
				double num = 0.0;
				int num2 = (int)freedom;
				for (int i = 0; i < num2; i++)
				{
					num += Math.Pow(Normal.Sample(rnd, 0.0, 1.0), 2.0);
				}
				return num;
			}
			return Gamma.SampleUnchecked(rnd, freedom / 2.0, 0.5);
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double freedom)
		{
			if (Math.Floor(freedom) == freedom && freedom < 2147483647.0)
			{
				int i = (int)freedom;
				double[] standard = new double[values.Length * i];
				Normal.SamplesUnchecked(rnd, standard, 0.0, 1.0);
				CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						int num = j * i;
						double num2 = 0.0;
						for (int k = 0; k < i; k++)
						{
							num2 += standard[num + k] * standard[num + k];
						}
						values[j] = num2;
					}
				});
			}
			else
			{
				Gamma.SamplesUnchecked(rnd, values, freedom / 2.0, 0.5);
			}
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double freedom)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, freedom);
			}
		}

		public static double PDF(double freedom, double x)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(freedom) || double.IsPositiveInfinity(x) || x == 0.0)
			{
				return 0.0;
			}
			if (freedom > 160.0)
			{
				return Math.Exp(PDFLn(freedom, x));
			}
			return Math.Pow(x, freedom / 2.0 - 1.0) * Math.Exp((0.0 - x) / 2.0) / (Math.Pow(2.0, freedom / 2.0) * SpecialFunctions.Gamma(freedom / 2.0));
		}

		public static double PDFLn(double freedom, double x)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(freedom) || double.IsPositiveInfinity(x) || x == 0.0)
			{
				return double.NegativeInfinity;
			}
			return (0.0 - x) / 2.0 + (freedom / 2.0 - 1.0) * Math.Log(x) - freedom / 2.0 * Math.Log(2.0) - SpecialFunctions.GammaLn(freedom / 2.0);
		}

		public static double CDF(double freedom, double x)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(x))
			{
				return 1.0;
			}
			if (double.IsPositiveInfinity(freedom))
			{
				return 1.0;
			}
			return SpecialFunctions.GammaLowerRegularized(freedom / 2.0, x / 2.0);
		}

		public static double InvCDF(double freedom, double p)
		{
			if (!IsValidParameterSet(freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.GammaLowerRegularizedInv(freedom / 2.0, p) / 0.5;
		}

		public static double Sample(System.Random rnd, double freedom)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, freedom);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double freedom)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, freedom);
		}

		public static void Samples(System.Random rnd, double[] values, double freedom)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, freedom);
		}

		public static double Sample(double freedom)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, freedom);
		}

		public static IEnumerable<double> Samples(double freedom)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, freedom);
		}

		public static void Samples(double[] values, double freedom)
		{
			if (freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, freedom);
		}
	}
	public class ContinuousUniform : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _lower;

		private readonly double _upper;

		public double LowerBound => _lower;

		public double UpperBound => _upper;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => (_lower + _upper) / 2.0;

		public double Variance => (_upper - _lower) * (_upper - _lower) / 12.0;

		public double StdDev => (_upper - _lower) / Math.Sqrt(12.0);

		public double Entropy => Math.Log(_upper - _lower);

		public double Skewness => 0.0;

		public double Mode => (_lower + _upper) / 2.0;

		public double Median => (_lower + _upper) / 2.0;

		public double Minimum => _lower;

		public double Maximum => _upper;

		public ContinuousUniform()
			: this(0.0, 1.0)
		{
		}

		public ContinuousUniform(double lower, double upper)
		{
			if (!IsValidParameterSet(lower, upper))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_lower = lower;
			_upper = upper;
		}

		public ContinuousUniform(double lower, double upper, System.Random randomSource)
		{
			if (!IsValidParameterSet(lower, upper))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_lower = lower;
			_upper = upper;
		}

		public override string ToString()
		{
			return $"ContinuousUniform(Lower = {_lower}, Upper = {_upper})";
		}

		public static bool IsValidParameterSet(double lower, double upper)
		{
			return lower <= upper;
		}

		public double Density(double x)
		{
			if (!(x < _lower) && !(x > _upper))
			{
				return 1.0 / (_upper - _lower);
			}
			return 0.0;
		}

		public double DensityLn(double x)
		{
			if (!(x < _lower) && !(x > _upper))
			{
				return 0.0 - Math.Log(_upper - _lower);
			}
			return double.NegativeInfinity;
		}

		public double CumulativeDistribution(double x)
		{
			if (!(x <= _lower))
			{
				if (!(x >= _upper))
				{
					return (x - _lower) / (_upper - _lower);
				}
				return 1.0;
			}
			return 0.0;
		}

		public double InverseCumulativeDistribution(double p)
		{
			if (!(p <= 0.0))
			{
				if (!(p >= 1.0))
				{
					return _lower * (1.0 - p) + _upper * p;
				}
				return _upper;
			}
			return _lower;
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _lower, _upper);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _lower, _upper);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _lower, _upper);
		}

		private static double SampleUnchecked(System.Random rnd, double lower, double upper)
		{
			return lower + rnd.NextDouble() * (upper - lower);
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double lower, double upper)
		{
			double difference = upper - lower;
			while (true)
			{
				yield return lower + rnd.NextDouble() * difference;
			}
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double lower, double upper)
		{
			rnd.NextDoubles(values);
			double difference = upper - lower;
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = lower + values[i] * difference;
				}
			});
		}

		public static double PDF(double lower, double upper, double x)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x < lower) && !(x > upper))
			{
				return 1.0 / (upper - lower);
			}
			return 0.0;
		}

		public static double PDFLn(double lower, double upper, double x)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x < lower) && !(x > upper))
			{
				return 0.0 - Math.Log(upper - lower);
			}
			return double.NegativeInfinity;
		}

		public static double CDF(double lower, double upper, double x)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x <= lower))
			{
				if (!(x >= upper))
				{
					return (x - lower) / (upper - lower);
				}
				return 1.0;
			}
			return 0.0;
		}

		public static double InvCDF(double lower, double upper, double p)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(p <= 0.0))
			{
				if (!(p >= 1.0))
				{
					return lower * (1.0 - p) + upper * p;
				}
				return upper;
			}
			return lower;
		}

		public static double Sample(System.Random rnd, double lower, double upper)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, lower, upper);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double lower, double upper)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, lower, upper);
		}

		public static void Samples(System.Random rnd, double[] values, double lower, double upper)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, lower, upper);
		}

		public static double Sample(double lower, double upper)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, lower, upper);
		}

		public static IEnumerable<double> Samples(double lower, double upper)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, lower, upper);
		}

		public static void Samples(double[] values, double lower, double upper)
		{
			if (upper < lower)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, lower, upper);
		}
	}
	public class ConwayMaxwellPoisson : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _lambda;

		private readonly double _nu;

		private double _mean = double.MinValue;

		private double _variance = double.MinValue;

		private double _z = double.MinValue;

		private const double Tolerance = 1E-12;

		public double Lambda => _lambda;

		public double Nu => _nu;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (_lambda == 0.0)
				{
					return 0.0;
				}
				if (_mean != double.MinValue)
				{
					return _mean;
				}
				double num = 1.0 + _lambda;
				double num2 = _lambda * _lambda / Math.Pow(2.0, _nu);
				double num3 = _lambda;
				double num4 = 2.0 * num2;
				for (int i = 3; i < 1000; i++)
				{
					double num5 = _lambda / Math.Pow(i, _nu);
					double num6 = _lambda / Math.Pow(i, _nu - 1.0) / (double)(i - 1);
					double num7 = num2 * num5;
					double num8 = num4 * num6;
					if (num8 < num4 && num7 < num2)
					{
						double num9 = num3 / num;
						double num10 = (num3 + num4 / (1.0 - num8 / num4)) / num;
						double num11 = num3 / (num + num2 / (1.0 - num7 / num2));
						if ((num10 - num11) / num9 < 1E-12)
						{
							break;
						}
					}
					num += num2;
					num3 += num4;
					num2 = num7;
					num4 = num8;
				}
				_mean = num3 / num;
				return _mean;
			}
		}

		public double Variance
		{
			get
			{
				if (_lambda == 0.0)
				{
					return 0.0;
				}
				if (_variance != double.MinValue)
				{
					return _variance;
				}
				double num = 1.0 + _lambda;
				double num2 = _lambda * _lambda / Math.Pow(2.0, _nu);
				double num3 = _lambda;
				double num4 = 4.0 * num2;
				for (int i = 3; i < 1000; i++)
				{
					double num5 = _lambda / Math.Pow(i, _nu);
					double num6 = _lambda / Math.Pow(i, _nu - 2.0) / (double)(i - 1) / (double)(i - 1);
					double num7 = num2 * num5;
					double num8 = num4 * num6;
					if (num8 < num4 && num7 < num2)
					{
						double num9 = num3 / num;
						double num10 = (num3 + num4 / (1.0 - num8 / num4)) / num;
						double num11 = num3 / (num + num2 / (1.0 - num7 / num2));
						if ((num10 - num11) / num9 < 1E-12)
						{
							break;
						}
					}
					num += num2;
					num3 += num4;
					num2 = num7;
					num4 = num8;
				}
				double mean = Mean;
				_variance = num3 / num - mean * mean;
				return _variance;
			}
		}

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Mode
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Minimum => 0;

		public int Maximum
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		private double Z
		{
			get
			{
				if (_z != double.MinValue)
				{
					return _z;
				}
				_z = Normalization(_lambda, _nu);
				return _z;
			}
		}

		public ConwayMaxwellPoisson(double lambda, double nu)
		{
			if (!IsValidParameterSet(lambda, nu))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_lambda = lambda;
			_nu = nu;
		}

		public ConwayMaxwellPoisson(double lambda, double nu, System.Random randomSource)
		{
			if (!IsValidParameterSet(lambda, nu))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_lambda = lambda;
			_nu = nu;
		}

		public override string ToString()
		{
			return $"ConwayMaxwellPoisson( = {_lambda},  = {_nu})";
		}

		public static bool IsValidParameterSet(double lambda, double nu)
		{
			if (lambda > 0.0)
			{
				return nu >= 0.0;
			}
			return false;
		}

		public double Probability(int k)
		{
			return Math.Pow(_lambda, k) / Math.Pow(SpecialFunctions.Factorial(k), _nu) / Z;
		}

		public double ProbabilityLn(int k)
		{
			return (double)k * Math.Log(_lambda) - _nu * SpecialFunctions.FactorialLn(k) - Math.Log(Z);
		}

		public double CumulativeDistribution(double x)
		{
			double z = Z;
			double num = 0.0;
			for (int i = 0; (double)i < x + 1.0; i++)
			{
				num += Math.Pow(_lambda, i) / Math.Pow(SpecialFunctions.Factorial(i), _nu) / z;
			}
			return num;
		}

		public static double PMF(double lambda, double nu, int k)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double num = Normalization(lambda, nu);
			return Math.Pow(lambda, k) / Math.Pow(SpecialFunctions.Factorial(k), nu) / num;
		}

		public static double PMFLn(double lambda, double nu, int k)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double d = Normalization(lambda, nu);
			return (double)k * Math.Log(lambda) - nu * SpecialFunctions.FactorialLn(k) - Math.Log(d);
		}

		public static double CDF(double lambda, double nu, double x)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double num = Normalization(lambda, nu);
			double num2 = 0.0;
			for (int i = 0; (double)i < x + 1.0; i++)
			{
				num2 += Math.Pow(lambda, i) / Math.Pow(SpecialFunctions.Factorial(i), nu) / num;
			}
			return num2;
		}

		private static double Normalization(double lambda, double nu)
		{
			double num = 1.0 + lambda;
			double num2 = lambda;
			for (int i = 2; i < 1000; i++)
			{
				double num3 = lambda / Math.Pow(i, nu);
				num2 *= num3;
				num += num2;
				if (num3 < 1.0 && num2 / (1.0 - num3) / num < 1E-12)
				{
					break;
				}
			}
			return num;
		}

		private static int SampleUnchecked(System.Random rnd, double lambda, double nu, double z)
		{
			double num = rnd.NextDouble();
			double num2 = 1.0 / z;
			double num3 = num2;
			int num4 = 0;
			for (; num > num3; num3 += num2)
			{
				num4++;
				num2 = num2 * lambda / Math.Pow(num4, nu);
			}
			return num4;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double lambda, double nu, double z)
		{
			double[] uniform = rnd.NextDoubles(values.Length);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					double num = uniform[i];
					double num2 = 1.0 / z;
					double num3 = num2;
					int num4 = 0;
					for (; num > num3; num3 += num2)
					{
						num4++;
						num2 = num2 * lambda / Math.Pow(num4, nu);
					}
					values[i] = num4;
				}
			});
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double lambda, double nu, double z)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, lambda, nu, z);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _lambda, _nu, Z);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _lambda, _nu, Z);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _lambda, _nu, Z);
		}

		public static int Sample(System.Random rnd, double lambda, double nu)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double z = Normalization(lambda, nu);
			return SampleUnchecked(rnd, lambda, nu, z);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double lambda, double nu)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double z = Normalization(lambda, nu);
			return SamplesUnchecked(rnd, lambda, nu, z);
		}

		public static void Samples(System.Random rnd, int[] values, double lambda, double nu)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double z = Normalization(lambda, nu);
			SamplesUnchecked(rnd, values, lambda, nu, z);
		}

		public static int Sample(double lambda, double nu)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double z = Normalization(lambda, nu);
			return SampleUnchecked(SystemRandomSource.Default, lambda, nu, z);
		}

		public static IEnumerable<int> Samples(double lambda, double nu)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double z = Normalization(lambda, nu);
			return SamplesUnchecked(SystemRandomSource.Default, lambda, nu, z);
		}

		public static void Samples(int[] values, double lambda, double nu)
		{
			if (!(lambda > 0.0) || !(nu >= 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double z = Normalization(lambda, nu);
			SamplesUnchecked(SystemRandomSource.Default, values, lambda, nu, z);
		}
	}
	public class Dirichlet : IDistribution
	{
		private System.Random _random;

		private readonly double[] _alpha;

		public double[] Alpha => _alpha;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public int Dimension => _alpha.Length;

		private double AlphaSum => _alpha.Sum();

		public double[] Mean
		{
			get
			{
				double alphaSum = AlphaSum;
				double[] array = new double[Dimension];
				for (int i = 0; i < Dimension; i++)
				{
					array[i] = _alpha[i] / alphaSum;
				}
				return array;
			}
		}

		public double[] Variance
		{
			get
			{
				double alphaSum = AlphaSum;
				double[] array = new double[_alpha.Length];
				for (int i = 0; i < _alpha.Length; i++)
				{
					array[i] = _alpha[i] * (alphaSum - _alpha[i]) / (alphaSum * alphaSum * (alphaSum + 1.0));
				}
				return array;
			}
		}

		public double Entropy
		{
			get
			{
				double num = _alpha.Sum((double t) => (t - 1.0) * SpecialFunctions.DiGamma(t));
				return SpecialFunctions.GammaLn(AlphaSum) + (AlphaSum - (double)Dimension) * SpecialFunctions.DiGamma(AlphaSum) - num;
			}
		}

		public Dirichlet(double[] alpha)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(alpha))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_alpha = (double[])alpha.Clone();
		}

		public Dirichlet(double[] alpha, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(alpha))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_alpha = (double[])alpha.Clone();
		}

		public Dirichlet(double alpha, int k)
		{
			double[] array = new double[k];
			for (int i = 0; i < k; i++)
			{
				array[i] = alpha;
			}
			_random = SystemRandomSource.Default;
			if (Control.CheckDistributionParameters && !IsValidParameterSet(array))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_alpha = (double[])array.Clone();
		}

		public Dirichlet(double alpha, int k, System.Random randomSource)
		{
			double[] array = new double[k];
			for (int i = 0; i < k; i++)
			{
				array[i] = alpha;
			}
			_random = randomSource ?? SystemRandomSource.Default;
			if (Control.CheckDistributionParameters && !IsValidParameterSet(array))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_alpha = (double[])array.Clone();
		}

		public override string ToString()
		{
			return $"Dirichlet(Dimension = {Dimension})";
		}

		public static bool IsValidParameterSet(double[] alpha)
		{
			bool flag = true;
			foreach (double num in alpha)
			{
				if (num < 0.0)
				{
					return false;
				}
				if (num > 0.0)
				{
					flag = false;
				}
			}
			return !flag;
		}

		public double Density(double[] x)
		{
			return Math.Exp(DensityLn(x));
		}

		public double DensityLn(double[] x)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			bool flag = x.Length == _alpha.Length - 1;
			if (x.Length != _alpha.Length && !flag)
			{
				throw new ArgumentException("x");
			}
			double num = 0.0;
			double num2 = 0.0;
			double num3 = 0.0;
			for (int i = 0; i < x.Length; i++)
			{
				double num4 = x[i];
				if (num4 <= 0.0 || num4 >= 1.0)
				{
					return 0.0;
				}
				num += (_alpha[i] - 1.0) * Math.Log(num4) - SpecialFunctions.GammaLn(_alpha[i]);
				num2 += num4;
				num3 += _alpha[i];
			}
			if (flag)
			{
				if (num2 >= 1.0)
				{
					return 0.0;
				}
				num += (_alpha[_alpha.Length - 1] - 1.0) * Math.Log(1.0 - num2) - SpecialFunctions.GammaLn(_alpha[_alpha.Length - 1]);
				num3 += _alpha[_alpha.Length - 1];
			}
			else if (!num2.AlmostEqualRelative(1.0, 8))
			{
				return 0.0;
			}
			return num + SpecialFunctions.GammaLn(num3);
		}

		public double[] Sample()
		{
			return Sample(_random, _alpha);
		}

		public static double[] Sample(System.Random rnd, double[] alpha)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(alpha))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			int num = alpha.Length;
			double[] array = new double[num];
			double num2 = 0.0;
			for (int i = 0; i < num; i++)
			{
				if (alpha[i] == 0.0)
				{
					array[i] = 0.0;
				}
				else
				{
					array[i] = Gamma.Sample(rnd, alpha[i], 1.0);
				}
				num2 += array[i];
			}
			for (int j = 0; j < num; j++)
			{
				array[j] /= num2;
			}
			return array;
		}
	}
	public class DiscreteUniform : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly int _lower;

		private readonly int _upper;

		public int LowerBound => _lower;

		public int UpperBound => _upper;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => (double)(_lower + _upper) / 2.0;

		public double StdDev => Math.Sqrt((((double)(_upper - _lower) + 1.0) * ((double)(_upper - _lower) + 1.0) - 1.0) / 12.0);

		public double Variance => (((double)(_upper - _lower) + 1.0) * ((double)(_upper - _lower) + 1.0) - 1.0) / 12.0;

		public double Entropy => Math.Log((double)(_upper - _lower) + 1.0);

		public double Skewness => 0.0;

		public int Minimum => _lower;

		public int Maximum => _upper;

		public int Mode => (int)Math.Floor((double)(_lower + _upper) / 2.0);

		public double Median => (double)(_lower + _upper) / 2.0;

		public DiscreteUniform(int lower, int upper)
		{
			if (!IsValidParameterSet(lower, upper))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_lower = lower;
			_upper = upper;
		}

		public DiscreteUniform(int lower, int upper, System.Random randomSource)
		{
			if (!IsValidParameterSet(lower, upper))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_lower = lower;
			_upper = upper;
		}

		public override string ToString()
		{
			return $"DiscreteUniform(Lower = {_lower}, Upper = {_upper})";
		}

		public static bool IsValidParameterSet(int lower, int upper)
		{
			return lower <= upper;
		}

		public double Probability(int k)
		{
			return PMF(_lower, _upper, k);
		}

		public double ProbabilityLn(int k)
		{
			return PMFLn(_lower, _upper, k);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_lower, _upper, x);
		}

		public static double PMF(int lower, int upper, int k)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k < lower || k > upper)
			{
				return 0.0;
			}
			return 1.0 / (double)(upper - lower + 1);
		}

		public static double PMFLn(int lower, int upper, int k)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k < lower || k > upper)
			{
				return double.NegativeInfinity;
			}
			return 0.0 - Math.Log(upper - lower + 1);
		}

		public static double CDF(int lower, int upper, double x)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < (double)lower)
			{
				return 0.0;
			}
			if (x >= (double)upper)
			{
				return 1.0;
			}
			return Math.Min(1.0, (Math.Floor(x) - (double)lower + 1.0) / (double)(upper - lower + 1));
		}

		private static int SampleUnchecked(System.Random rnd, int lower, int upper)
		{
			return rnd.Next(lower, upper + 1);
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, int lower, int upper)
		{
			rnd.NextInt32s(values, lower, upper + 1);
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, int lower, int upper)
		{
			return rnd.NextInt32Sequence(lower, upper + 1);
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _lower, _upper);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _lower, _upper);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _lower, _upper);
		}

		public static int Sample(System.Random rnd, int lower, int upper)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, lower, upper);
		}

		public static IEnumerable<int> Samples(System.Random rnd, int lower, int upper)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, lower, upper);
		}

		public static void Samples(System.Random rnd, int[] values, int lower, int upper)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, lower, upper);
		}

		public static int Sample(int lower, int upper)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, lower, upper);
		}

		public static IEnumerable<int> Samples(int lower, int upper)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, lower, upper);
		}

		public static void Samples(int[] values, int lower, int upper)
		{
			if (lower > upper)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, lower, upper);
		}
	}
	public class Erlang : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly int _shape;

		private readonly double _rate;

		public int Shape => _shape;

		public double Rate => _rate;

		public double Scale => 1.0 / _rate;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return _shape;
				}
				if (_rate == 0.0 && (double)_shape == 0.0)
				{
					return double.NaN;
				}
				return (double)_shape / _rate;
			}
		}

		public double Variance
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && (double)_shape == 0.0)
				{
					return double.NaN;
				}
				return (double)_shape / (_rate * _rate);
			}
		}

		public double StdDev
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && (double)_shape == 0.0)
				{
					return double.NaN;
				}
				return Math.Sqrt(_shape) / _rate;
			}
		}

		public double Entropy
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && (double)_shape == 0.0)
				{
					return double.NaN;
				}
				return (double)_shape - Math.Log(_rate) + SpecialFunctions.GammaLn(_shape) + (1.0 - (double)_shape) * SpecialFunctions.DiGamma(_shape);
			}
		}

		public double Skewness
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && (double)_shape == 0.0)
				{
					return double.NaN;
				}
				return 2.0 / Math.Sqrt(_shape);
			}
		}

		public double Mode
		{
			get
			{
				if (_shape < 1)
				{
					throw new NotSupportedException();
				}
				if (double.IsPositiveInfinity(_rate))
				{
					return _shape;
				}
				if (_rate == 0.0 && (double)_shape == 0.0)
				{
					return double.NaN;
				}
				return ((double)_shape - 1.0) / _rate;
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public Erlang(int shape, double rate)
		{
			if (!IsValidParameterSet(shape, rate))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_shape = shape;
			_rate = rate;
		}

		public Erlang(int shape, double rate, System.Random randomSource)
		{
			if (!IsValidParameterSet(shape, rate))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_shape = shape;
			_rate = rate;
		}

		public static Erlang WithShapeScale(int shape, double scale, System.Random randomSource = null)
		{
			return new Erlang(shape, 1.0 / scale, randomSource);
		}

		public static Erlang WithShapeRate(int shape, double rate, System.Random randomSource = null)
		{
			return new Erlang(shape, rate, randomSource);
		}

		public override string ToString()
		{
			return $"Erlang(k = {_shape},  = {_rate})";
		}

		public static bool IsValidParameterSet(int shape, double rate)
		{
			if (shape >= 0)
			{
				return rate >= 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_shape, _rate, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_shape, _rate, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_shape, _rate, x);
		}

		public double Sample()
		{
			return Gamma.SampleUnchecked(_random, _shape, _rate);
		}

		public void Samples(double[] values)
		{
			Gamma.SamplesUnchecked(_random, values, _shape, _rate);
		}

		public IEnumerable<double> Samples()
		{
			while (true)
			{
				yield return Gamma.SampleUnchecked(_random, _shape, _rate);
			}
		}

		public static double PDF(int shape, double rate, double x)
		{
			if ((double)shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(rate))
			{
				if (x != (double)shape)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if ((double)shape == 0.0 && rate == 0.0)
			{
				return 0.0;
			}
			if ((double)shape == 1.0)
			{
				return rate * Math.Exp((0.0 - rate) * x);
			}
			if ((double)shape > 160.0)
			{
				return Math.Exp(PDFLn(shape, rate, x));
			}
			return Math.Pow(rate, shape) * Math.Pow(x, (double)shape - 1.0) * Math.Exp((0.0 - rate) * x) / SpecialFunctions.Gamma(shape);
		}

		public static double PDFLn(int shape, double rate, double x)
		{
			if ((double)shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(rate))
			{
				if (x != (double)shape)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if ((double)shape == 0.0 && rate == 0.0)
			{
				return double.NegativeInfinity;
			}
			if ((double)shape == 1.0)
			{
				return Math.Log(rate) - rate * x;
			}
			return (double)shape * Math.Log(rate) + ((double)shape - 1.0) * Math.Log(x) - rate * x - SpecialFunctions.GammaLn(shape);
		}

		public static double CDF(int shape, double rate, double x)
		{
			if ((double)shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(rate))
			{
				if (!(x >= (double)shape))
				{
					return 0.0;
				}
				return 1.0;
			}
			if ((double)shape == 0.0 && rate == 0.0)
			{
				return 0.0;
			}
			return SpecialFunctions.GammaLowerRegularized(shape, x * rate);
		}

		public static double Sample(System.Random rnd, int shape, double rate)
		{
			return Gamma.Sample(rnd, shape, rate);
		}

		public static IEnumerable<double> Samples(System.Random rnd, int shape, double rate)
		{
			return Gamma.Samples(rnd, shape, rate);
		}

		public static void Samples(System.Random rnd, double[] values, int shape, double rate)
		{
			Gamma.Samples(rnd, values, shape, rate);
		}

		public static double Sample(int shape, double rate)
		{
			return Gamma.Sample(shape, rate);
		}

		public static IEnumerable<double> Samples(int shape, double rate)
		{
			return Gamma.Samples(shape, rate);
		}

		public static void Samples(double[] values, int shape, double rate)
		{
			Gamma.Samples(values, shape, rate);
		}
	}
	public class Exponential : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _rate;

		public double Rate => _rate;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => 1.0 / _rate;

		public double Variance => 1.0 / (_rate * _rate);

		public double StdDev => 1.0 / _rate;

		public double Entropy => 1.0 - Math.Log(_rate);

		public double Skewness => 2.0;

		public double Mode => 0.0;

		public double Median => Math.Log(2.0) / _rate;

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public Exponential(double rate)
		{
			if (!IsValidParameterSet(rate))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_rate = rate;
		}

		public Exponential(double rate, System.Random randomSource)
		{
			if (!IsValidParameterSet(rate))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_rate = rate;
		}

		public override string ToString()
		{
			return $"Exponential( = {_rate})";
		}

		public static bool IsValidParameterSet(double rate)
		{
			return rate >= 0.0;
		}

		public double Density(double x)
		{
			if (!(x < 0.0))
			{
				return _rate * Math.Exp((0.0 - _rate) * x);
			}
			return 0.0;
		}

		public double DensityLn(double x)
		{
			return Math.Log(_rate) - _rate * x;
		}

		public double CumulativeDistribution(double x)
		{
			if (!(x < 0.0))
			{
				return 1.0 - Math.Exp((0.0 - _rate) * x);
			}
			return 0.0;
		}

		public double InverseCumulativeDistribution(double p)
		{
			if (!(p >= 1.0))
			{
				return (0.0 - Math.Log(1.0 - p)) / _rate;
			}
			return double.PositiveInfinity;
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _rate);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _rate);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _rate);
		}

		private static double SampleUnchecked(System.Random rnd, double rate)
		{
			double num;
			for (num = rnd.NextDouble(); num == 0.0; num = rnd.NextDouble())
			{
			}
			return (0.0 - Math.Log(num)) / rate;
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double rate)
		{
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					double num;
					for (num = values[i]; num == 0.0; num = rnd.NextDouble())
					{
					}
					values[i] = (0.0 - Math.Log(num)) / rate;
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double rate)
		{
			return from r in rnd.NextDoubleSequence()
				where r != 0.0
				select (0.0 - Math.Log(r)) / rate;
		}

		public static double PDF(double rate, double x)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x < 0.0))
			{
				return rate * Math.Exp((0.0 - rate) * x);
			}
			return 0.0;
		}

		public static double PDFLn(double rate, double x)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Log(rate) - rate * x;
		}

		public static double CDF(double rate, double x)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x < 0.0))
			{
				return 1.0 - Math.Exp((0.0 - rate) * x);
			}
			return 0.0;
		}

		public static double InvCDF(double rate, double p)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(p >= 1.0))
			{
				return (0.0 - Math.Log(1.0 - p)) / rate;
			}
			return double.PositiveInfinity;
		}

		public static double Sample(System.Random rnd, double rate)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, rate);
		}

		public static void Samples(System.Random rnd, double[] values, double rate)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, rate);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double rate)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, rate);
		}

		public static double Sample(double rate)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, rate);
		}

		public static void Samples(double[] values, double rate)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, rate);
		}

		public static IEnumerable<double> Samples(double rate)
		{
			if (rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, rate);
		}
	}
	public class FisherSnedecor : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _freedom1;

		private readonly double _freedom2;

		public double DegreesOfFreedom1 => _freedom1;

		public double DegreesOfFreedom2 => _freedom2;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (_freedom2 <= 2.0)
				{
					throw new NotSupportedException();
				}
				return _freedom2 / (_freedom2 - 2.0);
			}
		}

		public double Variance
		{
			get
			{
				if (_freedom2 <= 4.0)
				{
					throw new NotSupportedException();
				}
				return 2.0 * _freedom2 * _freedom2 * (_freedom1 + _freedom2 - 2.0) / (_freedom1 * (_freedom2 - 2.0) * (_freedom2 - 2.0) * (_freedom2 - 4.0));
			}
		}

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness
		{
			get
			{
				if (_freedom2 <= 6.0)
				{
					throw new NotSupportedException();
				}
				return (2.0 * _freedom1 + _freedom2 - 2.0) * Math.Sqrt(8.0 * (_freedom2 - 4.0)) / ((_freedom2 - 6.0) * Math.Sqrt(_freedom1 * (_freedom1 + _freedom2 - 2.0)));
			}
		}

		public double Mode
		{
			get
			{
				if (_freedom1 <= 2.0)
				{
					throw new NotSupportedException();
				}
				return _freedom2 * (_freedom1 - 2.0) / (_freedom1 * (_freedom2 + 2.0));
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public FisherSnedecor(double d1, double d2)
		{
			if (!IsValidParameterSet(d1, d2))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_freedom1 = d1;
			_freedom2 = d2;
		}

		public FisherSnedecor(double d1, double d2, System.Random randomSource)
		{
			if (!IsValidParameterSet(d1, d2))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_freedom1 = d1;
			_freedom2 = d2;
		}

		public override string ToString()
		{
			return $"FisherSnedecor(d1 = {_freedom1}, d2 = {_freedom2})";
		}

		public static bool IsValidParameterSet(double d1, double d2)
		{
			if (d1 > 0.0)
			{
				return d2 > 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			return Math.Sqrt(Math.Pow(_freedom1 * x, _freedom1) * Math.Pow(_freedom2, _freedom2) / Math.Pow(_freedom1 * x + _freedom2, _freedom1 + _freedom2)) / (x * SpecialFunctions.Beta(_freedom1 / 2.0, _freedom2 / 2.0));
		}

		public double DensityLn(double x)
		{
			return Math.Log(Density(x));
		}

		public double CumulativeDistribution(double x)
		{
			return SpecialFunctions.BetaRegularized(_freedom1 / 2.0, _freedom2 / 2.0, _freedom1 * x / (_freedom1 * x + _freedom2));
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_freedom1, _freedom2, p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _freedom1, _freedom2);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _freedom1, _freedom2);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _freedom1, _freedom2);
		}

		private static double SampleUnchecked(System.Random rnd, double d1, double d2)
		{
			return ChiSquared.Sample(rnd, d1) * d2 / (ChiSquared.Sample(rnd, d2) * d1);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double d1, double d2)
		{
			double[] values2 = new double[values.Length];
			ChiSquared.SamplesUnchecked(rnd, values, d1);
			ChiSquared.SamplesUnchecked(rnd, values2, d2);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = values[i] * d2 / (values2[i] * d1);
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double d1, double d2)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, d1, d2);
			}
		}

		public static double PDF(double d1, double d2, double x)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Sqrt(Math.Pow(d1 * x, d1) * Math.Pow(d2, d2) / Math.Pow(d1 * x + d2, d1 + d2)) / (x * SpecialFunctions.Beta(d1 / 2.0, d2 / 2.0));
		}

		public static double PDFLn(double d1, double d2, double x)
		{
			return Math.Log(PDF(d1, d2, x));
		}

		public static double CDF(double d1, double d2, double x)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.BetaRegularized(d1 / 2.0, d2 / 2.0, d1 * x / (d1 * x + d2));
		}

		public static double InvCDF(double d1, double d2, double p)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Brent.FindRoot((double x) => SpecialFunctions.BetaRegularized(d1 / 2.0, d2 / 2.0, d1 * x / (d1 * x + d2)) - p, 0.0, 1000.0, 1E-12);
		}

		public static double Sample(System.Random rnd, double d1, double d2)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, d1, d2);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double d1, double d2)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, d1, d2);
		}

		public static void Samples(System.Random rnd, double[] values, double d1, double d2)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, d1, d2);
		}

		public static double Sample(double d1, double d2)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, d1, d2);
		}

		public static IEnumerable<double> Samples(double d1, double d2)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, d1, d2);
		}

		public static void Samples(double[] values, double d1, double d2)
		{
			if (d1 <= 0.0 || d2 <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, d1, d2);
		}
	}
	public class Gamma : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _shape;

		private readonly double _rate;

		public double Shape => _shape;

		public double Rate => _rate;

		public double Scale => 1.0 / _rate;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return _shape;
				}
				if (_rate == 0.0 && _shape == 0.0)
				{
					return double.NaN;
				}
				return _shape / _rate;
			}
		}

		public double Variance
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && _shape == 0.0)
				{
					return double.NaN;
				}
				return _shape / (_rate * _rate);
			}
		}

		public double StdDev
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && _shape == 0.0)
				{
					return double.NaN;
				}
				return Math.Sqrt(_shape / (_rate * _rate));
			}
		}

		public double Entropy
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && _shape == 0.0)
				{
					return double.NaN;
				}
				return _shape - Math.Log(_rate) + SpecialFunctions.GammaLn(_shape) + (1.0 - _shape) * SpecialFunctions.DiGamma(_shape);
			}
		}

		public double Skewness
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return 0.0;
				}
				if (_rate == 0.0 && _shape == 0.0)
				{
					return double.NaN;
				}
				return 2.0 / Math.Sqrt(_shape);
			}
		}

		public double Mode
		{
			get
			{
				if (double.IsPositiveInfinity(_rate))
				{
					return _shape;
				}
				if (_rate == 0.0 && _shape == 0.0)
				{
					return double.NaN;
				}
				return (_shape - 1.0) / _rate;
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public Gamma(double shape, double rate)
		{
			if (!IsValidParameterSet(shape, rate))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_shape = shape;
			_rate = rate;
		}

		public Gamma(double shape, double rate, System.Random randomSource)
		{
			if (!IsValidParameterSet(shape, rate))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_shape = shape;
			_rate = rate;
		}

		public static Gamma WithShapeScale(double shape, double scale, System.Random randomSource = null)
		{
			return new Gamma(shape, 1.0 / scale, randomSource);
		}

		public static Gamma WithShapeRate(double shape, double rate, System.Random randomSource = null)
		{
			return new Gamma(shape, rate, randomSource);
		}

		public override string ToString()
		{
			return $"Gamma( = {_shape},  = {_rate})";
		}

		public static bool IsValidParameterSet(double shape, double rate)
		{
			if (shape >= 0.0)
			{
				return rate >= 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_shape, _rate, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_shape, _rate, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_shape, _rate, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_shape, _rate, p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _shape, _rate);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _shape, _rate);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _shape, _rate);
		}

		internal static double SampleUnchecked(System.Random rnd, double shape, double rate)
		{
			if (double.IsPositiveInfinity(rate))
			{
				return shape;
			}
			double num = shape;
			double num2 = 1.0;
			if (shape < 1.0)
			{
				num = shape + 1.0;
				num2 = Math.Pow(rnd.NextDouble(), 1.0 / shape);
			}
			double num3 = num - 1.0 / 3.0;
			double num4 = 1.0 / Math.Sqrt(9.0 * num3);
			double num6;
			double num7;
			double num5;
			do
			{
				num5 = Normal.Sample(rnd, 0.0, 1.0);
				for (num6 = 1.0 + num4 * num5; num6 <= 0.0; num6 = 1.0 + num4 * num5)
				{
					num5 = Normal.Sample(rnd, 0.0, 1.0);
				}
				num6 = num6 * num6 * num6;
				num7 = rnd.NextDouble();
				num5 *= num5;
				if (num7 < 1.0 - 0.0331 * num5 * num5)
				{
					return num2 * num3 * num6 / rate;
				}
			}
			while (!(Math.Log(num7) < 0.5 * num5 + num3 * (1.0 - num6 + Math.Log(num6))));
			return num2 * num3 * num6 / rate;
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double shape, double rate)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, shape, rate);
			}
		}

		internal static IEnumerable<double> SamplesUnchecked(System.Random rnd, double location, double scale)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, location, scale);
			}
		}

		public static double PDF(double shape, double rate, double x)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(rate))
			{
				if (x != shape)
				{
					return 0.0;
				}
				return double.PositiveInfinity;
			}
			if (shape == 0.0 && rate == 0.0)
			{
				return 0.0;
			}
			if (shape == 1.0)
			{
				return rate * Math.Exp((0.0 - rate) * x);
			}
			if (shape > 160.0)
			{
				return Math.Exp(PDFLn(shape, rate, x));
			}
			return Math.Pow(rate, shape) * Math.Pow(x, shape - 1.0) * Math.Exp((0.0 - rate) * x) / SpecialFunctions.Gamma(shape);
		}

		public static double PDFLn(double shape, double rate, double x)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(rate))
			{
				if (x != shape)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			if (shape == 0.0 && rate == 0.0)
			{
				return double.NegativeInfinity;
			}
			if (shape == 1.0)
			{
				return Math.Log(rate) - rate * x;
			}
			return shape * Math.Log(rate) + (shape - 1.0) * Math.Log(x) - rate * x - SpecialFunctions.GammaLn(shape);
		}

		public static double CDF(double shape, double rate, double x)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(rate))
			{
				if (!(x >= shape))
				{
					return 0.0;
				}
				return 1.0;
			}
			if (shape == 0.0 && rate == 0.0)
			{
				return 0.0;
			}
			return SpecialFunctions.GammaLowerRegularized(shape, x * rate);
		}

		public static double InvCDF(double shape, double rate, double p)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.GammaLowerRegularizedInv(shape, p) / rate;
		}

		public static double Sample(System.Random rnd, double shape, double rate)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, shape, rate);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double shape, double rate)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, shape, rate);
		}

		public static void Samples(System.Random rnd, double[] values, double shape, double rate)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, shape, rate);
		}

		public static double Sample(double shape, double rate)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, shape, rate);
		}

		public static IEnumerable<double> Samples(double shape, double rate)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, shape, rate);
		}

		public static void Samples(double[] values, double shape, double rate)
		{
			if (shape < 0.0 || rate < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, shape, rate);
		}
	}
	public class Geometric : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _p;

		public double P => _p;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => 1.0 / _p;

		public double Variance => (1.0 - _p) / (_p * _p);

		public double StdDev => Math.Sqrt(1.0 - _p) / _p;

		public double Entropy => ((0.0 - _p) * Math.Log(_p, 2.0) - (1.0 - _p) * Math.Log(1.0 - _p, 2.0)) / _p;

		public double Skewness => (2.0 - _p) / Math.Sqrt(1.0 - _p);

		public int Mode => 1;

		public double Median
		{
			get
			{
				if (_p != 0.0)
				{
					if (_p != 1.0)
					{
						return Math.Ceiling(-0.6931471805599453 / Math.Log(1.0 - _p));
					}
					return 1.0;
				}
				return double.PositiveInfinity;
			}
		}

		public int Minimum => 1;

		public int Maximum => int.MaxValue;

		public Geometric(double p)
		{
			if (!IsValidParameterSet(p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_p = p;
		}

		public Geometric(double p, System.Random randomSource)
		{
			if (!IsValidParameterSet(p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_p = p;
		}

		public override string ToString()
		{
			return $"Geometric(p = {_p})";
		}

		public static bool IsValidParameterSet(double p)
		{
			if (p >= 0.0)
			{
				return p <= 1.0;
			}
			return false;
		}

		public double Probability(int k)
		{
			if (k <= 0)
			{
				return 0.0;
			}
			return Math.Pow(1.0 - _p, k - 1) * _p;
		}

		public double ProbabilityLn(int k)
		{
			if (k <= 0)
			{
				return double.NegativeInfinity;
			}
			return (double)(k - 1) * Math.Log(1.0 - _p) + Math.Log(_p);
		}

		public double CumulativeDistribution(double x)
		{
			return 1.0 - Math.Pow(1.0 - _p, x);
		}

		public static double PMF(double p, int k)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k <= 0)
			{
				return 0.0;
			}
			return Math.Pow(1.0 - p, k - 1) * p;
		}

		public static double PMFLn(double p, int k)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (k <= 0)
			{
				return double.NegativeInfinity;
			}
			return (double)(k - 1) * Math.Log(1.0 - p) + Math.Log(p);
		}

		public static double CDF(double p, double x)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 - Math.Pow(1.0 - p, x);
		}

		private static int SampleUnchecked(System.Random rnd, double p)
		{
			if (p != 1.0)
			{
				return (int)Math.Ceiling(Math.Log(1.0 - rnd.NextDouble(), 1.0 - p));
			}
			return 1;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double p)
		{
			if (p == 1.0)
			{
				CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
				{
					for (int j = a; j < b; j++)
					{
						values[j] = 1;
					}
				});
				return;
			}
			double[] uniform = rnd.NextDoubles(values.Length);
			double rp = 1.0 - p;
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = (int)Math.Ceiling(Math.Log(1.0 - uniform[i], rp));
				}
			});
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double p)
		{
			if (p == 1.0)
			{
				return Generate.RepeatSequence(1);
			}
			double rp = 1.0 - p;
			return from r in rnd.NextDoubleSequence()
				select (int)Math.Ceiling(Math.Log(1.0 - r, rp));
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _p);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _p);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _p);
		}

		public static int Sample(System.Random rnd, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, p);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, p);
		}

		public static void Samples(System.Random rnd, int[] values, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, p);
		}

		public static int Sample(double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, p);
		}

		public static IEnumerable<int> Samples(double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, p);
		}

		public static void Samples(int[] values, double p)
		{
			if (!(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, p);
		}
	}
	public class Hypergeometric : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly int _population;

		private readonly int _success;

		private readonly int _draws;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public int Population => _population;

		public int Draws => _draws;

		public int Success => _success;

		public double Mean => (double)_success * (double)_draws / (double)_population;

		public double Variance => (double)(_draws * _success * (_population - _draws) * (_population - _success)) / ((double)(_population * _population) * ((double)_population - 1.0));

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness => Math.Sqrt((double)_population - 1.0) * (double)(_population - 2 * _draws) * (double)(_population - 2 * _success) / (Math.Sqrt(_draws * _success * (_population - _success) * (_population - _draws)) * ((double)_population - 2.0));

		public int Mode => (_draws + 1) * (_success + 1) / (_population + 2);

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Minimum => Math.Max(0, _draws + _success - _population);

		public int Maximum => Math.Min(_success, _draws);

		public Hypergeometric(int population, int success, int draws)
		{
			if (!IsValidParameterSet(population, success, draws))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_population = population;
			_success = success;
			_draws = draws;
		}

		public Hypergeometric(int population, int success, int draws, System.Random randomSource)
		{
			if (!IsValidParameterSet(population, success, draws))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_population = population;
			_success = success;
			_draws = draws;
		}

		public override string ToString()
		{
			return $"Hypergeometric(N = {_population}, M = {_success}, n = {_draws})";
		}

		public static bool IsValidParameterSet(int population, int success, int draws)
		{
			if (population >= 0 && success >= 0 && draws >= 0 && success <= population)
			{
				return draws <= population;
			}
			return false;
		}

		public double Probability(int k)
		{
			return SpecialFunctions.Binomial(_success, k) * SpecialFunctions.Binomial(_population - _success, _draws - k) / SpecialFunctions.Binomial(_population, _draws);
		}

		public double ProbabilityLn(int k)
		{
			return SpecialFunctions.BinomialLn(_success, k) + SpecialFunctions.BinomialLn(_population - _success, _draws - k) - SpecialFunctions.BinomialLn(_population, _draws);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_population, _success, _draws, x);
		}

		public static double PMF(int population, int success, int draws, int k)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.Binomial(success, k) * SpecialFunctions.Binomial(population - success, draws - k) / SpecialFunctions.Binomial(population, draws);
		}

		public static double PMFLn(int population, int success, int draws, int k)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.BinomialLn(success, k) + SpecialFunctions.BinomialLn(population - success, draws - k) - SpecialFunctions.BinomialLn(population, draws);
		}

		public static double CDF(int population, int success, int draws, double x)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < (double)Math.Max(0, draws + success - population))
			{
				return 0.0;
			}
			if (x >= (double)Math.Min(success, draws))
			{
				return 1.0;
			}
			int num = (int)Math.Floor(x);
			double num2 = SpecialFunctions.BinomialLn(population, draws);
			double num3 = 0.0;
			for (int i = 0; i <= num; i++)
			{
				num3 += Math.Exp(SpecialFunctions.BinomialLn(success, i) + SpecialFunctions.BinomialLn(population - success, draws - i) - num2);
			}
			return Math.Min(num3, 1.0);
		}

		private static int SampleUnchecked(System.Random rnd, int population, int success, int draws)
		{
			int num = 0;
			do
			{
				double num2 = (double)success / (double)population;
				if (rnd.NextDouble() < num2)
				{
					num++;
					success--;
				}
				population--;
				draws--;
			}
			while (0 < draws);
			return num;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, int population, int success, int draws)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, population, success, draws);
			}
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, int population, int success, int draws)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, population, success, draws);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _population, _success, _draws);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _population, _success, _draws);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _population, _success, _draws);
		}

		public static int Sample(System.Random rnd, int population, int success, int draws)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, population, success, draws);
		}

		public static IEnumerable<int> Samples(System.Random rnd, int population, int success, int draws)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, population, success, draws);
		}

		public static void Samples(System.Random rnd, int[] values, int population, int success, int draws)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, population, success, draws);
		}

		public static int Sample(int population, int success, int draws)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, population, success, draws);
		}

		public static IEnumerable<int> Samples(int population, int success, int draws)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, population, success, draws);
		}

		public static void Samples(int[] values, int population, int success, int draws)
		{
			if (population < 0 || success < 0 || draws < 0 || success > population || draws > population)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, population, success, draws);
		}
	}
	public interface IContinuousDistribution : IUnivariateDistribution, IDistribution
	{
		double Mode { get; }

		double Minimum { get; }

		double Maximum { get; }

		double Density(double x);

		double DensityLn(double x);

		double Sample();

		void Samples(double[] values);

		IEnumerable<double> Samples();
	}
	public interface IDiscreteDistribution : IUnivariateDistribution, IDistribution
	{
		int Mode { get; }

		int Minimum { get; }

		int Maximum { get; }

		double Probability(int k);

		double ProbabilityLn(int k);

		int Sample();

		void Samples(int[] values);

		IEnumerable<int> Samples();
	}
	public interface IDistribution
	{
		System.Random RandomSource { get; set; }
	}
	public class InverseGamma : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _shape;

		private readonly double _scale;

		public double Shape => _shape;

		public double Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (_shape <= 1.0)
				{
					throw new NotSupportedException();
				}
				return _scale / (_shape - 1.0);
			}
		}

		public double Variance
		{
			get
			{
				if (_shape <= 2.0)
				{
					throw new NotSupportedException();
				}
				return _scale * _scale / ((_shape - 1.0) * (_shape - 1.0) * (_shape - 2.0));
			}
		}

		public double StdDev => _scale / (Math.Abs(_shape - 1.0) * Math.Sqrt(_shape - 2.0));

		public double Entropy => _shape + Math.Log(_scale) + SpecialFunctions.GammaLn(_shape) - (1.0 + _shape) * SpecialFunctions.DiGamma(_shape);

		public double Skewness
		{
			get
			{
				if (_shape <= 3.0)
				{
					throw new NotSupportedException();
				}
				return 4.0 * Math.Sqrt(_shape - 2.0) / (_shape - 3.0);
			}
		}

		public double Mode => _scale / (_shape + 1.0);

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public InverseGamma(double shape, double scale)
		{
			if (!IsValidParameterSet(shape, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_shape = shape;
			_scale = scale;
		}

		public InverseGamma(double shape, double scale, System.Random randomSource)
		{
			if (!IsValidParameterSet(shape, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_shape = shape;
			_scale = scale;
		}

		public override string ToString()
		{
			return $"InverseGamma( = {_shape},  = {_scale})";
		}

		public static bool IsValidParameterSet(double shape, double scale)
		{
			if (shape > 0.0)
			{
				return scale > 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			if (!(x < 0.0))
			{
				return Math.Pow(_scale, _shape) * Math.Pow(x, 0.0 - _shape - 1.0) * Math.Exp((0.0 - _scale) / x) / SpecialFunctions.Gamma(_shape);
			}
			return 0.0;
		}

		public double DensityLn(double x)
		{
			return Math.Log(Density(x));
		}

		public double CumulativeDistribution(double x)
		{
			return SpecialFunctions.GammaUpperRegularized(_shape, _scale / x);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _shape, _scale);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _shape, _scale);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _shape, _scale);
		}

		private static double SampleUnchecked(System.Random rnd, double shape, double scale)
		{
			return 1.0 / Gamma.SampleUnchecked(rnd, shape, scale);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double shape, double scale)
		{
			Gamma.SamplesUnchecked(rnd, values, shape, scale);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = 1.0 / values[i];
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double shape, double scale)
		{
			return from z in Gamma.SamplesUnchecked(rnd, shape, scale)
				select 1.0 / z;
		}

		public static double PDF(double shape, double scale, double x)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x < 0.0))
			{
				return Math.Pow(scale, shape) * Math.Pow(x, 0.0 - shape - 1.0) * Math.Exp((0.0 - scale) / x) / SpecialFunctions.Gamma(shape);
			}
			return 0.0;
		}

		public static double PDFLn(double shape, double scale, double x)
		{
			return Math.Log(PDF(shape, scale, x));
		}

		public static double CDF(double shape, double scale, double x)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.GammaUpperRegularized(shape, scale / x);
		}

		public static double Sample(System.Random rnd, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, shape, scale);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, shape, scale);
		}

		public static void Samples(System.Random rnd, double[] values, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, shape, scale);
		}

		public static double Sample(double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, shape, scale);
		}

		public static IEnumerable<double> Samples(double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, shape, scale);
		}

		public static void Samples(double[] values, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, shape, scale);
		}
	}
	public class InverseGaussian : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		public double Mu { get; }

		public double Lambda { get; }

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => Mu;

		public double Variance => Math.Pow(Mu, 3.0) / Lambda;

		public double StdDev => Math.Sqrt(Variance);

		public double Median => InvCDF(0.5);

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public double Skewness => 3.0 * Math.Sqrt(Mu / Lambda);

		public double Kurtosis => 15.0 * Mu / Lambda;

		public double Mode => Mu * (Math.Sqrt(1.0 + 9.0 * Mu * Mu / (4.0 * Lambda * Lambda)) - 3.0 * Mu / (2.0 * Lambda));

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public InverseGaussian(double mu, double lambda, System.Random randomSource = null)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			Mu = mu;
			Lambda = lambda;
		}

		public override string ToString()
		{
			return $"InverseGaussian( = {Mu},  = {Lambda})";
		}

		public static bool IsValidParameterSet(double mu, double lambda)
		{
			if (mu.IsFinite() && lambda.IsFinite() && mu > 0.0)
			{
				return lambda > 0.0;
			}
			return false;
		}

		public double Sample()
		{
			return SampleUnchecked(_random, Mu, Lambda);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, Mu, Lambda);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, Mu, Lambda);
		}

		public static double Sample(System.Random rnd, double mu, double lambda)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, mu, lambda);
		}

		public static void Samples(System.Random rnd, double[] values, double mu, double lambda)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, mu, lambda);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double mu, double lambda)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, mu, lambda);
		}

		internal static double SampleUnchecked(System.Random rnd, double mu, double lambda)
		{
			double normalSample = Normal.Sample(rnd, 0.0, 1.0);
			double uniformSample = rnd.NextDouble();
			return InverseGaussianSampleImpl(mu, lambda, normalSample, uniformSample);
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double mu, double lambda)
		{
			if (values.Length != 0)
			{
				double[] array = new double[values.Length];
				Normal.Samples(rnd, array, 0.0, 1.0);
				double[] array2 = rnd.NextDoubles(values.Length);
				for (int i = 0; i < values.Length; i++)
				{
					values[i] = InverseGaussianSampleImpl(mu, lambda, array[i], array2[i]);
				}
			}
		}

		internal static IEnumerable<double> SamplesUnchecked(System.Random rnd, double mu, double lambda)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, mu, lambda);
			}
		}

		internal static double InverseGaussianSampleImpl(double mu, double lambda, double normalSample, double uniformSample)
		{
			double num = normalSample * normalSample;
			double num2 = mu + mu * mu * num / (2.0 * lambda) - mu / (2.0 * lambda) * Math.Sqrt(4.0 * mu * lambda * num + mu * mu * num * num);
			if (uniformSample <= mu / (mu + num2))
			{
				return num2;
			}
			return mu * mu / num2;
		}

		public double Density(double x)
		{
			return DensityImpl(Mu, Lambda, x);
		}

		public double DensityLn(double x)
		{
			return DensityLnImpl(Mu, Lambda, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CumulativeDistributionImpl(Mu, Lambda, x);
		}

		public double InvCDF(double p)
		{
			if (NewtonRaphson.TryFindRoot((double x) => CumulativeDistribution(x) - p, Density, Mode, 0.0, double.PositiveInfinity, 1E-08, 100, out var root))
			{
				return root;
			}
			throw new NonConvergenceException("Numerical estimation of the statistic has failed. The used solver did not succeed in finding a root.");
		}

		public static double PDF(double mu, double lambda, double x)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DensityImpl(mu, lambda, x);
		}

		public static double PDFLn(double mu, double lambda, double x)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DensityLnImpl(mu, lambda, x);
		}

		public static double CDF(double mu, double lambda, double x)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return CumulativeDistributionImpl(mu, lambda, x);
		}

		public static double ICDF(double mu, double lambda, double p)
		{
			if (!IsValidParameterSet(mu, lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return new InverseGaussian(mu, lambda).InvCDF(p);
		}

		public static InverseGaussian Estimate(IEnumerable<double> samples, System.Random randomSource = null)
		{
			double num = samples.ToArray().Mean();
			double lambda = 1.0 / (1.0 / samples.HarmonicMean() - 1.0 / num);
			return new InverseGaussian(num, lambda, randomSource);
		}

		internal static double DensityImpl(double mu, double lambda, double x)
		{
			return Math.Sqrt(lambda / (Math.PI * 2.0 * Math.Pow(x, 3.0))) * Math.Exp(0.0 - lambda * Math.Pow(x - mu, 2.0) / (2.0 * mu * mu * x));
		}

		internal static double DensityLnImpl(double mu, double lambda, double x)
		{
			return Math.Log(Math.Sqrt(lambda / (Math.PI * 2.0 * Math.Pow(x, 3.0)))) - lambda * Math.Pow(x - mu, 2.0) / (2.0 * mu * mu * x);
		}

		internal static double CumulativeDistributionImpl(double mu, double lambda, double x)
		{
			return Normal.CDF(0.0, 1.0, Math.Sqrt(lambda / x) * (x / mu - 1.0)) + Math.Exp(2.0 * lambda / mu) * Normal.CDF(0.0, 1.0, (0.0 - Math.Sqrt(lambda / x)) * (x / mu + 1.0));
		}
	}
	public class InverseWishart : IDistribution
	{
		private System.Random _random;

		private readonly double _freedom;

		private readonly Matrix<double> _scale;

		private readonly Cholesky<double> _chol;

		public double DegreesOfFreedom => _freedom;

		public Matrix<double> Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public Matrix<double> Mean => _scale * (1.0 / (_freedom - (double)_scale.RowCount - 1.0));

		public Matrix<double> Mode => _scale * (1.0 / (_freedom + (double)_scale.RowCount + 1.0));

		public Matrix<double> Variance => Matrix<double>.Build.Dense(_scale.RowCount, _scale.ColumnCount, delegate(int i, int j)
		{
			double num = (_freedom - (double)_scale.RowCount + 1.0) * _scale.At(i, j) * _scale.At(i, j) + (_freedom - (double)_scale.RowCount - 1.0) * _scale.At(i, i) * _scale.At(j, j);
			double num2 = (_freedom - (double)_scale.RowCount) * (_freedom - (double)_scale.RowCount - 1.0) * (_freedom - (double)_scale.RowCount - 1.0) * (_freedom - (double)_scale.RowCount - 3.0);
			return num / num2;
		});

		public InverseWishart(double degreesOfFreedom, Matrix<double> scale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(degreesOfFreedom, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_freedom = degreesOfFreedom;
			_scale = scale;
			_chol = _scale.Cholesky();
		}

		public InverseWishart(double degreesOfFreedom, Matrix<double> scale, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(degreesOfFreedom, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_freedom = degreesOfFreedom;
			_scale = scale;
			_chol = _scale.Cholesky();
		}

		public override string ToString()
		{
			return $"InverseWishart( = {_freedom}, Rows = {_scale.RowCount}, Columns = {_scale.ColumnCount})";
		}

		public static bool IsValidParameterSet(double degreesOfFreedom, Matrix<double> scale)
		{
			if (scale.RowCount != scale.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < scale.RowCount; i++)
			{
				if (scale.At(i, i) <= 0.0)
				{
					return false;
				}
			}
			return degreesOfFreedom > 0.0;
		}

		public double Density(Matrix<double> x)
		{
			int rowCount = _scale.RowCount;
			if (x.RowCount != rowCount || x.ColumnCount != rowCount)
			{
				throw new ArgumentOutOfRangeException("x", "Matrix dimensions must agree.");
			}
			Cholesky<double> cholesky = x.Cholesky();
			double determinant = cholesky.Determinant;
			Matrix<double> matrix = cholesky.Solve(Scale);
			double num = Math.Pow(Math.PI, (double)rowCount * ((double)rowCount - 1.0) / 4.0);
			for (int i = 1; i <= rowCount; i++)
			{
				num *= SpecialFunctions.Gamma((_freedom + 1.0 - (double)i) / 2.0);
			}
			return Math.Pow(determinant, (0.0 - (_freedom + (double)rowCount + 1.0)) / 2.0) * Math.Exp(-0.5 * matrix.Trace()) * Math.Pow(_chol.Determinant, _freedom / 2.0) / Math.Pow(2.0, _freedom * (double)rowCount / 2.0) / num;
		}

		public Matrix<double> Sample()
		{
			return Sample(_random, _freedom, _scale);
		}

		public static Matrix<double> Sample(System.Random rnd, double degreesOfFreedom, Matrix<double> scale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(degreesOfFreedom, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Wishart.Sample(rnd, degreesOfFreedom, scale.Inverse()).PseudoInverse();
		}
	}
	public interface IUnivariateDistribution : IDistribution
	{
		double Mean { get; }

		double Variance { get; }

		double StdDev { get; }

		double Entropy { get; }

		double Skewness { get; }

		double Median { get; }

		double CumulativeDistribution(double x);
	}
	public class Laplace : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _location;

		private readonly double _scale;

		public double Location => _location;

		public double Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _location;

		public double Variance => 2.0 * _scale * _scale;

		public double StdDev => 1.4142135623730951 * _scale;

		public double Entropy => Math.Log(Math.E * 2.0 * _scale);

		public double Skewness => 0.0;

		public double Mode => _location;

		public double Median => _location;

		public double Minimum => double.NegativeInfinity;

		public double Maximum => double.PositiveInfinity;

		public Laplace()
			: this(0.0, 1.0)
		{
		}

		public Laplace(double location, double scale)
		{
			if (!IsValidParameterSet(location, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_location = location;
			_scale = scale;
		}

		public Laplace(double location, double scale, System.Random randomSource)
		{
			if (!IsValidParameterSet(location, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_location = location;
			_scale = scale;
		}

		public override string ToString()
		{
			return $"Laplace( = {_location}, b = {_scale})";
		}

		public static bool IsValidParameterSet(double location, double scale)
		{
			if (scale > 0.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		public double Density(double x)
		{
			return Math.Exp((0.0 - Math.Abs(x - _location)) / _scale) / (2.0 * _scale);
		}

		public double DensityLn(double x)
		{
			return (0.0 - Math.Abs(x - _location)) / _scale - Math.Log(2.0 * _scale);
		}

		public double CumulativeDistribution(double x)
		{
			return 0.5 * (1.0 + (double)Math.Sign(x - _location) * (1.0 - Math.Exp((0.0 - Math.Abs(x - _location)) / _scale)));
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _location, _scale);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _location, _scale);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _location, _scale);
		}

		private static double SampleUnchecked(System.Random rnd, double location, double scale)
		{
			double value = rnd.NextDouble() - 0.5;
			return location - scale * (double)Math.Sign(value) * Math.Log(1.0 - 2.0 * Math.Abs(value));
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double location, double scale)
		{
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					double value = values[i] - 0.5;
					values[i] = location - scale * (double)Math.Sign(value) * Math.Log(1.0 - 2.0 * Math.Abs(value));
				}
			});
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double location, double scale)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, location, scale);
			}
		}

		public static double PDF(double location, double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Exp((0.0 - Math.Abs(x - location)) / scale) / (2.0 * scale);
		}

		public static double PDFLn(double location, double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return (0.0 - Math.Abs(x - location)) / scale - Math.Log(2.0 * scale);
		}

		public static double CDF(double location, double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 0.5 * (1.0 + (double)Math.Sign(x - location) * (1.0 - Math.Exp((0.0 - Math.Abs(x - location)) / scale)));
		}

		public static double Sample(System.Random rnd, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, location, scale);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, location, scale);
		}

		public static void Samples(System.Random rnd, double[] values, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, location, scale);
		}

		public static double Sample(double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, location, scale);
		}

		public static IEnumerable<double> Samples(double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, location, scale);
		}

		public static void Samples(double[] values, double location, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, location, scale);
		}
	}
	public class LogNormal : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _mu;

		private readonly double _sigma;

		public double Mu => _mu;

		public double Sigma => _sigma;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => Math.Exp(_mu + _sigma * _sigma / 2.0);

		public double Variance
		{
			get
			{
				double num = _sigma * _sigma;
				return (Math.Exp(num) - 1.0) * Math.Exp(_mu + _mu + num);
			}
		}

		public double StdDev
		{
			get
			{
				double num = _sigma * _sigma;
				return Math.Sqrt((Math.Exp(num) - 1.0) * Math.Exp(_mu + _mu + num));
			}
		}

		public double Entropy => 0.5 + Math.Log(_sigma) + _mu + 0.9189385332046728;

		public double Skewness
		{
			get
			{
				double num = Math.Exp(_sigma * _sigma);
				return (num + 2.0) * Math.Sqrt(num - 1.0);
			}
		}

		public double Mode => Math.Exp(_mu - _sigma * _sigma);

		public double Median => Math.Exp(_mu);

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public LogNormal(double mu, double sigma)
		{
			if (!IsValidParameterSet(mu, sigma))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_mu = mu;
			_sigma = sigma;
		}

		public LogNormal(double mu, double sigma, System.Random randomSource)
		{
			if (!IsValidParameterSet(mu, sigma))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_mu = mu;
			_sigma = sigma;
		}

		public static LogNormal WithMuSigma(double mu, double sigma, System.Random randomSource = null)
		{
			return new LogNormal(mu, sigma, randomSource);
		}

		public static LogNormal WithMeanVariance(double mean, double var, System.Random randomSource = null)
		{
			double num = Math.Log(var / (mean * mean) + 1.0);
			return new LogNormal(Math.Log(mean) - num / 2.0, Math.Sqrt(num), randomSource);
		}

		public static LogNormal Estimate(IEnumerable<double> samples, System.Random randomSource = null)
		{
			Tuple<double, double> tuple = samples.Select((double s) => Math.Log(s)).MeanStandardDeviation();
			return new LogNormal(tuple.Item1, tuple.Item2, randomSource);
		}

		public override string ToString()
		{
			return $"LogNormal( = {_mu},  = {_sigma})";
		}

		public static bool IsValidParameterSet(double mu, double sigma)
		{
			if (sigma >= 0.0)
			{
				return !double.IsNaN(mu);
			}
			return false;
		}

		public double Density(double x)
		{
			if (x < 0.0)
			{
				return 0.0;
			}
			double num = (Math.Log(x) - _mu) / _sigma;
			return Math.Exp(-0.5 * num * num) / (x * _sigma * 2.5066282746310007);
		}

		public double DensityLn(double x)
		{
			if (x < 0.0)
			{
				return double.NegativeInfinity;
			}
			double num = (Math.Log(x) - _mu) / _sigma;
			return -0.5 * num * num - Math.Log(x * _sigma) - 0.9189385332046728;
		}

		public double CumulativeDistribution(double x)
		{
			if (!(x < 0.0))
			{
				return 0.5 * SpecialFunctions.Erfc((_mu - Math.Log(x)) / (_sigma * 1.4142135623730951));
			}
			return 0.0;
		}

		public double InverseCumulativeDistribution(double p)
		{
			if (!(p <= 0.0))
			{
				if (!(p >= 1.0))
				{
					return Math.Exp(_mu - _sigma * 1.4142135623730951 * SpecialFunctions.ErfcInv(2.0 * p));
				}
				return double.PositiveInfinity;
			}
			return 0.0;
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _mu, _sigma);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _mu, _sigma);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _mu, _sigma);
		}

		private static double SampleUnchecked(System.Random rnd, double mu, double sigma)
		{
			return Math.Exp(Normal.SampleUnchecked(rnd, mu, sigma));
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double mu, double sigma)
		{
			return Normal.SamplesUnchecked(rnd, mu, sigma).Select(Math.Exp);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double mu, double sigma)
		{
			Normal.SamplesUnchecked(rnd, values, mu, sigma);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = Math.Exp(values[i]);
				}
			});
		}

		public static double PDF(double mu, double sigma, double x)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return 0.0;
			}
			double num = (Math.Log(x) - mu) / sigma;
			return Math.Exp(-0.5 * num * num) / (x * sigma * 2.5066282746310007);
		}

		public static double PDFLn(double mu, double sigma, double x)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return double.NegativeInfinity;
			}
			double num = (Math.Log(x) - mu) / sigma;
			return -0.5 * num * num - Math.Log(x * sigma) - 0.9189385332046728;
		}

		public static double CDF(double mu, double sigma, double x)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(x < 0.0))
			{
				return 0.5 * (1.0 + SpecialFunctions.Erf((Math.Log(x) - mu) / (sigma * 1.4142135623730951)));
			}
			return 0.0;
		}

		public static double InvCDF(double mu, double sigma, double p)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (!(p <= 0.0))
			{
				if (!(p >= 1.0))
				{
					return Math.Exp(mu - sigma * 1.4142135623730951 * SpecialFunctions.ErfcInv(2.0 * p));
				}
				return double.PositiveInfinity;
			}
			return 0.0;
		}

		public static double Sample(System.Random rnd, double mu, double sigma)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, mu, sigma);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double mu, double sigma)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, mu, sigma);
		}

		public static void Samples(System.Random rnd, double[] values, double mu, double sigma)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, mu, sigma);
		}

		public static double Sample(double mu, double sigma)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, mu, sigma);
		}

		public static IEnumerable<double> Samples(double mu, double sigma)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, mu, sigma);
		}

		public static void Samples(double[] values, double mu, double sigma)
		{
			if (sigma < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, mu, sigma);
		}
	}
	public class MatrixNormal : IDistribution
	{
		private System.Random _random;

		private readonly Matrix<double> _m;

		private readonly Matrix<double> _v;

		private readonly Matrix<double> _k;

		public Matrix<double> Mean => _m;

		public Matrix<double> RowCovariance => _v;

		public Matrix<double> ColumnCovariance => _k;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public MatrixNormal(Matrix<double> m, Matrix<double> v, Matrix<double> k)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(m, v, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_m = m;
			_v = v;
			_k = k;
		}

		public MatrixNormal(Matrix<double> m, Matrix<double> v, Matrix<double> k, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(m, v, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_m = m;
			_v = v;
			_k = k;
		}

		public override string ToString()
		{
			return $"MatrixNormal(Rows = {_m.RowCount}, Columns = {_m.ColumnCount})";
		}

		public static bool IsValidParameterSet(Matrix<double> m, Matrix<double> v, Matrix<double> k)
		{
			int rowCount = m.RowCount;
			int columnCount = m.ColumnCount;
			if (v.ColumnCount != rowCount || v.RowCount != rowCount)
			{
				return false;
			}
			if (k.ColumnCount != columnCount || k.RowCount != columnCount)
			{
				return false;
			}
			for (int i = 0; i < v.RowCount; i++)
			{
				if (v.At(i, i) <= 0.0)
				{
					return false;
				}
			}
			for (int j = 0; j < k.RowCount; j++)
			{
				if (k.At(j, j) <= 0.0)
				{
					return false;
				}
			}
			return true;
		}

		public double Density(Matrix<double> x)
		{
			if (x.RowCount != _m.RowCount || x.ColumnCount != _m.ColumnCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(x, _m, "x");
			}
			Matrix<double> matrix = x - _m;
			Cholesky<double> cholesky = _v.Cholesky();
			Cholesky<double> cholesky2 = _k.Cholesky();
			return Math.Exp(-0.5 * cholesky2.Solve(matrix.Transpose() * cholesky.Solve(matrix)).Trace()) / Math.Pow(Math.PI * 2.0, (double)(x.RowCount * x.ColumnCount) / 2.0) / Math.Pow(cholesky2.Determinant, (double)x.RowCount / 2.0) / Math.Pow(cholesky.Determinant, (double)x.ColumnCount / 2.0);
		}

		public Matrix<double> Sample()
		{
			return Sample(_random, _m, _v, _k);
		}

		public static Matrix<double> Sample(System.Random rnd, Matrix<double> m, Matrix<double> v, Matrix<double> k)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(m, v, k))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			int rowCount = m.RowCount;
			int columnCount = m.ColumnCount;
			Matrix<double> covariance = v.KroneckerProduct(k.Inverse());
			Vector<double> vector = SampleVectorNormal(rnd, new MathNet.Numerics.LinearAlgebra.Double.DenseVector(rowCount * columnCount), covariance);
			Matrix<double> matrix = m.Clone();
			for (int i = 0; i < rowCount; i++)
			{
				for (int j = 0; j < columnCount; j++)
				{
					matrix.At(i, j, matrix.At(i, j) + vector[j * rowCount + i]);
				}
			}
			return matrix;
		}

		private static Vector<double> SampleVectorNormal(System.Random rnd, Vector<double> mean, Matrix<double> covariance)
		{
			Cholesky<double> cholesky = covariance.Cholesky();
			Vector<double> vector = Vector<double>.Build.Random(mean.Count, new Normal(rnd));
			return mean + cholesky.Factor * vector;
		}
	}
	public class Multinomial : IDistribution
	{
		private System.Random _random;

		private readonly double[] _p;

		private readonly int _trials;

		public double[] P => (double[])_p.Clone();

		public int N => _trials;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public Vector<double> Mean => (double)_trials * (MathNet.Numerics.LinearAlgebra.Double.DenseVector)P;

		public Vector<double> Variance
		{
			get
			{
				MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector = P;
				for (int i = 0; i < denseVector.Count; i++)
				{
					denseVector[i] *= (double)_trials * (1.0 - denseVector[i]);
				}
				return denseVector;
			}
		}

		public Vector<double> Skewness
		{
			get
			{
				MathNet.Numerics.LinearAlgebra.Double.DenseVector denseVector = P;
				for (int i = 0; i < denseVector.Count; i++)
				{
					denseVector[i] = (1.0 - 2.0 * denseVector[i]) / Math.Sqrt((double)_trials * (1.0 - denseVector[i]) * denseVector[i]);
				}
				return denseVector;
			}
		}

		public Multinomial(double[] p, int n)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(p, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_p = (double[])p.Clone();
			_trials = n;
		}

		public Multinomial(double[] p, int n, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(p, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_p = (double[])p.Clone();
			_trials = n;
		}

		public Multinomial(Histogram h, int n)
		{
			if (h == null)
			{
				throw new ArgumentNullException("h");
			}
			double[] array = new double[h.BucketCount];
			for (int i = 0; i < h.BucketCount; i++)
			{
				array[i] = h[i].Count;
			}
			if (Control.CheckDistributionParameters && !IsValidParameterSet(array, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_p = (double[])array.Clone();
			_trials = n;
			RandomSource = SystemRandomSource.Default;
		}

		public override string ToString()
		{
			return $"Multinomial(Dimension = {_p.Length}, Number of Trails = {_trials})";
		}

		public static bool IsValidParameterSet(IEnumerable<double> p, int n)
		{
			double num = 0.0;
			foreach (double item in p)
			{
				if (item < 0.0 || double.IsNaN(item))
				{
					return false;
				}
				num += item;
			}
			if (num == 0.0)
			{
				return false;
			}
			return n >= 0;
		}

		public double Probability(int[] x)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != _p.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "x");
			}
			if (x.Sum() == _trials)
			{
				double num = SpecialFunctions.Multinomial(_trials, x);
				double num2 = 1.0;
				for (int i = 0; i < x.Length; i++)
				{
					num2 *= Math.Pow(_p[i], x[i]);
				}
				return num * num2;
			}
			return 0.0;
		}

		public double ProbabilityLn(int[] x)
		{
			if (x == null)
			{
				throw new ArgumentNullException("x");
			}
			if (x.Length != _p.Length)
			{
				throw new ArgumentException("All vectors must have the same dimensionality.", "x");
			}
			if (x.Sum() == _trials)
			{
				double num = Math.Log(SpecialFunctions.Multinomial(_trials, x));
				double num2 = x.Select((int t, int i) => (double)t * Math.Log(_p[i])).Sum();
				return num + num2;
			}
			return 0.0;
		}

		public int[] Sample()
		{
			return Sample(_random, _p, _trials);
		}

		public IEnumerable<int[]> Samples()
		{
			while (true)
			{
				yield return Sample(_random, _p, _trials);
			}
		}

		public static int[] Sample(System.Random rnd, double[] p, int n)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(p, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cdfUnnormalized = Categorical.ProbabilityMassToCumulativeDistribution(p);
			int[] array = new int[p.Length];
			for (int i = 0; i < n; i++)
			{
				array[Categorical.SampleUnchecked(rnd, cdfUnnormalized)]++;
			}
			return array;
		}

		public static IEnumerable<int[]> Samples(System.Random rnd, double[] p, int n)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(p, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double[] cp = Categorical.ProbabilityMassToCumulativeDistribution(p);
			while (true)
			{
				int[] array = new int[p.Length];
				for (int i = 0; i < n; i++)
				{
					array[Categorical.SampleUnchecked(rnd, cp)]++;
				}
				yield return array;
			}
		}
	}
	public class NegativeBinomial : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _r;

		private readonly double _p;

		public double R => _r;

		public double P => _p;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _r * (1.0 - _p) / _p;

		public double Variance => _r * (1.0 - _p) / (_p * _p);

		public double StdDev => Math.Sqrt(_r * (1.0 - _p)) / _p;

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness => (2.0 - _p) / Math.Sqrt(_r * (1.0 - _p));

		public int Mode
		{
			get
			{
				if (!(_r > 1.0))
				{
					return 0;
				}
				return (int)Math.Floor((_r - 1.0) * (1.0 - _p) / _p);
			}
		}

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Minimum => 0;

		public int Maximum => int.MaxValue;

		public NegativeBinomial(double r, double p)
		{
			if (!IsValidParameterSet(r, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_p = p;
			_r = r;
		}

		public NegativeBinomial(double r, double p, System.Random randomSource)
		{
			if (!IsValidParameterSet(r, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_p = p;
			_r = r;
		}

		public override string ToString()
		{
			return $"NegativeBinomial(R = {_r}, P = {_p})";
		}

		public static bool IsValidParameterSet(double r, double p)
		{
			if (r >= 0.0 && p >= 0.0)
			{
				return p <= 1.0;
			}
			return false;
		}

		public double Probability(int k)
		{
			return PMF(_r, _p, k);
		}

		public double ProbabilityLn(int k)
		{
			return PMFLn(_r, _p, k);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_r, _p, x);
		}

		public static double PMF(double r, double p, int k)
		{
			return Math.Exp(PMFLn(r, p, k));
		}

		public static double PMFLn(double r, double p, int k)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SpecialFunctions.GammaLn(r + (double)k) - SpecialFunctions.GammaLn(r) - SpecialFunctions.GammaLn((double)k + 1.0) + r * Math.Log(p) + (double)k * Math.Log(1.0 - p);
		}

		public static double CDF(double r, double p, double x)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 - SpecialFunctions.BetaRegularized(x + 1.0, r, 1.0 - p);
		}

		private static int SampleUnchecked(System.Random rnd, double r, double p)
		{
			double num = Math.Exp(0.0 - Gamma.SampleUnchecked(rnd, r, p));
			double num2 = 1.0;
			int num3 = 0;
			do
			{
				num3++;
				num2 *= rnd.NextDouble();
			}
			while (num2 >= num);
			return num3 - 1;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double r, double p)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, r, p);
			}
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double r, double p)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, r, p);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _r, _p);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _r, _p);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _r, _p);
		}

		public static int Sample(System.Random rnd, double r, double p)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, r, p);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double r, double p)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, r, p);
		}

		public static void Samples(System.Random rnd, int[] values, double r, double p)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, r, p);
		}

		public static int Sample(double r, double p)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, r, p);
		}

		public static IEnumerable<int> Samples(double r, double p)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, r, p);
		}

		public static void Samples(int[] values, double r, double p)
		{
			if (!(r >= 0.0) || !(p >= 0.0) || !(p <= 1.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, r, p);
		}
	}
	public class Normal : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _mean;

		private readonly double _stdDev;

		public double Mean => _mean;

		public double StdDev => _stdDev;

		public double Variance => _stdDev * _stdDev;

		public double Precision => 1.0 / (_stdDev * _stdDev);

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Entropy => Math.Log(_stdDev) + 1.4189385332046727;

		public double Skewness => 0.0;

		public double Mode => _mean;

		public double Median => _mean;

		public double Minimum => double.NegativeInfinity;

		public double Maximum => double.PositiveInfinity;

		public Normal()
			: this(0.0, 1.0)
		{
		}

		public Normal(System.Random randomSource)
			: this(0.0, 1.0, randomSource)
		{
		}

		public Normal(double mean, double stddev)
		{
			if (!IsValidParameterSet(mean, stddev))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_mean = mean;
			_stdDev = stddev;
		}

		public Normal(double mean, double stddev, System.Random randomSource)
		{
			if (!IsValidParameterSet(mean, stddev))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_mean = mean;
			_stdDev = stddev;
		}

		public static Normal WithMeanStdDev(double mean, double stddev, System.Random randomSource = null)
		{
			return new Normal(mean, stddev, randomSource);
		}

		public static Normal WithMeanVariance(double mean, double var, System.Random randomSource = null)
		{
			return new Normal(mean, Math.Sqrt(var), randomSource);
		}

		public static Normal WithMeanPrecision(double mean, double precision, System.Random randomSource = null)
		{
			return new Normal(mean, 1.0 / Math.Sqrt(precision), randomSource);
		}

		public static Normal Estimate(IEnumerable<double> samples, System.Random randomSource = null)
		{
			Tuple<double, double> tuple = samples.MeanStandardDeviation();
			return new Normal(tuple.Item1, tuple.Item2, randomSource);
		}

		public override string ToString()
		{
			return $"Normal( = {_mean},  = {_stdDev})";
		}

		public static bool IsValidParameterSet(double mean, double stddev)
		{
			if (stddev >= 0.0)
			{
				return !double.IsNaN(mean);
			}
			return false;
		}

		public double Density(double x)
		{
			double num = (x - _mean) / _stdDev;
			return Math.Exp(-0.5 * num * num) / (2.5066282746310007 * _stdDev);
		}

		public double DensityLn(double x)
		{
			double num = (x - _mean) / _stdDev;
			return -0.5 * num * num - Math.Log(_stdDev) - 0.9189385332046728;
		}

		public double CumulativeDistribution(double x)
		{
			return 0.5 * SpecialFunctions.Erfc((_mean - x) / (_stdDev * 1.4142135623730951));
		}

		public double InverseCumulativeDistribution(double p)
		{
			return _mean - _stdDev * 1.4142135623730951 * SpecialFunctions.ErfcInv(2.0 * p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _mean, _stdDev);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _mean, _stdDev);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _mean, _stdDev);
		}

		internal static double SampleUnchecked(System.Random rnd, double mean, double stddev)
		{
			double x;
			double y;
			while (!PolarTransform(rnd.NextDouble(), rnd.NextDouble(), out x, out y))
			{
			}
			return mean + stddev * x;
		}

		internal static IEnumerable<double> SamplesUnchecked(System.Random rnd, double mean, double stddev)
		{
			while (true)
			{
				if (PolarTransform(rnd.NextDouble(), rnd.NextDouble(), out var x, out var y))
				{
					yield return mean + stddev * x;
					yield return mean + stddev * y;
				}
			}
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double mean, double stddev)
		{
			if (values.Length == 0)
			{
				return;
			}
			int num = (int)Math.Ceiling((double)(values.Length * 4) * (1.0 / Math.PI));
			if (num.IsOdd())
			{
				num++;
			}
			double[] array = rnd.NextDoubles(num);
			int num2 = 0;
			double x;
			double y;
			for (int i = 0; i < array.Length; i += 2)
			{
				if (num2 >= values.Length)
				{
					break;
				}
				if (PolarTransform(array[i], array[i + 1], out x, out y))
				{
					values[num2++] = mean + stddev * x;
					if (num2 == values.Length)
					{
						return;
					}
					values[num2++] = mean + stddev * y;
					if (num2 == values.Length)
					{
						return;
					}
				}
			}
			while (num2 < values.Length)
			{
				if (PolarTransform(rnd.NextDouble(), rnd.NextDouble(), out x, out y))
				{
					values[num2++] = mean + stddev * x;
					if (num2 == values.Length)
					{
						break;
					}
					values[num2++] = mean + stddev * y;
					if (num2 == values.Length)
					{
						break;
					}
				}
			}
		}

		private static bool PolarTransform(double a, double b, out double x, out double y)
		{
			double num = 2.0 * a - 1.0;
			double num2 = 2.0 * b - 1.0;
			double num3 = num * num + num2 * num2;
			if (num3 >= 1.0 || num3 == 0.0)
			{
				x = 0.0;
				y = 0.0;
				return false;
			}
			double num4 = Math.Sqrt(-2.0 * Math.Log(num3) / num3);
			x = num * num4;
			y = num2 * num4;
			return true;
		}

		public static double PDF(double mean, double stddev, double x)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double num = (x - mean) / stddev;
			return Math.Exp(-0.5 * num * num) / (2.5066282746310007 * stddev);
		}

		public static double PDFLn(double mean, double stddev, double x)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			double num = (x - mean) / stddev;
			return -0.5 * num * num - Math.Log(stddev) - 0.9189385332046728;
		}

		public static double CDF(double mean, double stddev, double x)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 0.5 * SpecialFunctions.Erfc((mean - x) / (stddev * 1.4142135623730951));
		}

		public static double InvCDF(double mean, double stddev, double p)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return mean - stddev * 1.4142135623730951 * SpecialFunctions.ErfcInv(2.0 * p);
		}

		public static double Sample(System.Random rnd, double mean, double stddev)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, mean, stddev);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double mean, double stddev)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, mean, stddev);
		}

		public static void Samples(System.Random rnd, double[] values, double mean, double stddev)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, mean, stddev);
		}

		public static double Sample(double mean, double stddev)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, mean, stddev);
		}

		public static IEnumerable<double> Samples(double mean, double stddev)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, mean, stddev);
		}

		public static void Samples(double[] values, double mean, double stddev)
		{
			if (stddev < 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, mean, stddev);
		}
	}
	public struct MeanPrecisionPair
	{
		public double Mean { get; set; }

		public double Precision { get; set; }

		public MeanPrecisionPair(double m, double p)
		{
			Mean = m;
			Precision = p;
		}
	}
	public class NormalGamma : IDistribution
	{
		private System.Random _random;

		private readonly double _meanLocation;

		private readonly double _meanScale;

		private readonly double _precisionShape;

		private readonly double _precisionInvScale;

		public double MeanLocation => _meanLocation;

		public double MeanScale => _meanScale;

		public double PrecisionShape => _precisionShape;

		public double PrecisionInverseScale => _precisionInvScale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public MeanPrecisionPair Mean
		{
			get
			{
				if (!double.IsPositiveInfinity(_precisionInvScale))
				{
					return new MeanPrecisionPair(_meanLocation, _precisionShape / _precisionInvScale);
				}
				return new MeanPrecisionPair(_meanLocation, _precisionShape);
			}
		}

		public MeanPrecisionPair Variance => new MeanPrecisionPair(_precisionInvScale / (_meanScale * (_precisionShape - 1.0)), _precisionShape / Math.Sqrt(_precisionInvScale));

		public NormalGamma(double meanLocation, double meanScale, double precisionShape, double precisionInverseScale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(meanLocation, meanScale, precisionShape, precisionInverseScale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_meanLocation = meanLocation;
			_meanScale = meanScale;
			_precisionShape = precisionShape;
			_precisionInvScale = precisionInverseScale;
		}

		public NormalGamma(double meanLocation, double meanScale, double precisionShape, double precisionInverseScale, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(meanLocation, meanScale, precisionShape, precisionInverseScale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_meanLocation = meanLocation;
			_meanScale = meanScale;
			_precisionShape = precisionShape;
			_precisionInvScale = precisionInverseScale;
		}

		public override string ToString()
		{
			return $"NormalGamma(Mean Location = {_meanLocation}, Mean Scale = {_meanScale}, Precision Shape = {_precisionShape}, Precision Inverse Scale = {_precisionInvScale})";
		}

		public static bool IsValidParameterSet(double meanLocation, double meanScale, double precShape, double precInvScale)
		{
			if (meanScale > 0.0 && precShape > 0.0 && precInvScale > 0.0)
			{
				return !double.IsNaN(meanLocation);
			}
			return false;
		}

		public StudentT MeanMarginal()
		{
			if (double.IsPositiveInfinity(_precisionInvScale))
			{
				return new StudentT(_meanLocation, 1.0 / (_meanScale * _precisionShape), double.PositiveInfinity);
			}
			return new StudentT(_meanLocation, Math.Sqrt(_precisionInvScale / (_meanScale * _precisionShape)), 2.0 * _precisionShape);
		}

		public Gamma PrecisionMarginal()
		{
			return new Gamma(_precisionShape, _precisionInvScale);
		}

		public double Density(MeanPrecisionPair mp)
		{
			return Density(mp.Mean, mp.Precision);
		}

		public double Density(double mean, double prec)
		{
			if (double.IsPositiveInfinity(_precisionInvScale) && _meanScale == 0.0)
			{
				throw new NotSupportedException();
			}
			if (double.IsPositiveInfinity(_precisionInvScale))
			{
				throw new NotSupportedException();
			}
			if (_meanScale <= 0.0)
			{
				throw new NotSupportedException();
			}
			if (_precisionShape > 160.0)
			{
				return Math.Exp(DensityLn(mean, prec));
			}
			double d = 0.0 - 0.5 * prec * _meanScale * (mean - _meanLocation) * (mean - _meanLocation) - prec * _precisionInvScale;
			return Math.Pow(prec * _precisionInvScale, _precisionShape) * Math.Exp(d) * Math.Sqrt(_meanScale) / (2.5066282746310007 * Math.Sqrt(prec) * SpecialFunctions.Gamma(_precisionShape));
		}

		public double DensityLn(MeanPrecisionPair mp)
		{
			return DensityLn(mp.Mean, mp.Precision);
		}

		public double DensityLn(double mean, double prec)
		{
			if (double.IsPositiveInfinity(_precisionInvScale) && _meanScale == 0.0)
			{
				throw new NotSupportedException();
			}
			if (double.IsPositiveInfinity(_precisionInvScale))
			{
				throw new NotSupportedException();
			}
			if (_meanScale <= 0.0)
			{
				throw new NotSupportedException();
			}
			double num = 0.0 - 0.5 * prec * _meanScale * (mean - _meanLocation) * (mean - _meanLocation) - prec * _precisionInvScale;
			return (_precisionShape - 0.5) * Math.Log(prec) + _precisionShape * Math.Log(_precisionInvScale) - 0.5 * Math.Log(_meanScale) + num - 0.9189385332046728 - SpecialFunctions.GammaLn(_precisionShape);
		}

		public MeanPrecisionPair Sample()
		{
			return Sample(_random, _meanLocation, _meanScale, _precisionShape, _precisionInvScale);
		}

		public IEnumerable<MeanPrecisionPair> Samples()
		{
			while (true)
			{
				yield return Sample(_random, _meanLocation, _meanScale, _precisionShape, _precisionInvScale);
			}
		}

		public static MeanPrecisionPair Sample(System.Random rnd, double meanLocation, double meanScale, double precisionShape, double precisionInverseScale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(meanLocation, meanScale, precisionShape, precisionInverseScale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			MeanPrecisionPair result = default(MeanPrecisionPair);
			result.Precision = (double.IsPositiveInfinity(precisionInverseScale) ? precisionShape : Gamma.Sample(rnd, precisionShape, precisionInverseScale));
			result.Mean = ((meanScale == 0.0) ? meanLocation : Normal.Sample(rnd, meanLocation, Math.Sqrt(1.0 / (meanScale * result.Precision))));
			return result;
		}

		public static IEnumerable<MeanPrecisionPair> Samples(System.Random rnd, double meanLocation, double meanScale, double precisionShape, double precisionInvScale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(meanLocation, meanScale, precisionShape, precisionInvScale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			while (true)
			{
				MeanPrecisionPair meanPrecisionPair = default(MeanPrecisionPair);
				meanPrecisionPair.Precision = (double.IsPositiveInfinity(precisionInvScale) ? precisionShape : Gamma.Sample(rnd, precisionShape, precisionInvScale));
				meanPrecisionPair.Mean = ((meanScale == 0.0) ? meanLocation : Normal.Sample(rnd, meanLocation, Math.Sqrt(1.0 / (meanScale * meanPrecisionPair.Precision))));
				yield return meanPrecisionPair;
			}
		}
	}
	public class Pareto : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _scale;

		private readonly double _shape;

		public double Scale => _scale;

		public double Shape => _shape;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (_shape <= 1.0)
				{
					throw new NotSupportedException();
				}
				return _shape * _scale / (_shape - 1.0);
			}
		}

		public double Variance
		{
			get
			{
				if (_shape <= 2.0)
				{
					return double.PositiveInfinity;
				}
				return _scale * _scale * _shape / ((_shape - 1.0) * (_shape - 1.0) * (_shape - 2.0));
			}
		}

		public double StdDev => _scale * Math.Sqrt(_shape) / (Math.Abs(_shape - 1.0) * Math.Sqrt(_shape - 2.0));

		public double Entropy => Math.Log(_shape / _scale) - 1.0 / _shape - 1.0;

		public double Skewness => 2.0 * (_shape + 1.0) / (_shape - 3.0) * Math.Sqrt((_shape - 2.0) / _shape);

		public double Mode => _scale;

		public double Median => _scale * Math.Pow(2.0, 1.0 / _shape);

		public double Minimum => _scale;

		public double Maximum => double.PositiveInfinity;

		public Pareto(double scale, double shape)
		{
			if (!IsValidParameterSet(scale, shape))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_scale = scale;
			_shape = shape;
		}

		public Pareto(double scale, double shape, System.Random randomSource)
		{
			if (!IsValidParameterSet(scale, shape))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_scale = scale;
			_shape = shape;
		}

		public override string ToString()
		{
			return $"Pareto(xm = {_scale},  = {_shape})";
		}

		public static bool IsValidParameterSet(double scale, double shape)
		{
			if (scale > 0.0)
			{
				return shape > 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			return _shape * Math.Pow(_scale, _shape) / Math.Pow(x, _shape + 1.0);
		}

		public double DensityLn(double x)
		{
			return Math.Log(_shape) + _shape * Math.Log(_scale) - (_shape + 1.0) * Math.Log(x);
		}

		public double CumulativeDistribution(double x)
		{
			return 1.0 - Math.Pow(_scale / x, _shape);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return _scale * Math.Pow(1.0 - p, -1.0 / _shape);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _scale, _shape);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _scale, _shape);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _scale, _shape);
		}

		private static double SampleUnchecked(System.Random rnd, double scale, double shape)
		{
			return scale * Math.Pow(rnd.NextDouble(), -1.0 / shape);
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double scale, double shape)
		{
			double power = -1.0 / shape;
			return from x in rnd.NextDoubleSequence()
				select scale * Math.Pow(x, power);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double scale, double shape)
		{
			double power = -1.0 / shape;
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = scale * Math.Pow(values[i], power);
				}
			});
		}

		public static double PDF(double scale, double shape, double x)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return shape * Math.Pow(scale, shape) / Math.Pow(x, shape + 1.0);
		}

		public static double PDFLn(double scale, double shape, double x)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Log(shape) + shape * Math.Log(scale) - (shape + 1.0) * Math.Log(x);
		}

		public static double CDF(double scale, double shape, double x)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 - Math.Pow(scale / x, shape);
		}

		public static double InvCDF(double scale, double shape, double p)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return scale * Math.Pow(1.0 - p, -1.0 / shape);
		}

		public static double Sample(System.Random rnd, double scale, double shape)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return scale * Math.Pow(rnd.NextDouble(), -1.0 / shape);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double scale, double shape)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, scale, shape);
		}

		public static void Samples(System.Random rnd, double[] values, double scale, double shape)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, scale, shape);
		}

		public static double Sample(double scale, double shape)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, scale, shape);
		}

		public static IEnumerable<double> Samples(double scale, double shape)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, scale, shape);
		}

		public static void Samples(double[] values, double scale, double shape)
		{
			if (scale <= 0.0 || shape <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, scale, shape);
		}
	}
	public class Poisson : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _lambda;

		public double Lambda => _lambda;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _lambda;

		public double Variance => _lambda;

		public double StdDev => Math.Sqrt(_lambda);

		public double Entropy => 0.5 * Math.Log(17.079468445347132 * _lambda) - 1.0 / (12.0 * _lambda) - 1.0 / (24.0 * _lambda * _lambda) - 19.0 / (360.0 * _lambda * _lambda * _lambda);

		public double Skewness => 1.0 / Math.Sqrt(_lambda);

		public int Minimum => 0;

		public int Maximum => int.MaxValue;

		public int Mode => (int)Math.Floor(_lambda);

		public double Median => Math.Floor(_lambda + 1.0 / 3.0 - 0.02 / _lambda);

		public Poisson(double lambda)
		{
			if (!IsValidParameterSet(lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_lambda = lambda;
		}

		public Poisson(double lambda, System.Random randomSource)
		{
			if (!IsValidParameterSet(lambda))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_lambda = lambda;
		}

		public override string ToString()
		{
			return $"Poisson( = {_lambda})";
		}

		public static bool IsValidParameterSet(double lambda)
		{
			return lambda > 0.0;
		}

		public double Probability(int k)
		{
			return Math.Exp(0.0 - _lambda + (double)k * Math.Log(_lambda) - SpecialFunctions.FactorialLn(k));
		}

		public double ProbabilityLn(int k)
		{
			return 0.0 - _lambda + (double)k * Math.Log(_lambda) - SpecialFunctions.FactorialLn(k);
		}

		public double CumulativeDistribution(double x)
		{
			return 1.0 - SpecialFunctions.GammaLowerRegularized(x + 1.0, _lambda);
		}

		public static double PMF(double lambda, int k)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Exp(0.0 - lambda + (double)k * Math.Log(lambda) - SpecialFunctions.FactorialLn(k));
		}

		public static double PMFLn(double lambda, int k)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 0.0 - lambda + (double)k * Math.Log(lambda) - SpecialFunctions.FactorialLn(k);
		}

		public static double CDF(double lambda, double x)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 - SpecialFunctions.GammaLowerRegularized(x + 1.0, lambda);
		}

		private static int SampleUnchecked(System.Random rnd, double lambda)
		{
			if (!(lambda < 30.0))
			{
				return DoSampleLarge(rnd, lambda);
			}
			return DoSampleShort(rnd, lambda);
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double lambda)
		{
			if (lambda < 30.0)
			{
				double num = Math.Exp(0.0 - lambda);
				for (int i = 0; i < values.Length; i++)
				{
					int num2 = 0;
					for (double num3 = rnd.NextDouble(); num3 >= num; num3 *= rnd.NextDouble())
					{
						num2++;
					}
					values[i] = num2;
				}
				return;
			}
			double d = 0.767 - 3.36 / lambda;
			double num4 = Math.PI / Math.Sqrt(3.0 * lambda);
			double num5 = num4 * lambda;
			double num6 = Math.Log(d) - lambda - Math.Log(num4);
			for (int j = 0; j < values.Length; j++)
			{
				int num9;
				while (true)
				{
					double num7 = rnd.NextDouble();
					double num8 = (num5 - Math.Log((1.0 - num7) / num7)) / num4;
					num9 = (int)Math.Floor(num8 + 0.5);
					if (num9 >= 0)
					{
						double num10 = rnd.NextDouble();
						double num11 = num5 - num4 * num8;
						double num12 = 1.0 + Math.Exp(num11);
						double num13 = num11 + Math.Log(num10 / (num12 * num12));
						double num14 = num6 + (double)num9 * Math.Log(lambda) - SpecialFunctions.FactorialLn(num9);
						if (num13 <= num14)
						{
							break;
						}
					}
				}
				values[j] = num9;
			}
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double lambda)
		{
			if (lambda < 30.0)
			{
				while (true)
				{
					yield return DoSampleShort(rnd, lambda);
				}
			}
			while (true)
			{
				yield return DoSampleLarge(rnd, lambda);
			}
		}

		private static int DoSampleShort(System.Random rnd, double lambda)
		{
			double num = Math.Exp(0.0 - lambda);
			int num2 = 0;
			for (double num3 = rnd.NextDouble(); num3 >= num; num3 *= rnd.NextDouble())
			{
				num2++;
			}
			return num2;
		}

		private static int DoSampleLarge(System.Random rnd, double lambda)
		{
			double d = 0.767 - 3.36 / lambda;
			double num = Math.PI / Math.Sqrt(3.0 * lambda);
			double num2 = num * lambda;
			double num3 = Math.Log(d) - lambda - Math.Log(num);
			int num6;
			while (true)
			{
				double num4 = rnd.NextDouble();
				double num5 = (num2 - Math.Log((1.0 - num4) / num4)) / num;
				num6 = (int)Math.Floor(num5 + 0.5);
				if (num6 >= 0)
				{
					double num7 = rnd.NextDouble();
					double num8 = num2 - num * num5;
					double num9 = 1.0 + Math.Exp(num8);
					double num10 = num8 + Math.Log(num7 / (num9 * num9));
					double num11 = num3 + (double)num6 * Math.Log(lambda) - SpecialFunctions.FactorialLn(num6);
					if (num10 <= num11)
					{
						break;
					}
				}
			}
			return num6;
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _lambda);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _lambda);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _lambda);
		}

		public static int Sample(System.Random rnd, double lambda)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, lambda);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double lambda)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, lambda);
		}

		public static void Samples(System.Random rnd, int[] values, double lambda)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, lambda);
		}

		public static int Sample(double lambda)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, lambda);
		}

		public static IEnumerable<int> Samples(double lambda)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, lambda);
		}

		public static void Samples(int[] values, double lambda)
		{
			if (!(lambda > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, lambda);
		}
	}
	public class Rayleigh : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _scale;

		public double Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _scale * Math.Sqrt(Math.PI / 2.0);

		public double Variance => 0.42920367320510344 * _scale * _scale;

		public double StdDev => Math.Sqrt(0.42920367320510344) * _scale;

		public double Entropy => 1.0 + Math.Log(_scale / 1.4142135623730951) + 0.28860783245076643;

		public double Skewness => 2.0 * Math.Sqrt(Math.PI) * 0.14159265358979312 / Math.Pow(0.8584073464102069, 1.5);

		public double Mode => _scale;

		public double Median => _scale * Math.Sqrt(Math.Log(4.0));

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public Rayleigh(double scale)
		{
			if (!IsValidParameterSet(scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_scale = scale;
		}

		public Rayleigh(double scale, System.Random randomSource)
		{
			if (!IsValidParameterSet(scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_scale = scale;
		}

		public override string ToString()
		{
			return $"Rayleigh( = {_scale})";
		}

		public static bool IsValidParameterSet(double scale)
		{
			return scale > 0.0;
		}

		public double Density(double x)
		{
			return x / (_scale * _scale) * Math.Exp((0.0 - x) * x / (2.0 * _scale * _scale));
		}

		public double DensityLn(double x)
		{
			return Math.Log(x / (_scale * _scale)) - x * x / (2.0 * _scale * _scale);
		}

		public double CumulativeDistribution(double x)
		{
			return 1.0 - Math.Exp((0.0 - x) * x / (2.0 * _scale * _scale));
		}

		public double InverseCumulativeDistribution(double p)
		{
			return _scale * Math.Sqrt(-2.0 * Math.Log(1.0 - p));
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _scale);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _scale);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _scale);
		}

		private static double SampleUnchecked(System.Random rnd, double scale)
		{
			return scale * Math.Sqrt(-2.0 * Math.Log(rnd.NextDouble()));
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double scale)
		{
			return from x in rnd.NextDoubleSequence()
				select scale * Math.Sqrt(-2.0 * Math.Log(x));
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double scale)
		{
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = scale * Math.Sqrt(-2.0 * Math.Log(values[i]));
				}
			});
		}

		public static double PDF(double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return x / (scale * scale) * Math.Exp((0.0 - x) * x / (2.0 * scale * scale));
		}

		public static double PDFLn(double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Log(x / (scale * scale)) - x * x / (2.0 * scale * scale);
		}

		public static double CDF(double scale, double x)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 - Math.Exp((0.0 - x) * x / (2.0 * scale * scale));
		}

		public static double InvCDF(double scale, double p)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return scale * Math.Sqrt(-2.0 * Math.Log(1.0 - p));
		}

		public static double Sample(System.Random rnd, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, scale);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, scale);
		}

		public static void Samples(System.Random rnd, double[] values, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, scale);
		}

		public static double Sample(double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, scale);
		}

		public static IEnumerable<double> Samples(double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, scale);
		}

		public static void Samples(double[] values, double scale)
		{
			if (scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, scale);
		}
	}
	public class SkewedGeneralizedError : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _skewness;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Location { get; private set; }

		public double Scale { get; private set; }

		public double Skew { get; private set; }

		public double P { get; private set; }

		public double Mode
		{
			get
			{
				if (Skew != 0.0)
				{
					return Mean - AdjustAddend(AdjustScale(Scale, Skew, P), Skew, P);
				}
				return Mean;
			}
		}

		public double Minimum => double.NegativeInfinity;

		public double Maximum => double.PositiveInfinity;

		public double Mean => Location;

		public double Variance => Scale * Scale;

		public double StdDev => Scale;

		public double Entropy
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public double Skewness => _skewness;

		public double Median
		{
			get
			{
				if (Skew != 0.0)
				{
					return InverseCumulativeDistribution(0.5);
				}
				return Mean;
			}
		}

		public SkewedGeneralizedError()
		{
			_random = SystemRandomSource.Default;
			Location = 0.0;
			Scale = 1.0;
			Skew = 0.0;
			P = 2.0;
		}

		public SkewedGeneralizedError(double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			Location = location;
			Scale = scale;
			Skew = skew;
			P = p;
			_skewness = CalculateSkewness();
		}

		public override string ToString()
		{
			return $"SkewedGeneralizedError( = {Location},  = {Scale},  = {Skew}, p = {P}";
		}

		public static bool IsValidParameterSet(double location, double scale, double skew, double p)
		{
			if (scale > 0.0 && skew > -1.0 && skew < 1.0 && p > 0.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		private double CalculateSkewness()
		{
			if (Skew == 0.0)
			{
				return 0.0;
			}
			double num = Math.Pow(Math.PI, 1.5);
			double num2 = SpecialFunctions.Gamma(1.0 / P);
			double num3 = SpecialFunctions.Gamma(0.5 + 1.0 / P);
			double num4 = SpecialFunctions.Gamma(3.0 / P);
			double num5 = SpecialFunctions.Gamma(4.0 / P);
			double num6 = Skew * Scale * Scale * Scale / (num * num2);
			double num7 = Math.Pow(2.0, (6.0 + P) / P) * Skew * Skew * Math.Pow(num3, 3.0) * num2;
			double num8 = 3.0 * Math.Pow(4.0, 1.0 / P) * Math.PI * (1.0 + 3.0 * Skew * Skew) * num3 * num4;
			double num9 = 4.0 * num * (1.0 + Skew * Skew) * num5;
			return num6 * (num7 - num8 + num9);
		}

		private static double AdjustScale(double scale, double skew, double p)
		{
			double num = SpecialFunctions.Gamma(3.0 / p);
			double x = SpecialFunctions.Gamma(0.5 + 1.0 / p);
			double num2 = SpecialFunctions.Gamma(1.0 / p);
			double num3 = SpecialFunctions.Gamma(1.0 / p);
			double num4 = Math.PI * (1.0 + 3.0 * skew * skew) * num;
			double num5 = Math.Pow(16.0, 1.0 / p) * skew * skew * Math.Pow(x, 2.0) * num2;
			double num6 = Math.PI * num3;
			return scale / Math.Sqrt((num4 - num5) / num6);
		}

		private static double AdjustX(double x, double scale, double skew, double p)
		{
			return x + AdjustAddend(scale, skew, p);
		}

		private static double AdjustAddend(double scale, double skew, double p)
		{
			return Math.Pow(2.0, 2.0 / p) * scale * skew * SpecialFunctions.Gamma(0.5 + 1.0 / p) / Math.Sqrt(Math.PI);
		}

		public static double PDF(double location, double scale, double skew, double p, double x)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			scale = AdjustScale(scale, skew, p);
			x = AdjustX(x, scale, skew, p);
			double num = Math.Abs(x - location);
			double num2 = scale * (1.0 + skew * (double)Math.Sign(x - location));
			double num3 = 2.0 * scale * SpecialFunctions.Gamma(1.0 / p);
			return p / (Math.Exp(Math.Pow(num / num2, p)) * num3);
		}

		public static double PDFLn(double location, double scale, double skew, double p, double x)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			scale = AdjustScale(scale, skew, p);
			x = AdjustX(x, scale, skew, p);
			return Math.Log(p) - Math.Log(2.0) - Math.Log(scale) - SpecialFunctions.GammaLn(1.0 / p) - Math.Pow(Math.Abs(x - location) / (scale * (1.0 + skew * (double)Math.Sign(x - location))), p);
		}

		public static double CDF(double location, double scale, double skew, double p, double x)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			scale = AdjustScale(scale, skew, p);
			x = AdjustX(x, scale, skew, p) - location;
			bool num = x < 0.0;
			if (num)
			{
				skew = 0.0 - skew;
				x = 0.0 - x;
			}
			double num2 = (1.0 - skew) / 2.0 + (1.0 + skew) / 2.0 * Gamma.CDF(1.0 / p, 1.0, Math.Pow(x / (scale * (1.0 + skew)), p));
			if (!num)
			{
				return num2;
			}
			return 1.0 - num2;
		}

		public static double InvCDF(double location, double scale, double skew, double p, double pr)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			scale = AdjustScale(scale, skew, p);
			bool num = pr < (1.0 - skew) / 2.0;
			double num2 = skew;
			if (num)
			{
				pr = 1.0 - pr;
				num2 = 0.0 - num2;
			}
			double num3 = scale * (1.0 + num2) * Math.Pow(Gamma.InvCDF(1.0 / p, 1.0, 2.0 * pr / (1.0 + num2) + (num2 - 1.0) / (num2 + 1.0)), 1.0 / p);
			if (num)
			{
				num3 = 0.0 - num3;
			}
			num3 += location;
			return num3 - AdjustAddend(scale, skew, p);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(Location, Scale, Skew, P, p);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(Location, Scale, Skew, P, x);
		}

		public double Density(double x)
		{
			return PDF(Location, Scale, Skew, P, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(Location, Scale, Skew, P, x);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, Location, Scale, Skew, P);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, Location, Scale, Skew, P);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, Location, Scale, Skew, P);
		}

		private static double SampleUnchecked(System.Random rnd, double location, double scale, double skew, double p)
		{
			double pr = ContinuousUniform.Sample(rnd, 0.0, 1.0);
			return InvCDF(location, scale, skew, p, pr);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double location, double scale, double skew, double p)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, location, scale, skew, p);
			}
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double location, double scale, double skew, double p)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, location, scale, skew, p);
			}
		}

		public static double Sample(System.Random rnd, double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, location, scale, skew, p);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, location, scale, skew, p);
		}

		public static void Samples(System.Random rnd, double[] values, double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, location, scale, skew, p);
		}

		public static double Sample(double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, location, scale, skew, p);
		}

		public static IEnumerable<double> Samples(double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, location, scale, skew, p);
		}

		public static void Samples(double[] values, double location, double scale, double skew, double p)
		{
			if (!IsValidParameterSet(location, scale, skew, p))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, location, scale, skew, p);
		}
	}
	public class SkewedGeneralizedT : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private IContinuousDistribution _d;

		private readonly double _skewness;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Location { get; }

		public double Scale { get; }

		public double Skew { get; }

		public double P { get; }

		public double Q { get; }

		public double Mode
		{
			get
			{
				IContinuousDistribution d = _d;
				if (d == null)
				{
					if (Skew != 0.0)
					{
						return Mean - AdjustAddend(AdjustScale(Scale, Skew, P, Q), Skew, P, Q);
					}
					return Mean;
				}
				return d.Mode;
			}
		}

		public double Minimum => _d?.Minimum ?? double.NegativeInfinity;

		public double Maximum => _d?.Maximum ?? double.PositiveInfinity;

		public double Mean => _d?.Mean ?? Location;

		public double Variance => _d?.Variance ?? (Scale * Scale);

		public double StdDev => _d?.StdDev ?? Scale;

		public double Entropy => (_d ?? throw new NotImplementedException()).Entropy;

		public double Skewness => _d?.Skewness ?? _skewness;

		public double Median
		{
			get
			{
				IContinuousDistribution d = _d;
				if (d == null)
				{
					if (Skew != 0.0)
					{
						return InverseCumulativeDistribution(0.5);
					}
					return Mean;
				}
				return d.Median;
			}
		}

		public SkewedGeneralizedT()
		{
			_random = SystemRandomSource.Default;
			Location = 0.0;
			Scale = 1.0;
			Skew = 0.0;
			P = 2.0;
			Q = double.PositiveInfinity;
			_d = new Normal(Location, Scale, _random);
		}

		public SkewedGeneralizedT(double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			Location = location;
			Scale = scale;
			Skew = skew;
			P = p;
			Q = q;
			_d = FindSpecializedDistribution(location, scale, skew, p, q);
			if (_d == null)
			{
				_skewness = CalculateSkewness();
			}
		}

		public static IContinuousDistribution FindSpecializedDistribution(double location, double scale, double skew, double p, double q)
		{
			if (p == double.PositiveInfinity)
			{
				scale *= Math.Sqrt(3.0);
				return new ContinuousUniform(location - scale, location + scale);
			}
			if (q == double.PositiveInfinity)
			{
				return new SkewedGeneralizedError(location, scale, skew, p);
			}
			return null;
		}

		public override string ToString()
		{
			return $"SkewedGeneralizedT( = {Location},  = {Scale},  = {Skew}, p = {P}, q = {Q})";
		}

		public static bool IsValidParameterSet(double location, double scale, double skew, double p, double q)
		{
			if (scale > 0.0 && skew > -1.0 && skew < 1.0 && p > 0.0 && q > 0.0 && p * q > 2.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		private double CalculateSkewness()
		{
			if (P * Q <= 3.0 || Skew == 0.0)
			{
				return 0.0;
			}
			double x = AdjustScale(Scale, Skew, P, Q);
			double num = SpecialFunctions.Beta(1.0 / P, Q);
			double num2 = SpecialFunctions.Beta(2.0 / P, Q - 1.0 / P);
			double num3 = SpecialFunctions.Beta(3.0 / P, Q - 2.0 / P);
			double num4 = SpecialFunctions.Beta(4.0 / P, Q - 3.0 / P);
			double num5 = 2.0 * Math.Pow(Q, 3.0 / P) * Skew * Math.Pow(x, 3.0) / Math.Pow(num, 3.0);
			double num6 = 8.0 * Skew * Skew * Math.Pow(num2, 3.0);
			double num7 = 3.0 * (1.0 + 3.0 * Skew * Skew) * num;
			double num8 = num2 * num3;
			double num9 = 2.0 * (1.0 + Skew * Skew) * Math.Pow(num, 2.0) * num4;
			return num5 * (num6 - num7 * num8 + num9);
		}

		private static double AdjustScale(double scale, double skew, double p, double q)
		{
			double num = SpecialFunctions.Beta(3.0 / p, q - 2.0 / p);
			double num2 = SpecialFunctions.Beta(1.0 / p, q);
			double num3 = SpecialFunctions.Beta(2.0 / p, q - 1.0 / p);
			double num4 = SpecialFunctions.Beta(1.0 / p, q);
			return scale / (Math.Pow(q, 1.0 / p) * Math.Sqrt((3.0 * skew * skew + 1.0) * num / num2 - 4.0 * skew * skew * (num3 / num4 * (num3 / num4))));
		}

		private static double AdjustX(double x, double scale, double skew, double p, double q)
		{
			return x + AdjustAddend(scale, skew, p, q);
		}

		private static double AdjustAddend(double scale, double skew, double p, double q)
		{
			double num = SpecialFunctions.Beta(2.0 / p, q - 1.0 / p);
			double num2 = SpecialFunctions.Beta(1.0 / p, q);
			return 2.0 * scale * skew * Math.Pow(q, 1.0 / p) * num / num2;
		}

		public static double PDF(double location, double scale, double skew, double p, double q, double x)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return PDFunc(location, scale, skew, p, q, ln: false)(x);
		}

		public static double PDFLn(double location, double scale, double skew, double p, double q, double x)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return PDFunc(location, scale, skew, p, q, ln: true)(x);
		}

		private static double PDFull(double location, double scale, double skew, double p, double q, double x)
		{
			scale = AdjustScale(scale, skew, p, q);
			x = AdjustX(x, scale, skew, p, q);
			double num = SpecialFunctions.Beta(1.0 / p, q);
			int num2 = Math.Sign(x - location);
			double num3 = Math.Pow(Math.Abs(x - location), p);
			double num4 = q * Math.Pow(scale, p) * Math.Pow(skew * (double)num2 + 1.0, p);
			double num5 = 2.0 * scale * Math.Pow(q, 1.0 / p) * num * Math.Pow(num3 / num4 + 1.0, 1.0 / p + q);
			return p / num5;
		}

		private static double PDFullLn(double location, double scale, double skew, double p, double q, double x)
		{
			scale = AdjustScale(scale, skew, p, q);
			x = AdjustX(x, scale, skew, p, q);
			double num = SpecialFunctions.BetaLn(1.0 / p, q);
			return Math.Log(p) - Math.Log(2.0) - Math.Log(scale) - Math.Log(q) / p - num - (1.0 / p + q) * Math.Log(1.0 + Math.Pow(Math.Abs(x - location), p) / (q * Math.Pow(scale, p) * Math.Pow(1.0 + skew * (double)Math.Sign(x - location), p)));
		}

		private static Func<double, double> PDFunc(double location, double scale, double skew, double p, double q, bool ln)
		{
			if (p == double.PositiveInfinity)
			{
				scale *= Math.Sqrt(3.0);
				return (double x) => (!ln) ? ContinuousUniform.PDF(-1.0 * (Math.Sqrt(3.0) * scale + location), Math.Sqrt(3.0) * scale + location, x) : ContinuousUniform.PDFLn(location - scale, location + scale, x);
			}
			if (q == double.PositiveInfinity)
			{
				return (double x) => (!ln) ? SkewedGeneralizedError.PDF(location, scale, skew, p, x) : SkewedGeneralizedError.PDFLn(location, scale, skew, p, x);
			}
			return (double x) => (!ln) ? PDFull(location, scale, skew, p, q, x) : PDFullLn(location, scale, skew, p, q, x);
		}

		public static double CDF(double location, double scale, double skew, double p, double q, double x)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			scale = AdjustScale(scale, skew, p, q);
			x = AdjustX(x, scale, skew, p, q) - location;
			bool num = x > 0.0;
			if (num)
			{
				skew = 0.0 - skew;
				x = 0.0 - x;
			}
			double num2 = (1.0 - skew) / 2.0 + (skew - 1.0) / 2.0 * Beta.CDF(1.0 / p, q, 1.0 / (1.0 + q * Math.Pow(scale * (1.0 - skew) / (0.0 - x), p)));
			if (!num)
			{
				return num2;
			}
			return 1.0 - num2;
		}

		public static double InvCDF(double location, double scale, double skew, double p, double q, double pr)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			IContinuousDistribution continuousDistribution = FindSpecializedDistribution(location, scale, skew, p, q);
			if (continuousDistribution != null)
			{
				if (continuousDistribution is SkewedGeneralizedError skewedGeneralizedError)
				{
					return skewedGeneralizedError.InverseCumulativeDistribution(pr);
				}
				if (continuousDistribution is ContinuousUniform continuousUniform)
				{
					return continuousUniform.InverseCumulativeDistribution(pr);
				}
			}
			scale = AdjustScale(scale, skew, p, q);
			bool num = pr > (1.0 - skew) / 2.0;
			double num2 = skew;
			if (num)
			{
				pr = 1.0 - pr;
				num2 = 0.0 - num2;
			}
			double num3 = scale * (num2 - 1.0) * Math.Pow(1.0 / (q * Beta.InvCDF(1.0 / p, q, 1.0 - 2.0 * pr / (1.0 - num2))) - 1.0 / q, -1.0 / p);
			if (num)
			{
				num3 = 0.0 - num3;
			}
			num3 += location;
			return num3 - AdjustAddend(scale, skew, p, q);
		}

		public double CumulativeDistribution(double x)
		{
			return _d?.CumulativeDistribution(x) ?? CDF(Location, Scale, Skew, P, Q, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			if (_d != null)
			{
				IContinuousDistribution d = _d;
				if (d is SkewedGeneralizedError skewedGeneralizedError)
				{
					return skewedGeneralizedError.InverseCumulativeDistribution(p);
				}
				if (d is ContinuousUniform continuousUniform)
				{
					return continuousUniform.InverseCumulativeDistribution(p);
				}
			}
			return InvCDF(Location, Scale, Skew, P, Q, p);
		}

		public double Density(double x)
		{
			return _d?.Density(x) ?? PDF(Location, Scale, Skew, P, Q, x);
		}

		public double DensityLn(double x)
		{
			return _d?.DensityLn(x) ?? PDFLn(Location, Scale, Skew, P, Q, x);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, Location, Scale, Skew, P, Q);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, Location, Scale, Skew, P, Q);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, Location, Scale, Skew, P, Q);
		}

		private static double SampleUnchecked(System.Random rnd, double location, double scale, double skew, double p, double q)
		{
			double pr = ContinuousUniform.Sample(rnd, 0.0, 1.0);
			return InvCDF(location, scale, skew, p, q, pr);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double location, double scale, double skew, double p, double q)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, location, scale, skew, p, q);
			}
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double location, double scale, double skew, double p, double q)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, location, scale, skew, p, q);
			}
		}

		public static double Sample(System.Random rnd, double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, location, scale, skew, p, q);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, location, scale, skew, p, q);
		}

		public static void Samples(System.Random rnd, double[] values, double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, location, scale, skew, p, q);
		}

		public static double Sample(double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, location, scale, skew, p, q);
		}

		public static IEnumerable<double> Samples(double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, location, scale, skew, p, q);
		}

		public static void Samples(double[] values, double location, double scale, double skew, double p, double q)
		{
			if (!IsValidParameterSet(location, scale, skew, p, q))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, location, scale, skew, p, q);
		}
	}
	public class Stable : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _alpha;

		private readonly double _beta;

		private readonly double _scale;

		private readonly double _location;

		public double Alpha => _alpha;

		public double Beta => _beta;

		public double Scale => _scale;

		public double Location => _location;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (_alpha <= 1.0)
				{
					throw new NotSupportedException();
				}
				return _location;
			}
		}

		public double Variance
		{
			get
			{
				if (_alpha == 2.0)
				{
					return 2.0 * _scale * _scale;
				}
				return double.PositiveInfinity;
			}
		}

		public double StdDev
		{
			get
			{
				if (_alpha == 2.0)
				{
					return 1.4142135623730951 * _scale;
				}
				return double.PositiveInfinity;
			}
		}

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness
		{
			get
			{
				if (_alpha != 2.0)
				{
					throw new NotSupportedException();
				}
				return 0.0;
			}
		}

		public double Mode
		{
			get
			{
				if (_beta != 0.0)
				{
					throw new NotSupportedException();
				}
				return _location;
			}
		}

		public double Median
		{
			get
			{
				if (_beta != 0.0)
				{
					throw new NotSupportedException();
				}
				return _location;
			}
		}

		public double Minimum
		{
			get
			{
				if (Math.Abs(_beta) == 1.0)
				{
					return 0.0;
				}
				return double.NegativeInfinity;
			}
		}

		public double Maximum => double.PositiveInfinity;

		public Stable(double alpha, double beta, double scale, double location)
		{
			if (!IsValidParameterSet(alpha, beta, scale, location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_alpha = alpha;
			_beta = beta;
			_scale = scale;
			_location = location;
		}

		public Stable(double alpha, double beta, double scale, double location, System.Random randomSource)
		{
			if (!IsValidParameterSet(alpha, beta, scale, location))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_alpha = alpha;
			_beta = beta;
			_scale = scale;
			_location = location;
		}

		public override string ToString()
		{
			return $"Stable( = {_alpha},  = {_beta}, c = {_scale},  = {_location})";
		}

		public static bool IsValidParameterSet(double alpha, double beta, double scale, double location)
		{
			if (alpha > 0.0 && alpha <= 2.0 && beta >= -1.0 && beta <= 1.0 && scale > 0.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_alpha, _beta, _scale, _location, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_alpha, _beta, _scale, _location, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_alpha, _beta, _scale, _location, x);
		}

		private static double SampleUnchecked(System.Random rnd, double alpha, double beta, double scale, double location)
		{
			double num = ContinuousUniform.Sample(rnd, -Math.PI / 2.0, Math.PI / 2.0);
			double num2 = Exponential.Sample(rnd, 1.0);
			if (!1.0.AlmostEqual(alpha))
			{
				double num3 = 1.0 / alpha * Math.Atan(beta * Math.Tan(Math.PI / 2.0 * alpha));
				double num4 = alpha * (num + num3);
				double num5 = beta * Math.Tan(Math.PI / 2.0 * alpha);
				double num6 = Math.Pow(1.0 + num5 * num5, 1.0 / (2.0 * alpha));
				double num7 = Math.Sin(num4) / Math.Pow(Math.Cos(num), 1.0 / alpha);
				double num8 = Math.Pow(Math.Cos(num - num4) / num2, (1.0 - alpha) / alpha);
				return location + scale * (num6 * num7 * num8);
			}
			double num9 = Math.PI / 2.0 + beta * num;
			double num10 = num9 * Math.Tan(num);
			double num11 = beta * Math.Log(Math.PI / 2.0 * num2 * Math.Cos(num) / num9);
			return location + scale * (2.0 / Math.PI) * (num10 - num11);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double alpha, double beta, double scale, double location)
		{
			double[] array = new double[values.Length];
			double[] array2 = new double[values.Length];
			ContinuousUniform.SamplesUnchecked(rnd, array, -Math.PI / 2.0, Math.PI / 2.0);
			Exponential.SamplesUnchecked(rnd, array2, 1.0);
			if (!1.0.AlmostEqual(alpha))
			{
				for (int i = 0; i < values.Length; i++)
				{
					double num = array[i];
					double num2 = 1.0 / alpha * Math.Atan(beta * Math.Tan(Math.PI / 2.0 * alpha));
					double num3 = alpha * (num + num2);
					double num4 = beta * Math.Tan(Math.PI / 2.0 * alpha);
					double num5 = Math.Pow(1.0 + num4 * num4, 1.0 / (2.0 * alpha));
					double num6 = Math.Sin(num3) / Math.Pow(Math.Cos(num), 1.0 / alpha);
					double num7 = Math.Pow(Math.Cos(num - num3) / array2[i], (1.0 - alpha) / alpha);
					values[i] = location + scale * (num5 * num6 * num7);
				}
			}
			else
			{
				for (int j = 0; j < values.Length; j++)
				{
					double num8 = array[j];
					double num9 = Math.PI / 2.0 + beta * num8;
					double num10 = num9 * Math.Tan(num8);
					double num11 = beta * Math.Log(Math.PI / 2.0 * array2[j] * Math.Cos(num8) / num9);
					values[j] = location + scale * (2.0 / Math.PI) * (num10 - num11);
				}
			}
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double alpha, double beta, double scale, double location)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, alpha, beta, scale, location);
			}
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _alpha, _beta, _scale, _location);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _alpha, _beta, _scale, _location);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _alpha, _beta, _scale, _location);
		}

		public static double PDF(double alpha, double beta, double scale, double location, double x)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (alpha == 2.0)
			{
				return Normal.PDF(location, 1.4142135623730951 * scale, x);
			}
			if (alpha == 1.0 && beta == 0.0)
			{
				return Cauchy.PDF(location, scale, x);
			}
			if (alpha == 0.5 && beta == 1.0 && x >= location)
			{
				return Math.Sqrt(scale / (Math.PI * 2.0)) * Math.Exp((0.0 - scale) / (2.0 * (x - location))) / Math.Pow(x - location, 1.5);
			}
			throw new NotSupportedException();
		}

		public static double PDFLn(double alpha, double beta, double scale, double location, double x)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (alpha == 2.0)
			{
				return Normal.PDFLn(location, 1.4142135623730951 * scale, x);
			}
			if (alpha == 1.0 && beta == 0.0)
			{
				return Cauchy.PDFLn(location, scale, x);
			}
			if (alpha == 0.5 && beta == 1.0 && x >= location)
			{
				return Math.Log(scale / (Math.PI * 2.0)) / 2.0 - scale / (2.0 * (x - location)) - 1.5 * Math.Log(x - location);
			}
			throw new NotSupportedException();
		}

		public static double CDF(double alpha, double beta, double scale, double location, double x)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (alpha == 2.0)
			{
				return Normal.CDF(location, 1.4142135623730951 * scale, x);
			}
			if (alpha == 1.0 && beta == 0.0)
			{
				return Cauchy.CDF(location, scale, x);
			}
			if (alpha == 0.5 && beta == 1.0)
			{
				return SpecialFunctions.Erfc(Math.Sqrt(scale / (2.0 * (x - location))));
			}
			throw new NotSupportedException();
		}

		public static double Sample(System.Random rnd, double alpha, double beta, double scale, double location)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, alpha, beta, scale, location);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double alpha, double beta, double scale, double location)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, alpha, beta, scale, location);
		}

		public static void Samples(System.Random rnd, double[] values, double alpha, double beta, double scale, double location)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, alpha, beta, scale, location);
		}

		public static double Sample(double alpha, double beta, double scale, double location)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, alpha, beta, scale, location);
		}

		public static IEnumerable<double> Samples(double alpha, double beta, double scale, double location)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, alpha, beta, scale, location);
		}

		public static void Samples(double[] values, double alpha, double beta, double scale, double location)
		{
			if (alpha <= 0.0 || alpha > 2.0 || beta < -1.0 || beta > 1.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, alpha, beta, scale, location);
		}
	}
	public class StudentT : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _location;

		private readonly double _scale;

		private readonly double _freedom;

		public double Location => _location;

		public double Scale => _scale;

		public double DegreesOfFreedom => _freedom;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean
		{
			get
			{
				if (!(_freedom > 1.0))
				{
					return double.NaN;
				}
				return _location;
			}
		}

		public double Variance
		{
			get
			{
				if (double.IsPositiveInfinity(_freedom))
				{
					return _scale * _scale;
				}
				if (_freedom > 2.0)
				{
					return _freedom * _scale * _scale / (_freedom - 2.0);
				}
				if (!(_freedom > 1.0))
				{
					return double.NaN;
				}
				return double.PositiveInfinity;
			}
		}

		public double StdDev
		{
			get
			{
				if (double.IsPositiveInfinity(_freedom))
				{
					return Math.Sqrt(_scale * _scale);
				}
				if (_freedom > 2.0)
				{
					return Math.Sqrt(_freedom * _scale * _scale / (_freedom - 2.0));
				}
				if (!(_freedom > 1.0))
				{
					return double.NaN;
				}
				return double.PositiveInfinity;
			}
		}

		public double Entropy
		{
			get
			{
				if (_location != 0.0 || _scale != 1.0)
				{
					throw new NotSupportedException();
				}
				return (_freedom + 1.0) / 2.0 * (SpecialFunctions.DiGamma((1.0 + _freedom) / 2.0) - SpecialFunctions.DiGamma(_freedom / 2.0)) + Math.Log(Math.Sqrt(_freedom) * SpecialFunctions.Beta(_freedom / 2.0, 0.5));
			}
		}

		public double Skewness
		{
			get
			{
				if (_freedom <= 3.0)
				{
					throw new NotSupportedException();
				}
				return 0.0;
			}
		}

		public double Mode => _location;

		public double Median => _location;

		public double Minimum => double.NegativeInfinity;

		public double Maximum => double.PositiveInfinity;

		public StudentT()
		{
			_random = SystemRandomSource.Default;
			_location = 0.0;
			_scale = 1.0;
			_freedom = 1.0;
		}

		public StudentT(double location, double scale, double freedom)
		{
			if (!IsValidParameterSet(location, scale, freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_location = location;
			_scale = scale;
			_freedom = freedom;
		}

		public StudentT(double location, double scale, double freedom, System.Random randomSource)
		{
			if (!IsValidParameterSet(location, scale, freedom))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_location = location;
			_scale = scale;
			_freedom = freedom;
		}

		public override string ToString()
		{
			return $"StudentT( = {_location},  = {_scale},  = {_freedom})";
		}

		public static bool IsValidParameterSet(double location, double scale, double freedom)
		{
			if (scale > 0.0 && freedom > 0.0)
			{
				return !double.IsNaN(location);
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_location, _scale, _freedom, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_location, _scale, _freedom, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_location, _scale, _freedom, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_location, _scale, _freedom, p);
		}

		private static double SampleUnchecked(System.Random rnd, double location, double scale, double freedom)
		{
			double num = Gamma.SampleUnchecked(rnd, 0.5 * freedom, 0.5);
			return Normal.Sample(rnd, location, scale * Math.Sqrt(freedom / num));
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double location, double scale, double freedom)
		{
			Gamma.SamplesUnchecked(rnd, values, 0.5 * freedom, 0.5);
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = Normal.Sample(rnd, location, scale * Math.Sqrt(freedom / values[i]));
			}
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double location, double scale, double freedom)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, location, scale, freedom);
			}
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _location, _scale, _freedom);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _location, _scale, _freedom);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _location, _scale, _freedom);
		}

		public static double PDF(double location, double scale, double freedom, double x)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (freedom >= 100000000.0)
			{
				return Normal.PDF(location, scale, x);
			}
			double num = (x - location) / scale;
			return Math.Exp(SpecialFunctions.GammaLn((freedom + 1.0) / 2.0) - SpecialFunctions.GammaLn(freedom / 2.0)) * Math.Pow(1.0 + num * num / freedom, -0.5 * (freedom + 1.0)) / Math.Sqrt(freedom * Math.PI) / scale;
		}

		public static double PDFLn(double location, double scale, double freedom, double x)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (freedom >= 100000000.0)
			{
				return Normal.PDFLn(location, scale, x);
			}
			double num = (x - location) / scale;
			return SpecialFunctions.GammaLn((freedom + 1.0) / 2.0) - 0.5 * ((freedom + 1.0) * Math.Log(1.0 + num * num / freedom)) - SpecialFunctions.GammaLn(freedom / 2.0) - 0.5 * Math.Log(freedom * Math.PI) - Math.Log(scale);
		}

		public static double CDF(double location, double scale, double freedom, double x)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(freedom))
			{
				return Normal.CDF(location, scale, x);
			}
			double num = (x - location) / scale;
			double x2 = freedom / (freedom + num * num);
			double num2 = 0.5 * SpecialFunctions.BetaRegularized(freedom / 2.0, 0.5, x2);
			if (!(x <= location))
			{
				return 1.0 - num2;
			}
			return num2;
		}

		public static double InvCDF(double location, double scale, double freedom, double p)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (double.IsPositiveInfinity(freedom))
			{
				return Normal.InvCDF(location, scale, p);
			}
			if (p == 0.5)
			{
				return location;
			}
			return Brent.FindRoot(delegate(double x)
			{
				double num = (x - location) / scale;
				double x2 = freedom / (freedom + num * num);
				double num2 = 0.5 * SpecialFunctions.BetaRegularized(freedom / 2.0, 0.5, x2);
				return (!(x <= location)) ? (1.0 - num2 - p) : (num2 - p);
			}, -800.0, 800.0, 1E-12);
		}

		public static double Sample(System.Random rnd, double location, double scale, double freedom)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, location, scale, freedom);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double location, double scale, double freedom)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, location, scale, freedom);
		}

		public static void Samples(System.Random rnd, double[] values, double location, double scale, double freedom)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, location, scale, freedom);
		}

		public static double Sample(double location, double scale, double freedom)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, location, scale, freedom);
		}

		public static IEnumerable<double> Samples(double location, double scale, double freedom)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, location, scale, freedom);
		}

		public static void Samples(double[] values, double location, double scale, double freedom)
		{
			if (scale <= 0.0 || freedom <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, location, scale, freedom);
		}
	}
	public class Triangular : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _lower;

		private readonly double _upper;

		private readonly double _mode;

		public double LowerBound => _lower;

		public double UpperBound => _upper;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => (_lower + _upper + _mode) / 3.0;

		public double Variance
		{
			get
			{
				double lower = _lower;
				double upper = _upper;
				double mode = _mode;
				return (lower * lower + upper * upper + mode * mode - lower * upper - lower * mode - upper * mode) / 18.0;
			}
		}

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy => 0.5 + Math.Log((_upper - _lower) / 2.0);

		public double Skewness
		{
			get
			{
				double lower = _lower;
				double upper = _upper;
				double mode = _mode;
				double num = Math.Sqrt(2.0) * (lower + upper - 2.0 * mode) * (2.0 * lower - upper - mode) * (lower - 2.0 * upper + mode);
				double num2 = 5.0 * Math.Pow(lower * lower + upper * upper + mode * mode - lower * upper - lower * mode - upper * mode, 1.5);
				return num / num2;
			}
		}

		public double Mode => _mode;

		public double Median
		{
			get
			{
				double lower = _lower;
				double upper = _upper;
				double mode = _mode;
				if (!(mode >= (lower + upper) / 2.0))
				{
					return upper - Math.Sqrt((upper - lower) * (upper - mode) / 2.0);
				}
				return lower + Math.Sqrt((upper - lower) * (mode - lower) / 2.0);
			}
		}

		public double Minimum => _lower;

		public double Maximum => _upper;

		public Triangular(double lower, double upper, double mode)
		{
			if (!IsValidParameterSet(lower, upper, mode))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_lower = lower;
			_upper = upper;
			_mode = mode;
		}

		public Triangular(double lower, double upper, double mode, System.Random randomSource)
		{
			if (!IsValidParameterSet(lower, upper, mode))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_lower = lower;
			_upper = upper;
			_mode = mode;
		}

		public override string ToString()
		{
			return $"Triangular(Lower = {_lower}, Upper = {_upper}, Mode = {_mode})";
		}

		public static bool IsValidParameterSet(double lower, double upper, double mode)
		{
			if (upper >= mode && mode >= lower && !double.IsInfinity(upper) && !double.IsInfinity(lower))
			{
				return !double.IsInfinity(mode);
			}
			return false;
		}

		public double Density(double x)
		{
			return PDF(_lower, _upper, _mode, x);
		}

		public double DensityLn(double x)
		{
			return PDFLn(_lower, _upper, _mode, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CDF(_lower, _upper, _mode, x);
		}

		public double InverseCumulativeDistribution(double p)
		{
			return InvCDF(_lower, _upper, _mode, p);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _lower, _upper, _mode);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _lower, _upper, _mode);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _lower, _upper, _mode);
		}

		private static double SampleUnchecked(System.Random rnd, double lower, double upper, double mode)
		{
			double num = rnd.NextDouble();
			if (!(num < (mode - lower) / (upper - lower)))
			{
				return upper - Math.Sqrt((1.0 - num) * (upper - lower) * (upper - mode));
			}
			return lower + Math.Sqrt(num * (upper - lower) * (mode - lower));
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double lower, double upper, double mode)
		{
			double num = mode - lower;
			double num2 = upper - lower;
			double num3 = upper - mode;
			double u = num / num2;
			double v = num2 * num;
			double w = num2 * num3;
			return from x in rnd.NextDoubleSequence()
				select (!(x < u)) ? (upper - Math.Sqrt((1.0 - x) * w)) : (lower + Math.Sqrt(x * v));
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double lower, double upper, double mode)
		{
			double num = mode - lower;
			double num2 = upper - lower;
			double num3 = upper - mode;
			double u = num / num2;
			double v = num2 * num;
			double w = num2 * num3;
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = ((values[i] < u) ? (lower + Math.Sqrt(values[i] * v)) : (upper - Math.Sqrt((1.0 - values[i]) * w)));
				}
			});
		}

		public static double PDF(double lower, double upper, double mode, double x)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (lower <= x && x <= mode)
			{
				return 2.0 * (x - lower) / ((upper - lower) * (mode - lower));
			}
			if (mode < x && x <= upper)
			{
				return 2.0 * (upper - x) / ((upper - lower) * (upper - mode));
			}
			return 0.0;
		}

		public static double PDFLn(double lower, double upper, double mode, double x)
		{
			return Math.Log(PDF(lower, upper, mode, x));
		}

		public static double CDF(double lower, double upper, double mode, double x)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < lower)
			{
				return 0.0;
			}
			if (lower <= x && x <= mode)
			{
				return (x - lower) * (x - lower) / ((upper - lower) * (mode - lower));
			}
			if (mode < x && x <= upper)
			{
				return 1.0 - (upper - x) * (upper - x) / ((upper - lower) * (upper - mode));
			}
			return 1.0;
		}

		public static double InvCDF(double lower, double upper, double mode, double p)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (p <= 0.0)
			{
				return lower;
			}
			if (p < (mode - lower) / (upper - lower))
			{
				return lower + Math.Sqrt(p * (mode - lower) * (upper - lower));
			}
			if (p < 1.0)
			{
				return upper - Math.Sqrt((1.0 - p) * (upper - mode) * (upper - lower));
			}
			return upper;
		}

		public static double Sample(System.Random rnd, double lower, double upper, double mode)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, lower, upper, mode);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double lower, double upper, double mode)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, lower, upper, mode);
		}

		public static void Samples(System.Random rnd, double[] values, double lower, double upper, double mode)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, lower, upper, mode);
		}

		public static double Sample(double lower, double upper, double mode)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, lower, upper, mode);
		}

		public static IEnumerable<double> Samples(double lower, double upper, double mode)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, lower, upper, mode);
		}

		public static void Samples(double[] values, double lower, double upper, double mode)
		{
			if (!(upper >= mode) || !(mode >= lower))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, lower, upper, mode);
		}
	}
	public class TruncatedPareto : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Scale { get; }

		public double Shape { get; }

		public double Truncation { get; }

		public double Mean => GetMoment(1);

		public double Variance => GetMoment(2) - Math.Pow(GetMoment(1), 2.0);

		public double StdDev => Math.Sqrt(Variance);

		public double Mode
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Minimum => Scale;

		public double Maximum => Truncation;

		public double Entropy
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public double Skewness
		{
			get
			{
				double mean = Mean;
				double variance = Variance;
				double stdDev = StdDev;
				return (GetMoment(3) - 3.0 * mean * variance - mean * mean * mean) / (stdDev * stdDev * stdDev);
			}
		}

		public double Median => Scale * Math.Pow(1.0 - 0.5 * (1.0 - Math.Pow(Scale / Truncation, Shape)), 0.0 - 1.0 / Shape);

		public TruncatedPareto(double scale, double shape, double truncation, System.Random randomSource = null)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			Scale = scale;
			Shape = shape;
			Truncation = truncation;
		}

		public override string ToString()
		{
			return $"Truncated Pareto(Scale = {Scale}, Shape = {Shape}, Truncation = {Truncation})";
		}

		public static bool IsValidParameterSet(double scale, double shape, double truncation)
		{
			if (scale.IsFinite() && shape.IsFinite() && truncation.IsFinite() && scale > 0.0 && shape > 0.0)
			{
				return truncation > scale;
			}
			return false;
		}

		public double GetMoment(int n)
		{
			if (Shape.AlmostEqual(n))
			{
				return Shape * Math.Pow(Scale, n) / (1.0 - Math.Pow(Scale / Truncation, Shape)) * Math.Log(Truncation / Scale);
			}
			return Shape * Math.Pow(Scale, n) / (Shape - (double)n) * ((1.0 - Math.Pow(Scale / Truncation, Shape - (double)n)) / (1.0 - Math.Pow(Scale / Truncation, Shape)));
		}

		public double Sample()
		{
			return SampleUnchecked(_random, Scale, Shape, Truncation);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, Scale, Shape, Truncation);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, Scale, Shape, Truncation);
		}

		public static double Sample(System.Random rnd, double scale, double shape, double truncation)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, scale, shape, truncation);
		}

		public static void Samples(System.Random rnd, double[] values, double scale, double shape, double truncation)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, scale, shape, truncation);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double scale, double shape, double truncation)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, scale, shape, truncation);
		}

		internal static double SampleUnchecked(System.Random rnd, double scale, double shape, double truncation)
		{
			double p = rnd.NextDouble();
			return InvCDFUncheckedImpl(scale, shape, truncation, p);
		}

		internal static void SamplesUnchecked(System.Random rnd, double[] values, double scale, double shape, double truncation)
		{
			if (values.Length != 0)
			{
				double[] array = rnd.NextDoubles(values.Length);
				for (int i = 0; i < values.Length; i++)
				{
					values[i] = InvCDFUncheckedImpl(scale, shape, truncation, array[i]);
				}
			}
		}

		internal static IEnumerable<double> SamplesUnchecked(System.Random rnd, double scale, double shape, double truncation)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, scale, shape, truncation);
			}
		}

		public double Density(double x)
		{
			return DensityImpl(Scale, Shape, Truncation, x);
		}

		public double DensityLn(double x)
		{
			return DensityLnImpl(Scale, Shape, Truncation, x);
		}

		public double CumulativeDistribution(double x)
		{
			return CumulativeDistributionImpl(Scale, Shape, Truncation, x);
		}

		public double InvCDF(double p)
		{
			return InvCDFUncheckedImpl(Scale, Shape, Truncation, p);
		}

		public static double ICDF(double scale, double shape, double truncation, double p)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return InvCDFUncheckedImpl(scale, shape, truncation, p);
		}

		public static double PDF(double scale, double shape, double truncation, double x)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DensityImpl(scale, shape, truncation, x);
		}

		public static double PDFLn(double scale, double shape, double truncation, double x)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DensityLnImpl(scale, shape, truncation, x);
		}

		public static double CDF(double scale, double shape, double truncation, double x)
		{
			if (!IsValidParameterSet(scale, shape, truncation))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return CumulativeDistributionImpl(scale, shape, truncation, x);
		}

		internal static double DensityImpl(double scale, double shape, double truncation, double x)
		{
			if (x < scale || x > truncation)
			{
				return 0.0;
			}
			return shape * Math.Pow(scale, shape) * Math.Pow(x, 0.0 - shape - 1.0) / (1.0 - Math.Pow(scale / truncation, shape));
		}

		internal static double DensityLnImpl(double scale, double shape, double truncation, double x)
		{
			return Math.Log(DensityImpl(scale, shape, truncation, x));
		}

		internal static double CumulativeDistributionImpl(double scale, double shape, double truncation, double x)
		{
			if (x <= scale)
			{
				return 0.0;
			}
			if (x >= truncation)
			{
				return 1.0;
			}
			return (1.0 - Math.Pow(scale, shape) * Math.Pow(x, 0.0 - shape)) / (1.0 - Math.Pow(scale / truncation, shape));
		}

		internal static double InvCDFUncheckedImpl(double scale, double shape, double truncation, double p)
		{
			double num = p * Math.Pow(truncation, shape) - p * Math.Pow(scale, shape) - Math.Pow(truncation, shape);
			double num2 = Math.Pow(truncation, shape) * Math.Pow(scale, shape);
			return Math.Pow((0.0 - num) / num2, 0.0 - 1.0 / shape);
		}
	}
	public class Weibull : IContinuousDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _shape;

		private readonly double _scale;

		private readonly double _scalePowShapeInv;

		public double Shape => _shape;

		public double Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => _scale * SpecialFunctions.Gamma(1.0 + 1.0 / _shape);

		public double Variance => _scale * _scale * SpecialFunctions.Gamma(1.0 + 2.0 / _shape) - Mean * Mean;

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy => 0.5772156649015329 * (1.0 - 1.0 / _shape) + Math.Log(_scale / _shape) + 1.0;

		public double Skewness
		{
			get
			{
				double mean = Mean;
				double stdDev = StdDev;
				double num = stdDev * stdDev;
				double num2 = num * stdDev;
				return (_scale * _scale * _scale * SpecialFunctions.Gamma(1.0 + 3.0 / _shape) - 3.0 * num * mean - mean * mean * mean) / num2;
			}
		}

		public double Mode
		{
			get
			{
				if (_shape <= 1.0)
				{
					return 0.0;
				}
				return _scale * Math.Pow((_shape - 1.0) / _shape, 1.0 / _shape);
			}
		}

		public double Median => _scale * Math.Pow(0.6931471805599453, 1.0 / _shape);

		public double Minimum => 0.0;

		public double Maximum => double.PositiveInfinity;

		public Weibull(double shape, double scale)
		{
			if (!IsValidParameterSet(shape, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_shape = shape;
			_scale = scale;
			_scalePowShapeInv = Math.Pow(scale, 0.0 - shape);
		}

		public Weibull(double shape, double scale, System.Random randomSource)
		{
			if (!IsValidParameterSet(shape, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_shape = shape;
			_scale = scale;
			_scalePowShapeInv = Math.Pow(scale, 0.0 - shape);
		}

		public override string ToString()
		{
			return $"Weibull(k = {_shape},  = {_scale})";
		}

		public static bool IsValidParameterSet(double shape, double scale)
		{
			if (shape > 0.0)
			{
				return scale > 0.0;
			}
			return false;
		}

		public double Density(double x)
		{
			if (x >= 0.0)
			{
				if (x == 0.0 && _shape == 1.0)
				{
					return _shape / _scale;
				}
				return _shape * Math.Pow(x / _scale, _shape - 1.0) * Math.Exp((0.0 - Math.Pow(x, _shape)) * _scalePowShapeInv) / _scale;
			}
			return 0.0;
		}

		public double DensityLn(double x)
		{
			if (x >= 0.0)
			{
				if (x == 0.0 && _shape == 1.0)
				{
					return Math.Log(_shape) - Math.Log(_scale);
				}
				return Math.Log(_shape) + (_shape - 1.0) * Math.Log(x / _scale) - Math.Pow(x, _shape) * _scalePowShapeInv - Math.Log(_scale);
			}
			return double.NegativeInfinity;
		}

		public double CumulativeDistribution(double x)
		{
			if (x < 0.0)
			{
				return 0.0;
			}
			return 0.0 - SpecialFunctions.ExponentialMinusOne((0.0 - Math.Pow(x, _shape)) * _scalePowShapeInv);
		}

		public double Sample()
		{
			return SampleUnchecked(_random, _shape, _scale);
		}

		public void Samples(double[] values)
		{
			SamplesUnchecked(_random, values, _shape, _scale);
		}

		public IEnumerable<double> Samples()
		{
			return SamplesUnchecked(_random, _shape, _scale);
		}

		private static double SampleUnchecked(System.Random rnd, double shape, double scale)
		{
			double d = rnd.NextDouble();
			return scale * Math.Pow(0.0 - Math.Log(d), 1.0 / shape);
		}

		private static IEnumerable<double> SamplesUnchecked(System.Random rnd, double shape, double scale)
		{
			double exponent = 1.0 / shape;
			return from x in rnd.NextDoubleSequence()
				select scale * Math.Pow(0.0 - Math.Log(x), exponent);
		}

		private static void SamplesUnchecked(System.Random rnd, double[] values, double shape, double scale)
		{
			double exponent = 1.0 / shape;
			rnd.NextDoubles(values);
			CommonParallel.For(0, values.Length, 4096, delegate(int a, int b)
			{
				for (int i = a; i < b; i++)
				{
					values[i] = scale * Math.Pow(0.0 - Math.Log(values[i]), exponent);
				}
			});
		}

		public static double PDF(double shape, double scale, double x)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x >= 0.0)
			{
				if (x == 0.0 && shape == 1.0)
				{
					return shape / scale;
				}
				return shape * Math.Pow(x / scale, shape - 1.0) * Math.Exp((0.0 - Math.Pow(x, shape)) * Math.Pow(scale, 0.0 - shape)) / scale;
			}
			return 0.0;
		}

		public static double PDFLn(double shape, double scale, double x)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x >= 0.0)
			{
				if (x == 0.0 && shape == 1.0)
				{
					return Math.Log(shape) - Math.Log(scale);
				}
				return Math.Log(shape) + (shape - 1.0) * Math.Log(x / scale) - Math.Pow(x, shape) * Math.Pow(scale, 0.0 - shape) - Math.Log(scale);
			}
			return double.NegativeInfinity;
		}

		public static double CDF(double shape, double scale, double x)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 0.0)
			{
				return 0.0;
			}
			return 0.0 - SpecialFunctions.ExponentialMinusOne((0.0 - Math.Pow(x, shape)) * Math.Pow(scale, 0.0 - shape));
		}

		public static Weibull Estimate(IEnumerable<double> samples, System.Random randomSource = null)
		{
			double[] array = (samples as double[]) ?? samples.ToArray();
			double num = array.Length;
			double num2 = 0.0;
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = -2147483648.0;
			double num6 = 0.0;
			if (num <= 1.0)
			{
				throw new Exception("Observations not sufficient");
			}
			double num7 = 10.0;
			double num8 = 0.0;
			double[] array2;
			while (Math.Abs(num7 - num5) >= 0.0001)
			{
				num2 = (num3 = (num4 = 0.0));
				array2 = array;
				foreach (double num9 in array2)
				{
					if (num9 > 0.0)
					{
						num2 += Math.Log(num9);
						num3 += Math.Pow(num9, num7);
						num4 += Math.Pow(num9, num7) * Math.Log(num9);
					}
				}
				num6 = num * num3 / (num * num4 - num2 * num3);
				num5 = num7;
				num7 = (num7 + num6) / 2.0;
			}
			array2 = array;
			foreach (double num10 in array2)
			{
				if (num10 > 0.0)
				{
					num8 += Math.Pow(num10, num7);
				}
			}
			num8 = Math.Pow(num8 / num, 1.0 / num7);
			return new Weibull(num7, num8, randomSource);
		}

		public static double Sample(System.Random rnd, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, shape, scale);
		}

		public static IEnumerable<double> Samples(System.Random rnd, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, shape, scale);
		}

		public static void Samples(System.Random rnd, double[] values, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, shape, scale);
		}

		public static double Sample(double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, shape, scale);
		}

		public static IEnumerable<double> Samples(double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, shape, scale);
		}

		public static void Samples(double[] values, double shape, double scale)
		{
			if (shape <= 0.0 || scale <= 0.0)
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, shape, scale);
		}
	}
	public class Wishart : IDistribution
	{
		private System.Random _random;

		private readonly double _degreesOfFreedom;

		private readonly Matrix<double> _scale;

		private readonly Cholesky<double> _chol;

		public double DegreesOfFreedom => _degreesOfFreedom;

		public Matrix<double> Scale => _scale;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public Matrix<double> Mean => _degreesOfFreedom * _scale;

		public Matrix<double> Mode => (_degreesOfFreedom - (double)_scale.RowCount - 1.0) * _scale;

		public Matrix<double> Variance => Matrix<double>.Build.Dense(_scale.RowCount, _scale.ColumnCount, (int i, int j) => _degreesOfFreedom * (_scale.At(i, j) * _scale.At(i, j) + _scale.At(i, i) * _scale.At(j, j)));

		public Wishart(double degreesOfFreedom, Matrix<double> scale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(degreesOfFreedom, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_degreesOfFreedom = degreesOfFreedom;
			_scale = scale;
			_chol = _scale.Cholesky();
		}

		public Wishart(double degreesOfFreedom, Matrix<double> scale, System.Random randomSource)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(degreesOfFreedom, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_degreesOfFreedom = degreesOfFreedom;
			_scale = scale;
			_chol = _scale.Cholesky();
		}

		public static bool IsValidParameterSet(double degreesOfFreedom, Matrix<double> scale)
		{
			if (scale.RowCount != scale.ColumnCount)
			{
				return false;
			}
			for (int i = 0; i < scale.RowCount; i++)
			{
				if (scale.At(i, i) <= 0.0)
				{
					return false;
				}
			}
			if (degreesOfFreedom <= 0.0 || double.IsNaN(degreesOfFreedom))
			{
				return false;
			}
			return true;
		}

		public override string ToString()
		{
			return $"Wishart(DegreesOfFreedom = {_degreesOfFreedom}, Rows = {_scale.RowCount}, Columns = {_scale.ColumnCount})";
		}

		public double Density(Matrix<double> x)
		{
			int rowCount = _scale.RowCount;
			if (x.RowCount != rowCount || x.ColumnCount != rowCount)
			{
				throw Matrix<double>.DimensionsDontMatch<ArgumentOutOfRangeException>(x, _scale, "x");
			}
			double x2 = x.Determinant();
			Matrix<double> matrix = _chol.Solve(x);
			double num = Math.Pow(Math.PI, (double)rowCount * ((double)rowCount - 1.0) / 4.0);
			for (int i = 1; i <= rowCount; i++)
			{
				num *= SpecialFunctions.Gamma((_degreesOfFreedom + 1.0 - (double)i) / 2.0);
			}
			return Math.Pow(x2, (_degreesOfFreedom - (double)rowCount - 1.0) / 2.0) * Math.Exp(-0.5 * matrix.Trace()) / Math.Pow(2.0, _degreesOfFreedom * (double)rowCount / 2.0) / Math.Pow(_chol.Determinant, _degreesOfFreedom / 2.0) / num;
		}

		public Matrix<double> Sample()
		{
			return DoSample(RandomSource, _degreesOfFreedom, _scale, _chol);
		}

		public static Matrix<double> Sample(System.Random rnd, double degreesOfFreedom, Matrix<double> scale)
		{
			if (Control.CheckDistributionParameters && !IsValidParameterSet(degreesOfFreedom, scale))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return DoSample(rnd, degreesOfFreedom, scale, scale.Cholesky());
		}

		private static Matrix<double> DoSample(System.Random rnd, double degreesOfFreedom, Matrix<double> scale, Cholesky<double> chol)
		{
			int rowCount = scale.RowCount;
			MathNet.Numerics.LinearAlgebra.Double.DenseMatrix denseMatrix = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix(rowCount, rowCount);
			for (int i = 0; i < rowCount; i++)
			{
				denseMatrix.At(i, i, Math.Sqrt(Gamma.Sample(rnd, (degreesOfFreedom - (double)i) / 2.0, 0.5)));
			}
			for (int j = 1; j < rowCount; j++)
			{
				for (int k = 0; k < j; k++)
				{
					denseMatrix.At(j, k, Normal.Sample(rnd, 0.0, 1.0));
				}
			}
			Matrix<double> factor = chol.Factor;
			return factor * denseMatrix * denseMatrix.Transpose() * factor.Transpose();
		}
	}
	public class Zipf : IDiscreteDistribution, IUnivariateDistribution, IDistribution
	{
		private System.Random _random;

		private readonly double _s;

		private readonly int _n;

		public double S => _s;

		public int N => _n;

		public System.Random RandomSource
		{
			get
			{
				return _random;
			}
			set
			{
				_random = value ?? SystemRandomSource.Default;
			}
		}

		public double Mean => SpecialFunctions.GeneralHarmonic(_n, _s - 1.0) / SpecialFunctions.GeneralHarmonic(_n, _s);

		public double Variance
		{
			get
			{
				if (_s <= 3.0)
				{
					throw new NotSupportedException();
				}
				double num = SpecialFunctions.GeneralHarmonic(_n, _s);
				return SpecialFunctions.GeneralHarmonic(_n, _s - 2.0) * SpecialFunctions.GeneralHarmonic(_n, _s) - Math.Pow(SpecialFunctions.GeneralHarmonic(_n, _s - 1.0), 2.0) / (num * num);
			}
		}

		public double StdDev => Math.Sqrt(Variance);

		public double Entropy
		{
			get
			{
				double num = 0.0;
				for (int i = 0; i < _n; i++)
				{
					num += Math.Log(i + 1) / Math.Pow(i + 1, _s);
				}
				return _s / SpecialFunctions.GeneralHarmonic(_n, _s) * num + Math.Log(SpecialFunctions.GeneralHarmonic(_n, _s));
			}
		}

		public double Skewness
		{
			get
			{
				if (_s <= 4.0)
				{
					throw new NotSupportedException();
				}
				return (SpecialFunctions.GeneralHarmonic(_n, _s - 3.0) * Math.Pow(SpecialFunctions.GeneralHarmonic(_n, _s), 2.0) - SpecialFunctions.GeneralHarmonic(_n, _s - 1.0) * (3.0 * SpecialFunctions.GeneralHarmonic(_n, _s - 2.0) * SpecialFunctions.GeneralHarmonic(_n, _s) - Math.Pow(SpecialFunctions.GeneralHarmonic(_n, _s - 1.0), 2.0))) / Math.Pow(SpecialFunctions.GeneralHarmonic(_n, _s - 2.0) * SpecialFunctions.GeneralHarmonic(_n, _s) - Math.Pow(SpecialFunctions.GeneralHarmonic(_n, _s - 1.0), 2.0), 1.5);
			}
		}

		public int Mode => 1;

		public double Median
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public int Minimum => 1;

		public int Maximum => _n;

		public Zipf(double s, int n)
		{
			if (!IsValidParameterSet(s, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = SystemRandomSource.Default;
			_s = s;
			_n = n;
		}

		public Zipf(double s, int n, System.Random randomSource)
		{
			if (!IsValidParameterSet(s, n))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			_random = randomSource ?? SystemRandomSource.Default;
			_s = s;
			_n = n;
		}

		public override string ToString()
		{
			return $"Zipf(S = {_s}, N = {_n})";
		}

		public static bool IsValidParameterSet(double s, int n)
		{
			if (n > 0)
			{
				return s > 0.0;
			}
			return false;
		}

		public double Probability(int k)
		{
			return 1.0 / Math.Pow(k, _s) / SpecialFunctions.GeneralHarmonic(_n, _s);
		}

		public double ProbabilityLn(int k)
		{
			return Math.Log(Probability(k));
		}

		public double CumulativeDistribution(double x)
		{
			if (x < 1.0)
			{
				return 0.0;
			}
			return SpecialFunctions.GeneralHarmonic((int)x, _s) / SpecialFunctions.GeneralHarmonic(_n, _s);
		}

		public static double PMF(double s, int n, int k)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return 1.0 / Math.Pow(k, s) / SpecialFunctions.GeneralHarmonic(n, s);
		}

		public static double PMFLn(double s, int n, int k)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return Math.Log(PMF(s, n, k));
		}

		public static double CDF(double s, int n, double x)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			if (x < 1.0)
			{
				return 0.0;
			}
			return SpecialFunctions.GeneralHarmonic((int)x, s) / SpecialFunctions.GeneralHarmonic(n, s);
		}

		private static int SampleUnchecked(System.Random rnd, double s, int n)
		{
			double num;
			for (num = 0.0; num == 0.0; num = rnd.NextDouble())
			{
			}
			double num2 = 1.0 / SpecialFunctions.GeneralHarmonic(n, s);
			double num3 = 0.0;
			int i;
			for (i = 1; i <= n; i++)
			{
				num3 += num2 / Math.Pow(i, s);
				if (num3 >= num)
				{
					break;
				}
			}
			return i;
		}

		private static void SamplesUnchecked(System.Random rnd, int[] values, double s, int n)
		{
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = SampleUnchecked(rnd, s, n);
			}
		}

		private static IEnumerable<int> SamplesUnchecked(System.Random rnd, double s, int n)
		{
			while (true)
			{
				yield return SampleUnchecked(rnd, s, n);
			}
		}

		public int Sample()
		{
			return SampleUnchecked(_random, _s, _n);
		}

		public void Samples(int[] values)
		{
			SamplesUnchecked(_random, values, _s, _n);
		}

		public IEnumerable<int> Samples()
		{
			return SamplesUnchecked(_random, _s, _n);
		}

		public static int Sample(System.Random rnd, double s, int n)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(rnd, s, n);
		}

		public static IEnumerable<int> Samples(System.Random rnd, double s, int n)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(rnd, s, n);
		}

		public static void Samples(System.Random rnd, int[] values, double s, int n)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(rnd, values, s, n);
		}

		public static int Sample(double s, int n)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SampleUnchecked(SystemRandomSource.Default, s, n);
		}

		public static IEnumerable<int> Samples(double s, int n)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			return SamplesUnchecked(SystemRandomSource.Default, s, n);
		}

		public static void Samples(int[] values, double s, int n)
		{
			if (n <= 0 || !(s > 0.0))
			{
				throw new ArgumentException("Invalid parametrization for the distribution.");
			}
			SamplesUnchecked(SystemRandomSource.Default, values, s, n);
		}
	}
}
namespace MathNet.Numerics.Differentiation
{
	public class FiniteDifferenceCoefficients
	{
		private double[][,] _coefficients;

		private int _points;

		public int Points
		{
			get
			{
				return _points;
			}
			set
			{
				CalculateCoefficients(value);
				_points = value;
			}
		}

		public FiniteDifferenceCoefficients(int points)
		{
			Points = points;
			CalculateCoefficients(Points);
		}

		public double[] GetCoefficients(int center, int order)
		{
			if (center >= _coefficients.Length)
			{
				throw new ArgumentOutOfRangeException("center", "Center position must be within the point range.");
			}
			if (order >= _coefficients.Length)
			{
				throw new ArgumentOutOfRangeException("order", "Maximum difference order is points-1.");
			}
			int length = _coefficients[center].GetLength(1);
			double[] array = new double[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = _coefficients[center][order, i];
			}
			return array;
		}

		public double[,] GetCoefficientsForAllOrders(int center)
		{
			if (center >= _coefficients.Length)
			{
				throw new ArgumentOutOfRangeException("center", "Center position must be within the point range.");
			}
			return _coefficients[center];
		}

		private void CalculateCoefficients(int points)
		{
			double[][,] array = new double[points][,];
			for (int i = 0; i < points; i++)
			{
				MathNet.Numerics.LinearAlgebra.Double.DenseMatrix denseMatrix = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix(points);
				int num = points - i - 1;
				for (int num2 = points - 1; num2 >= 0; num2--)
				{
					denseMatrix[num2, 0] = 1.0;
					for (int j = 1; j < points; j++)
					{
						denseMatrix[num2, j] = denseMatrix[num2, j - 1] * (double)num / (double)j;
					}
					num--;
				}
				array[i] = denseMatrix.Inverse().ToArray();
				double num3 = SpecialFunctions.Factorial(points);
				for (int k = 0; k < points; k++)
				{
					for (int l = 0; l < points; l++)
					{
						array[i][k, l] = Math.Round(array[i][k, l] * num3, MidpointRounding.AwayFromZero) / num3;
					}
				}
			}
			_coefficients = array;
		}
	}
	public enum StepType
	{
		Absolute,
		RelativeX,
		Relative
	}
	public class NumericalDerivative
	{
		private readonly int _points;

		private int _center;

		private double _stepSize = Math.Pow(2.0, -10.0);

		private double _epsilon = Precision.PositiveMachineEpsilon;

		private double _baseStepSize = Math.Pow(2.0, -26.0);

		private readonly FiniteDifferenceCoefficients _coefficients;

		public double StepSize
		{
			get
			{
				return _stepSize;
			}
			set
			{
				double a = Math.Log(Math.Abs(value)) / Math.Log(2.0);
				_stepSize = Math.Pow(2.0, Math.Round(a));
			}
		}

		public double BaseStepSize
		{
			get
			{
				return _baseStepSize;
			}
			set
			{
				double a = Math.Log(Math.Abs(value)) / Math.Log(2.0);
				_baseStepSize = Math.Pow(2.0, Math.Round(a));
			}
		}

		public double Epsilon
		{
			get
			{
				return _epsilon;
			}
			set
			{
				double a = Math.Log(Math.Abs(value)) / Math.Log(2.0);
				_epsilon = Math.Pow(2.0, Math.Round(a));
			}
		}

		public int Center
		{
			get
			{
				return _center;
			}
			set
			{
				if (value >= _points || value < 0)
				{
					throw new ArgumentOutOfRangeException("value", "Center must lie between 0 and points -1");
				}
				_center = value;
			}
		}

		public int Evaluations { get; private set; }

		public StepType StepType { get; set; } = StepType.Relative;


		public NumericalDerivative()
			: this(3, 1)
		{
		}

		public NumericalDerivative(int points, int center)
		{
			if (points < 2)
			{
				throw new ArgumentOutOfRangeException("points", "Points must be two or greater.");
			}
			_center = center;
			_points = points;
			Center = center;
			_coefficients = new FiniteDifferenceCoefficients(points);
		}

		public double EvaluateDerivative(double[] points, int order, double stepSize)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (order >= _points || order < 0)
			{
				throw new ArgumentOutOfRangeException("order", "Order must be between zero and points-1.");
			}
			return _coefficients.GetCoefficients(Center, order).Select((double t, int i) => t * points[i]).Sum() / Math.Pow(stepSize, order);
		}

		public double EvaluateDerivative(Func<double, double> f, double x, int order, double? currentValue = null)
		{
			double[] coefficients = _coefficients.GetCoefficients(Center, order);
			double num = CalculateStepSize(_points, x, order);
			double[] array = new double[_points];
			for (int i = 0; i < _points; i++)
			{
				if (i == Center && currentValue.HasValue)
				{
					array[i] = currentValue.Value;
				}
				else if (coefficients[i] != 0.0)
				{
					array[i] = f(x + (double)(i - Center) * num);
					Evaluations++;
				}
			}
			return EvaluateDerivative(array, order, num);
		}

		public Func<double, double> CreateDerivativeFunctionHandle(Func<double, double> f, int order)
		{
			return (double x) => EvaluateDerivative(f, x, order);
		}

		public double EvaluatePartialDerivative(Func<double[], double> f, double[] x, int parameterIndex, int order, double? currentValue = null)
		{
			double num = x[parameterIndex];
			double[] coefficients = _coefficients.GetCoefficients(Center, order);
			double num2 = CalculateStepSize(_points, x[parameterIndex], order);
			double[] array = new double[_points];
			for (int i = 0; i < _points; i++)
			{
				if (i == Center && currentValue.HasValue)
				{
					array[i] = currentValue.Value;
				}
				else if (coefficients[i] != 0.0)
				{
					x[parameterIndex] = num + (double)(i - Center) * num2;
					array[i] = f(x);
					Evaluations++;
				}
			}
			x[parameterIndex] = num;
			return EvaluateDerivative(array, order, num2);
		}

		public double[] EvaluatePartialDerivative(Func<double[], double>[] f, double[] x, int parameterIndex, int order, double?[] currentValue = null)
		{
			double[] array = new double[f.Length];
			for (int i = 0; i < f.Length; i++)
			{
				if (currentValue != null && currentValue[i].HasValue)
				{
					array[i] = EvaluatePartialDerivative(f[i], x, parameterIndex, order, currentValue[i].Value);
				}
				else
				{
					array[i] = EvaluatePartialDerivative(f[i], x, parameterIndex, order);
				}
			}
			return array;
		}

		public Func<double[], double> CreatePartialDerivativeFunctionHandle(Func<double[], double> f, int parameterIndex, int order)
		{
			return (double[] x) => EvaluatePartialDerivative(f, x, parameterIndex, order);
		}

		public Func<double[], double[]> CreatePartialDerivativeFunctionHandle(Func<double[], double>[] f, int parameterIndex, int order)
		{
			return (double[] x) => EvaluatePartialDerivative(f, x, parameterIndex, order);
		}

		public double EvaluateMixedPartialDerivative(Func<double[], double> f, double[] x, int[] parameterIndex, int order, double? currentValue = null)
		{
			if (parameterIndex.Length != order)
			{
				throw new ArgumentOutOfRangeException("parameterIndex", "The number of parameters must match derivative order.");
			}
			if (order == 1)
			{
				return EvaluatePartialDerivative(f, x, parameterIndex[0], order, currentValue);
			}
			int num = order - 1;
			int[] array = new int[num];
			Array.Copy(parameterIndex, 0, array, 0, num);
			double[] array2 = new double[_points];
			int num2 = parameterIndex[order - 1];
			double num3 = CalculateStepSize(_points, x[num2], order);
			double num4 = x[num2];
			for (int i = 0; i < _points; i++)
			{
				x[num2] = num4 + (double)(i - Center) * num3;
				array2[i] = EvaluateMixedPartialDerivative(f, x, array, num);
			}
			x[num2] = num4;
			return EvaluateDerivative(array2, 1, num3);
		}

		public double[] EvaluateMixedPartialDerivative(Func<double[], double>[] f, double[] x, int[] parameterIndex, int order, double?[] currentValue = null)
		{
			double[] array = new double[f.Length];
			for (int i = 0; i < f.Length; i++)
			{
				if (currentValue != null && currentValue[i].HasValue)
				{
					array[i] = EvaluateMixedPartialDerivative(f[i], x, parameterIndex, order, currentValue[i].Value);
				}
				else
				{
					array[i] = EvaluateMixedPartialDerivative(f[i], x, parameterIndex, order);
				}
			}
			return array;
		}

		public Func<double[], double> CreateMixedPartialDerivativeFunctionHandle(Func<double[], double> f, int[] parameterIndex, int order)
		{
			return (double[] x) => EvaluateMixedPartialDerivative(f, x, parameterIndex, order);
		}

		public Func<double[], double[]> CreateMixedPartialDerivativeFunctionHandle(Func<double[], double>[] f, int[] parameterIndex, int order)
		{
			return (double[] x) => EvaluateMixedPartialDerivative(f, x, parameterIndex, order);
		}

		public void ResetEvaluations()
		{
			Evaluations = 0;
		}

		private double[] CalculateStepSize(int points, double[] x, double order)
		{
			double[] array = new double[x.Length];
			for (int i = 1; i < array.Length; i++)
			{
				array[i] = CalculateStepSize(points, x[i], order);
			}
			return array;
		}

		private double CalculateStepSize(int points, double x, double order)
		{
			if (StepType == StepType.RelativeX)
			{
				StepSize = BaseStepSize * (1.0 + Math.Abs(x));
			}
			else if (StepType == StepType.Relative)
			{
				double num = (double)points - order;
				BaseStepSize = Math.Pow(Epsilon, 1.0 / (num + order));
				StepSize = BaseStepSize * (1.0 + Math.Abs(x));
			}
			return StepSize;
		}
	}
	public class NumericalHessian
	{
		private readonly NumericalDerivative _df;

		public int FunctionEvaluations => _df.Evaluations;

		public NumericalHessian()
			: this(3, 1)
		{
		}

		public NumericalHessian(int points, int center)
		{
			_df = new NumericalDerivative(points, center);
		}

		public double[] Evaluate(Func<double, double> f, double x)
		{
			return new double[1] { _df.EvaluateDerivative(f, x, 2) };
		}

		public double[,] Evaluate(Func<double[], double> f, double[] x)
		{
			double[,] array = new double[x.Length, x.Length];
			for (int i = 0; i < x.Length; i++)
			{
				array[i, i] = _df.EvaluatePartialDerivative(f, x, i, 2);
			}
			for (int j = 0; j < x.Length; j++)
			{
				for (int k = 0; k < j; k++)
				{
					array[k, j] = (array[j, k] = _df.EvaluateMixedPartialDerivative(f, x, new int[2] { j, k }, 2));
				}
			}
			return array;
		}

		public void ResetFunctionEvaluations()
		{
			_df.ResetEvaluations();
		}
	}
	public class NumericalJacobian
	{
		private readonly NumericalDerivative _df;

		public int FunctionEvaluations => _df.Evaluations;

		public NumericalJacobian()
			: this(3, 1)
		{
		}

		public NumericalJacobian(int points, int center)
		{
			_df = new NumericalDerivative(points, center);
		}

		public double[] Evaluate(Func<double, double> f, double x)
		{
			return new double[1] { _df.EvaluateDerivative(f, x, 1) };
		}

		public double[] Evaluate(Func<double[], double> f, double[] x)
		{
			double[] array = new double[x.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = _df.EvaluatePartialDerivative(f, x, i, 1);
			}
			return array;
		}

		public double[] Evaluate(Func<double[], double> f, double[] x, double currentValue)
		{
			double[] array = new double[x.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = _df.EvaluatePartialDerivative(f, x, i, 1, currentValue);
			}
			return array;
		}

		public double[,] Evaluate(Func<double[], double>[] f, double[] x)
		{
			double[,] array = new double[f.Length, x.Length];
			for (int i = 0; i < f.Length; i++)
			{
				double[] array2 = Evaluate(f[i], x);
				for (int j = 0; j < array2.Length; j++)
				{
					array[i, j] = array2[j];
				}
			}
			return array;
		}

		public double[,] Evaluate(Func<double[], double>[] f, double[] x, double[] currentValues)
		{
			double[,] array = new double[f.Length, x.Length];
			for (int i = 0; i < f.Length; i++)
			{
				double[] array2 = Evaluate(f[i], x, currentValues[i]);
				for (int j = 0; j < array2.Length; j++)
				{
					array[i, j] = array2[j];
				}
			}
			return array;
		}

		public void ResetFunctionEvaluations()
		{
			_df.ResetEvaluations();
		}
	}
}
